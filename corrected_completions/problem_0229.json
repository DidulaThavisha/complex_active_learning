{
  "entry_id": "problem_0229",
  "problem_index": 229,
  "prompt": "Title: Almost Identity Permutations\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nA permutation *p* of size *n* is an array such that every integer from 1 to *n* occurs exactly once in this array.\n\nLet's call a permutation an almost identity permutation iff there exist at least *n*<=-<=*k* indices *i* (1<=≤<=*i*<=≤<=*n*) such that *p**i*<==<=*i*.\n\nYour task is to count the number of almost identity permutations for given numbers *n* and *k*.\n\nInput Specification:\nThe first line contains two integers *n* and *k* (4<=≤<=*n*<=≤<=1000, 1<=≤<=*k*<=≤<=4).\n\nOutput Specification:\nPrint the number of almost identity permutations for given *n* and *k*.\n\nDemo Input:\n['4 1\\n', '4 2\\n', '5 3\\n', '5 4\\n']\n\nDemo Output:\n['1\\n', '7\\n', '31\\n', '76\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem asks us to count \"almost identity permutations\" where at least n-k positions have p[i] = i. This means at most k positions can be different from their index.\n\nThe key insight is that we need to count permutations where exactly 0, 1, 2, ..., or k positions are NOT fixed points. For each case where exactly m positions (0 ≤ m ≤ k) are not fixed, we need:\n1. Choose which m positions are not fixed: C(n, m)\n2. Count derangements of those m positions: D(m)\n\nA derangement is a permutation where no element appears in its original position.\n\nThe compilation error was due to using `split()` which doesn't exist in Ballerina's string type. We need to use `regex:split()` from the `ballerina/regex` module.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. An \"almost identity permutation\" has at least n-k positions where p[i] = i\n//    This means at most k positions can differ from their indices\n// 2. We sum over all cases where exactly m positions (0 <= m <= k) are NOT fixed\n// 3. For each m:\n//    - Choose m positions from n: C(n, m) = n! / (m! * (n-m)!)\n//    - Arrange those m positions so none is in original position: D(m) (derangement)\n// 4. Derangement formula: D(0) = 1, D(1) = 0, D(2) = 1, D(3) = 2, D(4) = 9\n//    General: D(n) = (n-1) * (D(n-1) + D(n-2))\n// 5. Answer = sum of C(n, m) * D(m) for m from 0 to k\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\nfunction binomial(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    // Use the property C(n,k) = C(n,k-1) * (n-k+1) / k to avoid overflow\n    int result = 1;\n    int i = 0;\n    while i < k {\n        result = result * (n - i);\n        result = result / (i + 1);\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate derangement D(n) - permutations where no element is in its original position\nfunction derangement(int n) returns int {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    if n == 2 {\n        return 1;\n    }\n    \n    // Use dynamic programming: D(n) = (n-1) * (D(n-1) + D(n-2))\n    int prev2 = 1; // D(0)\n    int prev1 = 0; // D(1)\n    int current = 1; // D(2)\n    \n    int i = 3;\n    while i <= n {\n        prev2 = prev1;\n        prev1 = current;\n        current = (i - 1) * (prev1 + prev2);\n        i = i + 1;\n    }\n    \n    return current;\n}\n\n// Count almost identity permutations\nfunction countAlmostIdentityPermutations(int n, int k) returns int {\n    int count = 0;\n    int m = 0;\n    \n    // Sum over all cases where exactly m positions are NOT fixed (0 <= m <= k)\n    while m <= k {\n        int ways = binomial(n, m) * derangement(m);\n        count = count + ways;\n        m = m + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split to split the input by whitespace\n        string[] parts = regex:split(input_line.trim(), \" \");\n        \n        if parts.length() != 2 {\n            io:println(\"Error: Expected two integers\");\n            return;\n        }\n        \n        int|error n_result = 'int:fromString(parts[0]);\n        int|error k_result = 'int:fromString(parts[1]);\n        \n        if n_result is error {\n            io:println(\"Error: Invalid input for n\");\n            return;\n        }\n        \n        if k_result is error {\n            io:println(\"Error: Invalid input for k\");\n            return;\n        }\n        \n        int n = n_result;\n        int k = k_result;\n        \n        if n < 4 || n > 1000 || k < 1 || k > 4 {\n            io:println(\"Error: Constraints not met (4 <= n <= 1000, 1 <= k <= 4)\");\n            return;\n        }\n        \n        int result = countAlmostIdentityPermutations(n, k);\n        io:println(result);\n    } else {\n        io:println(\"Error: No input received\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testDerangement() {\n    test:assertEquals(derangement(0), 1);\n    test:assertEquals(derangement(1), 0);\n    test:assertEquals(derangement(2), 1);\n    test:assertEquals(derangement(3), 2);\n    test:assertEquals(derangement(4), 9);\n}\n\n@test:Config {}\nfunction testBinomial() {\n    test:assertEquals(binomial(4, 0), 1);\n    test:assertEquals(binomial(4, 1), 4);\n    test:assertEquals(binomial(4, 2), 6);\n    test:assertEquals(binomial(5, 3), 10);\n}\n\n@test:Config {}\nfunction testAlmostIdentityPermutations() {\n    test:assertEquals(countAlmostIdentityPermutations(4, 1), 1);\n    test:assertEquals(countAlmostIdentityPermutations(4, 2), 7);\n    test:assertEquals(countAlmostIdentityPermutations(5, 3), 31);\n    test:assertEquals(countAlmostIdentityPermutations(5, 4), 76);\n}\n\n@test:Config {}\nfunction testFactorial() {\n    test:assertEquals(factorial(0), 1);\n    test:assertEquals(factorial(1), 1);\n    test:assertEquals(factorial(4), 24);\n    test:assertEquals(factorial(5), 120);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. An \"almost identity permutation\" has at least n-k positions where p[i] = i\n//    This means at most k positions can differ from their indices\n// 2. We sum over all cases where exactly m positions (0 <= m <= k) are NOT fixed\n// 3. For each m:\n//    - Choose m positions from n: C(n, m) = n! / (m! * (n-m)!)\n//    - Arrange those m positions so none is in original position: D(m) (derangement)\n// 4. Derangement formula: D(0) = 1, D(1) = 0, D(2) = 1, D(3) = 2, D(4) = 9\n//    General: D(n) = (n-1) * (D(n-1) + D(n-2))\n// 5. Answer = sum of C(n, m) * D(m) for m from 0 to k\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\nfunction binomial(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    // Use the property C(n,k) = C(n,k-1) * (n-k+1) / k to avoid overflow\n    int result = 1;\n    int i = 0;\n    while i < k {\n        result = result * (n - i);\n        result = result / (i + 1);\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate derangement D(n) - permutations where no element is in its original position\nfunction derangement(int n) returns int {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    if n == 2 {\n        return 1;\n    }\n    \n    // Use dynamic programming: D(n) = (n-1) * (D(n-1) + D(n-2))\n    int prev2 = 1; // D(0)\n    int prev1 = 0; // D(1)\n    int current = 1; // D(2)\n    \n    int i = 3;\n    while i <= n {\n        prev2 = prev1;\n        prev1 = current;\n        current = (i - 1) * (prev1 + prev2);\n        i = i + 1;\n    }\n    \n    return current;\n}\n\n// Count almost identity permutations\nfunction countAlmostIdentityPermutations(int n, int k) returns int {\n    int count = 0;\n    int m = 0;\n    \n    // Sum over all cases where exactly m positions are NOT fixed (0 <= m <= k)\n    while m <= k {\n        int ways = binomial(n, m) * derangement(m);\n        count = count + ways;\n        m = m + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split to split the input by whitespace\n        string[] parts = regex:split(input_line.trim(), \" \");\n        \n        if parts.length() != 2 {\n            io:println(\"Error: Expected two integers\");\n            return;\n        }\n        \n        int|error n_result = 'int:fromString(parts[0]);\n        int|error k_result = 'int:fromString(parts[1]);\n        \n        if n_result is error {\n            io:println(\"Error: Invalid input for n\");\n            return;\n        }\n        \n        if k_result is error {\n            io:println(\"Error: Invalid input for k\");\n            return;\n        }\n        \n        int n = n_result;\n        int k = k_result;\n        \n        if n < 4 || n > 1000 || k < 1 || k > 4 {\n            io:println(\"Error: Constraints not met (4 <= n <= 1000, 1 <= k <= 4)\");\n            return;\n        }\n        \n        int result = countAlmostIdentityPermutations(n, k);\n        io:println(result);\n    } else {\n        io:println(\"Error: No input received\");\n    }\n}",
  "tests_passed": 4,
  "tests_total": 4,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 4/4 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:12:55.155069",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to count \"almost identity permutations\" where at least n-k positions have p[i] = i. This means at most k positions can be different from their index.\n\nThe key insight is that we need to count permutations where exactly 0, 1, 2, ..., or k positions are NOT fixed points. For each case where exactly m positions (0 ≤ m ≤ k) are not fixed, we need:\n1. Choose which m positions are not fixed: C(n, m)\n2. Count derangements of those m positions: D(m)\n\nA derangement is a permutation where no element appears in its original position.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. An \"almost identity permutation\" has at least n-k positions where p[i] = i\n//    This means at most k positions can differ from their indices\n// 2. We sum over all cases where exactly m positions (0 <= m <= k) are NOT fixed\n// 3. For each m:\n//    - Choose m positions from n: C(n, m) = n! / (m! * (n-m)!)\n//    - Arrange those m positions so none is in original position: D(m) (derangement)\n// 4. Derangement formula: D(0) = 1, D(1) = 0, D(2) = 1, D(3) = 2, D(4) = 9\n//    General: D(n) = (n-1) * (D(n-1) + D(n-2))\n// 5. Answer = sum of C(n, m) * D(m) for m from 0 to k\n\nimport ballerina/io;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\nfunction binomial(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    // Use the property C(n,k) = C(n,k-1) * (n-k+1) / k to avoid overflow\n    int result = 1;\n    int i = 0;\n    while i < k {\n        result = result * (n - i);\n        result = result / (i + 1);\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate derangement D(n) - permutations where no element is in its original position\nfunction derangement(int n) returns int {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    if n == 2 {\n        return 1;\n    }\n    \n    // Use dynamic programming: D(n) = (n-1) * (D(n-1) + D(n-2))\n    int prev2 = 1; // D(0)\n    int prev1 = 0; // D(1)\n    int current = 1; // D(2)\n    \n    int i = 3;\n    while i <= n {\n        prev2 = prev1;\n        prev1 = current;\n        current = (i - 1) * (prev1 + prev2);\n        i = i + 1;\n    }\n    \n    return current;\n}\n\n// Count almost identity permutations\nfunction countAlmostIdentityPermutations(int n, int k) returns int {\n    int count = 0;\n    int m = 0;\n    \n    // Sum over all cases where exactly m positions are NOT fixed (0 <= m <= k)\n    while m <= k {\n        int ways = binomial(n, m) * derangement(m);\n        count = count + ways;\n        m = m + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() != 2 {\n            io:println(\"Error: Expected two integers\");\n            return;\n        }\n        \n        int|error n_result = 'int:fromString(parts[0]);\n        int|error k_result = 'int:fromString(parts[1]);\n        \n        if n_result is error {\n            io:println(\"Error: Invalid input for n\");\n            return;\n        }\n        \n        if k_result is error {\n            io:println(\"Error: Invalid input for k\");\n            return;\n        }\n        \n        int n = n_result;\n        int k = k_result;\n        \n        if n < 4 || n > 1000 || k < 1 || k > 4 {\n            io:println(\"Error: Constraints not met (4 <= n <= 1000, 1 <= k <= 4)\");\n            return;\n        }\n        \n        int result = countAlmostIdentityPermutations(n, k);\n        io:println(result);\n    } else {\n        io:println(\"Error: No input received\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testDerangement() {\n    test:assertEquals(derangement(0), 1);\n    test:assertEquals(derangement(1), 0);\n    test:assertEquals(derangement(2), 1);\n    test:assertEquals(derangement(3), 2);\n    test:assertEquals(derangement(4), 9);\n}\n\n@test:Config {}\nfunction testBinomial() {\n    test:assertEquals(binomial(4, 0), 1);\n    test:assertEquals(binomial(4, 1), 4);\n    test:assertEquals(binomial(4, 2), 6);\n    test:assertEquals(binomial(5, 3), 10);\n}\n\n@test:Config {}\nfunction testAlmostIdentityPermutations() {\n    test:assertEquals(countAlmostIdentityPermutations(4, 1), 1);\n    test:assertEquals(countAlmostIdentityPermutations(4, 2), 7);\n    test:assertEquals(countAlmostIdentityPermutations(5, 3), 31);\n    test:assertEquals(countAlmostIdentityPermutations(5, 4), 76);\n}\n\n@test:Config {}\nfunction testFactorial() {\n    test:assertEquals(factorial(0), 1);\n    test:assertEquals(factorial(1), 1);\n    test:assertEquals(factorial(4), 24);\n    test:assertEquals(factorial(5), 120);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. An \"almost identity permutation\" has at least n-k positions where p[i] = i\n//    This means at most k positions can differ from their indices\n// 2. We sum over all cases where exactly m positions (0 <= m <= k) are NOT fixed\n// 3. For each m:\n//    - Choose m positions from n: C(n, m) = n! / (m! * (n-m)!)\n//    - Arrange those m positions so none is in original position: D(m) (derangement)\n// 4. Derangement formula: D(0) = 1, D(1) = 0, D(2) = 1, D(3) = 2, D(4) = 9\n//    General: D(n) = (n-1) * (D(n-1) + D(n-2))\n// 5. Answer = sum of C(n, m) * D(m) for m from 0 to k\n\nimport ballerina/io;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\nfunction binomial(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    // Use the property C(n,k) = C(n,k-1) * (n-k+1) / k to avoid overflow\n    int result = 1;\n    int i = 0;\n    while i < k {\n        result = result * (n - i);\n        result = result / (i + 1);\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate derangement D(n) - permutations where no element is in its original position\nfunction derangement(int n) returns int {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    if n == 2 {\n        return 1;\n    }\n    \n    // Use dynamic programming: D(n) = (n-1) * (D(n-1) + D(n-2))\n    int prev2 = 1; // D(0)\n    int prev1 = 0; // D(1)\n    int current = 1; // D(2)\n    \n    int i = 3;\n    while i <= n {\n        prev2 = prev1;\n        prev1 = current;\n        current = (i - 1) * (prev1 + prev2);\n        i = i + 1;\n    }\n    \n    return current;\n}\n\n// Count almost identity permutations\nfunction countAlmostIdentityPermutations(int n, int k) returns int {\n    int count = 0;\n    int m = 0;\n    \n    // Sum over all cases where exactly m positions are NOT fixed (0 <= m <= k)\n    while m <= k {\n        int ways = binomial(n, m) * derangement(m);\n        count = count + ways;\n        m = m + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() != 2 {\n            io:println(\"Error: Expected two integers\");\n            return;\n        }\n        \n        int|error n_result = 'int:fromString(parts[0]);\n        int|error k_result = 'int:fromString(parts[1]);\n        \n        if n_result is error {\n            io:println(\"Error: Invalid input for n\");\n            return;\n        }\n        \n        if k_result is error {\n            io:println(\"Error: Invalid input for k\");\n            return;\n        }\n        \n        int n = n_result;\n        int k = k_result;\n        \n        if n < 4 || n > 1000 || k < 1 || k > 4 {\n            io:println(\"Error: Constraints not met (4 <= n <= 1000, 1 <= k <= 4)\");\n            return;\n        }\n        \n        int result = countAlmostIdentityPermutations(n, k);\n        io:println(result);\n    } else {\n        io:println(\"Error: No input received\");\n    }\n}",
      "tests_passed": 0,
      "tests_total": 4,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(94:44,94:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(94:44,94:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(94:44,94:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:13:20.973049",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to count \"almost identity permutations\" where at least n-k positions have p[i] = i. This means at most k positions can be different from their index.\n\nThe key insight is that we need to count permutations where exactly 0, 1, 2, ..., or k positions are NOT fixed points. For each case where exactly m positions (0 ≤ m ≤ k) are not fixed, we need:\n1. Choose which m positions are not fixed: C(n, m)\n2. Count derangements of those m positions: D(m)\n\nA derangement is a permutation where no element appears in its original position.\n\nThe compilation error was due to using `split()` which doesn't exist in Ballerina's string type. We need to use `regex:split()` from the `ballerina/regex` module.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. An \"almost identity permutation\" has at least n-k positions where p[i] = i\n//    This means at most k positions can differ from their indices\n// 2. We sum over all cases where exactly m positions (0 <= m <= k) are NOT fixed\n// 3. For each m:\n//    - Choose m positions from n: C(n, m) = n! / (m! * (n-m)!)\n//    - Arrange those m positions so none is in original position: D(m) (derangement)\n// 4. Derangement formula: D(0) = 1, D(1) = 0, D(2) = 1, D(3) = 2, D(4) = 9\n//    General: D(n) = (n-1) * (D(n-1) + D(n-2))\n// 5. Answer = sum of C(n, m) * D(m) for m from 0 to k\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\nfunction binomial(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    // Use the property C(n,k) = C(n,k-1) * (n-k+1) / k to avoid overflow\n    int result = 1;\n    int i = 0;\n    while i < k {\n        result = result * (n - i);\n        result = result / (i + 1);\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate derangement D(n) - permutations where no element is in its original position\nfunction derangement(int n) returns int {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    if n == 2 {\n        return 1;\n    }\n    \n    // Use dynamic programming: D(n) = (n-1) * (D(n-1) + D(n-2))\n    int prev2 = 1; // D(0)\n    int prev1 = 0; // D(1)\n    int current = 1; // D(2)\n    \n    int i = 3;\n    while i <= n {\n        prev2 = prev1;\n        prev1 = current;\n        current = (i - 1) * (prev1 + prev2);\n        i = i + 1;\n    }\n    \n    return current;\n}\n\n// Count almost identity permutations\nfunction countAlmostIdentityPermutations(int n, int k) returns int {\n    int count = 0;\n    int m = 0;\n    \n    // Sum over all cases where exactly m positions are NOT fixed (0 <= m <= k)\n    while m <= k {\n        int ways = binomial(n, m) * derangement(m);\n        count = count + ways;\n        m = m + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split to split the input by whitespace\n        string[] parts = regex:split(input_line.trim(), \" \");\n        \n        if parts.length() != 2 {\n            io:println(\"Error: Expected two integers\");\n            return;\n        }\n        \n        int|error n_result = 'int:fromString(parts[0]);\n        int|error k_result = 'int:fromString(parts[1]);\n        \n        if n_result is error {\n            io:println(\"Error: Invalid input for n\");\n            return;\n        }\n        \n        if k_result is error {\n            io:println(\"Error: Invalid input for k\");\n            return;\n        }\n        \n        int n = n_result;\n        int k = k_result;\n        \n        if n < 4 || n > 1000 || k < 1 || k > 4 {\n            io:println(\"Error: Constraints not met (4 <= n <= 1000, 1 <= k <= 4)\");\n            return;\n        }\n        \n        int result = countAlmostIdentityPermutations(n, k);\n        io:println(result);\n    } else {\n        io:println(\"Error: No input received\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testDerangement() {\n    test:assertEquals(derangement(0), 1);\n    test:assertEquals(derangement(1), 0);\n    test:assertEquals(derangement(2), 1);\n    test:assertEquals(derangement(3), 2);\n    test:assertEquals(derangement(4), 9);\n}\n\n@test:Config {}\nfunction testBinomial() {\n    test:assertEquals(binomial(4, 0), 1);\n    test:assertEquals(binomial(4, 1), 4);\n    test:assertEquals(binomial(4, 2), 6);\n    test:assertEquals(binomial(5, 3), 10);\n}\n\n@test:Config {}\nfunction testAlmostIdentityPermutations() {\n    test:assertEquals(countAlmostIdentityPermutations(4, 1), 1);\n    test:assertEquals(countAlmostIdentityPermutations(4, 2), 7);\n    test:assertEquals(countAlmostIdentityPermutations(5, 3), 31);\n    test:assertEquals(countAlmostIdentityPermutations(5, 4), 76);\n}\n\n@test:Config {}\nfunction testFactorial() {\n    test:assertEquals(factorial(0), 1);\n    test:assertEquals(factorial(1), 1);\n    test:assertEquals(factorial(4), 24);\n    test:assertEquals(factorial(5), 120);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. An \"almost identity permutation\" has at least n-k positions where p[i] = i\n//    This means at most k positions can differ from their indices\n// 2. We sum over all cases where exactly m positions (0 <= m <= k) are NOT fixed\n// 3. For each m:\n//    - Choose m positions from n: C(n, m) = n! / (m! * (n-m)!)\n//    - Arrange those m positions so none is in original position: D(m) (derangement)\n// 4. Derangement formula: D(0) = 1, D(1) = 0, D(2) = 1, D(3) = 2, D(4) = 9\n//    General: D(n) = (n-1) * (D(n-1) + D(n-2))\n// 5. Answer = sum of C(n, m) * D(m) for m from 0 to k\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate binomial coefficient C(n, k) = n! / (k! * (n-k)!)\nfunction binomial(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    // Use the property C(n,k) = C(n,k-1) * (n-k+1) / k to avoid overflow\n    int result = 1;\n    int i = 0;\n    while i < k {\n        result = result * (n - i);\n        result = result / (i + 1);\n        i = i + 1;\n    }\n    return result;\n}\n\n// Calculate derangement D(n) - permutations where no element is in its original position\nfunction derangement(int n) returns int {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    if n == 2 {\n        return 1;\n    }\n    \n    // Use dynamic programming: D(n) = (n-1) * (D(n-1) + D(n-2))\n    int prev2 = 1; // D(0)\n    int prev1 = 0; // D(1)\n    int current = 1; // D(2)\n    \n    int i = 3;\n    while i <= n {\n        prev2 = prev1;\n        prev1 = current;\n        current = (i - 1) * (prev1 + prev2);\n        i = i + 1;\n    }\n    \n    return current;\n}\n\n// Count almost identity permutations\nfunction countAlmostIdentityPermutations(int n, int k) returns int {\n    int count = 0;\n    int m = 0;\n    \n    // Sum over all cases where exactly m positions are NOT fixed (0 <= m <= k)\n    while m <= k {\n        int ways = binomial(n, m) * derangement(m);\n        count = count + ways;\n        m = m + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split to split the input by whitespace\n        string[] parts = regex:split(input_line.trim(), \" \");\n        \n        if parts.length() != 2 {\n            io:println(\"Error: Expected two integers\");\n            return;\n        }\n        \n        int|error n_result = 'int:fromString(parts[0]);\n        int|error k_result = 'int:fromString(parts[1]);\n        \n        if n_result is error {\n            io:println(\"Error: Invalid input for n\");\n            return;\n        }\n        \n        if k_result is error {\n            io:println(\"Error: Invalid input for k\");\n            return;\n        }\n        \n        int n = n_result;\n        int k = k_result;\n        \n        if n < 4 || n > 1000 || k < 1 || k > 4 {\n            io:println(\"Error: Constraints not met (4 <= n <= 1000, 1 <= k <= 4)\");\n            return;\n        }\n        \n        int result = countAlmostIdentityPermutations(n, k);\n        io:println(result);\n    } else {\n        io:println(\"Error: No input received\");\n    }\n}",
      "tests_passed": 4,
      "tests_total": 4,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 4/4 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T04:13:56.706076"
}