{
  "entry_id": "problem_0054",
  "problem_index": 54,
  "prompt": "Title: Wooden Fence\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nVasya has recently bought some land and decided to surround it with a wooden fence.\n\nHe went to a company called \"Wooden board\" that produces wooden boards for fences. Vasya read in the catalog of products that the company has at its disposal *n* different types of wood. The company uses the *i*-th type of wood to produce a board of this type that is a rectangular *a**i* by *b**i* block.\n\nVasya decided to order boards in this company and build a fence from them. It turned out that the storehouse of the company is so large that Vasya can order arbitrary number of boards of every type. Note that Vasya is allowed to turn the boards as he builds the fence. However, Vasya cannot turn square boards.\n\nVasya is required to construct a fence of length *l*, however, an arbitrary fence won't do. Vasya wants his fence to look beautiful. We'll say that a fence is beautiful if and only if the following two conditions are fulfilled:\n -  there are no two successive boards of the same type -  the first board of the fence has an arbitrary length, and the length of each subsequent board equals the width of the previous one \nIn other words, the fence is considered beautiful, if the type of the *i*-th board in the fence is different from the *i*<=-<=1-th board's type; besides, the *i*-th board's length is equal to the *i*<=-<=1-th board's width (for all *i*, starting from 2).\n\nNow Vasya wonders, how many variants of arranging a fence for his land exist. Your task is to count the number of different beautiful fences of length *l*.\n\nTwo fences will be considered the same if the corresponding sequences of fence boards types and rotations are the same, otherwise the fences are different. Since the sought number can be large enough, you need to calculate the answer modulo 1000000007 (109<=+<=7).\n\nInput Specification:\nThe first line contains two integers *n* and *l* (1<=≤<=*n*<=≤<=100,<=1<=≤<=*l*<=≤<=3000) — the number of different board types and the fence length, correspondingly. Next *n* lines contain descriptions of board types: the *i*-th line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100) — the sizes of the board of the *i*-th type. All numbers on the lines are separated by spaces.\n\nOutput Specification:\nPrint a single integer — the sought number of variants modulo 1000000007 (109<=+<=7).\n\nDemo Input:\n['2 3\\n1 2\\n2 3\\n', '1 2\\n2 2\\n', '6 6\\n2 1\\n3 2\\n2 5\\n3 3\\n5 1\\n2 1\\n']\n\nDemo Output:\n['2\\n', '1\\n', '20\\n']\n\nNote:\nIn the first sample there are exactly two variants of arranging a beautiful fence of length 3: \n -  As the first fence board use the board of the first type of length 1 and width 2. As the second board use board of the second type of length 2 and width 3. -  Use one board of the second type after you turn it. That makes its length equal 3, and width — 2.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:52:44.771772",
      "status": "failed",
      "completion": "# Overview\nThis problem is a dynamic programming problem where we need to count the number of ways to build a beautiful fence of length `l` using `n` types of boards. The key constraints are:\n1. No two successive boards can be of the same type\n2. Each board's length must equal the previous board's width\n3. Boards can be rotated (except square boards)\n\nWe'll use dynamic programming where `dp[i][j][k]` represents the number of ways to build a fence of length `i` ending with board type `j` in orientation `k` (0 for original, 1 for rotated).\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get n board types and target length l\n// 2. For each board type, we can use it in two orientations (unless it's square)\n// 3. Use DP: dp[length][board_type][orientation] = count of ways\n// 4. Transition: for each position, try all board types and orientations\n//    where the current board's length equals the previous board's width\n// 5. Sum all valid fence configurations of length exactly l\n\nimport ballerina/io;\n\nconst int MOD = 1000000007;\n\ntype Board record {\n    int a;\n    int b;\n};\n\nfunction countBeautifulFences(Board[] boards, int targetLength) returns int {\n    int n = boards.length();\n    \n    // dp[length][boardIndex][orientation]\n    // orientation: 0 = a×b (length a, width b), 1 = b×a (length b, width a)\n    map<map<map<int>>> dp = {};\n    \n    // Initialize: place first board at position 0\n    foreach int i in 0 ..< n {\n        Board board = boards[i];\n        \n        // Try orientation 0: length = a, width = b\n        if board.a <= targetLength {\n            addToDP(dp, board.a, i, 0, 1);\n        }\n        \n        // Try orientation 1: length = b, width = a (only if not square)\n        if board.a != board.b && board.b <= targetLength {\n            addToDP(dp, board.b, i, 1, 1);\n        }\n    }\n    \n    // Fill DP table\n    foreach int len in 1 ... targetLength {\n        if !dp.hasKey(len.toString()) {\n            continue;\n        }\n        \n        map<map<int>> lenMap = dp.get(len.toString());\n        \n        foreach int prevBoard in 0 ..< n {\n            string prevBoardStr = prevBoard.toString();\n            if !lenMap.hasKey(prevBoardStr) {\n                continue;\n            }\n            \n            map<int> orientMap = lenMap.get(prevBoardStr);\n            \n            foreach int prevOrient in 0 ... 1 {\n                string orientStr = prevOrient.toString();\n                if !orientMap.hasKey(orientStr) {\n                    continue;\n                }\n                \n                int count = orientMap.get(orientStr);\n                if count == 0 {\n                    continue;\n                }\n                \n                // Get the width of previous board\n                Board prevBoardData = boards[prevBoard];\n                int prevWidth = prevOrient == 0 ? prevBoardData.b : prevBoardData.a;\n                \n                // Try placing next board\n                foreach int nextBoard in 0 ..< n {\n                    if nextBoard == prevBoard {\n                        continue; // Can't use same type consecutively\n                    }\n                    \n                    Board nextBoardData = boards[nextBoard];\n                    \n                    // Orientation 0: length = a, width = b\n                    if nextBoardData.a == prevWidth {\n                        int newLen = len + nextBoardData.a;\n                        if newLen <= targetLength {\n                            addToDP(dp, newLen, nextBoard, 0, count);\n                        }\n                    }\n                    \n                    // Orientation 1: length = b, width = a\n                    if nextBoardData.a != nextBoardData.b && nextBoardData.b == prevWidth {\n                        int newLen = len + nextBoardData.b;\n                        if newLen <= targetLength {\n                            addToDP(dp, newLen, nextBoard, 1, count);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Count all fences of exactly targetLength\n    int result = 0;\n    string targetStr = targetLength.toString();\n    if dp.hasKey(targetStr) {\n        map<map<int>> lenMap = dp.get(targetStr);\n        foreach var orientMap in lenMap {\n            foreach var count in orientMap {\n                result = (result + count) % MOD;\n            }\n        }\n    }\n    \n    return result;\n}\n\nfunction addToDP(map<map<map<int>>> dp, int len, int board, int orient, int count) {\n    string lenStr = len.toString();\n    string boardStr = board.toString();\n    string orientStr = orient.toString();\n    \n    if !dp.hasKey(lenStr) {\n        dp[lenStr] = {};\n    }\n    \n    map<map<int>> lenMap = dp.get(lenStr);\n    if !lenMap.hasKey(boardStr) {\n        lenMap[boardStr] = {};\n    }\n    \n    map<int> orientMap = lenMap.get(boardStr);\n    int current = orientMap.hasKey(orientStr) ? orientMap.get(orientStr) : 0;\n    orientMap[orientStr] = (current + count) % MOD;\n}\n\npublic function main() returns error? {\n    // Read first line: n and l\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = firstLine.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int l = check 'int:fromString(parts[1]);\n    \n    // Read n board descriptions\n    Board[] boards = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read board description\");\n        }\n        \n        string[] boardParts = line.trim().split(\" \");\n        if boardParts.length() != 2 {\n            return error(\"Invalid board format\");\n        }\n        \n        int a = check 'int:fromString(boardParts[0]);\n        int b = check 'int:fromString(boardParts[1]);\n        \n        boards.push({a: a, b: b});\n    }\n    \n    int result = countBeautifulFences(boards, l);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Board[] boards = [{a: 1, b: 2}, {a: 2, b: 3}];\n    int result = countBeautifulFences(boards, 3);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    Board[] boards = [{a: 2, b: 2}];\n    int result = countBeautifulFences(boards, 2);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    Board[] boards = [\n        {a: 2, b: 1},\n        {a: 3, b: 2},\n        {a: 2, b: 5},\n        {a: 3, b: 3},\n        {a: 5, b: 1},\n        {a: 2, b: 1}\n    ];\n    int result = countBeautifulFences(boards, 6);\n    test:assertEquals(result, 20);\n}\n\n@test:Config {}\nfunction testSingleBoard() {\n    Board[] boards = [{a: 1, b: 1}];\n    int result = countBeautifulFences(boards, 1);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNoSolution() {\n    Board[] boards = [{a: 5, b: 5}];\n    int result = countBeautifulFences(boards, 3);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get n board types and target length l\n// 2. For each board type, we can use it in two orientations (unless it's square)\n// 3. Use DP: dp[length][board_type][orientation] = count of ways\n// 4. Transition: for each position, try all board types and orientations\n//    where the current board's length equals the previous board's width\n// 5. Sum all valid fence configurations of length exactly l\n\nimport ballerina/io;\n\nconst int MOD = 1000000007;\n\ntype Board record {\n    int a;\n    int b;\n};\n\nfunction countBeautifulFences(Board[] boards, int targetLength) returns int {\n    int n = boards.length();\n    \n    // dp[length][boardIndex][orientation]\n    // orientation: 0 = a×b (length a, width b), 1 = b×a (length b, width a)\n    map<map<map<int>>> dp = {};\n    \n    // Initialize: place first board at position 0\n    foreach int i in 0 ..< n {\n        Board board = boards[i];\n        \n        // Try orientation 0: length = a, width = b\n        if board.a <= targetLength {\n            addToDP(dp, board.a, i, 0, 1);\n        }\n        \n        // Try orientation 1: length = b, width = a (only if not square)\n        if board.a != board.b && board.b <= targetLength {\n            addToDP(dp, board.b, i, 1, 1);\n        }\n    }\n    \n    // Fill DP table\n    foreach int len in 1 ... targetLength {\n        if !dp.hasKey(len.toString()) {\n            continue;\n        }\n        \n        map<map<int>> lenMap = dp.get(len.toString());\n        \n        foreach int prevBoard in 0 ..< n {\n            string prevBoardStr = prevBoard.toString();\n            if !lenMap.hasKey(prevBoardStr) {\n                continue;\n            }\n            \n            map<int> orientMap = lenMap.get(prevBoardStr);\n            \n            foreach int prevOrient in 0 ... 1 {\n                string orientStr = prevOrient.toString();\n                if !orientMap.hasKey(orientStr) {\n                    continue;\n                }\n                \n                int count = orientMap.get(orientStr);\n                if count == 0 {\n                    continue;\n                }\n                \n                // Get the width of previous board\n                Board prevBoardData = boards[prevBoard];\n                int prevWidth = prevOrient == 0 ? prevBoardData.b : prevBoardData.a;\n                \n                // Try placing next board\n                foreach int nextBoard in 0 ..< n {\n                    if nextBoard == prevBoard {\n                        continue; // Can't use same type consecutively\n                    }\n                    \n                    Board nextBoardData = boards[nextBoard];\n                    \n                    // Orientation 0: length = a, width = b\n                    if nextBoardData.a == prevWidth {\n                        int newLen = len + nextBoardData.a;\n                        if newLen <= targetLength {\n                            addToDP(dp, newLen, nextBoard, 0, count);\n                        }\n                    }\n                    \n                    // Orientation 1: length = b, width = a\n                    if nextBoardData.a != nextBoardData.b && nextBoardData.b == prevWidth {\n                        int newLen = len + nextBoardData.b;\n                        if newLen <= targetLength {\n                            addToDP(dp, newLen, nextBoard, 1, count);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Count all fences of exactly targetLength\n    int result = 0;\n    string targetStr = targetLength.toString();\n    if dp.hasKey(targetStr) {\n        map<map<int>> lenMap = dp.get(targetStr);\n        foreach var orientMap in lenMap {\n            foreach var count in orientMap {\n                result = (result + count) % MOD;\n            }\n        }\n    }\n    \n    return result;\n}\n\nfunction addToDP(map<map<map<int>>> dp, int len, int board, int orient, int count) {\n    string lenStr = len.toString();\n    string boardStr = board.toString();\n    string orientStr = orient.toString();\n    \n    if !dp.hasKey(lenStr) {\n        dp[lenStr] = {};\n    }\n    \n    map<map<int>> lenMap = dp.get(lenStr);\n    if !lenMap.hasKey(boardStr) {\n        lenMap[boardStr] = {};\n    }\n    \n    map<int> orientMap = lenMap.get(boardStr);\n    int current = orientMap.hasKey(orientStr) ? orientMap.get(orientStr) : 0;\n    orientMap[orientStr] = (current + count) % MOD;\n}\n\npublic function main() returns error? {\n    // Read first line: n and l\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = firstLine.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int l = check 'int:fromString(parts[1]);\n    \n    // Read n board descriptions\n    Board[] boards = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read board description\");\n        }\n        \n        string[] boardParts = line.trim().split(\" \");\n        if boardParts.length() != 2 {\n            return error(\"Invalid board format\");\n        }\n        \n        int a = check 'int:fromString(boardParts[0]);\n        int b = check 'int:fromString(boardParts[1]);\n        \n        boards.push({a: a, b: b});\n    }\n    \n    int result = countBeautifulFences(boards, l);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(140:39,140:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(156:43,156:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(140:39,140:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(156:43,156:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(140:39,140:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(156:43,156:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:53:16.239011",
      "status": "failed",
      "completion": "Looking at the compilation errors, the issue is that `split` is not a method on `string` in Ballerina. I need to use `regex:split` from the standard library instead. Let me fix this and also reconsider the DP approach to ensure correctness.\n\n# Overview\nThis is a dynamic programming problem where we build a beautiful fence of length `l` using `n` types of boards. Key constraints:\n1. No two consecutive boards can be the same type\n2. Each board's length must equal the previous board's width\n3. Boards can be rotated unless they're square\n\nThe DP approach: `dp[currentLength][lastBoardType][lastOrientation]` = number of ways to reach this state.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n board types and target length l\n// 2. Each board can be placed in up to 2 orientations (original a×b or rotated b×a)\n//    - Square boards (a==b) can only be placed one way\n// 3. Use DP: dp[length][boardType][orientation] = count of ways to build fence\n// 4. For each state, try adding next board where:\n//    - Next board type must differ from current board type\n//    - Next board's length must equal current board's width\n// 5. Answer is sum of all states where length equals targetLength\n\nimport ballerina/io;\nimport ballerina/regex;\n\nconst int MOD = 1000000007;\n\ntype Board record {|\n    int a;\n    int b;\n|};\n\nfunction countBeautifulFences(Board[] boards, int targetLength) returns int {\n    int n = boards.length();\n    \n    // dp[len][boardIdx][orientation] where orientation: 0 = (a,b), 1 = (b,a)\n    // Use 3D array for simpler access\n    int[][][] dp = [];\n    \n    // Initialize dp array\n    foreach int i in 0 ... targetLength {\n        int[][] layer = [];\n        foreach int j in 0 ..< n {\n            int[] orientations = [0, 0];\n            layer.push(orientations);\n        }\n        dp.push(layer);\n    }\n    \n    // Base case: start with each board type in each valid orientation\n    foreach int i in 0 ..< n {\n        Board board = boards[i];\n        \n        // Orientation 0: length=a, width=b\n        if board.a <= targetLength {\n            dp[board.a][i][0] = 1;\n        }\n        \n        // Orientation 1: length=b, width=a (only if not square)\n        if board.a != board.b && board.b <= targetLength {\n            dp[board.b][i][1] = 1;\n        }\n    }\n    \n    // DP transition\n    foreach int len in 1 ..< targetLength {\n        foreach int prevBoard in 0 ..< n {\n            foreach int prevOrient in 0 ... 1 {\n                int ways = dp[len][prevBoard][prevOrient];\n                if ways == 0 {\n                    continue;\n                }\n                \n                // Get width of previous board in current orientation\n                Board prevBoardData = boards[prevBoard];\n                int prevWidth = prevOrient == 0 ? prevBoardData.b : prevBoardData.a;\n                \n                // Try each next board type\n                foreach int nextBoard in 0 ..< n {\n                    if nextBoard == prevBoard {\n                        continue; // Cannot use same type consecutively\n                    }\n                    \n                    Board nextBoardData = boards[nextBoard];\n                    \n                    // Try orientation 0: length=a, width=b\n                    if nextBoardData.a == prevWidth {\n                        int newLen = len + nextBoardData.a;\n                        if newLen <= targetLength {\n                            dp[newLen][nextBoard][0] = (dp[newLen][nextBoard][0] + ways) % MOD;\n                        }\n                    }\n                    \n                    // Try orientation 1: length=b, width=a (only if not square)\n                    if nextBoardData.a != nextBoardData.b && nextBoardData.b == prevWidth {\n                        int newLen = len + nextBoardData.b;\n                        if newLen <= targetLength {\n                            dp[newLen][nextBoard][1] = (dp[newLen][nextBoard][1] + ways) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum all ways to reach exactly targetLength\n    int result = 0;\n    foreach int boardIdx in 0 ..< n {\n        foreach int orient in 0 ... 1 {\n            result = (result + dp[targetLength][boardIdx][orient]) % MOD;\n        }\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n and l\n    string? firstLine = io:readln(\"Enter n and l: \");\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(firstLine.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int l = check 'int:fromString(parts[1]);\n    \n    if n < 1 || n > 100 || l < 1 || l > 3000 {\n        return error(\"Input out of bounds\");\n    }\n    \n    // Read n board descriptions\n    Board[] boards = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read board description\");\n        }\n        \n        string[] boardParts = regex:split(line.trim(), \" \");\n        if boardParts.length() != 2 {\n            return error(\"Invalid board format\");\n        }\n        \n        int a = check 'int:fromString(boardParts[0]);\n        int b = check 'int:fromString(boardParts[1]);\n        \n        if a < 1 || a > 100 || b < 1 || b > 100 {\n            return error(\"Board dimensions out of bounds\");\n        }\n        \n        boards.push({a: a, b: b});\n    }\n    \n    int result = countBeautifulFences(boards, l);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Board[] boards = [{a: 1, b: 2}, {a: 2, b: 3}];\n    int result = countBeautifulFences(boards, 3);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    Board[] boards = [{a: 2, b: 2}];\n    int result = countBeautifulFences(boards, 2);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    Board[] boards = [\n        {a: 2, b: 1},\n        {a: 3, b: 2},\n        {a: 2, b: 5},\n        {a: 3, b: 3},\n        {a: 5, b: 1},\n        {a: 2, b: 1}\n    ];\n    int result = countBeautifulFences(boards, 6);\n    test:assertEquals(result, 20);\n}\n\n@test:Config {}\nfunction testSingleSquareBoard() {\n    Board[] boards = [{a: 1, b: 1}];\n    int result = countBeautifulFences(boards, 1);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNoSolution() {\n    Board[] boards = [{a: 5, b: 5}];\n    int result = countBeautifulFences(boards, 3);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testTwoDifferentBoards() {\n    Board[] boards = [{a: 1, b: 2}, {a: 2, b: 1}];\n    int result = countBeautifulFences(boards, 2);\n    test:assertEquals(result, 2);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n board types and target length l\n// 2. Each board can be placed in up to 2 orientations (original a×b or rotated b×a)\n//    - Square boards (a==b) can only be placed one way\n// 3. Use DP: dp[length][boardType][orientation] = count of ways to build fence\n// 4. For each state, try adding next board where:\n//    - Next board type must differ from current board type\n//    - Next board's length must equal current board's width\n// 5. Answer is sum of all states where length equals targetLength\n\nimport ballerina/io;\nimport ballerina/regex;\n\nconst int MOD = 1000000007;\n\ntype Board record {|\n    int a;\n    int b;\n|};\n\nfunction countBeautifulFences(Board[] boards, int targetLength) returns int {\n    int n = boards.length();\n    \n    // dp[len][boardIdx][orientation] where orientation: 0 = (a,b), 1 = (b,a)\n    // Use 3D array for simpler access\n    int[][][] dp = [];\n    \n    // Initialize dp array\n    foreach int i in 0 ... targetLength {\n        int[][] layer = [];\n        foreach int j in 0 ..< n {\n            int[] orientations = [0, 0];\n            layer.push(orientations);\n        }\n        dp.push(layer);\n    }\n    \n    // Base case: start with each board type in each valid orientation\n    foreach int i in 0 ..< n {\n        Board board = boards[i];\n        \n        // Orientation 0: length=a, width=b\n        if board.a <= targetLength {\n            dp[board.a][i][0] = 1;\n        }\n        \n        // Orientation 1: length=b, width=a (only if not square)\n        if board.a != board.b && board.b <= targetLength {\n            dp[board.b][i][1] = 1;\n        }\n    }\n    \n    // DP transition\n    foreach int len in 1 ..< targetLength {\n        foreach int prevBoard in 0 ..< n {\n            foreach int prevOrient in 0 ... 1 {\n                int ways = dp[len][prevBoard][prevOrient];\n                if ways == 0 {\n                    continue;\n                }\n                \n                // Get width of previous board in current orientation\n                Board prevBoardData = boards[prevBoard];\n                int prevWidth = prevOrient == 0 ? prevBoardData.b : prevBoardData.a;\n                \n                // Try each next board type\n                foreach int nextBoard in 0 ..< n {\n                    if nextBoard == prevBoard {\n                        continue; // Cannot use same type consecutively\n                    }\n                    \n                    Board nextBoardData = boards[nextBoard];\n                    \n                    // Try orientation 0: length=a, width=b\n                    if nextBoardData.a == prevWidth {\n                        int newLen = len + nextBoardData.a;\n                        if newLen <= targetLength {\n                            dp[newLen][nextBoard][0] = (dp[newLen][nextBoard][0] + ways) % MOD;\n                        }\n                    }\n                    \n                    // Try orientation 1: length=b, width=a (only if not square)\n                    if nextBoardData.a != nextBoardData.b && nextBoardData.b == prevWidth {\n                        int newLen = len + nextBoardData.b;\n                        if newLen <= targetLength {\n                            dp[newLen][nextBoard][1] = (dp[newLen][nextBoard][1] + ways) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Sum all ways to reach exactly targetLength\n    int result = 0;\n    foreach int boardIdx in 0 ..< n {\n        foreach int orient in 0 ... 1 {\n            result = (result + dp[targetLength][boardIdx][orient]) % MOD;\n        }\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n and l\n    string? firstLine = io:readln(\"Enter n and l: \");\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(firstLine.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int l = check 'int:fromString(parts[1]);\n    \n    if n < 1 || n > 100 || l < 1 || l > 3000 {\n        return error(\"Input out of bounds\");\n    }\n    \n    // Read n board descriptions\n    Board[] boards = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read board description\");\n        }\n        \n        string[] boardParts = regex:split(line.trim(), \" \");\n        if boardParts.length() != 2 {\n            return error(\"Invalid board format\");\n        }\n        \n        int a = check 'int:fromString(boardParts[0]);\n        int b = check 'int:fromString(boardParts[1]);\n        \n        if a < 1 || a > 100 || b < 1 || b > 100 {\n            return error(\"Board dimensions out of bounds\");\n        }\n        \n        boards.push({a: a, b: b});\n    }\n    \n    int result = countBeautifulFences(boards, l);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/3 tests (0.0%), need 75%",
      "error": "Only passed 0/3 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "2 3\n1 2\n2 3\n",
          "expected_output": "2\n",
          "actual_output": "Enter n and l: 2\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/3 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T00:53:55.836478"
}