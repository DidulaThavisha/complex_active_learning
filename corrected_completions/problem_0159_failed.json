{
  "entry_id": "problem_0159",
  "problem_index": 159,
  "prompt": "Title: Petya's Exams\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nPetya studies at university. The current academic year finishes with $n$ special days. Petya needs to pass $m$ exams in those special days. The special days in this problem are numbered from $1$ to $n$.\n\nThere are three values about each exam:\n -  $s_i$ — the day, when questions for the $i$-th exam will be published, -  $d_i$ — the day of the $i$-th exam ($s_i &lt; d_i$), -  $c_i$ — number of days Petya needs to prepare for the $i$-th exam. For the $i$-th exam Petya should prepare in days between $s_i$ and $d_i-1$, inclusive. \nThere are three types of activities for Petya in each day: to spend a day doing nothing (taking a rest), to spend a day passing exactly one exam or to spend a day preparing for exactly one exam. So he can't pass/prepare for multiple exams in a day. He can't mix his activities in a day. If he is preparing for the $i$-th exam in day $j$, then $s_i \\le j &lt; d_i$.\n\nIt is allowed to have breaks in a preparation to an exam and to alternate preparations for different exams in consecutive days. So preparation for an exam is not required to be done in consecutive days.\n\nFind the schedule for Petya to prepare for all exams and pass them, or report that it is impossible.\n\nInput Specification:\nThe first line contains two integers $n$ and $m$ $(2 \\le n \\le 100, 1 \\le m \\le n)$ — the number of days and the number of exams.\n\nEach of the following $m$ lines contains three integers $s_i$, $d_i$, $c_i$ $(1 \\le s_i &lt; d_i \\le n, 1 \\le c_i \\le n)$ — the day, when questions for the $i$-th exam will be given, the day of the $i$-th exam, number of days Petya needs to prepare for the $i$-th exam. \n\nGuaranteed, that all the exams will be in different days. Questions for different exams can be given in the same day. It is possible that, in the day of some exam, the questions for other exams are given.\n\nOutput Specification:\nIf Petya can not prepare and pass all the exams, print -1. In case of positive answer, print $n$ integers, where the $j$-th number is:\n -  $(m + 1)$, if the $j$-th day is a day of some exam (recall that in each day no more than one exam is conducted), -  zero, if in the $j$-th day Petya will have a rest, -  $i$ ($1 \\le i \\le m$), if Petya will prepare for the $i$-th exam in the day $j$ (the total number of days Petya prepares for each exam should be strictly equal to the number of days needed to prepare for it).Assume that the exams are numbered in order of appearing in the input, starting from $1$.If there are multiple schedules, print any of them.\n\nDemo Input:\n['5 2\\n1 3 1\\n1 5 1\\n', '3 2\\n1 3 1\\n1 2 1\\n', '10 3\\n4 7 2\\n1 10 3\\n8 9 1\\n']\n\nDemo Output:\n['1 2 3 0 3 \\n', '-1\\n', '2 2 2 1 1 0 4 3 4 4 \\n']\n\nNote:\nIn the first example Petya can, for example, prepare for exam $1$ in the first day, prepare for exam $2$ in the second day, pass exam $1$ in the third day, relax in the fourth day, and pass exam $2$ in the fifth day. So, he can prepare and pass all exams.\n\nIn the second example, there are three days and two exams. So, Petya can prepare in only one day (because in two other days he should pass exams). Then Petya can not prepare and pass all exams.",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:45:58.818261",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires scheduling exam preparation and exam days for Petya. We need to:\n1. Parse exam information (start day, exam day, preparation days needed)\n2. Sort exams by their exam day to prioritize earlier exams\n3. Schedule exam days first (these are fixed)\n4. Greedily fill preparation days for each exam in order of their exam dates\n5. Validate that all exams can be prepared for and taken\n\nThe strategy is to:\n- Mark all exam days first\n- Process exams in order of exam day (earliest first)\n- For each exam, try to schedule the required preparation days between start and exam day\n- If we can't fit all preparation days, return -1\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to schedule n days for m exams\n// 2. Each exam has: start day (when questions published), exam day, and prep days needed\n// 3. Strategy:\n//    - First, mark all exam days in the schedule\n//    - Sort exams by exam day (prioritize earlier exams)\n//    - For each exam (in sorted order), try to schedule preparation days\n//    - Preparation can only happen between start day and exam day (exclusive)\n//    - If we can't fit all required prep days, return -1\n// 4. Output: array where each index represents a day\n//    - 0 = rest day\n//    - i (1 to m) = prepare for exam i\n//    - exam_index (when it's exam day) = the exam number\n\nimport ballerina/io;\n\ntype Exam record {\n    int originalIndex;  // 1-based index in input order\n    int startDay;       // day questions are published\n    int examDay;        // day of exam\n    int prepDays;       // days needed to prepare\n};\n\nfunction solveSchedule(int n, Exam[] exams) returns int[]|error {\n    // Initialize schedule array (1-indexed, so size n+1)\n    int[] schedule = [];\n    foreach int i in 0 ..< n + 1 {\n        schedule.push(0);\n    }\n    \n    // First, mark all exam days\n    foreach Exam exam in exams {\n        if schedule[exam.examDay] != 0 {\n            // Conflict: two exams on same day (shouldn't happen per problem)\n            return error(\"Two exams on same day\");\n        }\n        schedule[exam.examDay] = exam.originalIndex;\n    }\n    \n    // Sort exams by exam day (earlier exams first)\n    Exam[] sortedExams = exams.clone();\n    foreach int i in 0 ..< sortedExams.length() {\n        foreach int j in i + 1 ..< sortedExams.length() {\n            if sortedExams[j].examDay < sortedExams[i].examDay {\n                Exam temp = sortedExams[i];\n                sortedExams[i] = sortedExams[j];\n                sortedExams[j] = temp;\n            }\n        }\n    }\n    \n    // For each exam (in order of exam day), schedule preparation\n    foreach Exam exam in sortedExams {\n        int prepScheduled = 0;\n        \n        // Try to schedule prep days between startDay and examDay\n        foreach int day in exam.startDay ..< exam.examDay {\n            if schedule[day] == 0 {\n                schedule[day] = exam.originalIndex;\n                prepScheduled += 1;\n                if prepScheduled == exam.prepDays {\n                    break;\n                }\n            }\n        }\n        \n        // Check if we scheduled enough prep days\n        if prepScheduled < exam.prepDays {\n            return error(\"Cannot schedule all preparation days\");\n        }\n    }\n    \n    return schedule;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read m exam specifications\n    Exam[] exams = [];\n    foreach int i in 1 ..= m {\n        string? examLine = io:readln();\n        if examLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        string[] examParts = examLine.trim().split(\" \");\n        if examParts.length() != 3 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int s = check 'int:fromString(examParts[0]);\n        int d = check 'int:fromString(examParts[1]);\n        int c = check 'int:fromString(examParts[2]);\n        \n        Exam exam = {\n            originalIndex: i,\n            startDay: s,\n            examDay: d,\n            prepDays: c\n        };\n        exams.push(exam);\n    }\n    \n    // Solve the scheduling problem\n    int[]|error result = solveSchedule(n, exams);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        // Output schedule (skip index 0, output from 1 to n)\n        string output = \"\";\n        foreach int day in 1 ..= n {\n            if output != \"\" {\n                output += \" \";\n            }\n            output += result[day].toString();\n        }\n        io:println(output);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 1, examDay: 3, prepDays: 1},\n        {originalIndex: 2, startDay: 1, examDay: 5, prepDays: 1}\n    ];\n    \n    int[]|error result = solveSchedule(5, exams);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        // Check that exam 1 is on day 3\n        test:assertEquals(result[3], 1);\n        // Check that exam 2 is on day 5\n        test:assertEquals(result[5], 2);\n        // Check that at least one prep day exists for exam 1\n        int prep1Count = 0;\n        foreach int day in 1 ..< 3 {\n            if result[day] == 1 {\n                prep1Count += 1;\n            }\n        }\n        test:assertEquals(prep1Count, 1);\n    }\n}\n\n@test:Config {}\nfunction testExample2Impossible() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 1, examDay: 3, prepDays: 1},\n        {originalIndex: 2, startDay: 1, examDay: 2, prepDays: 1}\n    ];\n    \n    int[]|error result = solveSchedule(3, exams);\n    test:assertTrue(result is error);\n}\n\n@test:Config {}\nfunction testExample3() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 4, examDay: 7, prepDays: 2},\n        {originalIndex: 2, startDay: 1, examDay: 10, prepDays: 3},\n        {originalIndex: 3, startDay: 8, examDay: 9, prepDays: 1}\n    ];\n    \n    int[]|error result = solveSchedule(10, exams);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        // Check exam days are correctly marked\n        test:assertEquals(result[7], 1);\n        test:assertEquals(result[10], 2);\n        test:assertEquals(result[9], 3);\n    }\n}\n\n@test:Config {}\nfunction testSingleExam() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 1, examDay: 5, prepDays: 3}\n    ];\n    \n    int[]|error result = solveSchedule(5, exams);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        // Exam on day 5\n        test:assertEquals(result[5], 1);\n        // Count prep days\n        int prepCount = 0;\n        foreach int day in 1 ..< 5 {\n            if result[day] == 1 {\n                prepCount += 1;\n            }\n        }\n        test:assertEquals(prepCount, 3);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need to schedule n days for m exams\n// 2. Each exam has: start day (when questions published), exam day, and prep days needed\n// 3. Strategy:\n//    - First, mark all exam days in the schedule\n//    - Sort exams by exam day (prioritize earlier exams)\n//    - For each exam (in sorted order), try to schedule preparation days\n//    - Preparation can only happen between start day and exam day (exclusive)\n//    - If we can't fit all required prep days, return -1\n// 4. Output: array where each index represents a day\n//    - 0 = rest day\n//    - i (1 to m) = prepare for exam i\n//    - exam_index (when it's exam day) = the exam number\n\nimport ballerina/io;\n\ntype Exam record {\n    int originalIndex;  // 1-based index in input order\n    int startDay;       // day questions are published\n    int examDay;        // day of exam\n    int prepDays;       // days needed to prepare\n};\n\nfunction solveSchedule(int n, Exam[] exams) returns int[]|error {\n    // Initialize schedule array (1-indexed, so size n+1)\n    int[] schedule = [];\n    foreach int i in 0 ..< n + 1 {\n        schedule.push(0);\n    }\n    \n    // First, mark all exam days\n    foreach Exam exam in exams {\n        if schedule[exam.examDay] != 0 {\n            // Conflict: two exams on same day (shouldn't happen per problem)\n            return error(\"Two exams on same day\");\n        }\n        schedule[exam.examDay] = exam.originalIndex;\n    }\n    \n    // Sort exams by exam day (earlier exams first)\n    Exam[] sortedExams = exams.clone();\n    foreach int i in 0 ..< sortedExams.length() {\n        foreach int j in i + 1 ..< sortedExams.length() {\n            if sortedExams[j].examDay < sortedExams[i].examDay {\n                Exam temp = sortedExams[i];\n                sortedExams[i] = sortedExams[j];\n                sortedExams[j] = temp;\n            }\n        }\n    }\n    \n    // For each exam (in order of exam day), schedule preparation\n    foreach Exam exam in sortedExams {\n        int prepScheduled = 0;\n        \n        // Try to schedule prep days between startDay and examDay\n        foreach int day in exam.startDay ..< exam.examDay {\n            if schedule[day] == 0 {\n                schedule[day] = exam.originalIndex;\n                prepScheduled += 1;\n                if prepScheduled == exam.prepDays {\n                    break;\n                }\n            }\n        }\n        \n        // Check if we scheduled enough prep days\n        if prepScheduled < exam.prepDays {\n            return error(\"Cannot schedule all preparation days\");\n        }\n    }\n    \n    return schedule;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read m exam specifications\n    Exam[] exams = [];\n    foreach int i in 1 ..= m {\n        string? examLine = io:readln();\n        if examLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        string[] examParts = examLine.trim().split(\" \");\n        if examParts.length() != 3 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int s = check 'int:fromString(examParts[0]);\n        int d = check 'int:fromString(examParts[1]);\n        int c = check 'int:fromString(examParts[2]);\n        \n        Exam exam = {\n            originalIndex: i,\n            startDay: s,\n            examDay: d,\n            prepDays: c\n        };\n        exams.push(exam);\n    }\n    \n    // Solve the scheduling problem\n    int[]|error result = solveSchedule(n, exams);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        // Output schedule (skip index 0, output from 1 to n)\n        string output = \"\";\n        foreach int day in 1 ..= n {\n            if output != \"\" {\n                output += \" \";\n            }\n            output += result[day].toString();\n        }\n        io:println(output);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(83:36,83:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(94:22,94:25)] invalid operation: type 'int' does not support field access\nERROR [main.bal:(94:25,94:25)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing close brace token\nERROR [main.bal:(94:26,94:26)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing open brace token\nERROR [main.bal:(94:30,94:30)] missing semicolon token\nERROR [main.bal:",
      "error": "Compilation error: ERROR [main.bal:(83:36,83:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(94:22,94:25)] invalid operation: type 'int' does not support field access\nERROR [main.bal:(94:25,94:25)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing close brace token\nERROR [main.bal:(94:26,94:26)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing open brace token\nERROR [main.bal:(94:30,94:30)] missing semicolon token\nERROR [main.bal:",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(83:36,83:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(94:22,94:25)] invalid operation: type 'int' does not support field access\nERROR [main.bal:(94:25,94:25)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing close brace token\nERROR [main.bal:(94:26,94:26)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing identifier\nERROR [main.bal:(94:26,94:26)] missing open brace token\nERROR [main.bal:(94:30,94:30)] missing semicolon token\nERROR [main.bal:(101:46,101:51)] undefined function 'split' in type 'string'\nERROR [main.bal:(112:28,112:29)] undefined symbol 'i'\nERROR [main.bal:(128:28,128:31)] invalid operation: type 'int' does not support field access\nERROR [main.bal:(128:31,128:31)] missing identifier\nERROR [main.bal:(128:32,128:32)] missing close brace token\nERROR [main.bal:(128:32,128:32)] missing close brace token\nERROR [main.bal:(128:32,128:32)] missing identifier\nERROR [main.bal:(128:32,128:32)] missing identifier\nERROR [main.bal:(128:32,128:32)] missing open brace token\nERROR [main.bal:(128:36,128:36)] missing semicolon token\nERROR [main.bal:(129:16,129:22)] undefined symbol 'output'\nERROR [main.bal:(130:17,130:23)] undefined symbol 'output'\nERROR [main.bal:(132:13,132:19)] undefined symbol 'output'\nERROR [main.bal:(132:23,132:34)] invalid operation: type '(int[]|error)' does not support member access\nERROR [main.bal:(134:20,134:26)] undefined symbol 'output'\nERROR [main.bal:(136:1,136:2)] invalid token '}'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:46:32.965894",
      "status": "failed",
      "completion": "Looking at the compilation errors, I need to fix:\n\n1. `split()` is not a built-in method - need to use `regex:split()` from ballerina/lang.regexp\n2. String concatenation and iteration issues\n3. Proper use of lang library functions\n\nLet me rewrite the solution with proper Ballerina syntax:\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Schedule n days for m exams\n// 2. Each exam has: start day (questions published), exam day, prep days needed\n// 3. Strategy:\n//    - Mark all exam days first in the schedule\n//    - Sort exams by exam day (prioritize earlier exams to avoid conflicts)\n//    - For each exam in sorted order, greedily assign preparation days\n//    - Preparation must be between start day and exam day (exclusive of exam day)\n//    - If we can't fit all required prep days for any exam, return -1\n// 4. Output format: array where index represents day number\n//    - 0 = rest day\n//    - i (1 to m) = prepare for exam i  \n//    - exam_index = the exam happening that day\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\ntype Exam record {\n    int originalIndex;  // 1-based index from input\n    int startDay;       // day questions published\n    int examDay;        // day of exam\n    int prepDays;       // days needed to prepare\n};\n\nfunction solveSchedule(int n, Exam[] exams) returns int[]|error {\n    // Initialize schedule array (size n+1 for 1-indexed access)\n    int[] schedule = [];\n    int idx = 0;\n    while idx <= n {\n        schedule.push(0);\n        idx = idx + 1;\n    }\n    \n    // First pass: mark all exam days\n    foreach Exam exam in exams {\n        if schedule[exam.examDay] != 0 {\n            return error(\"Conflict: multiple exams on same day\");\n        }\n        schedule[exam.examDay] = exam.originalIndex;\n    }\n    \n    // Sort exams by exam day using bubble sort (earlier exams first)\n    Exam[] sortedExams = exams.clone();\n    int i = 0;\n    while i < sortedExams.length() {\n        int j = i + 1;\n        while j < sortedExams.length() {\n            if sortedExams[j].examDay < sortedExams[i].examDay {\n                Exam temp = sortedExams[i];\n                sortedExams[i] = sortedExams[j];\n                sortedExams[j] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    \n    // Second pass: schedule preparation days for each exam\n    foreach Exam exam in sortedExams {\n        int prepScheduled = 0;\n        \n        // Try to find free days between startDay and examDay\n        int day = exam.startDay;\n        while day < exam.examDay {\n            if schedule[day] == 0 {\n                schedule[day] = exam.originalIndex;\n                prepScheduled = prepScheduled + 1;\n                if prepScheduled == exam.prepDays {\n                    break;\n                }\n            }\n            day = day + 1;\n        }\n        \n        // Verify we scheduled enough prep days\n        if prepScheduled < exam.prepDays {\n            return error(\"Insufficient days to prepare for exam\");\n        }\n    }\n    \n    return schedule;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    regexp:Span[] parts1 = regexp:split(re ` +`, line1.trim());\n    if parts1.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0].substring());\n    int m = check 'int:fromString(parts1[1].substring());\n    \n    // Read m exam specifications\n    Exam[] exams = [];\n    int examIdx = 1;\n    while examIdx <= m {\n        string? examLine = io:readln();\n        if examLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        regexp:Span[] examParts = regexp:split(re ` +`, examLine.trim());\n        if examParts.length() != 3 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int s = check 'int:fromString(examParts[0].substring());\n        int d = check 'int:fromString(examParts[1].substring());\n        int c = check 'int:fromString(examParts[2].substring());\n        \n        Exam exam = {\n            originalIndex: examIdx,\n            startDay: s,\n            examDay: d,\n            prepDays: c\n        };\n        exams.push(exam);\n        examIdx = examIdx + 1;\n    }\n    \n    // Solve the scheduling problem\n    int[]|error result = solveSchedule(n, exams);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        // Output schedule from day 1 to n\n        string[] outputParts = [];\n        int day = 1;\n        while day <= n {\n            outputParts.push(result[day].toString());\n            day = day + 1;\n        }\n        io:println(string:'join(\" \", ...outputParts));\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 1, examDay: 3, prepDays: 1},\n        {originalIndex: 2, startDay: 1, examDay: 5, prepDays: 1}\n    ];\n    \n    int[]|error result = solveSchedule(5, exams);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        // Exam 1 should be on day 3\n        test:assertEquals(result[3], 1);\n        // Exam 2 should be on day 5\n        test:assertEquals(result[5], 2);\n        // Count prep days for exam 1 (should be exactly 1)\n        int prep1Count = 0;\n        int day = 1;\n        while day < 3 {\n            if result[day] == 1 {\n                prep1Count = prep1Count + 1;\n            }\n            day = day + 1;\n        }\n        test:assertEquals(prep1Count, 1);\n    }\n}\n\n@test:Config {}\nfunction testExample2Impossible() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 1, examDay: 3, prepDays: 1},\n        {originalIndex: 2, startDay: 1, examDay: 2, prepDays: 1}\n    ];\n    \n    int[]|error result = solveSchedule(3, exams);\n    // This should be impossible - only 1 day available but need 2 prep days\n    test:assertTrue(result is error);\n}\n\n@test:Config {}\nfunction testExample3() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 4, examDay: 7, prepDays: 2},\n        {originalIndex: 2, startDay: 1, examDay: 10, prepDays: 3},\n        {originalIndex: 3, startDay: 8, examDay: 9, prepDays: 1}\n    ];\n    \n    int[]|error result = solveSchedule(10, exams);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        // Verify exam days\n        test:assertEquals(result[7], 1);\n        test:assertEquals(result[10], 2);\n        test:assertEquals(result[9], 3);\n        \n        // Count prep days for exam 1\n        int prep1Count = 0;\n        int day = 4;\n        while day < 7 {\n            if result[day] == 1 {\n                prep1Count = prep1Count + 1;\n            }\n            day = day + 1;\n        }\n        test:assertEquals(prep1Count, 2);\n    }\n}\n\n@test:Config {}\nfunction testSingleExam() {\n    Exam[] exams = [\n        {originalIndex: 1, startDay: 1, examDay: 5, prepDays: 3}\n    ];\n    \n    int[]|error result = solveSchedule(5, exams);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        // Exam should be on day 5\n        test:assertEquals(result[5], 1);\n        \n        // Count prep days (should be exactly 3)\n        int prepCount = 0;\n        int day = 1;\n        while day < 5 {\n            if result[day] == 1 {\n                prepCount = prepCount + 1;\n            }\n            day = day + 1;\n        }\n        test:assertEquals(prepCount, 3);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Schedule n days for m exams\n// 2. Each exam has: start day (questions published), exam day, prep days needed\n// 3. Strategy:\n//    - Mark all exam days first in the schedule\n//    - Sort exams by exam day (prioritize earlier exams to avoid conflicts)\n//    - For each exam in sorted order, greedily assign preparation days\n//    - Preparation must be between start day and exam day (exclusive of exam day)\n//    - If we can't fit all required prep days for any exam, return -1\n// 4. Output format: array where index represents day number\n//    - 0 = rest day\n//    - i (1 to m) = prepare for exam i  \n//    - exam_index = the exam happening that day\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\ntype Exam record {\n    int originalIndex;  // 1-based index from input\n    int startDay;       // day questions published\n    int examDay;        // day of exam\n    int prepDays;       // days needed to prepare\n};\n\nfunction solveSchedule(int n, Exam[] exams) returns int[]|error {\n    // Initialize schedule array (size n+1 for 1-indexed access)\n    int[] schedule = [];\n    int idx = 0;\n    while idx <= n {\n        schedule.push(0);\n        idx = idx + 1;\n    }\n    \n    // First pass: mark all exam days\n    foreach Exam exam in exams {\n        if schedule[exam.examDay] != 0 {\n            return error(\"Conflict: multiple exams on same day\");\n        }\n        schedule[exam.examDay] = exam.originalIndex;\n    }\n    \n    // Sort exams by exam day using bubble sort (earlier exams first)\n    Exam[] sortedExams = exams.clone();\n    int i = 0;\n    while i < sortedExams.length() {\n        int j = i + 1;\n        while j < sortedExams.length() {\n            if sortedExams[j].examDay < sortedExams[i].examDay {\n                Exam temp = sortedExams[i];\n                sortedExams[i] = sortedExams[j];\n                sortedExams[j] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    \n    // Second pass: schedule preparation days for each exam\n    foreach Exam exam in sortedExams {\n        int prepScheduled = 0;\n        \n        // Try to find free days between startDay and examDay\n        int day = exam.startDay;\n        while day < exam.examDay {\n            if schedule[day] == 0 {\n                schedule[day] = exam.originalIndex;\n                prepScheduled = prepScheduled + 1;\n                if prepScheduled == exam.prepDays {\n                    break;\n                }\n            }\n            day = day + 1;\n        }\n        \n        // Verify we scheduled enough prep days\n        if prepScheduled < exam.prepDays {\n            return error(\"Insufficient days to prepare for exam\");\n        }\n    }\n    \n    return schedule;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    regexp:Span[] parts1 = regexp:split(re ` +`, line1.trim());\n    if parts1.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0].substring());\n    int m = check 'int:fromString(parts1[1].substring());\n    \n    // Read m exam specifications\n    Exam[] exams = [];\n    int examIdx = 1;\n    while examIdx <= m {\n        string? examLine = io:readln();\n        if examLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        regexp:Span[] examParts = regexp:split(re ` +`, examLine.trim());\n        if examParts.length() != 3 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int s = check 'int:fromString(examParts[0].substring());\n        int d = check 'int:fromString(examParts[1].substring());\n        int c = check 'int:fromString(examParts[2].substring());\n        \n        Exam exam = {\n            originalIndex: examIdx,\n            startDay: s,\n            examDay: d,\n            prepDays: c\n        };\n        exams.push(exam);\n        examIdx = examIdx + 1;\n    }\n    \n    // Solve the scheduling problem\n    int[]|error result = solveSchedule(n, exams);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        // Output schedule from day 1 to n\n        string[] outputParts = [];\n        int day = 1;\n        while day <= n {\n            outputParts.push(result[day].toString());\n            day = day + 1;\n        }\n        io:println(string:'join(\" \", ...outputParts));\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(92:28,92:63)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nERROR [main.bal:(111:35,111:73)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(92:28,92:63)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nERROR [main.bal:(111:35,111:73)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(92:28,92:63)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nERROR [main.bal:(111:35,111:73)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(92:28,92:63)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nERROR [main.bal:(111:35,111:73)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T02:47:02.764718"
}