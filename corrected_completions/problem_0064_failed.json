{
  "entry_id": "problem_0064",
  "problem_index": 64,
  "prompt": "Title: Annoying Present\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAlice got an array of length $n$ as a birthday present once again! This is the third year in a row! \n\nAnd what is more disappointing, it is overwhelmengly boring, filled entirely with zeros. Bob decided to apply some changes to the array to cheer up Alice.\n\nBob has chosen $m$ changes of the following form. For some integer numbers $x$ and $d$, he chooses an arbitrary position $i$ ($1 \\le i \\le n$) and for every $j \\in [1, n]$ adds $x + d \\cdot dist(i, j)$ to the value of the $j$-th cell. $dist(i, j)$ is the distance between positions $i$ and $j$ (i.e. $dist(i, j) = |i - j|$, where $|x|$ is an absolute value of $x$).\n\nFor example, if Alice currently has an array $[2, 1, 2, 2]$ and Bob chooses position $3$ for $x = -1$ and $d = 2$ then the array will become $[2 - 1 + 2 \\cdot 2,~1 - 1 + 2 \\cdot 1,~2 - 1 + 2 \\cdot 0,~2 - 1 + 2 \\cdot 1]$ = $[5, 2, 1, 3]$. Note that Bob can't choose position $i$ outside of the array (that is, smaller than $1$ or greater than $n$).\n\nAlice will be the happiest when the elements of the array are as big as possible. Bob claimed that the arithmetic mean value of the elements will work fine as a metric.\n\nWhat is the maximum arithmetic mean value Bob can achieve?\n\nInput Specification:\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^5$) — the number of elements of the array and the number of changes.\n\nEach of the next $m$ lines contains two integers $x_i$ and $d_i$ ($-10^3 \\le x_i, d_i \\le 10^3$) — the parameters for the $i$-th change.\n\nOutput Specification:\nPrint the maximal average arithmetic mean of the elements Bob can achieve.\n\nYour answer is considered correct if its absolute or relative error doesn't exceed $10^{-6}$.\n\nDemo Input:\n['2 3\\n-1 3\\n0 0\\n-1 -4\\n', '3 2\\n0 2\\n5 0\\n']\n\nDemo Output:\n['-2.500000000000000\\n', '7.000000000000000\\n']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:05:05.272726",
      "status": "failed",
      "completion": "# Overview\nThis problem requires maximizing the arithmetic mean of an array after applying m transformations. Each transformation adds `x + d * dist(i, j)` to each element j when choosing position i.\n\nKey insights:\n1. For each transformation, we need to choose the optimal position i to maximize the sum\n2. When d >= 0, choosing i=1 or i=n (edges) maximizes the sum\n3. When d < 0, choosing i = middle position maximizes the sum (minimizes distances)\n4. The sum contribution of choosing position i is: `n*x + d * sum_of_distances_from_i`\n5. Sum of distances from position i to all positions = sum of |i-j| for all j\n6. For position i: sum = (i-1)*i/2 + (n-i)*(n-i+1)/2\n\n<CODE>\n```ballerina\n// Reasoning:\n// For each transformation with parameters (x, d):\n// - If we choose position i, the total contribution to the array sum is:\n//   n*x + d * (sum of distances from i to all positions)\n// - Sum of distances from position i = sum of |i-j| for j=1 to n\n// - This equals: sum(j=1 to i-1)(i-j) + sum(j=i+1 to n)(j-i)\n//   = (i-1)*i/2 + (n-i)*(n-i+1)/2\n// - When d >= 0: minimize distance sum → choose i=1 or i=n (both give same result)\n// - When d < 0: maximize distance sum → choose middle position\n// - For odd n, middle is (n+1)/2\n// - For even n, both n/2 and n/2+1 give same distance sum\n\nimport ballerina/io;\n\nfunction calculateDistanceSum(int n, int pos) returns int {\n    // Sum of distances from position pos to all positions in [1, n]\n    int leftSum = (pos - 1) * pos / 2;\n    int rightSum = (n - pos) * (n - pos + 1) / 2;\n    return leftSum + rightSum;\n}\n\nfunction maxArithmeticMean(int n, int[][] changes) returns float {\n    float totalSum = 0.0;\n    \n    foreach int[] change in changes {\n        int x = change[0];\n        int d = change[1];\n        \n        int bestContribution = 0;\n        \n        if d >= 0 {\n            // Choose edge position (i=1 or i=n, both give same result)\n            int distSum = calculateDistanceSum(n, 1);\n            bestContribution = n * x + d * distSum;\n        } else {\n            // d < 0, choose middle position to maximize distance sum\n            int midPos = (n + 1) / 2;\n            int distSum = calculateDistanceSum(n, midPos);\n            bestContribution = n * x + d * distSum;\n        }\n        \n        totalSum += <float>bestContribution;\n    }\n    \n    return totalSum / <float>n;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for n and m\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    \n    // Read m changes\n    int[][] changes = [];\n    foreach int i in 0 ..< m {\n        string? changeLine = io:readln();\n        if changeLine is () {\n            return error(\"Failed to read change line\");\n        }\n        \n        string[] changeParts = changeLine.trim().split(\" \");\n        if changeParts.length() != 2 {\n            return error(\"Invalid input format for change\");\n        }\n        \n        int x = check 'int:fromString(changeParts[0]);\n        int d = check 'int:fromString(changeParts[1]);\n        changes.push([x, d]);\n    }\n    \n    float result = maxArithmeticMean(n, changes);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] changes = [[-1, 3], [0, 0], [-1, -4]];\n    float result = maxArithmeticMean(2, changes);\n    test:assertEquals(result, -2.5, msg = \"Example 1 failed\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] changes = [[0, 2], [5, 0]];\n    float result = maxArithmeticMean(3, changes);\n    test:assertEquals(result, 7.0, msg = \"Example 2 failed\");\n}\n\n@test:Config {}\nfunction testSingleElementArray() {\n    int[][] changes = [[5, 0], [3, 2]];\n    float result = maxArithmeticMean(1, changes);\n    // For n=1, distance sum is always 0\n    // Total = 1*5 + 0*0 + 1*3 + 2*0 = 8\n    test:assertEquals(result, 8.0, msg = \"Single element test failed\");\n}\n\n@test:Config {}\nfunction testAllZeroChanges() {\n    int[][] changes = [[0, 0], [0, 0]];\n    float result = maxArithmeticMean(5, changes);\n    test:assertEquals(result, 0.0, msg = \"All zero changes test failed\");\n}\n\n@test:Config {}\nfunction testNegativeD() {\n    int[][] changes = [[10, -2]];\n    float result = maxArithmeticMean(4, changes);\n    // n=4, middle position is 2 (or 3, both work)\n    // Distance sum from pos 2: |2-1| + |2-2| + |2-3| + |2-4| = 1+0+1+2 = 4\n    // Contribution: 4*10 + (-2)*4 = 40 - 8 = 32\n    // Mean: 32/4 = 8.0\n    test:assertEquals(result, 8.0, msg = \"Negative d test failed\");\n}\n\n@test:Config {}\nfunction testDistanceSumCalculation() {\n    // Test distance sum calculation for various positions\n    int dist1 = calculateDistanceSum(4, 1);\n    test:assertEquals(dist1, 6, msg = \"Distance from position 1 in array of 4\");\n    \n    int dist2 = calculateDistanceSum(4, 2);\n    test:assertEquals(dist2, 4, msg = \"Distance from position 2 in array of 4\");\n    \n    int dist3 = calculateDistanceSum(3, 2);\n    test:assertEquals(dist3, 2, msg = \"Distance from position 2 in array of 3\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// For each transformation with parameters (x, d):\n// - If we choose position i, the total contribution to the array sum is:\n//   n*x + d * (sum of distances from i to all positions)\n// - Sum of distances from position i = sum of |i-j| for j=1 to n\n// - This equals: sum(j=1 to i-1)(i-j) + sum(j=i+1 to n)(j-i)\n//   = (i-1)*i/2 + (n-i)*(n-i+1)/2\n// - When d >= 0: minimize distance sum → choose i=1 or i=n (both give same result)\n// - When d < 0: maximize distance sum → choose middle position\n// - For odd n, middle is (n+1)/2\n// - For even n, both n/2 and n/2+1 give same distance sum\n\nimport ballerina/io;\n\nfunction calculateDistanceSum(int n, int pos) returns int {\n    // Sum of distances from position pos to all positions in [1, n]\n    int leftSum = (pos - 1) * pos / 2;\n    int rightSum = (n - pos) * (n - pos + 1) / 2;\n    return leftSum + rightSum;\n}\n\nfunction maxArithmeticMean(int n, int[][] changes) returns float {\n    float totalSum = 0.0;\n    \n    foreach int[] change in changes {\n        int x = change[0];\n        int d = change[1];\n        \n        int bestContribution = 0;\n        \n        if d >= 0 {\n            // Choose edge position (i=1 or i=n, both give same result)\n            int distSum = calculateDistanceSum(n, 1);\n            bestContribution = n * x + d * distSum;\n        } else {\n            // d < 0, choose middle position to maximize distance sum\n            int midPos = (n + 1) / 2;\n            int distSum = calculateDistanceSum(n, midPos);\n            bestContribution = n * x + d * distSum;\n        }\n        \n        totalSum += <float>bestContribution;\n    }\n    \n    return totalSum / <float>n;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for n and m\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    \n    // Read m changes\n    int[][] changes = [];\n    foreach int i in 0 ..< m {\n        string? changeLine = io:readln();\n        if changeLine is () {\n            return error(\"Failed to read change line\");\n        }\n        \n        string[] changeParts = changeLine.trim().split(\" \");\n        if changeParts.length() != 2 {\n            return error(\"Invalid input format for change\");\n        }\n        \n        int x = check 'int:fromString(changeParts[0]);\n        int d = check 'int:fromString(changeParts[1]);\n        changes.push([x, d]);\n    }\n    \n    float result = maxArithmeticMean(n, changes);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(55:35,55:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(71:50,71:55)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(55:35,55:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(71:50,71:55)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(55:35,55:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(71:50,71:55)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:05:35.017648",
      "status": "failed",
      "completion": "# Overview\nThis problem requires maximizing the arithmetic mean of an array after applying m transformations. Each transformation adds `x + d * dist(i, j)` to each element j when choosing position i.\n\nKey insights:\n1. For each transformation, we need to choose the optimal position i to maximize the sum\n2. When d >= 0, choosing i=1 or i=n (edges) maximizes the sum\n3. When d < 0, choosing i = middle position maximizes the sum (minimizes distances)\n4. The sum contribution of choosing position i is: `n*x + d * sum_of_distances_from_i`\n5. Sum of distances from position i to all positions = sum of |i-j| for all j\n\n**Fix for compilation error**: Ballerina uses `regex:split()` from the `ballerina/regex` module instead of a direct `split()` method on strings.\n\n<CODE>\n```ballerina\n// Reasoning:\n// For each transformation with parameters (x, d):\n// - If we choose position i, the total contribution to the array sum is:\n//   n*x + d * (sum of distances from i to all positions)\n// - Sum of distances from position i = sum of |i-j| for j=1 to n\n// - This equals: sum(j=1 to i-1)(i-j) + sum(j=i+1 to n)(j-i)\n//   = (i-1)*i/2 + (n-i)*(n-i+1)/2\n// - When d >= 0: minimize distance sum → choose i=1 or i=n (both give same result)\n// - When d < 0: maximize distance sum → choose middle position\n// - For odd n, middle is (n+1)/2\n// - For even n, both n/2 and n/2+1 give same distance sum\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction calculateDistanceSum(int n, int pos) returns int {\n    // Sum of distances from position pos to all positions in [1, n]\n    int leftSum = (pos - 1) * pos / 2;\n    int rightSum = (n - pos) * (n - pos + 1) / 2;\n    return leftSum + rightSum;\n}\n\nfunction maxArithmeticMean(int n, int[][] changes) returns float {\n    float totalSum = 0.0;\n    \n    foreach int[] change in changes {\n        int x = change[0];\n        int d = change[1];\n        \n        int bestContribution = 0;\n        \n        if d >= 0 {\n            // Choose edge position (i=1 or i=n, both give same result)\n            int distSum = calculateDistanceSum(n, 1);\n            bestContribution = n * x + d * distSum;\n        } else {\n            // d < 0, choose middle position to maximize distance sum\n            int midPos = (n + 1) / 2;\n            int distSum = calculateDistanceSum(n, midPos);\n            bestContribution = n * x + d * distSum;\n        }\n        \n        totalSum += <float>bestContribution;\n    }\n    \n    return totalSum / <float>n;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for n and m\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    \n    // Read m changes\n    int[][] changes = [];\n    foreach int i in 0 ..< m {\n        string? changeLine = io:readln();\n        if changeLine is () {\n            return error(\"Failed to read change line\");\n        }\n        \n        string[] changeParts = regex:split(changeLine.trim(), \" \");\n        if changeParts.length() != 2 {\n            return error(\"Invalid input format for change\");\n        }\n        \n        int x = check 'int:fromString(changeParts[0]);\n        int d = check 'int:fromString(changeParts[1]);\n        changes.push([x, d]);\n    }\n    \n    float result = maxArithmeticMean(n, changes);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] changes = [[-1, 3], [0, 0], [-1, -4]];\n    float result = maxArithmeticMean(2, changes);\n    test:assertEquals(result, -2.5, msg = \"Example 1 failed\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] changes = [[0, 2], [5, 0]];\n    float result = maxArithmeticMean(3, changes);\n    test:assertEquals(result, 7.0, msg = \"Example 2 failed\");\n}\n\n@test:Config {}\nfunction testSingleElementArray() {\n    int[][] changes = [[5, 0], [3, 2]];\n    float result = maxArithmeticMean(1, changes);\n    // For n=1, distance sum is always 0\n    // Total = 1*5 + 0*0 + 1*3 + 2*0 = 8\n    test:assertEquals(result, 8.0, msg = \"Single element test failed\");\n}\n\n@test:Config {}\nfunction testAllZeroChanges() {\n    int[][] changes = [[0, 0], [0, 0]];\n    float result = maxArithmeticMean(5, changes);\n    test:assertEquals(result, 0.0, msg = \"All zero changes test failed\");\n}\n\n@test:Config {}\nfunction testNegativeD() {\n    int[][] changes = [[10, -2]];\n    float result = maxArithmeticMean(4, changes);\n    // n=4, middle position is 2 (or 3, both work)\n    // Distance sum from pos 2: |2-1| + |2-2| + |2-3| + |2-4| = 1+0+1+2 = 4\n    // Contribution: 4*10 + (-2)*4 = 40 - 8 = 32\n    // Mean: 32/4 = 8.0\n    test:assertEquals(result, 8.0, msg = \"Negative d test failed\");\n}\n\n@test:Config {}\nfunction testDistanceSumCalculation() {\n    // Test distance sum calculation for various positions\n    int dist1 = calculateDistanceSum(4, 1);\n    test:assertEquals(dist1, 6, msg = \"Distance from position 1 in array of 4\");\n    \n    int dist2 = calculateDistanceSum(4, 2);\n    test:assertEquals(dist2, 4, msg = \"Distance from position 2 in array of 4\");\n    \n    int dist3 = calculateDistanceSum(3, 2);\n    test:assertEquals(dist3, 2, msg = \"Distance from position 2 in array of 3\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// For each transformation with parameters (x, d):\n// - If we choose position i, the total contribution to the array sum is:\n//   n*x + d * (sum of distances from i to all positions)\n// - Sum of distances from position i = sum of |i-j| for j=1 to n\n// - This equals: sum(j=1 to i-1)(i-j) + sum(j=i+1 to n)(j-i)\n//   = (i-1)*i/2 + (n-i)*(n-i+1)/2\n// - When d >= 0: minimize distance sum → choose i=1 or i=n (both give same result)\n// - When d < 0: maximize distance sum → choose middle position\n// - For odd n, middle is (n+1)/2\n// - For even n, both n/2 and n/2+1 give same distance sum\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction calculateDistanceSum(int n, int pos) returns int {\n    // Sum of distances from position pos to all positions in [1, n]\n    int leftSum = (pos - 1) * pos / 2;\n    int rightSum = (n - pos) * (n - pos + 1) / 2;\n    return leftSum + rightSum;\n}\n\nfunction maxArithmeticMean(int n, int[][] changes) returns float {\n    float totalSum = 0.0;\n    \n    foreach int[] change in changes {\n        int x = change[0];\n        int d = change[1];\n        \n        int bestContribution = 0;\n        \n        if d >= 0 {\n            // Choose edge position (i=1 or i=n, both give same result)\n            int distSum = calculateDistanceSum(n, 1);\n            bestContribution = n * x + d * distSum;\n        } else {\n            // d < 0, choose middle position to maximize distance sum\n            int midPos = (n + 1) / 2;\n            int distSum = calculateDistanceSum(n, midPos);\n            bestContribution = n * x + d * distSum;\n        }\n        \n        totalSum += <float>bestContribution;\n    }\n    \n    return totalSum / <float>n;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for n and m\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    \n    // Read m changes\n    int[][] changes = [];\n    foreach int i in 0 ..< m {\n        string? changeLine = io:readln();\n        if changeLine is () {\n            return error(\"Failed to read change line\");\n        }\n        \n        string[] changeParts = regex:split(changeLine.trim(), \" \");\n        if changeParts.length() != 2 {\n            return error(\"Invalid input format for change\");\n        }\n        \n        int x = check 'int:fromString(changeParts[0]);\n        int d = check 'int:fromString(changeParts[1]);\n        changes.push([x, d]);\n    }\n    \n    float result = maxArithmeticMean(n, changes);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "2 3\n-1 3\n0 0\n-1 -4\n",
          "expected_output": "-2.500000000000000\n",
          "actual_output": "-2.5\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T01:06:04.195983"
}