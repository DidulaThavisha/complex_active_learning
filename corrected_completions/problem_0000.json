{
  "entry_id": "problem_0000",
  "problem_index": 0,
  "prompt": "Title: Taxes\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nMr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to *n* (*n*<=≥<=2) burles and the amount of tax he has to pay is calculated as the maximum divisor of *n* (not equal to *n*, of course). For example, if *n*<==<=6 then Funt has to pay 3 burles, while for *n*<==<=25 he needs to pay 5 and if *n*<==<=2 he pays only 1 burle.\n\nAs mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial *n* in several parts *n*1<=+<=*n*2<=+<=...<=+<=*n**k*<==<=*n* (here *k* is arbitrary, even *k*<==<=1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition *n**i*<=≥<=2 should hold for all *i* from 1 to *k*.\n\nOstap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split *n* in parts.\n\nInput Specification:\nThe first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=2·109) — the total year income of mr. Funt.\n\nOutput Specification:\nPrint one integer — minimum possible number of burles that mr. Funt has to pay as a tax.\n\nDemo Input:\n['4\\n', '27\\n']\n\nDemo Output:\n['2\\n', '3\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\n\nThe problem asks us to find the minimum tax Mr. Funt needs to pay. The tax for a number is its maximum proper divisor (largest divisor except the number itself). Mr. Funt can split his income `n` into parts and pay tax on each part separately to minimize total tax.\n\nKey insights:\n1. For a prime number `p`, the maximum divisor is 1, so tax = 1\n2. For a composite number, the maximum divisor is larger\n3. If we can split `n` into prime numbers, each prime contributes tax of 1\n4. If `n` is prime, we can't split it (minimum part is 2), so tax = 1\n5. If `n` is even, we can split it into 2's (all primes), so tax = 2 (since n/2 twos, each paying 1)\n6. If `n` is odd composite, we can express it as sum of 3 (prime) and (n-3). If (n-3) is even, we split (n-3) into 2's. Tax = 1 + (n-3)/2 * 1 = 1 + (n-3)/2\n7. If `n` is odd prime, tax = 1\n8. Actually, for odd composite that's not prime: if we use one 3 and rest 2's, we need (n-3) to be even, which it is since n is odd. Total parts = 1 + (n-3)/2, total tax = 1 + (n-3)/2 = (n-1)/2\n\nWait, let me reconsider:\n- If n is prime: tax = 1 (can't split, pay tax on n itself)\n- If n is even: split into n/2 parts of 2, tax = n/2 * 1 = n/2... but this seems high\n- Actually, if n is even, we can split as 2 + (n-2). If (n-2) is prime, tax = 1 + 1 = 2. If (n-2) is composite, keep splitting.\n- Better approach: if n is prime, tax = 1. If n is even (composite), we can use 2 + (n-2) where both are >= 2. By Goldbach's conjecture, n-2 (even if >= 4) can be sum of two primes. So minimum tax for even n >= 4 is 2.\n- If n is odd composite, n = 3 + (n-3) where n-3 is even and >= 4 (since n >= 7 for odd composite). So tax = 1 + 2 = 3.\n- If n = 2, it's prime, tax = 1\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. If n is prime, we cannot split it optimally (splitting would give worse tax),\n//    so we pay tax on n itself which is 1 (smallest divisor > 1)\n// 2. If n is even (n >= 4), we can split it as sum of two primes (Goldbach's conjecture).\n//    Each prime contributes tax of 1, so total tax = 2\n// 3. If n is odd and composite (n >= 9), we can split as 3 + (n-3) where n-3 is even.\n//    3 is prime (tax=1), and n-3 can be split into two primes (tax=2), total = 3\n// 4. Special case: n=2 is prime, tax = 1\n//\n// Algorithm:\n// - Check if n is prime -> return 1\n// - If n is even -> return 2\n// - If n is odd and not prime -> return 3\n\nimport ballerina/io;\n\n// Check if a number is prime\nfunction isPrime(int n) returns boolean {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    \n    int i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i = i + 2;\n    }\n    return true;\n}\n\n// Calculate minimum tax for given income\nfunction calculateMinimumTax(int n) returns int {\n    // If n is prime, we can't split beneficially, so tax is 1\n    if isPrime(n) {\n        return 1;\n    }\n    \n    // If n is even (and not prime, so n >= 4), we can split into two primes\n    // Each prime has tax 1, so total tax = 2\n    if n % 2 == 0 {\n        return 2;\n    }\n    \n    // If n is odd and composite, we split as 3 + (n-3)\n    // 3 is prime (tax=1), n-3 is even and >= 4, so it splits into two primes (tax=2)\n    // Total tax = 1 + 2 = 3\n    return 3;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 2 {\n        io:println(\"Error: Income must be at least 2\");\n        return;\n    }\n    \n    int result = calculateMinimumTax(n);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testPrimeNumbers() {\n    // Test with prime number 2\n    int result = calculateMinimumTax(2);\n    test:assertEquals(result, 1);\n    \n    // Test with prime number 7\n    result = calculateMinimumTax(7);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testEvenNumbers() {\n    // Test with even number 4 (from demo)\n    int result = calculateMinimumTax(4);\n    test:assertEquals(result, 2);\n    \n    // Test with even number 6\n    result = calculateMinimumTax(6);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testOddCompositeNumbers() {\n    // Test with odd composite number 27 (from demo)\n    int result = calculateMinimumTax(27);\n    test:assertEquals(result, 3);\n    \n    // Test with odd composite number 9\n    result = calculateMinimumTax(9);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testIsPrimeFunction() {\n    // Test isPrime with various inputs\n    test:assertTrue(isPrime(2));\n    test:assertTrue(isPrime(3));\n    test:assertFalse(isPrime(4));\n    test:assertTrue(isPrime(11));\n    test:assertFalse(isPrime(27));\n    test:assertTrue(isPrime(97));\n}\n\n@test:Config {}\nfunction testLargeNumbers() {\n    // Test with larger prime\n    int result = calculateMinimumTax(97);\n    test:assertEquals(result, 1);\n    \n    // Test with large even number\n    result = calculateMinimumTax(1000);\n    test:assertEquals(result, 2);\n    \n    // Test with large odd composite\n    result = calculateMinimumTax(999);\n    test:assertEquals(result, 3);\n    \n    // Test with another large number\n    result = calculateMinimumTax(100);\n    test:assertEquals(result, 2);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. If n is prime, we cannot split it optimally (splitting would give worse tax),\n//    so we pay tax on n itself which is 1 (smallest divisor > 1)\n// 2. If n is even (n >= 4), we can split it as sum of two primes (Goldbach's conjecture).\n//    Each prime contributes tax of 1, so total tax = 2\n// 3. If n is odd and composite (n >= 9), we can split as 3 + (n-3) where n-3 is even.\n//    3 is prime (tax=1), and n-3 can be split into two primes (tax=2), total = 3\n// 4. Special case: n=2 is prime, tax = 1\n//\n// Algorithm:\n// - Check if n is prime -> return 1\n// - If n is even -> return 2\n// - If n is odd and not prime -> return 3\n\nimport ballerina/io;\n\n// Check if a number is prime\nfunction isPrime(int n) returns boolean {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    \n    int i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i = i + 2;\n    }\n    return true;\n}\n\n// Calculate minimum tax for given income\nfunction calculateMinimumTax(int n) returns int {\n    // If n is prime, we can't split beneficially, so tax is 1\n    if isPrime(n) {\n        return 1;\n    }\n    \n    // If n is even (and not prime, so n >= 4), we can split into two primes\n    // Each prime has tax 1, so total tax = 2\n    if n % 2 == 0 {\n        return 2;\n    }\n    \n    // If n is odd and composite, we split as 3 + (n-3)\n    // 3 is prime (tax=1), n-3 is even and >= 4, so it splits into two primes (tax=2)\n    // Total tax = 1 + 2 = 3\n    return 3;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 2 {\n        io:println(\"Error: Income must be at least 2\");\n        return;\n    }\n    \n    int result = calculateMinimumTax(n);\n    io:println(result);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-04T23:54:37.915325",
      "status": "success",
      "completion": "# Overview\n\nThe problem asks us to find the minimum tax Mr. Funt needs to pay. The tax for a number is its maximum proper divisor (largest divisor except the number itself). Mr. Funt can split his income `n` into parts and pay tax on each part separately to minimize total tax.\n\nKey insights:\n1. For a prime number `p`, the maximum divisor is 1, so tax = 1\n2. For a composite number, the maximum divisor is larger\n3. If we can split `n` into prime numbers, each prime contributes tax of 1\n4. If `n` is prime, we can't split it (minimum part is 2), so tax = 1\n5. If `n` is even, we can split it into 2's (all primes), so tax = 2 (since n/2 twos, each paying 1)\n6. If `n` is odd composite, we can express it as sum of 3 (prime) and (n-3). If (n-3) is even, we split (n-3) into 2's. Tax = 1 + (n-3)/2 * 1 = 1 + (n-3)/2\n7. If `n` is odd prime, tax = 1\n8. Actually, for odd composite that's not prime: if we use one 3 and rest 2's, we need (n-3) to be even, which it is since n is odd. Total parts = 1 + (n-3)/2, total tax = 1 + (n-3)/2 = (n-1)/2\n\nWait, let me reconsider:\n- If n is prime: tax = 1 (can't split, pay tax on n itself)\n- If n is even: split into n/2 parts of 2, tax = n/2 * 1 = n/2... but this seems high\n- Actually, if n is even, we can split as 2 + (n-2). If (n-2) is prime, tax = 1 + 1 = 2. If (n-2) is composite, keep splitting.\n- Better approach: if n is prime, tax = 1. If n is even (composite), we can use 2 + (n-2) where both are >= 2. By Goldbach's conjecture, n-2 (even if >= 4) can be sum of two primes. So minimum tax for even n >= 4 is 2.\n- If n is odd composite, n = 3 + (n-3) where n-3 is even and >= 4 (since n >= 7 for odd composite). So tax = 1 + 2 = 3.\n- If n = 2, it's prime, tax = 1\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. If n is prime, we cannot split it optimally (splitting would give worse tax),\n//    so we pay tax on n itself which is 1 (smallest divisor > 1)\n// 2. If n is even (n >= 4), we can split it as sum of two primes (Goldbach's conjecture).\n//    Each prime contributes tax of 1, so total tax = 2\n// 3. If n is odd and composite (n >= 9), we can split as 3 + (n-3) where n-3 is even.\n//    3 is prime (tax=1), and n-3 can be split into two primes (tax=2), total = 3\n// 4. Special case: n=2 is prime, tax = 1\n//\n// Algorithm:\n// - Check if n is prime -> return 1\n// - If n is even -> return 2\n// - If n is odd and not prime -> return 3\n\nimport ballerina/io;\n\n// Check if a number is prime\nfunction isPrime(int n) returns boolean {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    \n    int i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i = i + 2;\n    }\n    return true;\n}\n\n// Calculate minimum tax for given income\nfunction calculateMinimumTax(int n) returns int {\n    // If n is prime, we can't split beneficially, so tax is 1\n    if isPrime(n) {\n        return 1;\n    }\n    \n    // If n is even (and not prime, so n >= 4), we can split into two primes\n    // Each prime has tax 1, so total tax = 2\n    if n % 2 == 0 {\n        return 2;\n    }\n    \n    // If n is odd and composite, we split as 3 + (n-3)\n    // 3 is prime (tax=1), n-3 is even and >= 4, so it splits into two primes (tax=2)\n    // Total tax = 1 + 2 = 3\n    return 3;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 2 {\n        io:println(\"Error: Income must be at least 2\");\n        return;\n    }\n    \n    int result = calculateMinimumTax(n);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testPrimeNumbers() {\n    // Test with prime number 2\n    int result = calculateMinimumTax(2);\n    test:assertEquals(result, 1);\n    \n    // Test with prime number 7\n    result = calculateMinimumTax(7);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testEvenNumbers() {\n    // Test with even number 4 (from demo)\n    int result = calculateMinimumTax(4);\n    test:assertEquals(result, 2);\n    \n    // Test with even number 6\n    result = calculateMinimumTax(6);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testOddCompositeNumbers() {\n    // Test with odd composite number 27 (from demo)\n    int result = calculateMinimumTax(27);\n    test:assertEquals(result, 3);\n    \n    // Test with odd composite number 9\n    result = calculateMinimumTax(9);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testIsPrimeFunction() {\n    // Test isPrime with various inputs\n    test:assertTrue(isPrime(2));\n    test:assertTrue(isPrime(3));\n    test:assertFalse(isPrime(4));\n    test:assertTrue(isPrime(11));\n    test:assertFalse(isPrime(27));\n    test:assertTrue(isPrime(97));\n}\n\n@test:Config {}\nfunction testLargeNumbers() {\n    // Test with larger prime\n    int result = calculateMinimumTax(97);\n    test:assertEquals(result, 1);\n    \n    // Test with large even number\n    result = calculateMinimumTax(1000);\n    test:assertEquals(result, 2);\n    \n    // Test with large odd composite\n    result = calculateMinimumTax(999);\n    test:assertEquals(result, 3);\n    \n    // Test with another large number\n    result = calculateMinimumTax(100);\n    test:assertEquals(result, 2);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. If n is prime, we cannot split it optimally (splitting would give worse tax),\n//    so we pay tax on n itself which is 1 (smallest divisor > 1)\n// 2. If n is even (n >= 4), we can split it as sum of two primes (Goldbach's conjecture).\n//    Each prime contributes tax of 1, so total tax = 2\n// 3. If n is odd and composite (n >= 9), we can split as 3 + (n-3) where n-3 is even.\n//    3 is prime (tax=1), and n-3 can be split into two primes (tax=2), total = 3\n// 4. Special case: n=2 is prime, tax = 1\n//\n// Algorithm:\n// - Check if n is prime -> return 1\n// - If n is even -> return 2\n// - If n is odd and not prime -> return 3\n\nimport ballerina/io;\n\n// Check if a number is prime\nfunction isPrime(int n) returns boolean {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    \n    int i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i = i + 2;\n    }\n    return true;\n}\n\n// Calculate minimum tax for given income\nfunction calculateMinimumTax(int n) returns int {\n    // If n is prime, we can't split beneficially, so tax is 1\n    if isPrime(n) {\n        return 1;\n    }\n    \n    // If n is even (and not prime, so n >= 4), we can split into two primes\n    // Each prime has tax 1, so total tax = 2\n    if n % 2 == 0 {\n        return 2;\n    }\n    \n    // If n is odd and composite, we split as 3 + (n-3)\n    // 3 is prime (tax=1), n-3 is even and >= 4, so it splits into two primes (tax=2)\n    // Total tax = 1 + 2 = 3\n    return 3;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 2 {\n        io:println(\"Error: Income must be at least 2\");\n        return;\n    }\n    \n    int result = calculateMinimumTax(n);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-04T23:55:21.640672"
}