{
  "entry_id": "problem_0072",
  "problem_index": 72,
  "prompt": "Title: Points and Segments (easy)\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nIahub isn't well prepared on geometry problems, but he heard that this year there will be a lot of geometry problems on the IOI selection camp. Scared, Iahub locked himself in the basement and started thinking of new problems of this kind. One of them is the following.\n\nIahub wants to draw *n* distinct points and *m* segments on the *OX* axis. He can draw each point with either red or blue. The drawing is good if and only if the following requirement is met: for each segment [*l**i*,<=*r**i*] consider all the red points belong to it (*r**i* points), and all the blue points belong to it (*b**i* points); each segment *i* should satisfy the inequality |*r**i*<=-<=*b**i*|<=≤<=1.\n\nIahub thinks that point *x* belongs to segment [*l*,<=*r*], if inequality *l*<=≤<=*x*<=≤<=*r* holds.\n\nIahub gives to you all coordinates of points and segments. Please, help him to find any good drawing.\n\nInput Specification:\nThe first line of input contains two integers: *n* (1<=≤<=*n*<=≤<=100) and *m* (1<=≤<=*m*<=≤<=100). The next line contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (0<=≤<=*x**i*<=≤<=100) — the coordinates of the points. The following *m* lines contain the descriptions of the *m* segments. Each line contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=≤<=*r**i*<=≤<=100) — the borders of the *i*-th segment.\n\nIt's guaranteed that all the points are distinct.\n\nOutput Specification:\nIf there is no good drawing for a given test, output a single integer -1. Otherwise output *n* integers, each integer must be 0 or 1. The *i*-th number denotes the color of the *i*-th point (0 is red, and 1 is blue).\n\nIf there are multiple good drawings you can output any of them.\n\nDemo Input:\n['3 3\\n3 7 14\\n1 5\\n6 10\\n11 15\\n', '3 4\\n1 2 3\\n1 2\\n2 3\\n5 6\\n2 2\\n']\n\nDemo Output:\n['0 0 0', '1 0 1 ']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:13:50.270087",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to color n points (with red=0 or blue=1) such that for each segment, the absolute difference between the number of red and blue points within that segment is at most 1.\n\nThe approach is to try all possible colorings (2^n possibilities) and check which one satisfies all segment constraints. Since n ≤ 100, we need a smarter approach. We can use a greedy or brute force approach for small n, but since the constraint is n ≤ 100, we'll use a backtracking or try all 2^n combinations with early pruning. However, for practical purposes with n=100, we need an efficient solution.\n\nA pragmatic approach: Since n can be up to 100, brute force 2^100 is impossible. Instead, we can try a greedy approach or use constraint satisfaction. Let's implement a simple greedy heuristic that tries to balance colors, and if that doesn't work, we try a few random assignments or systematic search for smaller inputs.\n\nFor this implementation, I'll use a backtracking approach with pruning for reasonable performance.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n points and m segments\n// 2. Try to assign colors (0=red, 1=blue) to points\n// 3. For each segment, count red and blue points within range\n// 4. Check if |red - blue| <= 1 for all segments\n// 5. Use backtracking to find a valid coloring\n// \n// Since n can be up to 100, we'll try a greedy approach first,\n// then fall back to limited search if needed.\n\nimport ballerina/io;\n\n// Check if a coloring satisfies all segment constraints\nfunction isValidColoring(int[] points, int[] colors, int[][] segments) returns boolean {\n    foreach int[] segment in segments {\n        int left = segment[0];\n        int right = segment[1];\n        int redCount = 0;\n        int blueCount = 0;\n        \n        foreach int i in 0 ..< points.length() {\n            if points[i] >= left && points[i] <= right {\n                if colors[i] == 0 {\n                    redCount += 1;\n                } else {\n                    blueCount += 1;\n                }\n            }\n        }\n        \n        int diff = redCount - blueCount;\n        if diff < -1 || diff > 1 {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Try to find a valid coloring using backtracking\nfunction findColoring(int[] points, int[][] segments) returns int[]|error {\n    int n = points.length();\n    \n    // Try all possible colorings using bit manipulation\n    // For n <= 20, we can try all 2^n combinations\n    if n <= 20 {\n        int maxCombinations = 1 << n; // 2^n\n        foreach int mask in 0 ..< maxCombinations {\n            int[] colors = [];\n            foreach int i in 0 ..< n {\n                if (mask & (1 << i)) != 0 {\n                    colors.push(1);\n                } else {\n                    colors.push(0);\n                }\n            }\n            \n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    } else {\n        // For larger n, try greedy approaches\n        // Try all zeros\n        int[] colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(0);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Try alternating pattern\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(i % 2);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Try a few random patterns based on position\n        foreach int pattern in 0 ..< 100 {\n            colors = [];\n            foreach int i in 0 ..< n {\n                colors.push((i + pattern) % 2);\n            }\n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    }\n    \n    return error(\"No valid coloring found\");\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: point coordinates\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read points\");\n    }\n    \n    string[] pointStrs = line2.trim().split(\" \");\n    if pointStrs.length() != n {\n        return error(\"Invalid number of points\");\n    }\n    \n    int[] points = [];\n    foreach string pointStr in pointStrs {\n        points.push(check 'int:fromString(pointStr));\n    }\n    \n    // Read m segments\n    int[][] segments = [];\n    foreach int i in 0 ..< m {\n        string? segLine = io:readln();\n        if segLine is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        string[] segParts = segLine.trim().split(\" \");\n        if segParts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int left = check 'int:fromString(segParts[0]);\n        int right = check 'int:fromString(segParts[1]);\n        segments.push([left, right]);\n    }\n    \n    // Find valid coloring\n    int[]|error result = findColoring(points, segments);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        string output = \"\";\n        foreach int i in 0 ..< result.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += result[i].toString();\n        }\n        io:println(output);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testValidColoring1() {\n    int[] points = [3, 7, 14];\n    int[] colors = [0, 0, 0];\n    int[][] segments = [[1, 5], [6, 10], [11, 15]];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result);\n}\n\n@test:Config {}\nfunction testValidColoring2() {\n    int[] points = [1, 2, 3];\n    int[] colors = [1, 0, 1];\n    int[][] segments = [[1, 2], [2, 3], [5, 6], [2, 2]];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result);\n}\n\n@test:Config {}\nfunction testInvalidColoring() {\n    int[] points = [1, 2, 3];\n    int[] colors = [0, 0, 0];\n    int[][] segments = [[1, 3]]; // 3 red, 0 blue, diff = 3 > 1\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertFalse(result);\n}\n\n@test:Config {}\nfunction testFindColoring() {\n    int[] points = [3, 7, 14];\n    int[][] segments = [[1, 5], [6, 10], [11, 15]];\n    \n    int[]|error result = findColoring(points, segments);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        test:assertEquals(result.length(), 3);\n        test:assertTrue(isValidColoring(points, result, segments));\n    }\n}\n\n@test:Config {}\nfunction testEmptySegments() {\n    int[] points = [1, 2, 3];\n    int[] colors = [0, 1, 0];\n    int[][] segments = [];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result); // No constraints, should be valid\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n points and m segments\n// 2. Try to assign colors (0=red, 1=blue) to points\n// 3. For each segment, count red and blue points within range\n// 4. Check if |red - blue| <= 1 for all segments\n// 5. Use backtracking to find a valid coloring\n// \n// Since n can be up to 100, we'll try a greedy approach first,\n// then fall back to limited search if needed.\n\nimport ballerina/io;\n\n// Check if a coloring satisfies all segment constraints\nfunction isValidColoring(int[] points, int[] colors, int[][] segments) returns boolean {\n    foreach int[] segment in segments {\n        int left = segment[0];\n        int right = segment[1];\n        int redCount = 0;\n        int blueCount = 0;\n        \n        foreach int i in 0 ..< points.length() {\n            if points[i] >= left && points[i] <= right {\n                if colors[i] == 0 {\n                    redCount += 1;\n                } else {\n                    blueCount += 1;\n                }\n            }\n        }\n        \n        int diff = redCount - blueCount;\n        if diff < -1 || diff > 1 {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Try to find a valid coloring using backtracking\nfunction findColoring(int[] points, int[][] segments) returns int[]|error {\n    int n = points.length();\n    \n    // Try all possible colorings using bit manipulation\n    // For n <= 20, we can try all 2^n combinations\n    if n <= 20 {\n        int maxCombinations = 1 << n; // 2^n\n        foreach int mask in 0 ..< maxCombinations {\n            int[] colors = [];\n            foreach int i in 0 ..< n {\n                if (mask & (1 << i)) != 0 {\n                    colors.push(1);\n                } else {\n                    colors.push(0);\n                }\n            }\n            \n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    } else {\n        // For larger n, try greedy approaches\n        // Try all zeros\n        int[] colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(0);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Try alternating pattern\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(i % 2);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Try a few random patterns based on position\n        foreach int pattern in 0 ..< 100 {\n            colors = [];\n            foreach int i in 0 ..< n {\n                colors.push((i + pattern) % 2);\n            }\n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    }\n    \n    return error(\"No valid coloring found\");\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: point coordinates\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read points\");\n    }\n    \n    string[] pointStrs = line2.trim().split(\" \");\n    if pointStrs.length() != n {\n        return error(\"Invalid number of points\");\n    }\n    \n    int[] points = [];\n    foreach string pointStr in pointStrs {\n        points.push(check 'int:fromString(pointStr));\n    }\n    \n    // Read m segments\n    int[][] segments = [];\n    foreach int i in 0 ..< m {\n        string? segLine = io:readln();\n        if segLine is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        string[] segParts = segLine.trim().split(\" \");\n        if segParts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int left = check 'int:fromString(segParts[0]);\n        int right = check 'int:fromString(segParts[1]);\n        segments.push([left, right]);\n    }\n    \n    // Find valid coloring\n    int[]|error result = findColoring(points, segments);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        string output = \"\";\n        foreach int i in 0 ..< result.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += result[i].toString();\n        }\n        io:println(output);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(103:36,103:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:39,117:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(135:44,135:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(103:36,103:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:39,117:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(135:44,135:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(103:36,103:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:39,117:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(135:44,135:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:14:23.747539",
      "status": "failed",
      "completion": "# Overview\nThis problem requires coloring n points with two colors (red=0, blue=1) such that for each segment, the absolute difference between red and blue points within that segment is at most 1. The approach uses brute force for small n (≤20) and greedy heuristics for larger n. The key fix is using proper Ballerina string methods.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n points and m segments from input\n// 2. Try to assign colors (0=red, 1=blue) to points\n// 3. For each segment, count red and blue points within range [l, r]\n// 4. Verify if |red - blue| <= 1 for all segments\n// 5. Use brute force for n <= 20, and greedy heuristics for larger n\n// \n// Fix: Use ballerina/lang.string functions for string manipulation\n// The split functionality is in regex library, so we need to parse manually\n// or use the proper string methods\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\n// Check if a coloring satisfies all segment constraints\nfunction isValidColoring(int[] points, int[] colors, int[][] segments) returns boolean {\n    foreach int[] segment in segments {\n        int left = segment[0];\n        int right = segment[1];\n        int redCount = 0;\n        int blueCount = 0;\n        \n        foreach int i in 0 ..< points.length() {\n            if points[i] >= left && points[i] <= right {\n                if colors[i] == 0 {\n                    redCount += 1;\n                } else {\n                    blueCount += 1;\n                }\n            }\n        }\n        \n        int diff = redCount - blueCount;\n        if diff < -1 || diff > 1 {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Try to find a valid coloring using backtracking for small n, greedy for large n\nfunction findColoring(int[] points, int[][] segments) returns int[]|error {\n    int n = points.length();\n    \n    // Try all possible colorings for small n (brute force)\n    if n <= 20 {\n        int maxCombinations = 1 << n; // 2^n\n        foreach int mask in 0 ..< maxCombinations {\n            int[] colors = [];\n            foreach int i in 0 ..< n {\n                if (mask & (1 << i)) != 0 {\n                    colors.push(1);\n                } else {\n                    colors.push(0);\n                }\n            }\n            \n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    } else {\n        // For larger n, try various greedy patterns\n        // Pattern 1: all zeros\n        int[] colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(0);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Pattern 2: all ones\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(1);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Pattern 3: alternating pattern\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(i % 2);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Pattern 4: reverse alternating\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push((i + 1) % 2);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Try multiple offset patterns\n        foreach int offset in 0 ..< 50 {\n            colors = [];\n            foreach int i in 0 ..< n {\n                colors.push((i + offset) % 2);\n            }\n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    }\n    \n    return error(\"No valid coloring found\");\n}\n\n// Helper function to split string by spaces\nfunction splitBySpace(string input) returns string[] {\n    regexp:RegExp spaceRegex = re ` +`;\n    return spaceRegex.split(input.trim());\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string line1Input = io:readln();\n    string[] parts1 = splitBySpace(line1Input);\n    \n    if parts1.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: point coordinates\n    string line2Input = io:readln();\n    string[] pointStrs = splitBySpace(line2Input);\n    \n    if pointStrs.length() != n {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int[] points = [];\n    foreach string pointStr in pointStrs {\n        int point = check 'int:fromString(pointStr);\n        points.push(point);\n    }\n    \n    // Read m segments\n    int[][] segments = [];\n    foreach int i in 0 ..< m {\n        string segLineInput = io:readln();\n        string[] segParts = splitBySpace(segLineInput);\n        \n        if segParts.length() != 2 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int left = check 'int:fromString(segParts[0]);\n        int right = check 'int:fromString(segParts[1]);\n        segments.push([left, right]);\n    }\n    \n    // Find valid coloring\n    int[]|error result = findColoring(points, segments);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        string output = \"\";\n        foreach int i in 0 ..< result.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += result[i].toString();\n        }\n        io:println(output);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testValidColoring1() {\n    int[] points = [3, 7, 14];\n    int[] colors = [0, 0, 0];\n    int[][] segments = [[1, 5], [6, 10], [11, 15]];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result);\n}\n\n@test:Config {}\nfunction testValidColoring2() {\n    int[] points = [1, 2, 3];\n    int[] colors = [1, 0, 1];\n    int[][] segments = [[1, 2], [2, 3], [5, 6], [2, 2]];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result);\n}\n\n@test:Config {}\nfunction testInvalidColoring() {\n    int[] points = [1, 2, 3];\n    int[] colors = [0, 0, 0];\n    int[][] segments = [[1, 3]]; // 3 red, 0 blue, diff = 3 > 1\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertFalse(result);\n}\n\n@test:Config {}\nfunction testFindColoring() {\n    int[] points = [3, 7, 14];\n    int[][] segments = [[1, 5], [6, 10], [11, 15]];\n    \n    int[]|error result = findColoring(points, segments);\n    test:assertTrue(result is int[]);\n    \n    if result is int[] {\n        test:assertEquals(result.length(), 3);\n        test:assertTrue(isValidColoring(points, result, segments));\n    }\n}\n\n@test:Config {}\nfunction testEmptySegments() {\n    int[] points = [1, 2, 3];\n    int[] colors = [0, 1, 0];\n    int[][] segments = [];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result);\n}\n\n@test:Config {}\nfunction testSinglePointMultipleSegments() {\n    int[] points = [5];\n    int[] colors = [0];\n    int[][] segments = [[1, 10], [3, 7]];\n    \n    boolean result = isValidColoring(points, colors, segments);\n    test:assertTrue(result);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n points and m segments from input\n// 2. Try to assign colors (0=red, 1=blue) to points\n// 3. For each segment, count red and blue points within range [l, r]\n// 4. Verify if |red - blue| <= 1 for all segments\n// 5. Use brute force for n <= 20, and greedy heuristics for larger n\n// \n// Fix: Use ballerina/lang.string functions for string manipulation\n// The split functionality is in regex library, so we need to parse manually\n// or use the proper string methods\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\n// Check if a coloring satisfies all segment constraints\nfunction isValidColoring(int[] points, int[] colors, int[][] segments) returns boolean {\n    foreach int[] segment in segments {\n        int left = segment[0];\n        int right = segment[1];\n        int redCount = 0;\n        int blueCount = 0;\n        \n        foreach int i in 0 ..< points.length() {\n            if points[i] >= left && points[i] <= right {\n                if colors[i] == 0 {\n                    redCount += 1;\n                } else {\n                    blueCount += 1;\n                }\n            }\n        }\n        \n        int diff = redCount - blueCount;\n        if diff < -1 || diff > 1 {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Try to find a valid coloring using backtracking for small n, greedy for large n\nfunction findColoring(int[] points, int[][] segments) returns int[]|error {\n    int n = points.length();\n    \n    // Try all possible colorings for small n (brute force)\n    if n <= 20 {\n        int maxCombinations = 1 << n; // 2^n\n        foreach int mask in 0 ..< maxCombinations {\n            int[] colors = [];\n            foreach int i in 0 ..< n {\n                if (mask & (1 << i)) != 0 {\n                    colors.push(1);\n                } else {\n                    colors.push(0);\n                }\n            }\n            \n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    } else {\n        // For larger n, try various greedy patterns\n        // Pattern 1: all zeros\n        int[] colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(0);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Pattern 2: all ones\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(1);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Pattern 3: alternating pattern\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push(i % 2);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Pattern 4: reverse alternating\n        colors = [];\n        foreach int i in 0 ..< n {\n            colors.push((i + 1) % 2);\n        }\n        if isValidColoring(points, colors, segments) {\n            return colors;\n        }\n        \n        // Try multiple offset patterns\n        foreach int offset in 0 ..< 50 {\n            colors = [];\n            foreach int i in 0 ..< n {\n                colors.push((i + offset) % 2);\n            }\n            if isValidColoring(points, colors, segments) {\n                return colors;\n            }\n        }\n    }\n    \n    return error(\"No valid coloring found\");\n}\n\n// Helper function to split string by spaces\nfunction splitBySpace(string input) returns string[] {\n    regexp:RegExp spaceRegex = re ` +`;\n    return spaceRegex.split(input.trim());\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string line1Input = io:readln();\n    string[] parts1 = splitBySpace(line1Input);\n    \n    if parts1.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: point coordinates\n    string line2Input = io:readln();\n    string[] pointStrs = splitBySpace(line2Input);\n    \n    if pointStrs.length() != n {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int[] points = [];\n    foreach string pointStr in pointStrs {\n        int point = check 'int:fromString(pointStr);\n        points.push(point);\n    }\n    \n    // Read m segments\n    int[][] segments = [];\n    foreach int i in 0 ..< m {\n        string segLineInput = io:readln();\n        string[] segParts = splitBySpace(segLineInput);\n        \n        if segParts.length() != 2 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int left = check 'int:fromString(segParts[0]);\n        int right = check 'int:fromString(segParts[1]);\n        segments.push([left, right]);\n    }\n    \n    // Find valid coloring\n    int[]|error result = findColoring(points, segments);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        string output = \"\";\n        foreach int i in 0 ..< result.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += result[i].toString();\n        }\n        io:println(output);\n    }\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "3 4\n1 2 3\n1 2\n2 3\n5 6\n2 2\n",
          "expected_output": "1 0 1 ",
          "actual_output": "0 1 0\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T01:14:58.367304"
}