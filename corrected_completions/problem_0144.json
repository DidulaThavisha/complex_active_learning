{
  "entry_id": "problem_0144",
  "problem_index": 144,
  "prompt": "Title: The Monster\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAs Will is stuck in the Upside Down, he can still communicate with his mom, Joyce, through the Christmas lights (he can turn them on and off with his mind). He can't directly tell his mom where he is, because the monster that took him to the Upside Down will know and relocate him. \n\nThus, he came up with a puzzle to tell his mom his coordinates. His coordinates are the answer to the following problem.\n\nA string consisting only of parentheses ('(' and ')') is called a bracket sequence. Some bracket sequence are called correct bracket sequences. More formally:\n -  Empty string is a correct bracket sequence. -  if *s* is a correct bracket sequence, then (*s*) is also a correct bracket sequence. -  if *s* and *t* are correct bracket sequences, then *st* (concatenation of *s* and *t*) is also a correct bracket sequence. \nA string consisting of parentheses and question marks ('?') is called pretty if and only if there's a way to replace each question mark with either '(' or ')' such that the resulting string is a non-empty correct bracket sequence.\n\nWill gave his mom a string *s* consisting of parentheses and question marks (using Morse code through the lights) and his coordinates are the number of pairs of integers (*l*,<=*r*) such that 1<=≤<=*l*<=≤<=*r*<=≤<=|*s*| and the string *s**l**s**l*<=+<=1... *s**r* is pretty, where *s**i* is *i*-th character of *s*.\n\nJoyce doesn't know anything about bracket sequences, so she asked for your help.\n\nInput Specification:\nThe first and only line of input contains string *s*, consisting only of characters '(', ')' and '?' (2<=≤<=|*s*|<=≤<=5000).\n\nOutput Specification:\nPrint the answer to Will's puzzle in the first and only line of output.\n\nDemo Input:\n['((?))\\n', '??()??\\n']\n\nDemo Output:\n['4\\n', '7\\n']\n\nNote:\nFor the first sample testcase, the pretty substrings of *s* are:\n 1.  \"(?\" which can be transformed to \"()\". 1.  \"?)\" which can be transformed to \"()\". 1.  \"((?)\" which can be transformed to \"(())\". 1.  \"(?))\" which can be transformed to \"(())\". \nFor the second sample testcase, the pretty substrings of *s* are:\n 1.  \"??\" which can be transformed to \"()\". 1.  \"()\". 1.  \"??()\" which can be transformed to \"()()\". 1.  \"?()?\" which can be transformed to \"(())\". 1.  \"??\" which can be transformed to \"()\". 1.  \"()??\" which can be transformed to \"()()\". 1.  \"??()??\" which can be transformed to \"()()()\".",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem asks us to count the number of substrings of a given string (containing '(', ')', and '?') that can be transformed into valid bracket sequences by replacing '?' with either '(' or ')'. A valid bracket sequence must be non-empty, balanced, and properly nested.\n\nThe approach:\n1. For each possible substring (l, r), check if it can form a valid bracket sequence\n2. A substring is \"pretty\" if it has even length (odd length can never be balanced) and can be balanced by replacing '?' appropriately\n3. Use dynamic programming or greedy approach: track the balance while allowing '?' to be flexible\n4. For validation, we try to balance brackets by greedily choosing what '?' should be, tracking min/max possible open bracket counts\n\n<CODE>\n```ballerina\n// Reasoning:\n// - A valid bracket sequence must have even length\n// - We need to check if we can replace '?' to make it balanced\n// - Strategy: For each substring, simulate going left to right tracking:\n//   - min_open: minimum possible open brackets count\n//   - max_open: maximum possible open brackets count\n// - At each position:\n//   - '(' increases both min and max by 1\n//   - ')' decreases both min and max by 1\n//   - '?' can be either, so it increases max and decreases min\n// - If max_open ever goes negative, impossible (too many close brackets)\n// - At the end, min_open should be able to reach 0 (balanced)\n// - Keep min_open >= 0 by clamping it\n\nimport ballerina/io;\n\nfunction isPretty(string s) returns boolean {\n    int len = s.length();\n    \n    // Must be non-empty and even length\n    if len == 0 || len % 2 == 1 {\n        return false;\n    }\n    \n    int min_open = 0;\n    int max_open = 0;\n    \n    // Forward pass\n    foreach int i in 0 ..< len {\n        string char = s.substring(i, i + 1);\n        \n        if char == \"(\" {\n            min_open += 1;\n            max_open += 1;\n        } else if char == \")\" {\n            min_open -= 1;\n            max_open -= 1;\n        } else { // '?'\n            min_open -= 1;  // treat as ')'\n            max_open += 1;  // treat as '('\n        }\n        \n        // If max_open is negative, too many ')' - impossible\n        if max_open < 0 {\n            return false;\n        }\n        \n        // Keep min_open non-negative (we can always use '?' as '(' if needed)\n        if min_open < 0 {\n            min_open = 0;\n        }\n    }\n    \n    // At the end, we need to be able to have exactly 0 open brackets\n    // This is possible if 0 is between min_open and max_open\n    return min_open == 0;\n}\n\nfunction countPrettySubstrings(string s) returns int {\n    int count = 0;\n    int len = s.length();\n    \n    // Check all possible substrings\n    foreach int l in 0 ..< len {\n        foreach int r in (l + 1) ... len {\n            string substring = s.substring(l, r);\n            if isPretty(substring) {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string s = input_line.trim();\n        int result = countPrettySubstrings(s);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testIsPretty() {\n    // Test valid pretty strings\n    test:assertTrue(isPretty(\"(?\"));\n    test:assertTrue(isPretty(\"?)\"));\n    test:assertTrue(isPretty(\"((?)\"));\n    test:assertTrue(isPretty(\"(?))\"));\n}\n\n@test:Config {}\nfunction testIsNotPretty() {\n    // Test invalid strings\n    test:assertFalse(isPretty(\"\"));  // empty\n    test:assertFalse(isPretty(\"(\"));  // odd length\n    test:assertFalse(isPretty(\"))\"));  // too many close\n    test:assertFalse(isPretty(\"((\"));  // too many open\n}\n\n@test:Config {}\nfunction testCountPrettySubstrings1() {\n    int result = countPrettySubstrings(\"((?))\");\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testCountPrettySubstrings2() {\n    int result = countPrettySubstrings(\"??()??\");\n    test:assertEquals(result, 7);\n}\n\n@test:Config {}\nfunction testCountPrettySubstringsSimple() {\n    int result = countPrettySubstrings(\"()\");\n    test:assertEquals(result, 1);\n    \n    result = countPrettySubstrings(\"??\");\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testCountPrettySubstringsComplex() {\n    // Test with more complex patterns\n    int result = countPrettySubstrings(\"(())\");\n    test:assertEquals(result, 2);  // \"()\" and \"(())\"\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - A valid bracket sequence must have even length\n// - We need to check if we can replace '?' to make it balanced\n// - Strategy: For each substring, simulate going left to right tracking:\n//   - min_open: minimum possible open brackets count\n//   - max_open: maximum possible open brackets count\n// - At each position:\n//   - '(' increases both min and max by 1\n//   - ')' decreases both min and max by 1\n//   - '?' can be either, so it increases max and decreases min\n// - If max_open ever goes negative, impossible (too many close brackets)\n// - At the end, min_open should be able to reach 0 (balanced)\n// - Keep min_open >= 0 by clamping it\n\nimport ballerina/io;\n\nfunction isPretty(string s) returns boolean {\n    int len = s.length();\n    \n    // Must be non-empty and even length\n    if len == 0 || len % 2 == 1 {\n        return false;\n    }\n    \n    int min_open = 0;\n    int max_open = 0;\n    \n    // Forward pass\n    foreach int i in 0 ..< len {\n        string char = s.substring(i, i + 1);\n        \n        if char == \"(\" {\n            min_open += 1;\n            max_open += 1;\n        } else if char == \")\" {\n            min_open -= 1;\n            max_open -= 1;\n        } else { // '?'\n            min_open -= 1;  // treat as ')'\n            max_open += 1;  // treat as '('\n        }\n        \n        // If max_open is negative, too many ')' - impossible\n        if max_open < 0 {\n            return false;\n        }\n        \n        // Keep min_open non-negative (we can always use '?' as '(' if needed)\n        if min_open < 0 {\n            min_open = 0;\n        }\n    }\n    \n    // At the end, we need to be able to have exactly 0 open brackets\n    // This is possible if 0 is between min_open and max_open\n    return min_open == 0;\n}\n\nfunction countPrettySubstrings(string s) returns int {\n    int count = 0;\n    int len = s.length();\n    \n    // Check all possible substrings\n    foreach int l in 0 ..< len {\n        foreach int r in (l + 1) ... len {\n            string substring = s.substring(l, r);\n            if isPretty(substring) {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string s = input_line.trim();\n        int result = countPrettySubstrings(s);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:32:16.066145",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to count the number of substrings of a given string (containing '(', ')', and '?') that can be transformed into valid bracket sequences by replacing '?' with either '(' or ')'. A valid bracket sequence must be non-empty, balanced, and properly nested.\n\nThe approach:\n1. For each possible substring (l, r), check if it can form a valid bracket sequence\n2. A substring is \"pretty\" if it has even length (odd length can never be balanced) and can be balanced by replacing '?' appropriately\n3. Use dynamic programming or greedy approach: track the balance while allowing '?' to be flexible\n4. For validation, we try to balance brackets by greedily choosing what '?' should be, tracking min/max possible open bracket counts\n\n<CODE>\n```ballerina\n// Reasoning:\n// - A valid bracket sequence must have even length\n// - We need to check if we can replace '?' to make it balanced\n// - Strategy: For each substring, simulate going left to right tracking:\n//   - min_open: minimum possible open brackets count\n//   - max_open: maximum possible open brackets count\n// - At each position:\n//   - '(' increases both min and max by 1\n//   - ')' decreases both min and max by 1\n//   - '?' can be either, so it increases max and decreases min\n// - If max_open ever goes negative, impossible (too many close brackets)\n// - At the end, min_open should be able to reach 0 (balanced)\n// - Keep min_open >= 0 by clamping it\n\nimport ballerina/io;\n\nfunction isPretty(string s) returns boolean {\n    int len = s.length();\n    \n    // Must be non-empty and even length\n    if len == 0 || len % 2 == 1 {\n        return false;\n    }\n    \n    int min_open = 0;\n    int max_open = 0;\n    \n    // Forward pass\n    foreach int i in 0 ..< len {\n        string char = s.substring(i, i + 1);\n        \n        if char == \"(\" {\n            min_open += 1;\n            max_open += 1;\n        } else if char == \")\" {\n            min_open -= 1;\n            max_open -= 1;\n        } else { // '?'\n            min_open -= 1;  // treat as ')'\n            max_open += 1;  // treat as '('\n        }\n        \n        // If max_open is negative, too many ')' - impossible\n        if max_open < 0 {\n            return false;\n        }\n        \n        // Keep min_open non-negative (we can always use '?' as '(' if needed)\n        if min_open < 0 {\n            min_open = 0;\n        }\n    }\n    \n    // At the end, we need to be able to have exactly 0 open brackets\n    // This is possible if 0 is between min_open and max_open\n    return min_open == 0;\n}\n\nfunction countPrettySubstrings(string s) returns int {\n    int count = 0;\n    int len = s.length();\n    \n    // Check all possible substrings\n    foreach int l in 0 ..< len {\n        foreach int r in (l + 1) ... len {\n            string substring = s.substring(l, r);\n            if isPretty(substring) {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string s = input_line.trim();\n        int result = countPrettySubstrings(s);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testIsPretty() {\n    // Test valid pretty strings\n    test:assertTrue(isPretty(\"(?\"));\n    test:assertTrue(isPretty(\"?)\"));\n    test:assertTrue(isPretty(\"((?)\"));\n    test:assertTrue(isPretty(\"(?))\"));\n}\n\n@test:Config {}\nfunction testIsNotPretty() {\n    // Test invalid strings\n    test:assertFalse(isPretty(\"\"));  // empty\n    test:assertFalse(isPretty(\"(\"));  // odd length\n    test:assertFalse(isPretty(\"))\"));  // too many close\n    test:assertFalse(isPretty(\"((\"));  // too many open\n}\n\n@test:Config {}\nfunction testCountPrettySubstrings1() {\n    int result = countPrettySubstrings(\"((?))\");\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testCountPrettySubstrings2() {\n    int result = countPrettySubstrings(\"??()??\");\n    test:assertEquals(result, 7);\n}\n\n@test:Config {}\nfunction testCountPrettySubstringsSimple() {\n    int result = countPrettySubstrings(\"()\");\n    test:assertEquals(result, 1);\n    \n    result = countPrettySubstrings(\"??\");\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testCountPrettySubstringsComplex() {\n    // Test with more complex patterns\n    int result = countPrettySubstrings(\"(())\");\n    test:assertEquals(result, 2);  // \"()\" and \"(())\"\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - A valid bracket sequence must have even length\n// - We need to check if we can replace '?' to make it balanced\n// - Strategy: For each substring, simulate going left to right tracking:\n//   - min_open: minimum possible open brackets count\n//   - max_open: maximum possible open brackets count\n// - At each position:\n//   - '(' increases both min and max by 1\n//   - ')' decreases both min and max by 1\n//   - '?' can be either, so it increases max and decreases min\n// - If max_open ever goes negative, impossible (too many close brackets)\n// - At the end, min_open should be able to reach 0 (balanced)\n// - Keep min_open >= 0 by clamping it\n\nimport ballerina/io;\n\nfunction isPretty(string s) returns boolean {\n    int len = s.length();\n    \n    // Must be non-empty and even length\n    if len == 0 || len % 2 == 1 {\n        return false;\n    }\n    \n    int min_open = 0;\n    int max_open = 0;\n    \n    // Forward pass\n    foreach int i in 0 ..< len {\n        string char = s.substring(i, i + 1);\n        \n        if char == \"(\" {\n            min_open += 1;\n            max_open += 1;\n        } else if char == \")\" {\n            min_open -= 1;\n            max_open -= 1;\n        } else { // '?'\n            min_open -= 1;  // treat as ')'\n            max_open += 1;  // treat as '('\n        }\n        \n        // If max_open is negative, too many ')' - impossible\n        if max_open < 0 {\n            return false;\n        }\n        \n        // Keep min_open non-negative (we can always use '?' as '(' if needed)\n        if min_open < 0 {\n            min_open = 0;\n        }\n    }\n    \n    // At the end, we need to be able to have exactly 0 open brackets\n    // This is possible if 0 is between min_open and max_open\n    return min_open == 0;\n}\n\nfunction countPrettySubstrings(string s) returns int {\n    int count = 0;\n    int len = s.length();\n    \n    // Check all possible substrings\n    foreach int l in 0 ..< len {\n        foreach int r in (l + 1) ... len {\n            string substring = s.substring(l, r);\n            if isPretty(substring) {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string s = input_line.trim();\n        int result = countPrettySubstrings(s);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T02:32:50.760746"
}