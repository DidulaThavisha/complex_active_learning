{
  "entry_id": "problem_0117",
  "problem_index": 117,
  "prompt": "Title: Возможно, вы знаете этих людей?\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nОсновой любой социальной сети является отношение дружбы между двумя пользователями в том или ином смысле. В одной известной социальной сети дружба симметрична, то есть если *a* является другом *b*, то *b* также является другом *a*. \n\nВ этой же сети есть функция, которая демонстрирует множество людей, имеющих высокую вероятность быть знакомыми для пользователя. Эта функция работает следующим образом. Зафиксируем пользователя *x*. Пусть некоторый другой человек *y*, не являющийся другом *x* на текущий момент, является другом не менее, чем для *k*% друзей *x*. Тогда он является предполагаемым другом для *x*.\n\nУ каждого человека в социальной сети есть свой уникальный идентификатор — это целое число от 1 до 109. Вам дан список пар пользователей, являющихся друзьями. Определите для каждого упомянутого пользователя множество его предполагаемых друзей.\n\nInput Specification:\nВ первой строке следуют два целых числа *m* и *k* (1<=≤<=*m*<=≤<=100, 0<=≤<=*k*<=≤<=100) — количество пар друзей и необходимый процент общих друзей для того, чтобы считаться предполагаемым другом.\n\nВ последующих *m* строках записано по два числа *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=109, *a**i*<=≠<=*b**i*), обозначающих идентификаторы пользователей, являющихся друзьями. \n\nГарантируется, что каждая пара людей фигурирует в списке не более одного раза.\n\nOutput Specification:\nДля всех упомянутых людей в порядке возрастания id выведите информацию о предполагаемых друзьях. Информация должна иметь вид \"*id*:<= *k* *id*1 *id*2 ... *id**k*\", где *id* — это id самого человека, *k* — количество его предполагаемых друзей, а *id*1, *id*2, ..., *id**k* — идентификаторы его предполагаемых друзей в возрастающем порядке.\n\nDemo Input:\n['5 51\\n10 23\\n23 42\\n39 42\\n10 39\\n39 58\\n', '5 100\\n1 2\\n1 3\\n1 4\\n2 3\\n2 4\\n']\n\nDemo Output:\n['10: 1 42\\n23: 1 39\\n39: 1 23\\n42: 1 10\\n58: 2 10 42\\n', '1: 0\\n2: 0\\n3: 1 4\\n4: 1 3\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:03:51.404375",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to identify potential friends in a social network based on mutual connections. For each user, we need to find other users who are not direct friends but share at least k% of mutual friends. The solution involves:\n1. Building a friendship graph\n2. For each user, calculating what percentage of their friends are also friends with other users\n3. Suggesting users who meet the k% threshold as potential friends\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get m (number of friendships) and k (percentage threshold)\n// 2. Build a friendship map where each user ID maps to a set of their friend IDs\n// 3. For each user in the network:\n//    - Get their list of friends\n//    - For each other user (not themselves, not already a friend):\n//      - Count how many of the user's friends are also friends with the candidate\n//      - Calculate percentage: (mutual_friends / total_friends) * 100\n//      - If >= k%, add to suggested friends list\n// 4. Output results in sorted order by user ID\n\nimport ballerina/io;\n\n// Function to find suggested friends for all users in a social network\nfunction findSuggestedFriends(int m, int k, int[][] friendships) returns map<int[]>|error {\n    // Build friendship graph\n    map<map<boolean>> friendsMap = {};\n    int[] allUsers = [];\n    map<boolean> userSet = {};\n    \n    // Process all friendships\n    foreach int[] pair in friendships {\n        int user1 = pair[0];\n        int user2 = pair[1];\n        \n        // Track all users\n        if !userSet.hasKey(user1.toString()) {\n            userSet[user1.toString()] = true;\n            allUsers.push(user1);\n        }\n        if !userSet.hasKey(user2.toString()) {\n            userSet[user2.toString()] = true;\n            allUsers.push(user2);\n        }\n        \n        // Add bidirectional friendship\n        if !friendsMap.hasKey(user1.toString()) {\n            friendsMap[user1.toString()] = {};\n        }\n        if !friendsMap.hasKey(user2.toString()) {\n            friendsMap[user2.toString()] = {};\n        }\n        \n        map<boolean> friends1 = friendsMap.get(user1.toString());\n        friends1[user2.toString()] = true;\n        friendsMap[user1.toString()] = friends1;\n        \n        map<boolean> friends2 = friendsMap.get(user2.toString());\n        friends2[user1.toString()] = true;\n        friendsMap[user2.toString()] = friends2;\n    }\n    \n    // Sort all users\n    int[] sortedUsers = allUsers.sort();\n    \n    // Find suggested friends for each user\n    map<int[]> suggestions = {};\n    \n    foreach int user in sortedUsers {\n        int[] suggested = [];\n        string userKey = user.toString();\n        \n        // Get user's friends\n        map<boolean> userFriends = friendsMap.hasKey(userKey) ? friendsMap.get(userKey) : {};\n        int friendCount = userFriends.length();\n        \n        // If user has no friends, they can't have suggestions based on mutual friends\n        if friendCount == 0 {\n            suggestions[userKey] = suggested;\n            continue;\n        }\n        \n        // Check each other user as a potential suggestion\n        foreach int candidate in sortedUsers {\n            if candidate == user {\n                continue;\n            }\n            \n            string candidateKey = candidate.toString();\n            \n            // Skip if already friends\n            if userFriends.hasKey(candidateKey) {\n                continue;\n            }\n            \n            // Count mutual friends\n            map<boolean> candidateFriends = friendsMap.hasKey(candidateKey) ? friendsMap.get(candidateKey) : {};\n            int mutualCount = 0;\n            \n            foreach string friendId in userFriends.keys() {\n                if candidateFriends.hasKey(friendId) {\n                    mutualCount += 1;\n                }\n            }\n            \n            // Calculate percentage and check threshold\n            int percentage = (mutualCount * 100) / friendCount;\n            if percentage >= k {\n                suggested.push(candidate);\n            }\n        }\n        \n        suggestions[userKey] = suggested;\n    }\n    \n    return suggestions;\n}\n\npublic function main() returns error? {\n    // Read first line: m and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int m = check 'int:fromString(parts[0]);\n    int k = check 'int:fromString(parts[1]);\n    \n    // Read m friendship pairs\n    int[][] friendships = [];\n    int i = 0;\n    while i < m {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read friendship pair\");\n        }\n        \n        string[] pairParts = line.trim().split(\" \");\n        if pairParts.length() != 2 {\n            return error(\"Invalid friendship pair format\");\n        }\n        \n        int user1 = check 'int:fromString(pairParts[0]);\n        int user2 = check 'int:fromString(pairParts[1]);\n        friendships.push([user1, user2]);\n        \n        i += 1;\n    }\n    \n    // Find suggested friends\n    map<int[]> suggestions = check findSuggestedFriends(m, k, friendships);\n    \n    // Output results in sorted order\n    string[] sortedKeys = suggestions.keys().sort();\n    \n    foreach string userKey in sortedKeys {\n        int userId = check 'int:fromString(userKey);\n        int[] suggestedList = suggestions.get(userKey);\n        \n        string output = userId.toString() + \": \" + suggestedList.length().toString();\n        foreach int suggestedId in suggestedList {\n            output += \" \" + suggestedId.toString();\n        }\n        io:println(output);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() returns error? {\n    // Test case 1: m=5, k=51\n    int[][] friendships1 = [[10, 23], [23, 42], [39, 42], [10, 39], [39, 58]];\n    map<int[]> result1 = check findSuggestedFriends(5, 51, friendships1);\n    \n    // User 10 should have suggestions: 42\n    test:assertEquals(result1.get(\"10\").length(), 1);\n    test:assertEquals(result1.get(\"10\")[0], 42);\n    \n    // User 58 should have suggestions: 10, 42\n    test:assertEquals(result1.get(\"58\").length(), 2);\n    test:assertTrue(result1.get(\"58\")[0] == 10);\n    test:assertTrue(result1.get(\"58\")[1] == 42);\n}\n\n@test:Config {}\nfunction testExample2() returns error? {\n    // Test case 2: m=5, k=100\n    int[][] friendships2 = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]];\n    map<int[]> result2 = check findSuggestedFriends(5, 100, friendships2);\n    \n    // User 1 should have no suggestions (needs 100% mutual friends)\n    test:assertEquals(result2.get(\"1\").length(), 0);\n    \n    // User 3 should have suggestion: 4\n    test:assertEquals(result2.get(\"3\").length(), 1);\n    test:assertEquals(result2.get(\"3\")[0], 4);\n}\n\n@test:Config {}\nfunction testNoFriendships() returns error? {\n    // Test with no friendships\n    int[][] friendships = [];\n    map<int[]> result = check findSuggestedFriends(0, 50, friendships);\n    \n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testSingleFriendship() returns error? {\n    // Test with single friendship, k=0\n    int[][] friendships = [[1, 2]];\n    map<int[]> result = check findSuggestedFriends(1, 0, friendships);\n    \n    // Both users should have no suggestions (no mutual friends possible)\n    test:assertEquals(result.get(\"1\").length(), 0);\n    test:assertEquals(result.get(\"2\").length(), 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get m (number of friendships) and k (percentage threshold)\n// 2. Build a friendship map where each user ID maps to a set of their friend IDs\n// 3. For each user in the network:\n//    - Get their list of friends\n//    - For each other user (not themselves, not already a friend):\n//      - Count how many of the user's friends are also friends with the candidate\n//      - Calculate percentage: (mutual_friends / total_friends) * 100\n//      - If >= k%, add to suggested friends list\n// 4. Output results in sorted order by user ID\n\nimport ballerina/io;\n\n// Function to find suggested friends for all users in a social network\nfunction findSuggestedFriends(int m, int k, int[][] friendships) returns map<int[]>|error {\n    // Build friendship graph\n    map<map<boolean>> friendsMap = {};\n    int[] allUsers = [];\n    map<boolean> userSet = {};\n    \n    // Process all friendships\n    foreach int[] pair in friendships {\n        int user1 = pair[0];\n        int user2 = pair[1];\n        \n        // Track all users\n        if !userSet.hasKey(user1.toString()) {\n            userSet[user1.toString()] = true;\n            allUsers.push(user1);\n        }\n        if !userSet.hasKey(user2.toString()) {\n            userSet[user2.toString()] = true;\n            allUsers.push(user2);\n        }\n        \n        // Add bidirectional friendship\n        if !friendsMap.hasKey(user1.toString()) {\n            friendsMap[user1.toString()] = {};\n        }\n        if !friendsMap.hasKey(user2.toString()) {\n            friendsMap[user2.toString()] = {};\n        }\n        \n        map<boolean> friends1 = friendsMap.get(user1.toString());\n        friends1[user2.toString()] = true;\n        friendsMap[user1.toString()] = friends1;\n        \n        map<boolean> friends2 = friendsMap.get(user2.toString());\n        friends2[user1.toString()] = true;\n        friendsMap[user2.toString()] = friends2;\n    }\n    \n    // Sort all users\n    int[] sortedUsers = allUsers.sort();\n    \n    // Find suggested friends for each user\n    map<int[]> suggestions = {};\n    \n    foreach int user in sortedUsers {\n        int[] suggested = [];\n        string userKey = user.toString();\n        \n        // Get user's friends\n        map<boolean> userFriends = friendsMap.hasKey(userKey) ? friendsMap.get(userKey) : {};\n        int friendCount = userFriends.length();\n        \n        // If user has no friends, they can't have suggestions based on mutual friends\n        if friendCount == 0 {\n            suggestions[userKey] = suggested;\n            continue;\n        }\n        \n        // Check each other user as a potential suggestion\n        foreach int candidate in sortedUsers {\n            if candidate == user {\n                continue;\n            }\n            \n            string candidateKey = candidate.toString();\n            \n            // Skip if already friends\n            if userFriends.hasKey(candidateKey) {\n                continue;\n            }\n            \n            // Count mutual friends\n            map<boolean> candidateFriends = friendsMap.hasKey(candidateKey) ? friendsMap.get(candidateKey) : {};\n            int mutualCount = 0;\n            \n            foreach string friendId in userFriends.keys() {\n                if candidateFriends.hasKey(friendId) {\n                    mutualCount += 1;\n                }\n            }\n            \n            // Calculate percentage and check threshold\n            int percentage = (mutualCount * 100) / friendCount;\n            if percentage >= k {\n                suggested.push(candidate);\n            }\n        }\n        \n        suggestions[userKey] = suggested;\n    }\n    \n    return suggestions;\n}\n\npublic function main() returns error? {\n    // Read first line: m and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int m = check 'int:fromString(parts[0]);\n    int k = check 'int:fromString(parts[1]);\n    \n    // Read m friendship pairs\n    int[][] friendships = [];\n    int i = 0;\n    while i < m {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read friendship pair\");\n        }\n        \n        string[] pairParts = line.trim().split(\" \");\n        if pairParts.length() != 2 {\n            return error(\"Invalid friendship pair format\");\n        }\n        \n        int user1 = check 'int:fromString(pairParts[0]);\n        int user2 = check 'int:fromString(pairParts[1]);\n        friendships.push([user1, user2]);\n        \n        i += 1;\n    }\n    \n    // Find suggested friends\n    map<int[]> suggestions = check findSuggestedFriends(m, k, friendships);\n    \n    // Output results in sorted order\n    string[] sortedKeys = suggestions.keys().sort();\n    \n    foreach string userKey in sortedKeys {\n        int userId = check 'int:fromString(userKey);\n        int[] suggestedList = suggestions.get(userKey);\n        \n        string output = userId.toString() + \": \" + suggestedList.length().toString();\n        foreach int suggestedId in suggestedList {\n            output += \" \" + suggestedId.toString();\n        }\n        io:println(output);\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(116:35,116:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(133:42,133:47)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(116:35,116:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(133:42,133:47)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(116:35,116:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(133:42,133:47)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:04:24.493509",
      "status": "failed",
      "completion": "Looking at the compilation errors, the issue is that I'm trying to use `.split()` method on strings, but in Ballerina, the correct way to split strings is using the `regex:split()` function from the `ballerina/regex` module, or using `string:split()` from `ballerina/lang.string`.\n\nLet me analyze the problem more carefully:\n1. Build a friendship graph from the input pairs\n2. For each user, find candidates who are NOT direct friends but share >= k% of mutual friends\n3. The percentage calculation is: (mutual_friends_count / user's_total_friends_count) * 100 >= k\n\nKey fixes needed:\n- Use `regex:split()` for string splitting\n- Ensure proper integer division handling for percentage calculation\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get m (number of friendships) and k (percentage threshold)\n// 2. Build a friendship map where each user ID maps to a set of their friend IDs\n// 3. For each user in the network:\n//    - Get their list of friends (count = friendCount)\n//    - For each other user (not themselves, not already a friend):\n//      - Count how many of the user's friends are also friends with the candidate\n//      - Calculate percentage: (mutual_friends / user_friends) * 100\n//      - If percentage >= k%, add to suggested friends list\n// 4. Output results in sorted order by user ID\n//\n// Important: The percentage is based on the original user's friend count, not the candidate's\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to find suggested friends for all users in a social network\nfunction findSuggestedFriends(int m, int k, int[][] friendships) returns map<int[]>|error {\n    // Build friendship graph using maps\n    map<map<boolean>> friendsMap = {};\n    map<boolean> userSet = {};\n    \n    // Process all friendships - build bidirectional friendship graph\n    foreach int[] pair in friendships {\n        int user1 = pair[0];\n        int user2 = pair[1];\n        \n        // Track all unique users\n        userSet[user1.toString()] = true;\n        userSet[user2.toString()] = true;\n        \n        // Initialize friendship maps if not exist\n        if !friendsMap.hasKey(user1.toString()) {\n            friendsMap[user1.toString()] = {};\n        }\n        if !friendsMap.hasKey(user2.toString()) {\n            friendsMap[user2.toString()] = {};\n        }\n        \n        // Add bidirectional friendship\n        map<boolean> friends1 = friendsMap.get(user1.toString());\n        friends1[user2.toString()] = true;\n        friendsMap[user1.toString()] = friends1;\n        \n        map<boolean> friends2 = friendsMap.get(user2.toString());\n        friends2[user1.toString()] = true;\n        friendsMap[user2.toString()] = friends2;\n    }\n    \n    // Get all user IDs and sort them\n    string[] userKeys = userSet.keys();\n    int[] allUserIds = [];\n    foreach string key in userKeys {\n        int userId = check 'int:fromString(key);\n        allUserIds.push(userId);\n    }\n    int[] sortedUsers = allUserIds.sort();\n    \n    // Find suggested friends for each user\n    map<int[]> suggestions = {};\n    \n    foreach int user in sortedUsers {\n        int[] suggested = [];\n        string userKey = user.toString();\n        \n        // Get user's friends\n        map<boolean> userFriends = friendsMap.hasKey(userKey) ? friendsMap.get(userKey) : {};\n        int friendCount = userFriends.length();\n        \n        // If user has no friends, no suggestions possible\n        if friendCount == 0 {\n            suggestions[userKey] = suggested;\n            continue;\n        }\n        \n        // Check each other user as a potential suggestion\n        foreach int candidate in sortedUsers {\n            // Skip self\n            if candidate == user {\n                continue;\n            }\n            \n            string candidateKey = candidate.toString();\n            \n            // Skip if already friends\n            if userFriends.hasKey(candidateKey) {\n                continue;\n            }\n            \n            // Count mutual friends: friends of user who are also friends of candidate\n            map<boolean> candidateFriends = friendsMap.hasKey(candidateKey) ? friendsMap.get(candidateKey) : {};\n            int mutualCount = 0;\n            \n            // Iterate through user's friends and check if they're also candidate's friends\n            string[] userFriendKeys = userFriends.keys();\n            foreach string friendKey in userFriendKeys {\n                if candidateFriends.hasKey(friendKey) {\n                    mutualCount += 1;\n                }\n            }\n            \n            // Calculate percentage: (mutualCount / friendCount) * 100\n            // Using integer arithmetic: (mutualCount * 100) / friendCount\n            int percentage = (mutualCount * 100) / friendCount;\n            \n            if percentage >= k {\n                suggested.push(candidate);\n            }\n        }\n        \n        suggestions[userKey] = suggested;\n    }\n    \n    return suggestions;\n}\n\npublic function main() returns error? {\n    // Read first line: m and k\n    string? line1 = io:readln(\"Enter m and k: \");\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int m = check 'int:fromString(parts[0]);\n    int k = check 'int:fromString(parts[1]);\n    \n    // Read m friendship pairs\n    int[][] friendships = [];\n    int i = 0;\n    while i < m {\n        string? line = io:readln(\"Enter friendship pair: \");\n        if line is () {\n            return error(\"Failed to read friendship pair\");\n        }\n        \n        string[] pairParts = regex:split(line.trim(), \" \");\n        if pairParts.length() != 2 {\n            return error(\"Invalid friendship pair format\");\n        }\n        \n        int user1 = check 'int:fromString(pairParts[0]);\n        int user2 = check 'int:fromString(pairParts[1]);\n        friendships.push([user1, user2]);\n        \n        i += 1;\n    }\n    \n    // Find suggested friends\n    map<int[]> suggestions = check findSuggestedFriends(m, k, friendships);\n    \n    // Output results in sorted order by user ID\n    string[] sortedKeys = suggestions.keys();\n    int[] sortedUserIds = [];\n    foreach string key in sortedKeys {\n        int userId = check 'int:fromString(key);\n        sortedUserIds.push(userId);\n    }\n    sortedUserIds = sortedUserIds.sort();\n    \n    foreach int userId in sortedUserIds {\n        string userKey = userId.toString();\n        int[] suggestedList = suggestions.get(userKey);\n        \n        string output = userId.toString() + \": \" + suggestedList.length().toString();\n        foreach int suggestedId in suggestedList {\n            output += \" \" + suggestedId.toString();\n        }\n        io:println(output);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() returns error? {\n    // Test case 1: m=5, k=51\n    // Friendships: 10-23, 23-42, 39-42, 10-39, 39-58\n    // Friends: 10:[23,39], 23:[10,42], 39:[42,10,58], 42:[23,39], 58:[39]\n    int[][] friendships1 = [[10, 23], [23, 42], [39, 42], [10, 39], [39, 58]];\n    map<int[]> result1 = check findSuggestedFriends(5, 51, friendships1);\n    \n    // User 10 has friends [23,39]. Check candidate 42:\n    // mutual with 42: 23(yes), 39(yes) = 2/2 = 100% >= 51 ✓\n    test:assertEquals(result1.get(\"10\").length(), 1);\n    test:assertEquals(result1.get(\"10\")[0], 42);\n    \n    // User 58 has friends [39]. Check candidates:\n    // 10: mutual = 39 = 1/1 = 100% >= 51 ✓\n    // 42: mutual = 39 = 1/1 = 100% >= 51 ✓\n    test:assertEquals(result1.get(\"58\").length(), 2);\n    test:assertEquals(result1.get(\"58\")[0], 10);\n    test:assertEquals(result1.get(\"58\")[1], 42);\n}\n\n@test:Config {}\nfunction testExample2() returns error? {\n    // Test case 2: m=5, k=100\n    // Friendships: 1-2, 1-3, 1-4, 2-3, 2-4\n    // Friends: 1:[2,3,4], 2:[1,3,4], 3:[1,2], 4:[1,2]\n    int[][] friendships2 = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]];\n    map<int[]> result2 = check findSuggestedFriends(5, 100, friendships2);\n    \n    // User 1 has friends [2,3,4]. No candidate has 100% mutual (3/3)\n    test:assertEquals(result2.get(\"1\").length(), 0);\n    \n    // User 3 has friends [1,2]. Check candidate 4:\n    // mutual with 4: 1(yes), 2(yes) = 2/2 = 100% >= 100 ✓\n    test:assertEquals(result2.get(\"3\").length(), 1);\n    test:assertEquals(result2.get(\"3\")[0], 4);\n}\n\n@test:Config {}\nfunction testNoFriendships() returns error? {\n    // Test with no friendships\n    int[][] friendships = [];\n    map<int[]> result = check findSuggestedFriends(0, 50, friendships);\n    \n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testSingleFriendship() returns error? {\n    // Test with single friendship, k=0\n    // Users 1 and 2 are friends, but no one else exists\n    int[][] friendships = [[1, 2]];\n    map<int[]> result = check findSuggestedFriends(1, 0, friendships);\n    \n    // Both users have no suggestions (no third party for mutual friends)\n    test:assertEquals(result.get(\"1\").length(), 0);\n    test:assertEquals(result.get(\"2\").length(), 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get m (number of friendships) and k (percentage threshold)\n// 2. Build a friendship map where each user ID maps to a set of their friend IDs\n// 3. For each user in the network:\n//    - Get their list of friends (count = friendCount)\n//    - For each other user (not themselves, not already a friend):\n//      - Count how many of the user's friends are also friends with the candidate\n//      - Calculate percentage: (mutual_friends / user_friends) * 100\n//      - If percentage >= k%, add to suggested friends list\n// 4. Output results in sorted order by user ID\n//\n// Important: The percentage is based on the original user's friend count, not the candidate's\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to find suggested friends for all users in a social network\nfunction findSuggestedFriends(int m, int k, int[][] friendships) returns map<int[]>|error {\n    // Build friendship graph using maps\n    map<map<boolean>> friendsMap = {};\n    map<boolean> userSet = {};\n    \n    // Process all friendships - build bidirectional friendship graph\n    foreach int[] pair in friendships {\n        int user1 = pair[0];\n        int user2 = pair[1];\n        \n        // Track all unique users\n        userSet[user1.toString()] = true;\n        userSet[user2.toString()] = true;\n        \n        // Initialize friendship maps if not exist\n        if !friendsMap.hasKey(user1.toString()) {\n            friendsMap[user1.toString()] = {};\n        }\n        if !friendsMap.hasKey(user2.toString()) {\n            friendsMap[user2.toString()] = {};\n        }\n        \n        // Add bidirectional friendship\n        map<boolean> friends1 = friendsMap.get(user1.toString());\n        friends1[user2.toString()] = true;\n        friendsMap[user1.toString()] = friends1;\n        \n        map<boolean> friends2 = friendsMap.get(user2.toString());\n        friends2[user1.toString()] = true;\n        friendsMap[user2.toString()] = friends2;\n    }\n    \n    // Get all user IDs and sort them\n    string[] userKeys = userSet.keys();\n    int[] allUserIds = [];\n    foreach string key in userKeys {\n        int userId = check 'int:fromString(key);\n        allUserIds.push(userId);\n    }\n    int[] sortedUsers = allUserIds.sort();\n    \n    // Find suggested friends for each user\n    map<int[]> suggestions = {};\n    \n    foreach int user in sortedUsers {\n        int[] suggested = [];\n        string userKey = user.toString();\n        \n        // Get user's friends\n        map<boolean> userFriends = friendsMap.hasKey(userKey) ? friendsMap.get(userKey) : {};\n        int friendCount = userFriends.length();\n        \n        // If user has no friends, no suggestions possible\n        if friendCount == 0 {\n            suggestions[userKey] = suggested;\n            continue;\n        }\n        \n        // Check each other user as a potential suggestion\n        foreach int candidate in sortedUsers {\n            // Skip self\n            if candidate == user {\n                continue;\n            }\n            \n            string candidateKey = candidate.toString();\n            \n            // Skip if already friends\n            if userFriends.hasKey(candidateKey) {\n                continue;\n            }\n            \n            // Count mutual friends: friends of user who are also friends of candidate\n            map<boolean> candidateFriends = friendsMap.hasKey(candidateKey) ? friendsMap.get(candidateKey) : {};\n            int mutualCount = 0;\n            \n            // Iterate through user's friends and check if they're also candidate's friends\n            string[] userFriendKeys = userFriends.keys();\n            foreach string friendKey in userFriendKeys {\n                if candidateFriends.hasKey(friendKey) {\n                    mutualCount += 1;\n                }\n            }\n            \n            // Calculate percentage: (mutualCount / friendCount) * 100\n            // Using integer arithmetic: (mutualCount * 100) / friendCount\n            int percentage = (mutualCount * 100) / friendCount;\n            \n            if percentage >= k {\n                suggested.push(candidate);\n            }\n        }\n        \n        suggestions[userKey] = suggested;\n    }\n    \n    return suggestions;\n}\n\npublic function main() returns error? {\n    // Read first line: m and k\n    string? line1 = io:readln(\"Enter m and k: \");\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int m = check 'int:fromString(parts[0]);\n    int k = check 'int:fromString(parts[1]);\n    \n    // Read m friendship pairs\n    int[][] friendships = [];\n    int i = 0;\n    while i < m {\n        string? line = io:readln(\"Enter friendship pair: \");\n        if line is () {\n            return error(\"Failed to read friendship pair\");\n        }\n        \n        string[] pairParts = regex:split(line.trim(), \" \");\n        if pairParts.length() != 2 {\n            return error(\"Invalid friendship pair format\");\n        }\n        \n        int user1 = check 'int:fromString(pairParts[0]);\n        int user2 = check 'int:fromString(pairParts[1]);\n        friendships.push([user1, user2]);\n        \n        i += 1;\n    }\n    \n    // Find suggested friends\n    map<int[]> suggestions = check findSuggestedFriends(m, k, friendships);\n    \n    // Output results in sorted order by user ID\n    string[] sortedKeys = suggestions.keys();\n    int[] sortedUserIds = [];\n    foreach string key in sortedKeys {\n        int userId = check 'int:fromString(key);\n        sortedUserIds.push(userId);\n    }\n    sortedUserIds = sortedUserIds.sort();\n    \n    foreach int userId in sortedUserIds {\n        string userKey = userId.toString();\n        int[] suggestedList = suggestions.get(userKey);\n        \n        string output = userId.toString() + \": \" + suggestedList.length().toString();\n        foreach int suggestedId in suggestedList {\n            output += \" \" + suggestedId.toString();\n        }\n        io:println(output);\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5 51\n10 23\n23 42\n39 42\n10 39\n39 58\n",
          "expected_output": "10: 1 42\n23: 1 39\n39: 1 23\n42: 1 10\n58: 2 10 42\n",
          "actual_output": "Enter m and k: Enter friendship pair: Enter friendship pair: Enter friendship pair: Enter friendship pair: Enter friendship pair: 10: 1 42\n23: 1 39\n39: 1 23\n42: 1 10\n58: 2 10 42\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T02:05:08.172214"
}