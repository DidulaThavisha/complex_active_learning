{
  "entry_id": "problem_0194",
  "problem_index": 194,
  "prompt": "Title: Multi-core Processor\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nThe research center Q has developed a new multi-core processor. The processor consists of *n* cores and has *k* cells of cache memory. Consider the work of this processor.\n\nAt each cycle each core of the processor gets one instruction: either do nothing, or the number of the memory cell (the core will write an information to the cell). After receiving the command, the core executes it immediately. Sometimes it happens that at one cycle, multiple cores try to write the information into a single cell. Unfortunately, the developers did not foresee the possibility of resolving conflicts between cores, so in this case there is a deadlock: all these cores and the corresponding memory cell are locked forever. Each of the locked cores ignores all further commands, and no core in the future will be able to record an information into the locked cell. If any of the cores tries to write an information into some locked cell, it is immediately locked.\n\nThe development team wants to explore the deadlock situation. Therefore, they need a program that will simulate the processor for a given set of instructions for each core within *m* cycles . You're lucky, this interesting work is entrusted to you. According to the instructions, during the *m* cycles define for each core the number of the cycle, during which it will become locked. It is believed that initially all cores and all memory cells are not locked.\n\nInput Specification:\nThe first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=100). Then follow *n* lines describing instructions. The *i*-th line contains *m* integers: *x**i*1,<=*x**i*2,<=...,<=*x**im* (0<=≤<=*x**ij*<=≤<=*k*), where *x**ij* is the instruction that must be executed by the *i*-th core at the *j*-th cycle. If *x**ij* equals 0, then the corresponding instruction is «do nothing». But if *x**ij* is a number from 1 to *k*, then the corresponding instruction is «write information to the memory cell number *x**ij*».\n\nWe assume that the cores are numbered from 1 to *n*, the work cycles are numbered from 1 to *m* and the memory cells are numbered from 1 to *k*.\n\nOutput Specification:\nPrint *n* lines. In the *i*-th line print integer *t**i*. This number should be equal to 0 if the *i*-th core won't be locked, or it should be equal to the number of the cycle when this core will be locked.\n\nDemo Input:\n['4 3 5\\n1 0 0\\n1 0 2\\n2 3 1\\n3 2 0\\n', '3 2 2\\n1 2\\n1 2\\n2 2\\n', '1 1 1\\n0\\n']\n\nDemo Output:\n['1\\n1\\n3\\n0\\n', '1\\n1\\n0\\n', '0\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:34:20.021427",
      "status": "failed",
      "completion": "# Overview\nThis problem simulates a multi-core processor where cores write to memory cells. When multiple cores try to write to the same cell in the same cycle, all those cores and that cell become locked. Any core trying to write to a locked cell also becomes locked immediately.\n\nThe solution:\n1. Parse input to get n cores, m cycles, k memory cells, and instructions for each core\n2. Simulate each cycle sequentially\n3. Track which cores and cells are locked\n4. For each cycle, identify conflicts (multiple cores writing to same cell)\n5. Lock cores involved in conflicts and the memory cells\n6. Lock cores that try to write to already-locked cells\n7. Output the cycle number when each core gets locked (0 if never locked)\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We need to simulate m cycles for n cores writing to k memory cells\n// - At each cycle, we check which cores are trying to write to the same cell\n// - If multiple cores write to the same cell, all are locked along with that cell\n// - If a core writes to an already locked cell, it gets locked immediately\n// - We track when each core gets locked (0 if never locked)\n//\n// Algorithm:\n// 1. Parse input: n, m, k and n lines of m instructions each\n// 2. Initialize tracking arrays: coreLocked (cycle when locked), cellLocked (boolean)\n// 3. For each cycle 1 to m:\n//    a. Group cores by the cell they're writing to (ignoring 0 and already locked cores)\n//    b. For each cell being written to:\n//       - If cell is already locked, lock all cores trying to write to it\n//       - If multiple cores write to same cell, lock all those cores and the cell\n// 4. Output the lock cycle for each core (0 if not locked)\n\nimport ballerina/io;\n\nfunction simulateProcessor(int n, int m, int k, int[][] instructions) returns int[] {\n    // Track when each core gets locked (0 means not locked)\n    int[] coreLocked = [];\n    // Track which memory cells are locked\n    boolean[] cellLocked = [];\n    \n    // Initialize arrays\n    int i = 0;\n    while i < n {\n        coreLocked.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i <= k {\n        cellLocked.push(false);\n        i += 1;\n    }\n    \n    // Simulate each cycle\n    int cycle = 1;\n    while cycle <= m {\n        // Map from cell number to list of core indices writing to it\n        map<int[]> cellWriters = {};\n        \n        // Collect which cores are writing to which cells\n        int coreIdx = 0;\n        while coreIdx < n {\n            // Skip if core is already locked\n            if coreLocked[coreIdx] == 0 {\n                int cellNum = instructions[coreIdx][cycle - 1];\n                if cellNum > 0 {\n                    // Check if cell is already locked\n                    if cellLocked[cellNum] {\n                        coreLocked[coreIdx] = cycle;\n                    } else {\n                        // Add this core to the list of writers for this cell\n                        string key = cellNum.toString();\n                        if cellWriters.hasKey(key) {\n                            int[]? writers = cellWriters[key];\n                            if writers is int[] {\n                                writers.push(coreIdx);\n                            }\n                        } else {\n                            cellWriters[key] = [coreIdx];\n                        }\n                    }\n                }\n            }\n            coreIdx += 1;\n        }\n        \n        // Check for conflicts (multiple cores writing to same cell)\n        foreach string cellKey in cellWriters.keys() {\n            int[]? writers = cellWriters[cellKey];\n            if writers is int[] {\n                if writers.length() > 1 {\n                    // Multiple cores writing to same cell - lock all of them\n                    foreach int core in writers {\n                        if coreLocked[core] == 0 {\n                            coreLocked[core] = cycle;\n                        }\n                    }\n                    // Lock the memory cell\n                    int|error cellNum = 'int:fromString(cellKey);\n                    if cellNum is int {\n                        cellLocked[cellNum] = true;\n                    }\n                }\n            }\n        }\n        \n        cycle += 1;\n    }\n    \n    return coreLocked;\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read n lines of instructions\n    int[][] instructions = [];\n    int i = 0;\n    while i < n {\n        string? instructionLine = io:readln();\n        if instructionLine is () {\n            return error(\"Failed to read instruction line\");\n        }\n        \n        string[] instrParts = instructionLine.trim().split(\" \");\n        if instrParts.length() != m {\n            return error(\"Invalid instruction format\");\n        }\n        \n        int[] coreInstructions = [];\n        int j = 0;\n        while j < m {\n            int instr = check 'int:fromString(instrParts[j]);\n            coreInstructions.push(instr);\n            j += 1;\n        }\n        instructions.push(coreInstructions);\n        i += 1;\n    }\n    \n    // Simulate and get results\n    int[] results = simulateProcessor(n, m, k, instructions);\n    \n    // Output results\n    foreach int lockCycle in results {\n        io:println(lockCycle.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] instructions = [\n        [1, 0, 0],\n        [1, 0, 2],\n        [2, 3, 1],\n        [3, 2, 0]\n    ];\n    int[] result = simulateProcessor(4, 3, 5, instructions);\n    test:assertEquals(result[0], 1); // Core 1 locked at cycle 1\n    test:assertEquals(result[1], 1); // Core 2 locked at cycle 1\n    test:assertEquals(result[2], 3); // Core 3 locked at cycle 3\n    test:assertEquals(result[3], 0); // Core 4 never locked\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] instructions = [\n        [1, 2],\n        [1, 2],\n        [2, 2]\n    ];\n    int[] result = simulateProcessor(3, 2, 2, instructions);\n    test:assertEquals(result[0], 1); // Core 1 locked at cycle 1\n    test:assertEquals(result[1], 1); // Core 2 locked at cycle 1\n    test:assertEquals(result[2], 0); // Core 3 never locked (writes to different cell)\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[][] instructions = [\n        [0]\n    ];\n    int[] result = simulateProcessor(1, 1, 1, instructions);\n    test:assertEquals(result[0], 0); // Core does nothing, never locked\n}\n\n@test:Config {}\nfunction testLockedCellAccess() {\n    // Core 1 and 2 conflict on cell 1 at cycle 1\n    // Core 3 tries to write to cell 1 at cycle 2 (should lock)\n    int[][] instructions = [\n        [1, 0],\n        [1, 0],\n        [0, 1]\n    ];\n    int[] result = simulateProcessor(3, 2, 1, instructions);\n    test:assertEquals(result[0], 1); // Core 1 locked at cycle 1\n    test:assertEquals(result[1], 1); // Core 2 locked at cycle 1\n    test:assertEquals(result[2], 2); // Core 3 locked at cycle 2 (writes to locked cell)\n}\n\n@test:Config {}\nfunction testNoConflicts() {\n    int[][] instructions = [\n        [1, 2, 3],\n        [2, 3, 1],\n        [3, 1, 2]\n    ];\n    int[] result = simulateProcessor(3, 3, 3, instructions);\n    test:assertEquals(result[0], 0); // No conflicts, no locks\n    test:assertEquals(result[1], 0);\n    test:assertEquals(result[2], 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We need to simulate m cycles for n cores writing to k memory cells\n// - At each cycle, we check which cores are trying to write to the same cell\n// - If multiple cores write to the same cell, all are locked along with that cell\n// - If a core writes to an already locked cell, it gets locked immediately\n// - We track when each core gets locked (0 if never locked)\n//\n// Algorithm:\n// 1. Parse input: n, m, k and n lines of m instructions each\n// 2. Initialize tracking arrays: coreLocked (cycle when locked), cellLocked (boolean)\n// 3. For each cycle 1 to m:\n//    a. Group cores by the cell they're writing to (ignoring 0 and already locked cores)\n//    b. For each cell being written to:\n//       - If cell is already locked, lock all cores trying to write to it\n//       - If multiple cores write to same cell, lock all those cores and the cell\n// 4. Output the lock cycle for each core (0 if not locked)\n\nimport ballerina/io;\n\nfunction simulateProcessor(int n, int m, int k, int[][] instructions) returns int[] {\n    // Track when each core gets locked (0 means not locked)\n    int[] coreLocked = [];\n    // Track which memory cells are locked\n    boolean[] cellLocked = [];\n    \n    // Initialize arrays\n    int i = 0;\n    while i < n {\n        coreLocked.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i <= k {\n        cellLocked.push(false);\n        i += 1;\n    }\n    \n    // Simulate each cycle\n    int cycle = 1;\n    while cycle <= m {\n        // Map from cell number to list of core indices writing to it\n        map<int[]> cellWriters = {};\n        \n        // Collect which cores are writing to which cells\n        int coreIdx = 0;\n        while coreIdx < n {\n            // Skip if core is already locked\n            if coreLocked[coreIdx] == 0 {\n                int cellNum = instructions[coreIdx][cycle - 1];\n                if cellNum > 0 {\n                    // Check if cell is already locked\n                    if cellLocked[cellNum] {\n                        coreLocked[coreIdx] = cycle;\n                    } else {\n                        // Add this core to the list of writers for this cell\n                        string key = cellNum.toString();\n                        if cellWriters.hasKey(key) {\n                            int[]? writers = cellWriters[key];\n                            if writers is int[] {\n                                writers.push(coreIdx);\n                            }\n                        } else {\n                            cellWriters[key] = [coreIdx];\n                        }\n                    }\n                }\n            }\n            coreIdx += 1;\n        }\n        \n        // Check for conflicts (multiple cores writing to same cell)\n        foreach string cellKey in cellWriters.keys() {\n            int[]? writers = cellWriters[cellKey];\n            if writers is int[] {\n                if writers.length() > 1 {\n                    // Multiple cores writing to same cell - lock all of them\n                    foreach int core in writers {\n                        if coreLocked[core] == 0 {\n                            coreLocked[core] = cycle;\n                        }\n                    }\n                    // Lock the memory cell\n                    int|error cellNum = 'int:fromString(cellKey);\n                    if cellNum is int {\n                        cellLocked[cellNum] = true;\n                    }\n                }\n            }\n        }\n        \n        cycle += 1;\n    }\n    \n    return coreLocked;\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read n lines of instructions\n    int[][] instructions = [];\n    int i = 0;\n    while i < n {\n        string? instructionLine = io:readln();\n        if instructionLine is () {\n            return error(\"Failed to read instruction line\");\n        }\n        \n        string[] instrParts = instructionLine.trim().split(\" \");\n        if instrParts.length() != m {\n            return error(\"Invalid instruction format\");\n        }\n        \n        int[] coreInstructions = [];\n        int j = 0;\n        while j < m {\n            int instr = check 'int:fromString(instrParts[j]);\n            coreInstructions.push(instr);\n            j += 1;\n        }\n        instructions.push(coreInstructions);\n        i += 1;\n    }\n    \n    // Simulate and get results\n    int[] results = simulateProcessor(n, m, k, instructions);\n    \n    // Output results\n    foreach int lockCycle in results {\n        io:println(lockCycle.toString());\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(105:35,105:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(123:54,123:59)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(105:35,105:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(123:54,123:59)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(105:35,105:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(123:54,123:59)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:34:54.202759",
      "status": "failed",
      "completion": "Looking at the compilation errors, the issue is that `string` doesn't have a `split` method in Ballerina. I need to use the `regex` module from the standard library to split strings.\n\nLet me analyze the problem again:\n1. Multiple cores write to memory cells over m cycles\n2. When 2+ cores write to the same cell in the same cycle → all those cores lock + that cell locks\n3. When any core tries to write to an already-locked cell → that core locks immediately\n4. Need to track when each core gets locked (0 if never)\n\nI'll use `regex:split()` for string splitting and fix the implementation.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Simulate m cycles for n cores writing to k memory cells\n// - Track locked cores (cycle when locked) and locked cells (boolean)\n// - Each cycle:\n//   1. For each unlocked core, check what cell it's writing to\n//   2. If writing to already-locked cell → lock the core immediately\n//   3. If multiple cores write to same unlocked cell → lock all those cores and the cell\n// - Output lock cycle for each core (0 if never locked)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction simulateProcessor(int n, int m, int k, int[][] instructions) returns int[] {\n    // Track when each core gets locked (0 means not locked)\n    int[] coreLocked = [];\n    // Track which memory cells are locked\n    boolean[] cellLocked = [];\n    \n    // Initialize arrays\n    int i = 0;\n    while i < n {\n        coreLocked.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i <= k {\n        cellLocked.push(false);\n        i += 1;\n    }\n    \n    // Simulate each cycle\n    int cycle = 1;\n    while cycle <= m {\n        // Map from cell number to list of core indices writing to it\n        map<int[]> cellWriters = {};\n        \n        // Collect which cores are writing to which cells\n        int coreIdx = 0;\n        while coreIdx < n {\n            // Skip if core is already locked\n            if coreLocked[coreIdx] == 0 {\n                int cellNum = instructions[coreIdx][cycle - 1];\n                if cellNum > 0 {\n                    // Check if cell is already locked\n                    if cellLocked[cellNum] {\n                        coreLocked[coreIdx] = cycle;\n                    } else {\n                        // Add this core to the list of writers for this cell\n                        string key = cellNum.toString();\n                        if cellWriters.hasKey(key) {\n                            int[]? writers = cellWriters[key];\n                            if writers is int[] {\n                                writers.push(coreIdx);\n                            }\n                        } else {\n                            cellWriters[key] = [coreIdx];\n                        }\n                    }\n                }\n            }\n            coreIdx += 1;\n        }\n        \n        // Check for conflicts (multiple cores writing to same cell)\n        foreach string cellKey in cellWriters.keys() {\n            int[]? writers = cellWriters[cellKey];\n            if writers is int[] {\n                if writers.length() > 1 {\n                    // Multiple cores writing to same cell - lock all of them\n                    foreach int core in writers {\n                        if coreLocked[core] == 0 {\n                            coreLocked[core] = cycle;\n                        }\n                    }\n                    // Lock the memory cell\n                    int|error cellNum = 'int:fromString(cellKey);\n                    if cellNum is int {\n                        cellLocked[cellNum] = true;\n                    }\n                }\n            }\n        }\n        \n        cycle += 1;\n    }\n    \n    return coreLocked;\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read n lines of instructions\n    int[][] instructions = [];\n    int i = 0;\n    while i < n {\n        string? instructionLine = io:readln();\n        if instructionLine is () {\n            return error(\"Failed to read instruction line\");\n        }\n        \n        string[] instrParts = regex:split(instructionLine.trim(), \" \");\n        if instrParts.length() != m {\n            return error(\"Invalid instruction format\");\n        }\n        \n        int[] coreInstructions = [];\n        int j = 0;\n        while j < m {\n            int instr = check 'int:fromString(instrParts[j]);\n            coreInstructions.push(instr);\n            j += 1;\n        }\n        instructions.push(coreInstructions);\n        i += 1;\n    }\n    \n    // Simulate and get results\n    int[] results = simulateProcessor(n, m, k, instructions);\n    \n    // Output results\n    foreach int lockCycle in results {\n        io:println(lockCycle.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] instructions = [\n        [1, 0, 0],\n        [1, 0, 2],\n        [2, 3, 1],\n        [3, 2, 0]\n    ];\n    int[] result = simulateProcessor(4, 3, 5, instructions);\n    test:assertEquals(result[0], 1); // Core 1 locked at cycle 1\n    test:assertEquals(result[1], 1); // Core 2 locked at cycle 1\n    test:assertEquals(result[2], 3); // Core 3 locked at cycle 3\n    test:assertEquals(result[3], 0); // Core 4 never locked\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] instructions = [\n        [1, 2],\n        [1, 2],\n        [2, 2]\n    ];\n    int[] result = simulateProcessor(3, 2, 2, instructions);\n    test:assertEquals(result[0], 1); // Core 1 locked at cycle 1\n    test:assertEquals(result[1], 1); // Core 2 locked at cycle 1\n    test:assertEquals(result[2], 0); // Core 3 never locked\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[][] instructions = [\n        [0]\n    ];\n    int[] result = simulateProcessor(1, 1, 1, instructions);\n    test:assertEquals(result[0], 0); // Core does nothing, never locked\n}\n\n@test:Config {}\nfunction testLockedCellAccess() {\n    // Core 1 and 2 conflict on cell 1 at cycle 1\n    // Core 3 tries to write to cell 1 at cycle 2 (should lock)\n    int[][] instructions = [\n        [1, 0],\n        [1, 0],\n        [0, 1]\n    ];\n    int[] result = simulateProcessor(3, 2, 1, instructions);\n    test:assertEquals(result[0], 1); // Core 1 locked at cycle 1\n    test:assertEquals(result[1], 1); // Core 2 locked at cycle 1\n    test:assertEquals(result[2], 2); // Core 3 locked at cycle 2 (writes to locked cell)\n}\n\n@test:Config {}\nfunction testNoConflicts() {\n    int[][] instructions = [\n        [1, 2, 3],\n        [2, 3, 1],\n        [3, 1, 2]\n    ];\n    int[] result = simulateProcessor(3, 3, 3, instructions);\n    test:assertEquals(result[0], 0); // No conflicts, no locks\n    test:assertEquals(result[1], 0);\n    test:assertEquals(result[2], 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Simulate m cycles for n cores writing to k memory cells\n// - Track locked cores (cycle when locked) and locked cells (boolean)\n// - Each cycle:\n//   1. For each unlocked core, check what cell it's writing to\n//   2. If writing to already-locked cell → lock the core immediately\n//   3. If multiple cores write to same unlocked cell → lock all those cores and the cell\n// - Output lock cycle for each core (0 if never locked)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction simulateProcessor(int n, int m, int k, int[][] instructions) returns int[] {\n    // Track when each core gets locked (0 means not locked)\n    int[] coreLocked = [];\n    // Track which memory cells are locked\n    boolean[] cellLocked = [];\n    \n    // Initialize arrays\n    int i = 0;\n    while i < n {\n        coreLocked.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i <= k {\n        cellLocked.push(false);\n        i += 1;\n    }\n    \n    // Simulate each cycle\n    int cycle = 1;\n    while cycle <= m {\n        // Map from cell number to list of core indices writing to it\n        map<int[]> cellWriters = {};\n        \n        // Collect which cores are writing to which cells\n        int coreIdx = 0;\n        while coreIdx < n {\n            // Skip if core is already locked\n            if coreLocked[coreIdx] == 0 {\n                int cellNum = instructions[coreIdx][cycle - 1];\n                if cellNum > 0 {\n                    // Check if cell is already locked\n                    if cellLocked[cellNum] {\n                        coreLocked[coreIdx] = cycle;\n                    } else {\n                        // Add this core to the list of writers for this cell\n                        string key = cellNum.toString();\n                        if cellWriters.hasKey(key) {\n                            int[]? writers = cellWriters[key];\n                            if writers is int[] {\n                                writers.push(coreIdx);\n                            }\n                        } else {\n                            cellWriters[key] = [coreIdx];\n                        }\n                    }\n                }\n            }\n            coreIdx += 1;\n        }\n        \n        // Check for conflicts (multiple cores writing to same cell)\n        foreach string cellKey in cellWriters.keys() {\n            int[]? writers = cellWriters[cellKey];\n            if writers is int[] {\n                if writers.length() > 1 {\n                    // Multiple cores writing to same cell - lock all of them\n                    foreach int core in writers {\n                        if coreLocked[core] == 0 {\n                            coreLocked[core] = cycle;\n                        }\n                    }\n                    // Lock the memory cell\n                    int|error cellNum = 'int:fromString(cellKey);\n                    if cellNum is int {\n                        cellLocked[cellNum] = true;\n                    }\n                }\n            }\n        }\n        \n        cycle += 1;\n    }\n    \n    return coreLocked;\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read n lines of instructions\n    int[][] instructions = [];\n    int i = 0;\n    while i < n {\n        string? instructionLine = io:readln();\n        if instructionLine is () {\n            return error(\"Failed to read instruction line\");\n        }\n        \n        string[] instrParts = regex:split(instructionLine.trim(), \" \");\n        if instrParts.length() != m {\n            return error(\"Invalid instruction format\");\n        }\n        \n        int[] coreInstructions = [];\n        int j = 0;\n        while j < m {\n            int instr = check 'int:fromString(instrParts[j]);\n            coreInstructions.push(instr);\n            j += 1;\n        }\n        instructions.push(coreInstructions);\n        i += 1;\n    }\n    \n    // Simulate and get results\n    int[] results = simulateProcessor(n, m, k, instructions);\n    \n    // Output results\n    foreach int lockCycle in results {\n        io:println(lockCycle.toString());\n    }\n    \n    return;\n}",
      "tests_passed": 2,
      "tests_total": 3,
      "tests_pass_rate": 0.6666666666666666,
      "validation_msg": "Only passed 2/3 tests (66.7%), need 75%",
      "error": "Only passed 2/3 tests (66.7%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "3 2 2\n1 2\n1 2\n2 2\n",
          "expected_output": "1\n1\n0\n",
          "actual_output": "",
          "error": "Timeout (code took >10 seconds)"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 2/3 tests (66.7%), need 75%",
  "timestamp": "2026-01-05T03:35:38.559859"
}