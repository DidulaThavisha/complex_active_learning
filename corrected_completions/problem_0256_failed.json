{
  "entry_id": "problem_0256",
  "problem_index": 256,
  "prompt": "Title: Andrey and Problem\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAndrey needs one more problem to conduct a programming contest. He has *n* friends who are always willing to help. He can ask some of them to come up with a contest problem. Andrey knows one value for each of his fiends — the probability that this friend will come up with a problem if Andrey asks him.\n\nHelp Andrey choose people to ask. As he needs only one problem, Andrey is going to be really upset if no one comes up with a problem or if he gets more than one problem from his friends. You need to choose such a set of people that maximizes the chances of Andrey not getting upset.\n\nInput Specification:\nThe first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of Andrey's friends. The second line contains *n* real numbers *p**i* (0.0<=≤<=*p**i*<=≤<=1.0) — the probability that the *i*-th friend can come up with a problem. The probabilities are given with at most 6 digits after decimal point.\n\nOutput Specification:\nPrint a single real number — the probability that Andrey won't get upset at the optimal choice of friends. The answer will be considered valid if it differs from the correct one by at most 10<=-<=9.\n\nDemo Input:\n['4\\n0.1 0.2 0.3 0.8\\n', '2\\n0.1 0.2\\n']\n\nDemo Output:\n['0.800000000000\\n', '0.260000000000\\n']\n\nNote:\nIn the first sample the best strategy for Andrey is to ask only one of his friends, the most reliable one.\n\nIn the second sample the best strategy for Andrey is to ask all of his friends to come up with a problem. Then the probability that he will get exactly one problem is 0.1·0.8 + 0.9·0.2 = 0.26.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:41:32.513964",
      "status": "failed",
      "completion": "# Overview\n\nThe problem asks us to find the optimal subset of friends to ask for a problem such that the probability of getting exactly one problem is maximized. \n\nFor each subset of friends, we need to calculate:\n- Probability of getting exactly 1 problem = sum over each friend i in subset of: p[i] * product of (1 - p[j]) for all other j in subset\n\nThe key insight is that we need to check all possible subsets (or use a greedy approach). However, checking individual friends and pairs is often optimal. The strategy is:\n1. Try asking no one (probability = 0)\n2. Try asking each friend individually (probability = p[i])\n3. Try asking combinations of friends and calculate probability of exactly one success\n\nFor efficiency, we can observe that we should try:\n- Each single friend alone\n- All possible subsets (since n ≤ 100, we need an efficient approach)\n\nActually, for this problem, we typically only need to consider:\n- Single friends (probability p[i])\n- Multiple friends where we calculate the exact probability\n\nLet me implement a solution that tries all possible subsets up to a reasonable size or uses dynamic programming.\n\n<CODE>\n```ballerina\n// Reasoning:\n// To maximize probability of exactly one problem, we need to choose a subset of friends.\n// For a given subset S, probability of exactly one problem is:\n// P(exactly 1) = sum over i in S of: p[i] * product over j in S, j!=i of: (1-p[j])\n// \n// Strategy: Try all possible subsets (2^n possibilities)\n// For small n (≤100), we can use bit manipulation or iterative approach\n// However, 2^100 is too large. We need optimization.\n// \n// Key insight: Often the optimal is either:\n// 1. A single friend with highest probability\n// 2. Multiple friends with low probabilities\n// \n// We'll check all possible subsets efficiently by limiting our search\n// or using the fact that we likely only need small subsets.\n\nimport ballerina/io;\n\n// Calculate probability of exactly one success given a subset of probabilities\nfunction calculateExactlyOneProb(decimal[] probabilities) returns decimal {\n    if probabilities.length() == 0 {\n        return 0.0;\n    }\n    \n    decimal totalProb = 0.0;\n    \n    // For each friend in the subset, calculate probability that only they succeed\n    foreach int i in 0 ..< probabilities.length() {\n        decimal prob = probabilities[i];\n        \n        // Multiply by probability that all others fail\n        foreach int j in 0 ..< probabilities.length() {\n            if i != j {\n                prob = prob * (1.0 - probabilities[j]);\n            }\n        }\n        \n        totalProb = totalProb + prob;\n    }\n    \n    return totalProb;\n}\n\n// Find the maximum probability by trying different subsets\nfunction findMaxProbability(decimal[] probabilities) returns decimal {\n    int n = probabilities.length();\n    decimal maxProb = 0.0;\n    \n    // Try all possible non-empty subsets using bit manipulation\n    // Limit to reasonable subset sizes due to computation\n    int maxSubsets = 1 << n; // 2^n\n    \n    // For n > 20, we need to optimize. Let's try a greedy approach for large n.\n    if n > 20 {\n        // Try single friends\n        foreach decimal p in probabilities {\n            if p > maxProb {\n                maxProb = p;\n            }\n        }\n        \n        // Try pairs and small combinations\n        foreach int i in 0 ..< n {\n            foreach int j in i + 1 ..< n {\n                decimal[] subset = [probabilities[i], probabilities[j]];\n                decimal prob = calculateExactlyOneProb(subset);\n                if prob > maxProb {\n                    maxProb = prob;\n                }\n            }\n        }\n        \n        return maxProb;\n    }\n    \n    // For smaller n, try all subsets\n    foreach int mask in 1 ..< maxSubsets {\n        decimal[] subset = [];\n        \n        foreach int i in 0 ..< n {\n            if (mask & (1 << i)) != 0 {\n                subset.push(probabilities[i]);\n            }\n        }\n        \n        decimal prob = calculateExactlyOneProb(subset);\n        if prob > maxProb {\n            maxProb = prob;\n        }\n    }\n    \n    return maxProb;\n}\n\npublic function main() returns error? {\n    // Read number of friends\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Read probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read probabilities\");\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    if parts.length() != n {\n        return error(\"Number of probabilities doesn't match n\");\n    }\n    \n    decimal[] probabilities = [];\n    foreach string part in parts {\n        decimal prob = check decimal:fromString(part.trim());\n        probabilities.push(prob);\n    }\n    \n    decimal result = findMaxProbability(probabilities);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleFriend() {\n    decimal[] probs = [0.8];\n    decimal result = calculateExactlyOneProb(probs);\n    test:assertEquals(result, 0.8);\n}\n\n@test:Config {}\nfunction testTwoFriendsExample() {\n    decimal[] probs = [0.1, 0.2];\n    decimal result = calculateExactlyOneProb(probs);\n    // P(exactly 1) = 0.1 * 0.8 + 0.9 * 0.2 = 0.08 + 0.18 = 0.26\n    test:assertTrue((result - 0.26).abs() < 0.0001);\n}\n\n@test:Config {}\nfunction testFindMaxWithSingleBest() {\n    decimal[] probs = [0.1, 0.2, 0.3, 0.8];\n    decimal result = findMaxProbability(probs);\n    // Best strategy is to ask only the friend with 0.8 probability\n    test:assertEquals(result, 0.8);\n}\n\n@test:Config {}\nfunction testFindMaxWithMultiple() {\n    decimal[] probs = [0.1, 0.2];\n    decimal result = findMaxProbability(probs);\n    // Best strategy is to ask both\n    test:assertTrue((result - 0.26).abs() < 0.0001);\n}\n\n@test:Config {}\nfunction testAllZeroProbabilities() {\n    decimal[] probs = [0.0, 0.0, 0.0];\n    decimal result = findMaxProbability(probs);\n    test:assertEquals(result, 0.0);\n}\n\n@test:Config {}\nfunction testThreeFriends() {\n    decimal[] probs = [0.5, 0.5, 0.5];\n    decimal result = calculateExactlyOneProb(probs);\n    // P(exactly 1) = 3 * 0.5 * 0.5 * 0.5 = 0.375\n    test:assertTrue((result - 0.375).abs() < 0.0001);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// To maximize probability of exactly one problem, we need to choose a subset of friends.\n// For a given subset S, probability of exactly one problem is:\n// P(exactly 1) = sum over i in S of: p[i] * product over j in S, j!=i of: (1-p[j])\n// \n// Strategy: Try all possible subsets (2^n possibilities)\n// For small n (≤100), we can use bit manipulation or iterative approach\n// However, 2^100 is too large. We need optimization.\n// \n// Key insight: Often the optimal is either:\n// 1. A single friend with highest probability\n// 2. Multiple friends with low probabilities\n// \n// We'll check all possible subsets efficiently by limiting our search\n// or using the fact that we likely only need small subsets.\n\nimport ballerina/io;\n\n// Calculate probability of exactly one success given a subset of probabilities\nfunction calculateExactlyOneProb(decimal[] probabilities) returns decimal {\n    if probabilities.length() == 0 {\n        return 0.0;\n    }\n    \n    decimal totalProb = 0.0;\n    \n    // For each friend in the subset, calculate probability that only they succeed\n    foreach int i in 0 ..< probabilities.length() {\n        decimal prob = probabilities[i];\n        \n        // Multiply by probability that all others fail\n        foreach int j in 0 ..< probabilities.length() {\n            if i != j {\n                prob = prob * (1.0 - probabilities[j]);\n            }\n        }\n        \n        totalProb = totalProb + prob;\n    }\n    \n    return totalProb;\n}\n\n// Find the maximum probability by trying different subsets\nfunction findMaxProbability(decimal[] probabilities) returns decimal {\n    int n = probabilities.length();\n    decimal maxProb = 0.0;\n    \n    // Try all possible non-empty subsets using bit manipulation\n    // Limit to reasonable subset sizes due to computation\n    int maxSubsets = 1 << n; // 2^n\n    \n    // For n > 20, we need to optimize. Let's try a greedy approach for large n.\n    if n > 20 {\n        // Try single friends\n        foreach decimal p in probabilities {\n            if p > maxProb {\n                maxProb = p;\n            }\n        }\n        \n        // Try pairs and small combinations\n        foreach int i in 0 ..< n {\n            foreach int j in i + 1 ..< n {\n                decimal[] subset = [probabilities[i], probabilities[j]];\n                decimal prob = calculateExactlyOneProb(subset);\n                if prob > maxProb {\n                    maxProb = prob;\n                }\n            }\n        }\n        \n        return maxProb;\n    }\n    \n    // For smaller n, try all subsets\n    foreach int mask in 1 ..< maxSubsets {\n        decimal[] subset = [];\n        \n        foreach int i in 0 ..< n {\n            if (mask & (1 << i)) != 0 {\n                subset.push(probabilities[i]);\n            }\n        }\n        \n        decimal prob = calculateExactlyOneProb(subset);\n        if prob > maxProb {\n            maxProb = prob;\n        }\n    }\n    \n    return maxProb;\n}\n\npublic function main() returns error? {\n    // Read number of friends\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Read probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read probabilities\");\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    if parts.length() != n {\n        return error(\"Number of probabilities doesn't match n\");\n    }\n    \n    decimal[] probabilities = [];\n    foreach string part in parts {\n        decimal prob = check decimal:fromString(part.trim());\n        probabilities.push(prob);\n    }\n    \n    decimal result = findMaxProbability(probabilities);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(110:35,110:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(110:35,110:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(110:35,110:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:42:06.328325",
      "status": "failed",
      "completion": "# Overview\n\nThe problem asks us to find the optimal subset of friends to ask for a problem such that the probability of getting exactly one problem is maximized.\n\nKey insight: For a subset of friends with probabilities p1, p2, ..., pk, the probability of getting exactly one problem is:\nP(exactly 1) = p1*(1-p2)*(1-p3)*...*(1-pk) + (1-p1)*p2*(1-p3)*...*(1-pk) + ... \n\nWe need to try different subsets and find the maximum probability. For n ≤ 100, we can't try all 2^100 subsets, but we can use dynamic programming or try strategically important subsets (single friends, and combinations for smaller n).\n\nThe compilation error was due to using `split` method incorrectly. In Ballerina, we need to use `regex:split` from the `ballerina/regex` module or use string:split method correctly.\n\n<CODE>\n```ballerina\n// Reasoning:\n// To maximize probability of exactly one problem, we need to choose a subset of friends.\n// For a given subset S, probability of exactly one problem is:\n// P(exactly 1) = sum over i in S of: p[i] * product over j in S, j!=i of: (1-p[j])\n// \n// Strategy: \n// 1. For small n (≤ 20), try all possible subsets using bit manipulation\n// 2. For larger n, use greedy approach: try single friends and small combinations\n// \n// Key observation: Often optimal solution is either a single high-probability friend\n// or a set of low-probability friends where combined they give exactly-one with high probability\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate probability of exactly one success given a subset of probabilities\nfunction calculateExactlyOneProb(decimal[] probabilities) returns decimal {\n    if probabilities.length() == 0 {\n        return 0.0d;\n    }\n    \n    decimal totalProb = 0.0d;\n    \n    // For each friend in the subset, calculate probability that only they succeed\n    foreach int i in 0 ..< probabilities.length() {\n        decimal prob = probabilities[i];\n        \n        // Multiply by probability that all others fail\n        foreach int j in 0 ..< probabilities.length() {\n            if i != j {\n                prob = prob * (1.0d - probabilities[j]);\n            }\n        }\n        \n        totalProb = totalProb + prob;\n    }\n    \n    return totalProb;\n}\n\n// Find the maximum probability by trying different subsets\nfunction findMaxProbability(decimal[] probabilities) returns decimal {\n    int n = probabilities.length();\n    decimal maxProb = 0.0d;\n    \n    // For n > 20, use optimized approach\n    if n > 20 {\n        // Try each single friend\n        foreach decimal p in probabilities {\n            if p > maxProb {\n                maxProb = p;\n            }\n        }\n        \n        // Try all pairs of friends\n        foreach int i in 0 ..< n {\n            foreach int j in i + 1 ..< n {\n                decimal[] subset = [probabilities[i], probabilities[j]];\n                decimal prob = calculateExactlyOneProb(subset);\n                if prob > maxProb {\n                    maxProb = prob;\n                }\n            }\n        }\n        \n        // Try all triplets with low probabilities (heuristic)\n        foreach int i in 0 ..< n {\n            if probabilities[i] > 0.5d {\n                continue; // Skip high probability friends for triplets\n            }\n            foreach int j in i + 1 ..< n {\n                if probabilities[j] > 0.5d {\n                    continue;\n                }\n                foreach int k in j + 1 ..< n {\n                    if probabilities[k] > 0.5d {\n                        continue;\n                    }\n                    decimal[] subset = [probabilities[i], probabilities[j], probabilities[k]];\n                    decimal prob = calculateExactlyOneProb(subset);\n                    if prob > maxProb {\n                        maxProb = prob;\n                    }\n                }\n            }\n        }\n        \n        return maxProb;\n    }\n    \n    // For smaller n, try all subsets using bit manipulation\n    int maxSubsets = 1 << n; // 2^n\n    \n    foreach int mask in 1 ..< maxSubsets {\n        decimal[] subset = [];\n        \n        foreach int i in 0 ..< n {\n            if (mask & (1 << i)) != 0 {\n                subset.push(probabilities[i]);\n            }\n        }\n        \n        decimal prob = calculateExactlyOneProb(subset);\n        if prob > maxProb {\n            maxProb = prob;\n        }\n    }\n    \n    return maxProb;\n}\n\npublic function main() returns error? {\n    // Read number of friends\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check int:fromString(line1.trim());\n    \n    if n < 1 || n > 100 {\n        return error(\"n must be between 1 and 100\");\n    }\n    \n    // Read probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read probabilities\");\n    }\n    \n    // Use regex:split to split by whitespace\n    string[] parts = regex:split(line2.trim(), \"\\\\s+\");\n    \n    if parts.length() != n {\n        return error(\"Number of probabilities doesn't match n\");\n    }\n    \n    decimal[] probabilities = [];\n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() == 0 {\n            continue;\n        }\n        decimal prob = check decimal:fromString(trimmedPart);\n        if prob < 0.0d || prob > 1.0d {\n            return error(\"Probability must be between 0.0 and 1.0\");\n        }\n        probabilities.push(prob);\n    }\n    \n    if probabilities.length() != n {\n        return error(\"Failed to parse correct number of probabilities\");\n    }\n    \n    decimal result = findMaxProbability(probabilities);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleFriend() {\n    decimal[] probs = [0.8d];\n    decimal result = calculateExactlyOneProb(probs);\n    test:assertEquals(result, 0.8d);\n}\n\n@test:Config {}\nfunction testTwoFriendsExample() {\n    decimal[] probs = [0.1d, 0.2d];\n    decimal result = calculateExactlyOneProb(probs);\n    // P(exactly 1) = 0.1 * 0.8 + 0.9 * 0.2 = 0.08 + 0.18 = 0.26\n    decimal expected = 0.26d;\n    test:assertTrue((result - expected).abs() < 0.0001d);\n}\n\n@test:Config {}\nfunction testFindMaxWithSingleBest() {\n    decimal[] probs = [0.1d, 0.2d, 0.3d, 0.8d];\n    decimal result = findMaxProbability(probs);\n    // Best strategy is to ask only the friend with 0.8 probability\n    test:assertEquals(result, 0.8d);\n}\n\n@test:Config {}\nfunction testFindMaxWithMultiple() {\n    decimal[] probs = [0.1d, 0.2d];\n    decimal result = findMaxProbability(probs);\n    // Best strategy is to ask both\n    decimal expected = 0.26d;\n    test:assertTrue((result - expected).abs() < 0.0001d);\n}\n\n@test:Config {}\nfunction testAllZeroProbabilities() {\n    decimal[] probs = [0.0d, 0.0d, 0.0d];\n    decimal result = findMaxProbability(probs);\n    test:assertEquals(result, 0.0d);\n}\n\n@test:Config {}\nfunction testThreeFriends() {\n    decimal[] probs = [0.5d, 0.5d, 0.5d];\n    decimal result = calculateExactlyOneProb(probs);\n    // P(exactly 1) = 3 * 0.5 * 0.5 * 0.5 = 0.375\n    decimal expected = 0.375d;\n    test:assertTrue((result - expected).abs() < 0.0001d);\n}\n\n@test:Config {}\nfunction testEmptySubset() {\n    decimal[] probs = [];\n    decimal result = calculateExactlyOneProb(probs);\n    test:assertEquals(result, 0.0d);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// To maximize probability of exactly one problem, we need to choose a subset of friends.\n// For a given subset S, probability of exactly one problem is:\n// P(exactly 1) = sum over i in S of: p[i] * product over j in S, j!=i of: (1-p[j])\n// \n// Strategy: \n// 1. For small n (≤ 20), try all possible subsets using bit manipulation\n// 2. For larger n, use greedy approach: try single friends and small combinations\n// \n// Key observation: Often optimal solution is either a single high-probability friend\n// or a set of low-probability friends where combined they give exactly-one with high probability\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate probability of exactly one success given a subset of probabilities\nfunction calculateExactlyOneProb(decimal[] probabilities) returns decimal {\n    if probabilities.length() == 0 {\n        return 0.0d;\n    }\n    \n    decimal totalProb = 0.0d;\n    \n    // For each friend in the subset, calculate probability that only they succeed\n    foreach int i in 0 ..< probabilities.length() {\n        decimal prob = probabilities[i];\n        \n        // Multiply by probability that all others fail\n        foreach int j in 0 ..< probabilities.length() {\n            if i != j {\n                prob = prob * (1.0d - probabilities[j]);\n            }\n        }\n        \n        totalProb = totalProb + prob;\n    }\n    \n    return totalProb;\n}\n\n// Find the maximum probability by trying different subsets\nfunction findMaxProbability(decimal[] probabilities) returns decimal {\n    int n = probabilities.length();\n    decimal maxProb = 0.0d;\n    \n    // For n > 20, use optimized approach\n    if n > 20 {\n        // Try each single friend\n        foreach decimal p in probabilities {\n            if p > maxProb {\n                maxProb = p;\n            }\n        }\n        \n        // Try all pairs of friends\n        foreach int i in 0 ..< n {\n            foreach int j in i + 1 ..< n {\n                decimal[] subset = [probabilities[i], probabilities[j]];\n                decimal prob = calculateExactlyOneProb(subset);\n                if prob > maxProb {\n                    maxProb = prob;\n                }\n            }\n        }\n        \n        // Try all triplets with low probabilities (heuristic)\n        foreach int i in 0 ..< n {\n            if probabilities[i] > 0.5d {\n                continue; // Skip high probability friends for triplets\n            }\n            foreach int j in i + 1 ..< n {\n                if probabilities[j] > 0.5d {\n                    continue;\n                }\n                foreach int k in j + 1 ..< n {\n                    if probabilities[k] > 0.5d {\n                        continue;\n                    }\n                    decimal[] subset = [probabilities[i], probabilities[j], probabilities[k]];\n                    decimal prob = calculateExactlyOneProb(subset);\n                    if prob > maxProb {\n                        maxProb = prob;\n                    }\n                }\n            }\n        }\n        \n        return maxProb;\n    }\n    \n    // For smaller n, try all subsets using bit manipulation\n    int maxSubsets = 1 << n; // 2^n\n    \n    foreach int mask in 1 ..< maxSubsets {\n        decimal[] subset = [];\n        \n        foreach int i in 0 ..< n {\n            if (mask & (1 << i)) != 0 {\n                subset.push(probabilities[i]);\n            }\n        }\n        \n        decimal prob = calculateExactlyOneProb(subset);\n        if prob > maxProb {\n            maxProb = prob;\n        }\n    }\n    \n    return maxProb;\n}\n\npublic function main() returns error? {\n    // Read number of friends\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check int:fromString(line1.trim());\n    \n    if n < 1 || n > 100 {\n        return error(\"n must be between 1 and 100\");\n    }\n    \n    // Read probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read probabilities\");\n    }\n    \n    // Use regex:split to split by whitespace\n    string[] parts = regex:split(line2.trim(), \"\\\\s+\");\n    \n    if parts.length() != n {\n        return error(\"Number of probabilities doesn't match n\");\n    }\n    \n    decimal[] probabilities = [];\n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() == 0 {\n            continue;\n        }\n        decimal prob = check decimal:fromString(trimmedPart);\n        if prob < 0.0d || prob > 1.0d {\n            return error(\"Probability must be between 0.0 and 1.0\");\n        }\n        probabilities.push(prob);\n    }\n    \n    if probabilities.length() != n {\n        return error(\"Failed to parse correct number of probabilities\");\n    }\n    \n    decimal result = findMaxProbability(probabilities);\n    io:println(result);\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4\n0.1 0.2 0.3 0.8\n",
          "expected_output": "0.800000000000\n",
          "actual_output": "0.8\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T04:42:43.659832"
}