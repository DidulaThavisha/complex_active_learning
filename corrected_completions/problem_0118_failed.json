{
  "entry_id": "problem_0118",
  "problem_index": 118,
  "prompt": "Title: Minimum Sum\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nPetya has *n* positive integers *a*1,<=*a*2,<=...,<=*a**n*. \n\nHis friend Vasya decided to joke and replaced all digits in Petya's numbers with a letters. He used the lowercase letters of the Latin alphabet from 'a' to 'j' and replaced all digits 0 with one letter, all digits 1 with another letter and so on. For any two different digits Vasya used distinct letters from 'a' to 'j'.\n\nYour task is to restore Petya's numbers. The restored numbers should be positive integers without leading zeros. Since there can be multiple ways to do it, determine the minimum possible sum of all Petya's numbers after the restoration. It is guaranteed that before Vasya's joke all Petya's numbers did not have leading zeros.\n\nInput Specification:\nThe first line contains a single integer *n* (1<=≤<=*n*<=≤<=1<=000) — the number of Petya's numbers.\n\nEach of the following lines contains non-empty string *s**i* consisting of lowercase Latin letters from 'a' to 'j' — the Petya's numbers after Vasya's joke. The length of each string does not exceed six characters.\n\nOutput Specification:\nDetermine the minimum sum of all Petya's numbers after the restoration. The restored numbers should be positive integers without leading zeros. It is guaranteed that the correct restore (without leading zeros) exists for all given tests.\n\nDemo Input:\n['3\\nab\\nde\\naj\\n', '5\\nabcdef\\nghij\\nbdef\\naccbd\\ng\\n', '3\\naa\\njj\\naa\\n']\n\nDemo Output:\n['47\\n', '136542\\n', '44\\n']\n\nNote:\nIn the first example, you need to replace the letter 'a' with the digit 1, the letter 'b' with the digit 0, the letter 'd' with the digit 2, the letter 'e' with the digit 3, and the letter 'j' with the digit 4. So after the restoration numbers will look like [10, 23, 14]. The sum of them is equal to 47, which is the minimum possible sum of the numbers after the correct restoration.\n\nIn the second example the numbers after the restoration can look like: [120468, 3579, 2468, 10024, 3]. \n\nIn the second example the numbers after the restoration can look like: [11, 22, 11].",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:05:08.173285",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires us to map letters 'a' to 'j' to digits 0-9 such that the sum of all resulting numbers is minimized, with the constraint that numbers cannot have leading zeros.\n\nThe strategy is:\n1. Parse the input to get all strings\n2. Calculate the contribution of each letter position (e.g., a letter in the ones place contributes less than in the thousands place)\n3. Identify which letters can be leading digits (they cannot be 0)\n4. Assign digits greedily: assign 0 to the letter with highest contribution (if not leading), then 1 to the next highest, etc.\n5. Calculate the final sum\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to minimize the sum, so letters that contribute more to the total should get smaller digit values\n// 2. A letter's contribution is the sum of positional values across all numbers (e.g., if 'a' appears in tens place twice, it contributes 20*digit_value)\n// 3. Letters that appear as first character of any string cannot be assigned 0 (no leading zeros)\n// 4. Strategy: Calculate contribution weights for each letter, sort by weight descending, assign smallest available digits to highest weights\n// 5. Handle the constraint that leading letters cannot be 0\n\nimport ballerina/io;\n\n// Function to calculate minimum sum after optimal digit assignment\nfunction calculateMinimumSum(string[] numbers) returns int|error {\n    // Track contribution weight of each letter (a-j maps to index 0-9)\n    int[] weights = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    boolean[] isLeading = [false, false, false, false, false, false, false, false, false, false];\n    \n    // Calculate positional weights for each letter\n    foreach string num in numbers {\n        if num.length() == 0 {\n            return error(\"Empty string in input\");\n        }\n        \n        int len = num.length();\n        \n        // Mark first character as leading (cannot be 0)\n        int firstCharIndex = <int>num[0] - <int>'a';\n        isLeading[firstCharIndex] = true;\n        \n        // Calculate contribution for each position\n        foreach int i in 0 ..< len {\n            int charIndex = <int>num[i] - <int>'a';\n            int positionValue = 1;\n            int power = len - i - 1;\n            \n            // Calculate 10^power\n            foreach int _ in 0 ..< power {\n                positionValue *= 10;\n            }\n            \n            weights[charIndex] += positionValue;\n        }\n    }\n    \n    // Create array of (letterIndex, weight) pairs and sort by weight descending\n    [int, int][] letterWeights = [];\n    foreach int i in 0 ..< 10 {\n        if weights[i] > 0 {\n            letterWeights.push([i, weights[i]]);\n        }\n    }\n    \n    // Sort by weight descending (bubble sort for simplicity)\n    int n = letterWeights.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if letterWeights[j][1] < letterWeights[j + 1][1] {\n                [int, int] temp = letterWeights[j];\n                letterWeights[j] = letterWeights[j + 1];\n                letterWeights[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Assign digits to letters (greedy approach)\n    int[] digitAssignment = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    int nextDigit = 0;\n    \n    // First pass: assign digits to letters, skipping 0 for leading letters\n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] {\n            // Skip for now, will assign non-zero digit\n            continue;\n        }\n        digitAssignment[letterIdx] = nextDigit;\n        nextDigit += 1;\n    }\n    \n    // Second pass: assign remaining digits to leading letters\n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] && digitAssignment[letterIdx] == -1 {\n            digitAssignment[letterIdx] = nextDigit;\n            nextDigit += 1;\n        }\n    }\n    \n    // Calculate the sum\n    int totalSum = 0;\n    foreach int i in 0 ..< 10 {\n        if digitAssignment[i] != -1 {\n            totalSum += weights[i] * digitAssignment[i];\n        }\n    }\n    \n    return totalSum;\n}\n\npublic function main() returns error? {\n    // Read number of strings\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        io:println(\"Error: Invalid number format\");\n        return;\n    }\n    \n    if n < 1 || n > 1000 {\n        io:println(\"Error: n must be between 1 and 1000\");\n        return;\n    }\n    \n    // Read all strings\n    string[] numbers = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            io:println(\"Error: Not enough input lines\");\n            return;\n        }\n        numbers.push(line.trim());\n    }\n    \n    // Calculate and output result\n    int|error result = calculateMinimumSum(numbers);\n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMinimumSumExample1() {\n    string[] numbers = [\"ab\", \"de\", \"aj\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 47);\n    }\n}\n\n@test:Config {}\nfunction testMinimumSumExample2() {\n    string[] numbers = [\"abcdef\", \"ghij\", \"bdef\", \"accbd\", \"g\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 136542);\n    }\n}\n\n@test:Config {}\nfunction testMinimumSumExample3() {\n    string[] numbers = [\"aa\", \"jj\", \"aa\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 44);\n    }\n}\n\n@test:Config {}\nfunction testMinimumSumSingleNumber() {\n    string[] numbers = [\"abc\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        // a cannot be 0 (leading), so optimal: a=1, b=0, c=0 -> 100\n        test:assertEquals(result, 100);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need to minimize the sum, so letters that contribute more to the total should get smaller digit values\n// 2. A letter's contribution is the sum of positional values across all numbers (e.g., if 'a' appears in tens place twice, it contributes 20*digit_value)\n// 3. Letters that appear as first character of any string cannot be assigned 0 (no leading zeros)\n// 4. Strategy: Calculate contribution weights for each letter, sort by weight descending, assign smallest available digits to highest weights\n// 5. Handle the constraint that leading letters cannot be 0\n\nimport ballerina/io;\n\n// Function to calculate minimum sum after optimal digit assignment\nfunction calculateMinimumSum(string[] numbers) returns int|error {\n    // Track contribution weight of each letter (a-j maps to index 0-9)\n    int[] weights = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    boolean[] isLeading = [false, false, false, false, false, false, false, false, false, false];\n    \n    // Calculate positional weights for each letter\n    foreach string num in numbers {\n        if num.length() == 0 {\n            return error(\"Empty string in input\");\n        }\n        \n        int len = num.length();\n        \n        // Mark first character as leading (cannot be 0)\n        int firstCharIndex = <int>num[0] - <int>'a';\n        isLeading[firstCharIndex] = true;\n        \n        // Calculate contribution for each position\n        foreach int i in 0 ..< len {\n            int charIndex = <int>num[i] - <int>'a';\n            int positionValue = 1;\n            int power = len - i - 1;\n            \n            // Calculate 10^power\n            foreach int _ in 0 ..< power {\n                positionValue *= 10;\n            }\n            \n            weights[charIndex] += positionValue;\n        }\n    }\n    \n    // Create array of (letterIndex, weight) pairs and sort by weight descending\n    [int, int][] letterWeights = [];\n    foreach int i in 0 ..< 10 {\n        if weights[i] > 0 {\n            letterWeights.push([i, weights[i]]);\n        }\n    }\n    \n    // Sort by weight descending (bubble sort for simplicity)\n    int n = letterWeights.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if letterWeights[j][1] < letterWeights[j + 1][1] {\n                [int, int] temp = letterWeights[j];\n                letterWeights[j] = letterWeights[j + 1];\n                letterWeights[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Assign digits to letters (greedy approach)\n    int[] digitAssignment = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    int nextDigit = 0;\n    \n    // First pass: assign digits to letters, skipping 0 for leading letters\n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] {\n            // Skip for now, will assign non-zero digit\n            continue;\n        }\n        digitAssignment[letterIdx] = nextDigit;\n        nextDigit += 1;\n    }\n    \n    // Second pass: assign remaining digits to leading letters\n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] && digitAssignment[letterIdx] == -1 {\n            digitAssignment[letterIdx] = nextDigit;\n            nextDigit += 1;\n        }\n    }\n    \n    // Calculate the sum\n    int totalSum = 0;\n    foreach int i in 0 ..< 10 {\n        if digitAssignment[i] != -1 {\n            totalSum += weights[i] * digitAssignment[i];\n        }\n    }\n    \n    return totalSum;\n}\n\npublic function main() returns error? {\n    // Read number of strings\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        io:println(\"Error: Invalid number format\");\n        return;\n    }\n    \n    if n < 1 || n > 1000 {\n        io:println(\"Error: n must be between 1 and 1000\");\n        return;\n    }\n    \n    // Read all strings\n    string[] numbers = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            io:println(\"Error: Not enough input lines\");\n            return;\n        }\n        numbers.push(line.trim());\n    }\n    \n    // Calculate and output result\n    int|error result = calculateMinimumSum(numbers);\n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(25:30,25:41)] incompatible types: 'string:Char' cannot be cast to 'int'\nERROR [main.bal:(25:49,25:51)] undefined symbol 'a'\nERROR [main.bal:(25:51,25:52)] incomplete quoted identifier\nERROR [main.bal:(25:51,25:51)] missing binary operator\nERROR [main.bal:(30:29,30:40)] incompatible types: 'string:Char' cannot be cast to 'int'\nERROR [main.bal:(30:48,30:50)] undefined symbol 'a'\nERROR [main.bal:(30:50,30:51)] incomplete quoted identifier\nERROR [main.bal:(30:50,30:50)] missing bina",
      "error": "Compilation error: ERROR [main.bal:(25:30,25:41)] incompatible types: 'string:Char' cannot be cast to 'int'\nERROR [main.bal:(25:49,25:51)] undefined symbol 'a'\nERROR [main.bal:(25:51,25:52)] incomplete quoted identifier\nERROR [main.bal:(25:51,25:51)] missing binary operator\nERROR [main.bal:(30:29,30:40)] incompatible types: 'string:Char' cannot be cast to 'int'\nERROR [main.bal:(30:48,30:50)] undefined symbol 'a'\nERROR [main.bal:(30:50,30:51)] incomplete quoted identifier\nERROR [main.bal:(30:50,30:50)] missing bina",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(25:30,25:41)] incompatible types: 'string:Char' cannot be cast to 'int'\nERROR [main.bal:(25:49,25:51)] undefined symbol 'a'\nERROR [main.bal:(25:51,25:52)] incomplete quoted identifier\nERROR [main.bal:(25:51,25:51)] missing binary operator\nERROR [main.bal:(30:29,30:40)] incompatible types: 'string:Char' cannot be cast to 'int'\nERROR [main.bal:(30:48,30:50)] undefined symbol 'a'\nERROR [main.bal:(30:50,30:51)] incomplete quoted identifier\nERROR [main.bal:(30:50,30:50)] missing binary operator\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:05:40.035967",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires mapping letters 'a' to 'j' to digits 0-9 to minimize the sum of all numbers, with the constraint that leading letters cannot be 0.\n\nThe key insight is:\n- Calculate the positional weight of each letter across all numbers\n- Letters with higher weights should get smaller digits\n- But letters that appear as leading characters cannot be assigned 0\n- Use a greedy assignment strategy: assign 0 to the highest-weight non-leading letter, then continue assigning increasing digits to decreasing weights\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input strings and calculate the contribution weight of each letter\n// 2. Weight = sum of positional values (e.g., letter at position 0 in a 3-digit number contributes 100x its digit value)\n// 3. Track which letters appear as leading characters (cannot be 0)\n// 4. Sort letters by weight in descending order\n// 5. Assign digits greedily: \n//    - First assign 0 to the highest-weight letter that's not leading\n//    - Then assign 1, 2, 3... to remaining letters in weight order\n//    - Ensure leading letters get non-zero digits\n// 6. Calculate final sum using the assignment\n\nimport ballerina/io;\n\nfunction calculateMinimumSum(string[] numbers) returns int|error {\n    // Track contribution weight of each letter (a-j maps to index 0-9)\n    int[] weights = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    boolean[] isLeading = [false, false, false, false, false, false, false, false, false, false];\n    \n    // Calculate positional weights for each letter\n    foreach string num in numbers {\n        if num.length() == 0 {\n            return error(\"Empty string in input\");\n        }\n        \n        int len = num.length();\n        \n        // Mark first character as leading (cannot be 0)\n        string:Char firstChar = num[0];\n        int firstCharIndex = firstChar.toCodePointInt() - 'a'.toCodePointInt();\n        isLeading[firstCharIndex] = true;\n        \n        // Calculate contribution for each position\n        foreach int i in 0 ..< len {\n            string:Char currentChar = num[i];\n            int charIndex = currentChar.toCodePointInt() - 'a'.toCodePointInt();\n            int positionValue = 1;\n            int power = len - i - 1;\n            \n            // Calculate 10^power\n            foreach int _ in 0 ..< power {\n                positionValue *= 10;\n            }\n            \n            weights[charIndex] += positionValue;\n        }\n    }\n    \n    // Create array of (letterIndex, weight) pairs for letters that appear\n    [int, int][] letterWeights = [];\n    foreach int i in 0 ..< 10 {\n        if weights[i] > 0 {\n            letterWeights.push([i, weights[i]]);\n        }\n    }\n    \n    // Sort by weight descending (bubble sort)\n    int n = letterWeights.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if letterWeights[j][1] < letterWeights[j + 1][1] {\n                [int, int] temp = letterWeights[j];\n                letterWeights[j] = letterWeights[j + 1];\n                letterWeights[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Assign digits to letters\n    int[] digitAssignment = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    int nextDigit = 0;\n    \n    // Strategy: Try to assign 0 to highest weight non-leading letter\n    // Then assign remaining digits in ascending order to remaining letters in descending weight order\n    \n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] {\n            // Leading letters must get non-zero digits, skip for now\n            continue;\n        }\n        digitAssignment[letterIdx] = nextDigit;\n        nextDigit += 1;\n    }\n    \n    // Now assign non-zero digits to leading letters\n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] && digitAssignment[letterIdx] == -1 {\n            digitAssignment[letterIdx] = nextDigit;\n            nextDigit += 1;\n        }\n    }\n    \n    // Calculate the total sum\n    int totalSum = 0;\n    foreach int i in 0 ..< 10 {\n        if digitAssignment[i] != -1 {\n            totalSum += weights[i] * digitAssignment[i];\n        }\n    }\n    \n    return totalSum;\n}\n\npublic function main() returns error? {\n    // Read number of strings\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int|error n = int:fromString(nLine.trim());\n    if n is error {\n        io:println(\"Error: Invalid number format\");\n        return;\n    }\n    \n    if n < 1 || n > 1000 {\n        io:println(\"Error: n must be between 1 and 1000\");\n        return;\n    }\n    \n    // Read all strings\n    string[] numbers = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            io:println(\"Error: Not enough input lines\");\n            return;\n        }\n        numbers.push(line.trim());\n    }\n    \n    // Calculate and output result\n    int|error result = calculateMinimumSum(numbers);\n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMinimumSumExample1() {\n    string[] numbers = [\"ab\", \"de\", \"aj\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 47);\n    }\n}\n\n@test:Config {}\nfunction testMinimumSumExample2() {\n    string[] numbers = [\"abcdef\", \"ghij\", \"bdef\", \"accbd\", \"g\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 136542);\n    }\n}\n\n@test:Config {}\nfunction testMinimumSumExample3() {\n    string[] numbers = [\"aa\", \"jj\", \"aa\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 44);\n    }\n}\n\n@test:Config {}\nfunction testMinimumSumSingleNumber() {\n    string[] numbers = [\"abc\"];\n    int|error result = calculateMinimumSum(numbers);\n    test:assertTrue(result is int);\n    if result is int {\n        // a is leading (cannot be 0), b and c are not leading\n        // weights: a=100, b=10, c=1\n        // optimal: b=0, c=1, a=2 -> 200+0+1=201\n        // or: c=0, b=1, a=2 -> 200+10+0=210\n        // so minimum is 201\n        test:assertEquals(result, 201);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input strings and calculate the contribution weight of each letter\n// 2. Weight = sum of positional values (e.g., letter at position 0 in a 3-digit number contributes 100x its digit value)\n// 3. Track which letters appear as leading characters (cannot be 0)\n// 4. Sort letters by weight in descending order\n// 5. Assign digits greedily: \n//    - First assign 0 to the highest-weight letter that's not leading\n//    - Then assign 1, 2, 3... to remaining letters in weight order\n//    - Ensure leading letters get non-zero digits\n// 6. Calculate final sum using the assignment\n\nimport ballerina/io;\n\nfunction calculateMinimumSum(string[] numbers) returns int|error {\n    // Track contribution weight of each letter (a-j maps to index 0-9)\n    int[] weights = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    boolean[] isLeading = [false, false, false, false, false, false, false, false, false, false];\n    \n    // Calculate positional weights for each letter\n    foreach string num in numbers {\n        if num.length() == 0 {\n            return error(\"Empty string in input\");\n        }\n        \n        int len = num.length();\n        \n        // Mark first character as leading (cannot be 0)\n        string:Char firstChar = num[0];\n        int firstCharIndex = firstChar.toCodePointInt() - 'a'.toCodePointInt();\n        isLeading[firstCharIndex] = true;\n        \n        // Calculate contribution for each position\n        foreach int i in 0 ..< len {\n            string:Char currentChar = num[i];\n            int charIndex = currentChar.toCodePointInt() - 'a'.toCodePointInt();\n            int positionValue = 1;\n            int power = len - i - 1;\n            \n            // Calculate 10^power\n            foreach int _ in 0 ..< power {\n                positionValue *= 10;\n            }\n            \n            weights[charIndex] += positionValue;\n        }\n    }\n    \n    // Create array of (letterIndex, weight) pairs for letters that appear\n    [int, int][] letterWeights = [];\n    foreach int i in 0 ..< 10 {\n        if weights[i] > 0 {\n            letterWeights.push([i, weights[i]]);\n        }\n    }\n    \n    // Sort by weight descending (bubble sort)\n    int n = letterWeights.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if letterWeights[j][1] < letterWeights[j + 1][1] {\n                [int, int] temp = letterWeights[j];\n                letterWeights[j] = letterWeights[j + 1];\n                letterWeights[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Assign digits to letters\n    int[] digitAssignment = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    int nextDigit = 0;\n    \n    // Strategy: Try to assign 0 to highest weight non-leading letter\n    // Then assign remaining digits in ascending order to remaining letters in descending weight order\n    \n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] {\n            // Leading letters must get non-zero digits, skip for now\n            continue;\n        }\n        digitAssignment[letterIdx] = nextDigit;\n        nextDigit += 1;\n    }\n    \n    // Now assign non-zero digits to leading letters\n    foreach [int, int] [letterIdx, _] in letterWeights {\n        if isLeading[letterIdx] && digitAssignment[letterIdx] == -1 {\n            digitAssignment[letterIdx] = nextDigit;\n            nextDigit += 1;\n        }\n    }\n    \n    // Calculate the total sum\n    int totalSum = 0;\n    foreach int i in 0 ..< 10 {\n        if digitAssignment[i] != -1 {\n            totalSum += weights[i] * digitAssignment[i];\n        }\n    }\n    \n    return totalSum;\n}\n\npublic function main() returns error? {\n    // Read number of strings\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int|error n = int:fromString(nLine.trim());\n    if n is error {\n        io:println(\"Error: Invalid number format\");\n        return;\n    }\n    \n    if n < 1 || n > 1000 {\n        io:println(\"Error: n must be between 1 and 1000\");\n        return;\n    }\n    \n    // Read all strings\n    string[] numbers = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            io:println(\"Error: Not enough input lines\");\n            return;\n        }\n        numbers.push(line.trim());\n    }\n    \n    // Calculate and output result\n    int|error result = calculateMinimumSum(numbers);\n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(29:59,29:61)] undefined symbol 'a'\nERROR [main.bal:(29:61,29:62)] incomplete quoted identifier\nERROR [main.bal:(29:61,29:61)] missing semicolon token\nERROR [main.bal:(35:60,35:62)] undefined symbol 'a'\nERROR [main.bal:(35:62,35:63)] incomplete quoted identifier\nERROR [main.bal:(35:62,35:62)] missing semicolon token\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(29:59,29:61)] undefined symbol 'a'\nERROR [main.bal:(29:61,29:62)] incomplete quoted identifier\nERROR [main.bal:(29:61,29:61)] missing semicolon token\nERROR [main.bal:(35:60,35:62)] undefined symbol 'a'\nERROR [main.bal:(35:62,35:63)] incomplete quoted identifier\nERROR [main.bal:(35:62,35:62)] missing semicolon token\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(29:59,29:61)] undefined symbol 'a'\nERROR [main.bal:(29:61,29:62)] incomplete quoted identifier\nERROR [main.bal:(29:61,29:61)] missing semicolon token\nERROR [main.bal:(35:60,35:62)] undefined symbol 'a'\nERROR [main.bal:(35:62,35:63)] incomplete quoted identifier\nERROR [main.bal:(35:62,35:62)] missing semicolon token\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(29:59,29:61)] undefined symbol 'a'\nERROR [main.bal:(29:61,29:62)] incomplete quoted identifier\nERROR [main.bal:(29:61,29:61)] missing semicolon token\nERROR [main.bal:(35:60,35:62)] undefined symbol 'a'\nERROR [main.bal:(35:62,35:63)] incomplete quoted identifier\nERROR [main.bal:(35:62,35:62)] missing semicolon token\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T02:06:06.509452"
}