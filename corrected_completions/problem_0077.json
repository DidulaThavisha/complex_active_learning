{
  "entry_id": "problem_0077",
  "problem_index": 77,
  "prompt": "Title: Number of Ways\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou've got array *a*[1],<=*a*[2],<=...,<=*a*[*n*], consisting of *n* integers. Count the number of ways to split all the elements of the array into three contiguous parts so that the sum of elements in each part is the same. \n\nMore formally, you need to find the number of such pairs of indices *i*,<=*j* (2<=≤<=*i*<=≤<=*j*<=≤<=*n*<=-<=1), that .\n\nInput Specification:\nThe first line contains integer *n* (1<=≤<=*n*<=≤<=5·105), showing how many numbers are in the array. The second line contains *n* integers *a*[1], *a*[2], ..., *a*[*n*] (|*a*[*i*]|<=≤<=<=109) — the elements of array *a*.\n\nOutput Specification:\nPrint a single integer — the number of ways to split the array into three parts with the same sum.\n\nDemo Input:\n['5\\n1 2 3 0 3\\n', '4\\n0 1 -1 0\\n', '2\\n4 1\\n']\n\nDemo Output:\n['2\\n', '1\\n', '0\\n']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem asks us to find the number of ways to split an array into three contiguous parts where each part has the same sum. We need to find pairs of indices (i, j) where 2 ≤ i ≤ j ≤ n-1 such that sum(a[1..i-1]) = sum(a[i..j-1]) = sum(a[j..n-1]).\n\nThe approach:\n1. Calculate the total sum of the array\n2. If total sum is not divisible by 3, return 0 (impossible to split equally)\n3. Use prefix sums to find valid split points\n4. For each position where prefix sum equals target_sum, it can be the end of first part\n5. For each position where prefix sum equals 2*target_sum, it can be the end of second part\n6. Count valid combinations ensuring i ≤ j and proper indices\n\n**Fix for compilation error**: The issue is that Ballerina's `string` type uses `string:split()` from the `ballerina/lang.string` module, not a direct method. We need to use `regex:split()` from `ballerina/regex` module.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First, we need to check if the total sum is divisible by 3\n// 2. If not divisible by 3, no valid split exists\n// 3. If divisible by 3, we need to find indices i and j such that:\n//    - sum of elements from index 0 to i-1 = total_sum/3\n//    - sum of elements from index 0 to j-1 = 2*total_sum/3\n//    - This ensures all three parts have equal sum\n// 4. We iterate through the array maintaining a prefix sum\n// 5. Count positions where prefix_sum = target_sum (potential i-1 positions)\n// 6. For each position where prefix_sum = 2*target_sum (potential j-1 positions),\n//    add the count of valid i positions found before this position\n// 7. Be careful with indices: i >= 2 (so i-1 >= 1), j <= n-1 (so j-1 <= n-2)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction countWaysToSplit(int[] arr) returns int {\n    int n = arr.length();\n    \n    // Edge case: need at least 3 elements to split into 3 parts\n    if n < 3 {\n        return 0;\n    }\n    \n    // Calculate total sum\n    int totalSum = 0;\n    foreach int num in arr {\n        totalSum += num;\n    }\n    \n    // If total sum is not divisible by 3, no valid split\n    if totalSum % 3 != 0 {\n        return 0;\n    }\n    \n    int targetSum = totalSum / 3;\n    int prefixSum = 0;\n    int countFirstPart = 0;  // Count of valid positions for end of first part\n    int ways = 0;\n    \n    // Iterate through array (excluding last element as we need at least one element in third part)\n    int i = 0;\n    while i < n - 1 {\n        prefixSum += arr[i];\n        \n        // If we're at a position where prefix sum = 2*targetSum,\n        // this could be end of second part (j-1 in 0-indexed, j in 1-indexed)\n        // All previously found first part positions can pair with this\n        // But we need i < j, so j must be at least at index 2 (0-indexed)\n        if prefixSum == 2 * targetSum && i >= 1 {\n            ways += countFirstPart;\n        }\n        \n        // If prefix sum equals targetSum, this could be end of first part (i-1 in 0-indexed)\n        // But we need to ensure there's room for second and third parts\n        // So we should be at most at index n-3 (leaving at least 2 elements)\n        if prefixSum == targetSum && i < n - 2 {\n            countFirstPart += 1;\n        }\n        \n        i += 1;\n    }\n    \n    return ways;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n <= 0 {\n        io:println(\"Error: Invalid array size\");\n        return;\n    }\n    \n    // Read array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        io:println(\"Error: No array input provided\");\n        return;\n    }\n    \n    string[] parts = regex:split(arrLine.trim(), \" \");\n    \n    if parts.length() != n {\n        io:println(\"Error: Array size mismatch\");\n        return;\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int num = check 'int:fromString(part.trim());\n        arr.push(num);\n    }\n    \n    int result = countWaysToSplit(arr);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] arr = [1, 2, 3, 0, 3];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] arr = [0, 1, -1, 0];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] arr = [4, 1];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testAllZeros() {\n    int[] arr = [0, 0, 0, 0, 0];\n    int result = countWaysToSplit(arr);\n    // For all zeros, many valid splits exist\n    // Positions: sum=0 at indices 0,1,2,3\n    // First part end at 0,1,2 (3 options)\n    // Second part end at 1,2,3 (but must be >= first part end)\n    // Valid pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3) = 6\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSumNotDivisibleBy3() {\n    int[] arr = [1, 2, 3, 4];\n    int result = countWaysToSplit(arr);\n    // Total sum = 10, not divisible by 3\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMinimumSize() {\n    int[] arr = [1, 1, 1];\n    int result = countWaysToSplit(arr);\n    // Can split as [1] [1] [1]\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNegativeNumbers() {\n    int[] arr = [-1, -1, -1, -3];\n    int result = countWaysToSplit(arr);\n    // Total sum = -6, target = -2\n    // Prefix: -1, -2, -3, -6\n    // First part ends where prefix = -2 (index 1)\n    // Second part ends where prefix = -4 (none)\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testSingleValidSplit() {\n    int[] arr = [3, 3, 3];\n    int result = countWaysToSplit(arr);\n    // Only one way: [3] [3] [3]\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. First, we need to check if the total sum is divisible by 3\n// 2. If not divisible by 3, no valid split exists\n// 3. If divisible by 3, we need to find indices i and j such that:\n//    - sum of elements from index 0 to i-1 = total_sum/3\n//    - sum of elements from index 0 to j-1 = 2*total_sum/3\n//    - This ensures all three parts have equal sum\n// 4. We iterate through the array maintaining a prefix sum\n// 5. Count positions where prefix_sum = target_sum (potential i-1 positions)\n// 6. For each position where prefix_sum = 2*target_sum (potential j-1 positions),\n//    add the count of valid i positions found before this position\n// 7. Be careful with indices: i >= 2 (so i-1 >= 1), j <= n-1 (so j-1 <= n-2)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction countWaysToSplit(int[] arr) returns int {\n    int n = arr.length();\n    \n    // Edge case: need at least 3 elements to split into 3 parts\n    if n < 3 {\n        return 0;\n    }\n    \n    // Calculate total sum\n    int totalSum = 0;\n    foreach int num in arr {\n        totalSum += num;\n    }\n    \n    // If total sum is not divisible by 3, no valid split\n    if totalSum % 3 != 0 {\n        return 0;\n    }\n    \n    int targetSum = totalSum / 3;\n    int prefixSum = 0;\n    int countFirstPart = 0;  // Count of valid positions for end of first part\n    int ways = 0;\n    \n    // Iterate through array (excluding last element as we need at least one element in third part)\n    int i = 0;\n    while i < n - 1 {\n        prefixSum += arr[i];\n        \n        // If we're at a position where prefix sum = 2*targetSum,\n        // this could be end of second part (j-1 in 0-indexed, j in 1-indexed)\n        // All previously found first part positions can pair with this\n        // But we need i < j, so j must be at least at index 2 (0-indexed)\n        if prefixSum == 2 * targetSum && i >= 1 {\n            ways += countFirstPart;\n        }\n        \n        // If prefix sum equals targetSum, this could be end of first part (i-1 in 0-indexed)\n        // But we need to ensure there's room for second and third parts\n        // So we should be at most at index n-3 (leaving at least 2 elements)\n        if prefixSum == targetSum && i < n - 2 {\n            countFirstPart += 1;\n        }\n        \n        i += 1;\n    }\n    \n    return ways;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n <= 0 {\n        io:println(\"Error: Invalid array size\");\n        return;\n    }\n    \n    // Read array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        io:println(\"Error: No array input provided\");\n        return;\n    }\n    \n    string[] parts = regex:split(arrLine.trim(), \" \");\n    \n    if parts.length() != n {\n        io:println(\"Error: Array size mismatch\");\n        return;\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int num = check 'int:fromString(part.trim());\n        arr.push(num);\n    }\n    \n    int result = countWaysToSplit(arr);\n    io:println(result);\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:19:10.173193",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the number of ways to split an array into three contiguous parts where each part has the same sum. We need to find pairs of indices (i, j) where 2 ≤ i ≤ j ≤ n-1 such that sum(a[1..i-1]) = sum(a[i..j-1]) = sum(a[j..n-1]).\n\nThe approach:\n1. Calculate the total sum of the array\n2. If total sum is not divisible by 3, return 0 (impossible to split equally)\n3. Use prefix sums to find valid split points\n4. For each position where prefix sum equals target_sum, it can be the end of first part\n5. For each position where prefix sum equals 2*target_sum, it can be the end of second part\n6. Count valid combinations ensuring i ≤ j and proper indices\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First, we need to check if the total sum is divisible by 3\n// 2. If not divisible by 3, no valid split exists\n// 3. If divisible by 3, we need to find indices i and j such that:\n//    - sum of elements from index 0 to i-1 = total_sum/3\n//    - sum of elements from index 0 to j-1 = 2*total_sum/3\n//    - This ensures all three parts have equal sum\n// 4. We iterate through the array maintaining a prefix sum\n// 5. Count positions where prefix_sum = target_sum (potential i-1 positions)\n// 6. For each position where prefix_sum = 2*target_sum (potential j-1 positions),\n//    add the count of valid i positions found before this position\n// 7. Be careful with indices: i >= 2 (so i-1 >= 1), j <= n-1 (so j-1 <= n-2)\n\nimport ballerina/io;\n\nfunction countWaysToSplit(int[] arr) returns int {\n    int n = arr.length();\n    \n    // Edge case: need at least 3 elements to split into 3 parts\n    if n < 3 {\n        return 0;\n    }\n    \n    // Calculate total sum\n    int totalSum = 0;\n    foreach int num in arr {\n        totalSum += num;\n    }\n    \n    // If total sum is not divisible by 3, no valid split\n    if totalSum % 3 != 0 {\n        return 0;\n    }\n    \n    int targetSum = totalSum / 3;\n    int prefixSum = 0;\n    int countFirstPart = 0;  // Count of valid positions for end of first part\n    int ways = 0;\n    \n    // Iterate through array (excluding last element as we need at least one element in third part)\n    int i = 0;\n    while i < n - 1 {\n        prefixSum += arr[i];\n        \n        // If we're at a position where prefix sum = 2*targetSum,\n        // this could be end of second part (j-1 in 0-indexed, j in 1-indexed)\n        // All previously found first part positions can pair with this\n        // But we need i < j, so j must be at least at index 2 (0-indexed)\n        if prefixSum == 2 * targetSum && i >= 1 {\n            ways += countFirstPart;\n        }\n        \n        // If prefix sum equals targetSum, this could be end of first part (i-1 in 0-indexed)\n        // But we need to ensure there's room for second and third parts\n        // So we should be at most at index n-3 (leaving at least 2 elements)\n        if prefixSum == targetSum && i < n - 2 {\n            countFirstPart += 1;\n        }\n        \n        i += 1;\n    }\n    \n    return ways;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n <= 0 {\n        io:println(\"Error: Invalid array size\");\n        return;\n    }\n    \n    // Read array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        io:println(\"Error: No array input provided\");\n        return;\n    }\n    \n    string[] parts = arrLine.trim().split(\" \");\n    \n    if parts.length() != n {\n        io:println(\"Error: Array size mismatch\");\n        return;\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int num = check 'int:fromString(part.trim());\n        arr.push(num);\n    }\n    \n    int result = countWaysToSplit(arr);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] arr = [1, 2, 3, 0, 3];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] arr = [0, 1, -1, 0];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] arr = [4, 1];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testAllZeros() {\n    int[] arr = [0, 0, 0, 0, 0];\n    int result = countWaysToSplit(arr);\n    // For all zeros, many valid splits exist\n    // Positions: sum=0 at indices 0,1,2,3\n    // First part end at 0,1,2 (3 options)\n    // Second part end at 1,2,3 (but must be >= first part end)\n    // Valid pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3) = 6\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSumNotDivisibleBy3() {\n    int[] arr = [1, 2, 3, 4];\n    int result = countWaysToSplit(arr);\n    // Total sum = 10, not divisible by 3\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMinimumSize() {\n    int[] arr = [1, 1, 1];\n    int result = countWaysToSplit(arr);\n    // Can split as [1] [1] [1]\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNegativeNumbers() {\n    int[] arr = [-1, -1, -1, -3];\n    int result = countWaysToSplit(arr);\n    // Total sum = -6, target = -2\n    // Prefix: -1, -2, -3, -6\n    // First part ends where prefix = -2 (index 1)\n    // Second part ends where prefix = -4 (none)\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testSingleValidSplit() {\n    int[] arr = [3, 3, 3];\n    int result = countWaysToSplit(arr);\n    // Only one way: [3] [3] [3]\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. First, we need to check if the total sum is divisible by 3\n// 2. If not divisible by 3, no valid split exists\n// 3. If divisible by 3, we need to find indices i and j such that:\n//    - sum of elements from index 0 to i-1 = total_sum/3\n//    - sum of elements from index 0 to j-1 = 2*total_sum/3\n//    - This ensures all three parts have equal sum\n// 4. We iterate through the array maintaining a prefix sum\n// 5. Count positions where prefix_sum = target_sum (potential i-1 positions)\n// 6. For each position where prefix_sum = 2*target_sum (potential j-1 positions),\n//    add the count of valid i positions found before this position\n// 7. Be careful with indices: i >= 2 (so i-1 >= 1), j <= n-1 (so j-1 <= n-2)\n\nimport ballerina/io;\n\nfunction countWaysToSplit(int[] arr) returns int {\n    int n = arr.length();\n    \n    // Edge case: need at least 3 elements to split into 3 parts\n    if n < 3 {\n        return 0;\n    }\n    \n    // Calculate total sum\n    int totalSum = 0;\n    foreach int num in arr {\n        totalSum += num;\n    }\n    \n    // If total sum is not divisible by 3, no valid split\n    if totalSum % 3 != 0 {\n        return 0;\n    }\n    \n    int targetSum = totalSum / 3;\n    int prefixSum = 0;\n    int countFirstPart = 0;  // Count of valid positions for end of first part\n    int ways = 0;\n    \n    // Iterate through array (excluding last element as we need at least one element in third part)\n    int i = 0;\n    while i < n - 1 {\n        prefixSum += arr[i];\n        \n        // If we're at a position where prefix sum = 2*targetSum,\n        // this could be end of second part (j-1 in 0-indexed, j in 1-indexed)\n        // All previously found first part positions can pair with this\n        // But we need i < j, so j must be at least at index 2 (0-indexed)\n        if prefixSum == 2 * targetSum && i >= 1 {\n            ways += countFirstPart;\n        }\n        \n        // If prefix sum equals targetSum, this could be end of first part (i-1 in 0-indexed)\n        // But we need to ensure there's room for second and third parts\n        // So we should be at most at index n-3 (leaving at least 2 elements)\n        if prefixSum == targetSum && i < n - 2 {\n            countFirstPart += 1;\n        }\n        \n        i += 1;\n    }\n    \n    return ways;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n <= 0 {\n        io:println(\"Error: Invalid array size\");\n        return;\n    }\n    \n    // Read array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        io:println(\"Error: No array input provided\");\n        return;\n    }\n    \n    string[] parts = arrLine.trim().split(\" \");\n    \n    if parts.length() != n {\n        io:println(\"Error: Array size mismatch\");\n        return;\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int num = check 'int:fromString(part.trim());\n        arr.push(num);\n    }\n    \n    int result = countWaysToSplit(arr);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(88:37,88:42)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(88:37,88:42)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(88:37,88:42)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:19:44.766388",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to find the number of ways to split an array into three contiguous parts where each part has the same sum. We need to find pairs of indices (i, j) where 2 ≤ i ≤ j ≤ n-1 such that sum(a[1..i-1]) = sum(a[i..j-1]) = sum(a[j..n-1]).\n\nThe approach:\n1. Calculate the total sum of the array\n2. If total sum is not divisible by 3, return 0 (impossible to split equally)\n3. Use prefix sums to find valid split points\n4. For each position where prefix sum equals target_sum, it can be the end of first part\n5. For each position where prefix sum equals 2*target_sum, it can be the end of second part\n6. Count valid combinations ensuring i ≤ j and proper indices\n\n**Fix for compilation error**: The issue is that Ballerina's `string` type uses `string:split()` from the `ballerina/lang.string` module, not a direct method. We need to use `regex:split()` from `ballerina/regex` module.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First, we need to check if the total sum is divisible by 3\n// 2. If not divisible by 3, no valid split exists\n// 3. If divisible by 3, we need to find indices i and j such that:\n//    - sum of elements from index 0 to i-1 = total_sum/3\n//    - sum of elements from index 0 to j-1 = 2*total_sum/3\n//    - This ensures all three parts have equal sum\n// 4. We iterate through the array maintaining a prefix sum\n// 5. Count positions where prefix_sum = target_sum (potential i-1 positions)\n// 6. For each position where prefix_sum = 2*target_sum (potential j-1 positions),\n//    add the count of valid i positions found before this position\n// 7. Be careful with indices: i >= 2 (so i-1 >= 1), j <= n-1 (so j-1 <= n-2)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction countWaysToSplit(int[] arr) returns int {\n    int n = arr.length();\n    \n    // Edge case: need at least 3 elements to split into 3 parts\n    if n < 3 {\n        return 0;\n    }\n    \n    // Calculate total sum\n    int totalSum = 0;\n    foreach int num in arr {\n        totalSum += num;\n    }\n    \n    // If total sum is not divisible by 3, no valid split\n    if totalSum % 3 != 0 {\n        return 0;\n    }\n    \n    int targetSum = totalSum / 3;\n    int prefixSum = 0;\n    int countFirstPart = 0;  // Count of valid positions for end of first part\n    int ways = 0;\n    \n    // Iterate through array (excluding last element as we need at least one element in third part)\n    int i = 0;\n    while i < n - 1 {\n        prefixSum += arr[i];\n        \n        // If we're at a position where prefix sum = 2*targetSum,\n        // this could be end of second part (j-1 in 0-indexed, j in 1-indexed)\n        // All previously found first part positions can pair with this\n        // But we need i < j, so j must be at least at index 2 (0-indexed)\n        if prefixSum == 2 * targetSum && i >= 1 {\n            ways += countFirstPart;\n        }\n        \n        // If prefix sum equals targetSum, this could be end of first part (i-1 in 0-indexed)\n        // But we need to ensure there's room for second and third parts\n        // So we should be at most at index n-3 (leaving at least 2 elements)\n        if prefixSum == targetSum && i < n - 2 {\n            countFirstPart += 1;\n        }\n        \n        i += 1;\n    }\n    \n    return ways;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n <= 0 {\n        io:println(\"Error: Invalid array size\");\n        return;\n    }\n    \n    // Read array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        io:println(\"Error: No array input provided\");\n        return;\n    }\n    \n    string[] parts = regex:split(arrLine.trim(), \" \");\n    \n    if parts.length() != n {\n        io:println(\"Error: Array size mismatch\");\n        return;\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int num = check 'int:fromString(part.trim());\n        arr.push(num);\n    }\n    \n    int result = countWaysToSplit(arr);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] arr = [1, 2, 3, 0, 3];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] arr = [0, 1, -1, 0];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] arr = [4, 1];\n    int result = countWaysToSplit(arr);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testAllZeros() {\n    int[] arr = [0, 0, 0, 0, 0];\n    int result = countWaysToSplit(arr);\n    // For all zeros, many valid splits exist\n    // Positions: sum=0 at indices 0,1,2,3\n    // First part end at 0,1,2 (3 options)\n    // Second part end at 1,2,3 (but must be >= first part end)\n    // Valid pairs: (0,1), (0,2), (0,3), (1,2), (1,3), (2,3) = 6\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSumNotDivisibleBy3() {\n    int[] arr = [1, 2, 3, 4];\n    int result = countWaysToSplit(arr);\n    // Total sum = 10, not divisible by 3\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMinimumSize() {\n    int[] arr = [1, 1, 1];\n    int result = countWaysToSplit(arr);\n    // Can split as [1] [1] [1]\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNegativeNumbers() {\n    int[] arr = [-1, -1, -1, -3];\n    int result = countWaysToSplit(arr);\n    // Total sum = -6, target = -2\n    // Prefix: -1, -2, -3, -6\n    // First part ends where prefix = -2 (index 1)\n    // Second part ends where prefix = -4 (none)\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testSingleValidSplit() {\n    int[] arr = [3, 3, 3];\n    int result = countWaysToSplit(arr);\n    // Only one way: [3] [3] [3]\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. First, we need to check if the total sum is divisible by 3\n// 2. If not divisible by 3, no valid split exists\n// 3. If divisible by 3, we need to find indices i and j such that:\n//    - sum of elements from index 0 to i-1 = total_sum/3\n//    - sum of elements from index 0 to j-1 = 2*total_sum/3\n//    - This ensures all three parts have equal sum\n// 4. We iterate through the array maintaining a prefix sum\n// 5. Count positions where prefix_sum = target_sum (potential i-1 positions)\n// 6. For each position where prefix_sum = 2*target_sum (potential j-1 positions),\n//    add the count of valid i positions found before this position\n// 7. Be careful with indices: i >= 2 (so i-1 >= 1), j <= n-1 (so j-1 <= n-2)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction countWaysToSplit(int[] arr) returns int {\n    int n = arr.length();\n    \n    // Edge case: need at least 3 elements to split into 3 parts\n    if n < 3 {\n        return 0;\n    }\n    \n    // Calculate total sum\n    int totalSum = 0;\n    foreach int num in arr {\n        totalSum += num;\n    }\n    \n    // If total sum is not divisible by 3, no valid split\n    if totalSum % 3 != 0 {\n        return 0;\n    }\n    \n    int targetSum = totalSum / 3;\n    int prefixSum = 0;\n    int countFirstPart = 0;  // Count of valid positions for end of first part\n    int ways = 0;\n    \n    // Iterate through array (excluding last element as we need at least one element in third part)\n    int i = 0;\n    while i < n - 1 {\n        prefixSum += arr[i];\n        \n        // If we're at a position where prefix sum = 2*targetSum,\n        // this could be end of second part (j-1 in 0-indexed, j in 1-indexed)\n        // All previously found first part positions can pair with this\n        // But we need i < j, so j must be at least at index 2 (0-indexed)\n        if prefixSum == 2 * targetSum && i >= 1 {\n            ways += countFirstPart;\n        }\n        \n        // If prefix sum equals targetSum, this could be end of first part (i-1 in 0-indexed)\n        // But we need to ensure there's room for second and third parts\n        // So we should be at most at index n-3 (leaving at least 2 elements)\n        if prefixSum == targetSum && i < n - 2 {\n            countFirstPart += 1;\n        }\n        \n        i += 1;\n    }\n    \n    return ways;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n <= 0 {\n        io:println(\"Error: Invalid array size\");\n        return;\n    }\n    \n    // Read array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        io:println(\"Error: No array input provided\");\n        return;\n    }\n    \n    string[] parts = regex:split(arrLine.trim(), \" \");\n    \n    if parts.length() != n {\n        io:println(\"Error: Array size mismatch\");\n        return;\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int num = check 'int:fromString(part.trim());\n        arr.push(num);\n    }\n    \n    int result = countWaysToSplit(arr);\n    io:println(result);\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T01:20:17.347998"
}