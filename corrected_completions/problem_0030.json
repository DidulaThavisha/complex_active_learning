{
  "entry_id": "problem_0030",
  "problem_index": 30,
  "prompt": "Title: Really Big Numbers\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nIvan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number *x* is really big if the difference between *x* and the sum of its digits (in decimal representation) is not less than *s*. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than *n*.\n\nIvan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.\n\nInput Specification:\nThe first (and the only) line contains two integers *n* and *s* (1<=≤<=*n*,<=*s*<=≤<=1018).\n\nOutput Specification:\nPrint one integer — the quantity of really big numbers that are not greater than *n*.\n\nDemo Input:\n['12 1\\n', '25 20\\n', '10 9\\n']\n\nDemo Output:\n['3\\n', '0\\n', '1\\n']\n\nNote:\nIn the first example numbers 10, 11 and 12 are really big.\n\nIn the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).\n\nIn the third example 10 is the only really big number (10 - 1 ≥ 9).",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\n\nThe problem asks us to find how many \"really big numbers\" exist that are not greater than n, where a number x is \"really big\" if (x - sum_of_digits(x)) >= s.\n\nKey observations:\n1. As numbers increase, the difference (x - sum_of_digits(x)) generally increases because x grows much faster than the sum of its digits\n2. The maximum sum of digits for a number is bounded (e.g., 999 has digit sum 27, while 1000 has digit sum 1)\n3. Once we find the first really big number, all numbers after it (up to some point) will also be really big due to the monotonic nature\n4. We can use binary search to find the smallest really big number, then count from there to n\n\nStrategy:\n- Use binary search to find the minimum number where (num - digit_sum(num)) >= s\n- If such a number exists and is <= n, the answer is (n - min_big_number + 1)\n- Otherwise, the answer is 0\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. A number x is \"really big\" if (x - sum_of_digits(x)) >= s\n// 2. As numbers grow, (x - sum_of_digits(x)) increases monotonically in general\n// 3. We can use binary search to find the smallest really big number\n// 4. Once found, count all numbers from that point up to n\n//\n// Binary search approach:\n// - Search in range [1, n] for the minimum number where condition holds\n// - If we find it, answer is (n - min_number + 1)\n// - If no such number exists, answer is 0\n\nimport ballerina/io;\n\n// Calculate sum of digits of a number\nfunction sumOfDigits(int num) returns int {\n    int sum = 0;\n    int n = num;\n    while n > 0 {\n        sum += n % 10;\n        n = n / 10;\n    }\n    return sum;\n}\n\n// Check if a number is really big\nfunction isReallyBig(int x, int s) returns boolean {\n    int digitSum = sumOfDigits(x);\n    return (x - digitSum) >= s;\n}\n\n// Find the count of really big numbers not greater than n\nfunction countReallyBigNumbers(int n, int s) returns int {\n    // Binary search for the smallest really big number\n    int left = 1;\n    int right = n;\n    int minBigNumber = -1;\n    \n    while left <= right {\n        int mid = left + (right - left) / 2;\n        \n        if isReallyBig(mid, s) {\n            minBigNumber = mid;\n            right = mid - 1;  // Try to find smaller\n        } else {\n            left = mid + 1;   // Need to go higher\n        }\n    }\n    \n    // If we found a really big number <= n, count from there to n\n    if minBigNumber != -1 {\n        return n - minBigNumber + 1;\n    }\n    \n    return 0;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmedInput = input_line.trim();\n        string[] parts = re `\\s+`.split(trimmedInput);\n        \n        if parts.length() == 2 {\n            int|error n_val = 'int:fromString(parts[0]);\n            int|error s_val = 'int:fromString(parts[1]);\n            \n            if n_val is int && s_val is int {\n                if n_val < 1 || s_val < 1 {\n                    io:println(\"Error: n and s must be at least 1\");\n                    return;\n                }\n                \n                int result = countReallyBigNumbers(n_val, s_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected exactly 2 integers\");\n        }\n    } else {\n        io:println(\"Error: Could not read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSumOfDigits() {\n    test:assertEquals(sumOfDigits(10), 1);\n    test:assertEquals(sumOfDigits(12), 3);\n    test:assertEquals(sumOfDigits(25), 7);\n    test:assertEquals(sumOfDigits(999), 27);\n}\n\n@test:Config {}\nfunction testIsReallyBig() {\n    // Test case 1: 10 - 1 = 9 >= 1 (true)\n    test:assertTrue(isReallyBig(10, 1));\n    \n    // Test case 2: 11 - 2 = 9 >= 1 (true)\n    test:assertTrue(isReallyBig(11, 1));\n    \n    // Test case 3: 25 - 7 = 18 >= 20 (false)\n    test:assertFalse(isReallyBig(25, 20));\n    \n    // Test case 4: 30 - 3 = 27 >= 20 (true)\n    test:assertTrue(isReallyBig(30, 20));\n}\n\n@test:Config {}\nfunction testCountReallyBigNumbers() {\n    // Test case 1: n=12, s=1\n    // Really big numbers: 10 (10-1=9>=1), 11 (11-2=9>=1), 12 (12-3=9>=1)\n    test:assertEquals(countReallyBigNumbers(12, 1), 3);\n    \n    // Test case 2: n=25, s=20\n    // No really big numbers <= 25\n    test:assertEquals(countReallyBigNumbers(25, 20), 0);\n    \n    // Test case 3: n=10, s=9\n    // Only 10 (10-1=9>=9)\n    test:assertEquals(countReallyBigNumbers(10, 9), 1);\n    \n    // Test case 4: n=100, s=1\n    // First really big number is 10, so count is 100-10+1=91\n    test:assertEquals(countReallyBigNumbers(100, 1), 91);\n}\n\n@test:Config {}\nfunction testEdgeCases() {\n    // Small values\n    test:assertEquals(countReallyBigNumbers(1, 1), 0);\n    \n    // When first number itself might qualify\n    test:assertEquals(countReallyBigNumbers(5, 1), 0);\n    \n    // Larger s value\n    test:assertEquals(countReallyBigNumbers(50, 30), 0);\n    \n    // Number exactly at boundary\n    test:assertEquals(countReallyBigNumbers(10, 10), 0);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. A number x is \"really big\" if (x - sum_of_digits(x)) >= s\n// 2. As numbers grow, (x - sum_of_digits(x)) increases monotonically in general\n// 3. We can use binary search to find the smallest really big number\n// 4. Once found, count all numbers from that point up to n\n//\n// Binary search approach:\n// - Search in range [1, n] for the minimum number where condition holds\n// - If we find it, answer is (n - min_number + 1)\n// - If no such number exists, answer is 0\n\nimport ballerina/io;\n\n// Calculate sum of digits of a number\nfunction sumOfDigits(int num) returns int {\n    int sum = 0;\n    int n = num;\n    while n > 0 {\n        sum += n % 10;\n        n = n / 10;\n    }\n    return sum;\n}\n\n// Check if a number is really big\nfunction isReallyBig(int x, int s) returns boolean {\n    int digitSum = sumOfDigits(x);\n    return (x - digitSum) >= s;\n}\n\n// Find the count of really big numbers not greater than n\nfunction countReallyBigNumbers(int n, int s) returns int {\n    // Binary search for the smallest really big number\n    int left = 1;\n    int right = n;\n    int minBigNumber = -1;\n    \n    while left <= right {\n        int mid = left + (right - left) / 2;\n        \n        if isReallyBig(mid, s) {\n            minBigNumber = mid;\n            right = mid - 1;  // Try to find smaller\n        } else {\n            left = mid + 1;   // Need to go higher\n        }\n    }\n    \n    // If we found a really big number <= n, count from there to n\n    if minBigNumber != -1 {\n        return n - minBigNumber + 1;\n    }\n    \n    return 0;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmedInput = input_line.trim();\n        string[] parts = re `\\s+`.split(trimmedInput);\n        \n        if parts.length() == 2 {\n            int|error n_val = 'int:fromString(parts[0]);\n            int|error s_val = 'int:fromString(parts[1]);\n            \n            if n_val is int && s_val is int {\n                if n_val < 1 || s_val < 1 {\n                    io:println(\"Error: n and s must be at least 1\");\n                    return;\n                }\n                \n                int result = countReallyBigNumbers(n_val, s_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected exactly 2 integers\");\n        }\n    } else {\n        io:println(\"Error: Could not read input\");\n    }\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:28:12.061157",
      "status": "success",
      "completion": "# Overview\n\nThe problem asks us to find how many \"really big numbers\" exist that are not greater than n, where a number x is \"really big\" if (x - sum_of_digits(x)) >= s.\n\nKey observations:\n1. As numbers increase, the difference (x - sum_of_digits(x)) generally increases because x grows much faster than the sum of its digits\n2. The maximum sum of digits for a number is bounded (e.g., 999 has digit sum 27, while 1000 has digit sum 1)\n3. Once we find the first really big number, all numbers after it (up to some point) will also be really big due to the monotonic nature\n4. We can use binary search to find the smallest really big number, then count from there to n\n\nStrategy:\n- Use binary search to find the minimum number where (num - digit_sum(num)) >= s\n- If such a number exists and is <= n, the answer is (n - min_big_number + 1)\n- Otherwise, the answer is 0\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. A number x is \"really big\" if (x - sum_of_digits(x)) >= s\n// 2. As numbers grow, (x - sum_of_digits(x)) increases monotonically in general\n// 3. We can use binary search to find the smallest really big number\n// 4. Once found, count all numbers from that point up to n\n//\n// Binary search approach:\n// - Search in range [1, n] for the minimum number where condition holds\n// - If we find it, answer is (n - min_number + 1)\n// - If no such number exists, answer is 0\n\nimport ballerina/io;\n\n// Calculate sum of digits of a number\nfunction sumOfDigits(int num) returns int {\n    int sum = 0;\n    int n = num;\n    while n > 0 {\n        sum += n % 10;\n        n = n / 10;\n    }\n    return sum;\n}\n\n// Check if a number is really big\nfunction isReallyBig(int x, int s) returns boolean {\n    int digitSum = sumOfDigits(x);\n    return (x - digitSum) >= s;\n}\n\n// Find the count of really big numbers not greater than n\nfunction countReallyBigNumbers(int n, int s) returns int {\n    // Binary search for the smallest really big number\n    int left = 1;\n    int right = n;\n    int minBigNumber = -1;\n    \n    while left <= right {\n        int mid = left + (right - left) / 2;\n        \n        if isReallyBig(mid, s) {\n            minBigNumber = mid;\n            right = mid - 1;  // Try to find smaller\n        } else {\n            left = mid + 1;   // Need to go higher\n        }\n    }\n    \n    // If we found a really big number <= n, count from there to n\n    if minBigNumber != -1 {\n        return n - minBigNumber + 1;\n    }\n    \n    return 0;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmedInput = input_line.trim();\n        string[] parts = re `\\s+`.split(trimmedInput);\n        \n        if parts.length() == 2 {\n            int|error n_val = 'int:fromString(parts[0]);\n            int|error s_val = 'int:fromString(parts[1]);\n            \n            if n_val is int && s_val is int {\n                if n_val < 1 || s_val < 1 {\n                    io:println(\"Error: n and s must be at least 1\");\n                    return;\n                }\n                \n                int result = countReallyBigNumbers(n_val, s_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected exactly 2 integers\");\n        }\n    } else {\n        io:println(\"Error: Could not read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSumOfDigits() {\n    test:assertEquals(sumOfDigits(10), 1);\n    test:assertEquals(sumOfDigits(12), 3);\n    test:assertEquals(sumOfDigits(25), 7);\n    test:assertEquals(sumOfDigits(999), 27);\n}\n\n@test:Config {}\nfunction testIsReallyBig() {\n    // Test case 1: 10 - 1 = 9 >= 1 (true)\n    test:assertTrue(isReallyBig(10, 1));\n    \n    // Test case 2: 11 - 2 = 9 >= 1 (true)\n    test:assertTrue(isReallyBig(11, 1));\n    \n    // Test case 3: 25 - 7 = 18 >= 20 (false)\n    test:assertFalse(isReallyBig(25, 20));\n    \n    // Test case 4: 30 - 3 = 27 >= 20 (true)\n    test:assertTrue(isReallyBig(30, 20));\n}\n\n@test:Config {}\nfunction testCountReallyBigNumbers() {\n    // Test case 1: n=12, s=1\n    // Really big numbers: 10 (10-1=9>=1), 11 (11-2=9>=1), 12 (12-3=9>=1)\n    test:assertEquals(countReallyBigNumbers(12, 1), 3);\n    \n    // Test case 2: n=25, s=20\n    // No really big numbers <= 25\n    test:assertEquals(countReallyBigNumbers(25, 20), 0);\n    \n    // Test case 3: n=10, s=9\n    // Only 10 (10-1=9>=9)\n    test:assertEquals(countReallyBigNumbers(10, 9), 1);\n    \n    // Test case 4: n=100, s=1\n    // First really big number is 10, so count is 100-10+1=91\n    test:assertEquals(countReallyBigNumbers(100, 1), 91);\n}\n\n@test:Config {}\nfunction testEdgeCases() {\n    // Small values\n    test:assertEquals(countReallyBigNumbers(1, 1), 0);\n    \n    // When first number itself might qualify\n    test:assertEquals(countReallyBigNumbers(5, 1), 0);\n    \n    // Larger s value\n    test:assertEquals(countReallyBigNumbers(50, 30), 0);\n    \n    // Number exactly at boundary\n    test:assertEquals(countReallyBigNumbers(10, 10), 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. A number x is \"really big\" if (x - sum_of_digits(x)) >= s\n// 2. As numbers grow, (x - sum_of_digits(x)) increases monotonically in general\n// 3. We can use binary search to find the smallest really big number\n// 4. Once found, count all numbers from that point up to n\n//\n// Binary search approach:\n// - Search in range [1, n] for the minimum number where condition holds\n// - If we find it, answer is (n - min_number + 1)\n// - If no such number exists, answer is 0\n\nimport ballerina/io;\n\n// Calculate sum of digits of a number\nfunction sumOfDigits(int num) returns int {\n    int sum = 0;\n    int n = num;\n    while n > 0 {\n        sum += n % 10;\n        n = n / 10;\n    }\n    return sum;\n}\n\n// Check if a number is really big\nfunction isReallyBig(int x, int s) returns boolean {\n    int digitSum = sumOfDigits(x);\n    return (x - digitSum) >= s;\n}\n\n// Find the count of really big numbers not greater than n\nfunction countReallyBigNumbers(int n, int s) returns int {\n    // Binary search for the smallest really big number\n    int left = 1;\n    int right = n;\n    int minBigNumber = -1;\n    \n    while left <= right {\n        int mid = left + (right - left) / 2;\n        \n        if isReallyBig(mid, s) {\n            minBigNumber = mid;\n            right = mid - 1;  // Try to find smaller\n        } else {\n            left = mid + 1;   // Need to go higher\n        }\n    }\n    \n    // If we found a really big number <= n, count from there to n\n    if minBigNumber != -1 {\n        return n - minBigNumber + 1;\n    }\n    \n    return 0;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmedInput = input_line.trim();\n        string[] parts = re `\\s+`.split(trimmedInput);\n        \n        if parts.length() == 2 {\n            int|error n_val = 'int:fromString(parts[0]);\n            int|error s_val = 'int:fromString(parts[1]);\n            \n            if n_val is int && s_val is int {\n                if n_val < 1 || s_val < 1 {\n                    io:println(\"Error: n and s must be at least 1\");\n                    return;\n                }\n                \n                int result = countReallyBigNumbers(n_val, s_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected exactly 2 integers\");\n        }\n    } else {\n        io:println(\"Error: Could not read input\");\n    }\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T00:28:51.429604"
}