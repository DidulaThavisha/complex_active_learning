{
  "entry_id": "problem_0260",
  "problem_index": 260,
  "prompt": "Title: Ravioli Sort\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nEverybody knows of [spaghetti sort](https://en.wikipedia.org/wiki/Spaghetti_sort). You decided to implement an analog sorting algorithm yourself, but as you survey your pantry you realize you're out of spaghetti! The only type of pasta you have is ravioli, but you are not going to let this stop you...\n\nYou come up with the following algorithm. For each number in the array *a**i*, build a stack of *a**i* ravioli. The image shows the stack for *a**i*<==<=4.\n\nArrange the stacks in one row in the order in which the corresponding numbers appear in the input array. Find the tallest one (if there are several stacks of maximal height, use the leftmost one). Remove it and add its height to the end of the output array. Shift the stacks in the row so that there is no gap between them. Repeat the procedure until all stacks have been removed.\n\nAt first you are very happy with your algorithm, but as you try it on more inputs you realize that it doesn't always produce the right sorted array. Turns out when two stacks of ravioli are next to each other (at any step of the process) and differ in height by two or more, the top ravioli of the taller stack slides down on top of the lower stack.\n\nGiven an input array, figure out whether the described algorithm will sort it correctly.\n\nInput Specification:\nThe first line of input contains a single number *n* (1<=≤<=*n*<=≤<=10) — the size of the array.\n\nThe second line of input contains *n* space-separated integers *a**i* (1<=≤<=*a**i*<=≤<=100) — the elements of the array.\n\nOutput Specification:\nOutput \"YES\" if the array can be sorted using the described procedure and \"NO\" if it can not.\n\nDemo Input:\n['3\\n1 2 3\\n', '3\\n3 1 2\\n']\n\nDemo Output:\n['YES\\n', 'NO\\n']\n\nNote:\nIn the second example the array will change even before the tallest stack is chosen for the first time: ravioli from stack of height 3 will slide on the stack of height 1, and the algorithm will output an array {2, 2, 2}.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\n\nThe problem asks us to determine if an array can be sorted using the \"ravioli sort\" algorithm. The key insight is that we don't need to simulate the entire sorting process - we just need to check if the initial array configuration is stable (i.e., no ravioli will slide between stacks).\n\nThe algorithm will work correctly if and only if no two adjacent stacks differ in height by 2 or more. If all adjacent elements have a difference of at most 1, the array is stable and the sorting will work as intended. Otherwise, ravioli will slide and corrupt the sorting process.\n\nThe compilation error in the previous attempt was due to using `split()` method directly on string. In Ballerina, we need to use `regex:split()` from the `ballerina/regex` module or use string methods correctly.\n\n<CODE>\n```ballerina\n// Reasoning:\n// The ravioli sort algorithm will only work correctly if the initial array is \"stable\"\n// A stable array means that no ravioli will slide between adjacent stacks\n// Ravioli slides when two adjacent stacks differ in height by 2 or more\n// \n// Strategy:\n// 1. Read the array size n\n// 2. Read the array elements\n// 3. Check each pair of adjacent elements\n// 4. If any pair has absolute difference >= 2, output \"NO\"\n// 5. If all adjacent pairs have difference < 2, output \"YES\"\n//\n// This works because:\n// - If initially stable, removing the tallest stack won't cause instability in remaining stacks\n// - If initially unstable, ravioli will slide before we even start sorting\n//\n// Fix: Use regex:split() instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction isRavioliSortable(int[] arr) returns boolean {\n    int n = arr.length();\n    \n    // Check all adjacent pairs\n    int i = 0;\n    while i < n - 1 {\n        int diff = arr[i] > arr[i + 1] ? arr[i] - arr[i + 1] : arr[i + 1] - arr[i];\n        if diff >= 2 {\n            return false;\n        }\n        i = i + 1;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read the array size\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid array size\");\n    }\n    \n    // Read the array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        return error(\"Failed to read array elements\");\n    }\n    \n    // Use regex:split to split the string by spaces\n    string[] parts = regex:split(arrLine.trim(), \" \");\n    if parts.length() != n {\n        return error(\"Array size mismatch\");\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int|error num = 'int:fromString(part);\n        if num is error {\n            return error(\"Invalid array element\");\n        }\n        arr.push(num);\n    }\n    \n    // Check if ravioli sort will work\n    boolean result = isRavioliSortable(arr);\n    \n    if result {\n        io:println(\"YES\");\n    } else {\n        io:println(\"NO\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testRavioliSortBasic() {\n    // Test case 1: [1, 2, 3] - all adjacent differ by 1, should be sortable\n    int[] arr1 = [1, 2, 3];\n    boolean result1 = isRavioliSortable(arr1);\n    test:assertEquals(result1, true, \"Array [1, 2, 3] should be sortable\");\n    \n    // Test case 2: [3, 1, 2] - 3 and 1 differ by 2, should not be sortable\n    int[] arr2 = [3, 1, 2];\n    boolean result2 = isRavioliSortable(arr2);\n    test:assertEquals(result2, false, \"Array [3, 1, 2] should not be sortable\");\n    \n    // Test case 3: [5, 5, 5] - all same height, should be sortable\n    int[] arr3 = [5, 5, 5];\n    boolean result3 = isRavioliSortable(arr3);\n    test:assertEquals(result3, true, \"Array [5, 5, 5] should be sortable\");\n    \n    // Test case 4: [1, 2, 4] - 2 and 4 differ by 2, should not be sortable\n    int[] arr4 = [1, 2, 4];\n    boolean result4 = isRavioliSortable(arr4);\n    test:assertEquals(result4, false, \"Array [1, 2, 4] should not be sortable\");\n}\n\n@test:Config {}\nfunction testRavioliSortEdgeCases() {\n    // Test case 5: Single element array should always be sortable\n    int[] arr5 = [100];\n    boolean result5 = isRavioliSortable(arr5);\n    test:assertEquals(result5, true, \"Single element array should be sortable\");\n    \n    // Test case 6: Two elements with difference of 1\n    int[] arr6 = [10, 11];\n    boolean result6 = isRavioliSortable(arr6);\n    test:assertEquals(result6, true, \"Array [10, 11] should be sortable\");\n    \n    // Test case 7: Two elements with difference of 2\n    int[] arr7 = [10, 12];\n    boolean result7 = isRavioliSortable(arr7);\n    test:assertEquals(result7, false, \"Array [10, 12] should not be sortable\");\n    \n    // Test case 8: Descending array with difference of 1\n    int[] arr8 = [5, 4, 3, 2, 1];\n    boolean result8 = isRavioliSortable(arr8);\n    test:assertEquals(result8, true, \"Array [5, 4, 3, 2, 1] should be sortable\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// The ravioli sort algorithm will only work correctly if the initial array is \"stable\"\n// A stable array means that no ravioli will slide between adjacent stacks\n// Ravioli slides when two adjacent stacks differ in height by 2 or more\n// \n// Strategy:\n// 1. Read the array size n\n// 2. Read the array elements\n// 3. Check each pair of adjacent elements\n// 4. If any pair has absolute difference >= 2, output \"NO\"\n// 5. If all adjacent pairs have difference < 2, output \"YES\"\n//\n// This works because:\n// - If initially stable, removing the tallest stack won't cause instability in remaining stacks\n// - If initially unstable, ravioli will slide before we even start sorting\n//\n// Fix: Use regex:split() instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction isRavioliSortable(int[] arr) returns boolean {\n    int n = arr.length();\n    \n    // Check all adjacent pairs\n    int i = 0;\n    while i < n - 1 {\n        int diff = arr[i] > arr[i + 1] ? arr[i] - arr[i + 1] : arr[i + 1] - arr[i];\n        if diff >= 2 {\n            return false;\n        }\n        i = i + 1;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read the array size\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid array size\");\n    }\n    \n    // Read the array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        return error(\"Failed to read array elements\");\n    }\n    \n    // Use regex:split to split the string by spaces\n    string[] parts = regex:split(arrLine.trim(), \" \");\n    if parts.length() != n {\n        return error(\"Array size mismatch\");\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int|error num = 'int:fromString(part);\n        if num is error {\n            return error(\"Invalid array element\");\n        }\n        arr.push(num);\n    }\n    \n    // Check if ravioli sort will work\n    boolean result = isRavioliSortable(arr);\n    \n    if result {\n        io:println(\"YES\");\n    } else {\n        io:println(\"NO\");\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:45:48.446362",
      "status": "failed",
      "completion": "# Overview\n\nThe problem asks us to determine if an array can be sorted using the \"ravioli sort\" algorithm. The key insight is that we don't need to simulate the entire sorting process - we just need to check if the initial array configuration is stable (i.e., no ravioli will slide between stacks).\n\nThe algorithm will work correctly if and only if no two adjacent stacks differ in height by 2 or more. If all adjacent elements have a difference of at most 1, the array is stable and the sorting will work as intended. Otherwise, ravioli will slide and corrupt the sorting process.\n\n<CODE>\n```ballerina\n// Reasoning:\n// The ravioli sort algorithm will only work correctly if the initial array is \"stable\"\n// A stable array means that no ravioli will slide between adjacent stacks\n// Ravioli slides when two adjacent stacks differ in height by 2 or more\n// \n// Strategy:\n// 1. Read the array size n\n// 2. Read the array elements\n// 3. Check each pair of adjacent elements\n// 4. If any pair has absolute difference >= 2, output \"NO\"\n// 5. If all adjacent pairs have difference < 2, output \"YES\"\n//\n// This works because:\n// - If initially stable, removing the tallest stack won't cause instability in remaining stacks\n// - If initially unstable, ravioli will slide before we even start sorting\n\nimport ballerina/io;\n\nfunction isRavioliSortable(int[] arr) returns boolean {\n    int n = arr.length();\n    \n    // Check all adjacent pairs\n    int i = 0;\n    while i < n - 1 {\n        int diff = arr[i] > arr[i + 1] ? arr[i] - arr[i + 1] : arr[i + 1] - arr[i];\n        if diff >= 2 {\n            return false;\n        }\n        i = i + 1;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read the array size\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid array size\");\n    }\n    \n    // Read the array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        return error(\"Failed to read array elements\");\n    }\n    \n    string[] parts = arrLine.trim().split(\" \");\n    if parts.length() != n {\n        return error(\"Array size mismatch\");\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int|error num = 'int:fromString(part);\n        if num is error {\n            return error(\"Invalid array element\");\n        }\n        arr.push(num);\n    }\n    \n    // Check if ravioli sort will work\n    boolean result = isRavioliSortable(arr);\n    \n    if result {\n        io:println(\"YES\");\n    } else {\n        io:println(\"NO\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testRavioliSortBasic() {\n    // Test case 1: [1, 2, 3] - all adjacent differ by 1, should be sortable\n    int[] arr1 = [1, 2, 3];\n    boolean result1 = isRavioliSortable(arr1);\n    test:assertEquals(result1, true, \"Array [1, 2, 3] should be sortable\");\n    \n    // Test case 2: [3, 1, 2] - 3 and 1 differ by 2, should not be sortable\n    int[] arr2 = [3, 1, 2];\n    boolean result2 = isRavioliSortable(arr2);\n    test:assertEquals(result2, false, \"Array [3, 1, 2] should not be sortable\");\n    \n    // Test case 3: [5, 5, 5] - all same height, should be sortable\n    int[] arr3 = [5, 5, 5];\n    boolean result3 = isRavioliSortable(arr3);\n    test:assertEquals(result3, true, \"Array [5, 5, 5] should be sortable\");\n    \n    // Test case 4: [1, 2, 4] - 2 and 4 differ by 2, should not be sortable\n    int[] arr4 = [1, 2, 4];\n    boolean result4 = isRavioliSortable(arr4);\n    test:assertEquals(result4, false, \"Array [1, 2, 4] should not be sortable\");\n}\n\n@test:Config {}\nfunction testRavioliSortEdgeCases() {\n    // Test case 5: Single element array should always be sortable\n    int[] arr5 = [100];\n    boolean result5 = isRavioliSortable(arr5);\n    test:assertEquals(result5, true, \"Single element array should be sortable\");\n    \n    // Test case 6: Two elements with difference of 1\n    int[] arr6 = [10, 11];\n    boolean result6 = isRavioliSortable(arr6);\n    test:assertEquals(result6, true, \"Array [10, 11] should be sortable\");\n    \n    // Test case 7: Two elements with difference of 2\n    int[] arr7 = [10, 12];\n    boolean result7 = isRavioliSortable(arr7);\n    test:assertEquals(result7, false, \"Array [10, 12] should not be sortable\");\n    \n    // Test case 8: Descending array with difference of 1\n    int[] arr8 = [5, 4, 3, 2, 1];\n    boolean result8 = isRavioliSortable(arr8);\n    test:assertEquals(result8, true, \"Array [5, 4, 3, 2, 1] should be sortable\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// The ravioli sort algorithm will only work correctly if the initial array is \"stable\"\n// A stable array means that no ravioli will slide between adjacent stacks\n// Ravioli slides when two adjacent stacks differ in height by 2 or more\n// \n// Strategy:\n// 1. Read the array size n\n// 2. Read the array elements\n// 3. Check each pair of adjacent elements\n// 4. If any pair has absolute difference >= 2, output \"NO\"\n// 5. If all adjacent pairs have difference < 2, output \"YES\"\n//\n// This works because:\n// - If initially stable, removing the tallest stack won't cause instability in remaining stacks\n// - If initially unstable, ravioli will slide before we even start sorting\n\nimport ballerina/io;\n\nfunction isRavioliSortable(int[] arr) returns boolean {\n    int n = arr.length();\n    \n    // Check all adjacent pairs\n    int i = 0;\n    while i < n - 1 {\n        int diff = arr[i] > arr[i + 1] ? arr[i] - arr[i + 1] : arr[i + 1] - arr[i];\n        if diff >= 2 {\n            return false;\n        }\n        i = i + 1;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read the array size\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid array size\");\n    }\n    \n    // Read the array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        return error(\"Failed to read array elements\");\n    }\n    \n    string[] parts = arrLine.trim().split(\" \");\n    if parts.length() != n {\n        return error(\"Array size mismatch\");\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int|error num = 'int:fromString(part);\n        if num is error {\n            return error(\"Invalid array element\");\n        }\n        arr.push(num);\n    }\n    \n    // Check if ravioli sort will work\n    boolean result = isRavioliSortable(arr);\n    \n    if result {\n        io:println(\"YES\");\n    } else {\n        io:println(\"NO\");\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(53:37,53:42)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(53:37,53:42)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(53:37,53:42)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:46:13.979775",
      "status": "success",
      "completion": "# Overview\n\nThe problem asks us to determine if an array can be sorted using the \"ravioli sort\" algorithm. The key insight is that we don't need to simulate the entire sorting process - we just need to check if the initial array configuration is stable (i.e., no ravioli will slide between stacks).\n\nThe algorithm will work correctly if and only if no two adjacent stacks differ in height by 2 or more. If all adjacent elements have a difference of at most 1, the array is stable and the sorting will work as intended. Otherwise, ravioli will slide and corrupt the sorting process.\n\nThe compilation error in the previous attempt was due to using `split()` method directly on string. In Ballerina, we need to use `regex:split()` from the `ballerina/regex` module or use string methods correctly.\n\n<CODE>\n```ballerina\n// Reasoning:\n// The ravioli sort algorithm will only work correctly if the initial array is \"stable\"\n// A stable array means that no ravioli will slide between adjacent stacks\n// Ravioli slides when two adjacent stacks differ in height by 2 or more\n// \n// Strategy:\n// 1. Read the array size n\n// 2. Read the array elements\n// 3. Check each pair of adjacent elements\n// 4. If any pair has absolute difference >= 2, output \"NO\"\n// 5. If all adjacent pairs have difference < 2, output \"YES\"\n//\n// This works because:\n// - If initially stable, removing the tallest stack won't cause instability in remaining stacks\n// - If initially unstable, ravioli will slide before we even start sorting\n//\n// Fix: Use regex:split() instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction isRavioliSortable(int[] arr) returns boolean {\n    int n = arr.length();\n    \n    // Check all adjacent pairs\n    int i = 0;\n    while i < n - 1 {\n        int diff = arr[i] > arr[i + 1] ? arr[i] - arr[i + 1] : arr[i + 1] - arr[i];\n        if diff >= 2 {\n            return false;\n        }\n        i = i + 1;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read the array size\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid array size\");\n    }\n    \n    // Read the array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        return error(\"Failed to read array elements\");\n    }\n    \n    // Use regex:split to split the string by spaces\n    string[] parts = regex:split(arrLine.trim(), \" \");\n    if parts.length() != n {\n        return error(\"Array size mismatch\");\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int|error num = 'int:fromString(part);\n        if num is error {\n            return error(\"Invalid array element\");\n        }\n        arr.push(num);\n    }\n    \n    // Check if ravioli sort will work\n    boolean result = isRavioliSortable(arr);\n    \n    if result {\n        io:println(\"YES\");\n    } else {\n        io:println(\"NO\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testRavioliSortBasic() {\n    // Test case 1: [1, 2, 3] - all adjacent differ by 1, should be sortable\n    int[] arr1 = [1, 2, 3];\n    boolean result1 = isRavioliSortable(arr1);\n    test:assertEquals(result1, true, \"Array [1, 2, 3] should be sortable\");\n    \n    // Test case 2: [3, 1, 2] - 3 and 1 differ by 2, should not be sortable\n    int[] arr2 = [3, 1, 2];\n    boolean result2 = isRavioliSortable(arr2);\n    test:assertEquals(result2, false, \"Array [3, 1, 2] should not be sortable\");\n    \n    // Test case 3: [5, 5, 5] - all same height, should be sortable\n    int[] arr3 = [5, 5, 5];\n    boolean result3 = isRavioliSortable(arr3);\n    test:assertEquals(result3, true, \"Array [5, 5, 5] should be sortable\");\n    \n    // Test case 4: [1, 2, 4] - 2 and 4 differ by 2, should not be sortable\n    int[] arr4 = [1, 2, 4];\n    boolean result4 = isRavioliSortable(arr4);\n    test:assertEquals(result4, false, \"Array [1, 2, 4] should not be sortable\");\n}\n\n@test:Config {}\nfunction testRavioliSortEdgeCases() {\n    // Test case 5: Single element array should always be sortable\n    int[] arr5 = [100];\n    boolean result5 = isRavioliSortable(arr5);\n    test:assertEquals(result5, true, \"Single element array should be sortable\");\n    \n    // Test case 6: Two elements with difference of 1\n    int[] arr6 = [10, 11];\n    boolean result6 = isRavioliSortable(arr6);\n    test:assertEquals(result6, true, \"Array [10, 11] should be sortable\");\n    \n    // Test case 7: Two elements with difference of 2\n    int[] arr7 = [10, 12];\n    boolean result7 = isRavioliSortable(arr7);\n    test:assertEquals(result7, false, \"Array [10, 12] should not be sortable\");\n    \n    // Test case 8: Descending array with difference of 1\n    int[] arr8 = [5, 4, 3, 2, 1];\n    boolean result8 = isRavioliSortable(arr8);\n    test:assertEquals(result8, true, \"Array [5, 4, 3, 2, 1] should be sortable\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// The ravioli sort algorithm will only work correctly if the initial array is \"stable\"\n// A stable array means that no ravioli will slide between adjacent stacks\n// Ravioli slides when two adjacent stacks differ in height by 2 or more\n// \n// Strategy:\n// 1. Read the array size n\n// 2. Read the array elements\n// 3. Check each pair of adjacent elements\n// 4. If any pair has absolute difference >= 2, output \"NO\"\n// 5. If all adjacent pairs have difference < 2, output \"YES\"\n//\n// This works because:\n// - If initially stable, removing the tallest stack won't cause instability in remaining stacks\n// - If initially unstable, ravioli will slide before we even start sorting\n//\n// Fix: Use regex:split() instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction isRavioliSortable(int[] arr) returns boolean {\n    int n = arr.length();\n    \n    // Check all adjacent pairs\n    int i = 0;\n    while i < n - 1 {\n        int diff = arr[i] > arr[i + 1] ? arr[i] - arr[i + 1] : arr[i + 1] - arr[i];\n        if diff >= 2 {\n            return false;\n        }\n        i = i + 1;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read the array size\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid array size\");\n    }\n    \n    // Read the array elements\n    string? arrLine = io:readln();\n    if arrLine is () {\n        return error(\"Failed to read array elements\");\n    }\n    \n    // Use regex:split to split the string by spaces\n    string[] parts = regex:split(arrLine.trim(), \" \");\n    if parts.length() != n {\n        return error(\"Array size mismatch\");\n    }\n    \n    int[] arr = [];\n    foreach string part in parts {\n        int|error num = 'int:fromString(part);\n        if num is error {\n            return error(\"Invalid array element\");\n        }\n        arr.push(num);\n    }\n    \n    // Check if ravioli sort will work\n    boolean result = isRavioliSortable(arr);\n    \n    if result {\n        io:println(\"YES\");\n    } else {\n        io:println(\"NO\");\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T04:46:41.525600"
}