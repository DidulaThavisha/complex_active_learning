{
  "entry_id": "problem_0192",
  "problem_index": 192,
  "prompt": "Title: New Year Snowmen\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAs meticulous Gerald sets the table and caring Alexander sends the postcards, Sergey makes snowmen. Each showman should consist of three snowballs: a big one, a medium one and a small one. Sergey's twins help him: they've already made *n* snowballs with radii equal to *r*1, *r*2, ..., *r**n*. To make a snowman, one needs any three snowballs whose radii are pairwise different. For example, the balls with radii 1, 2 and 3 can be used to make a snowman but 2, 2, 3 or 2, 2, 2 cannot. Help Sergey and his twins to determine what maximum number of snowmen they can make from those snowballs.\n\nInput Specification:\nThe first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of snowballs. The next line contains *n* integers — the balls' radii *r*1, *r*2, ..., *r**n* (1<=≤<=*r**i*<=≤<=109). The balls' radii can coincide.\n\nOutput Specification:\nPrint on the first line a single number *k* — the maximum number of the snowmen. Next *k* lines should contain the snowmen's descriptions. The description of each snowman should consist of three space-separated numbers — the big ball's radius, the medium ball's radius and the small ball's radius. It is allowed to print the snowmen in any order. If there are several solutions, print any of them.\n\nDemo Input:\n['7\\n1 2 3 4 5 6 7\\n', '3\\n2 2 3\\n']\n\nDemo Output:\n['2\\n3 2 1\\n6 5 4\\n', '0\\n']\n\nNote:\nnone",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\n\nThe problem requires finding the maximum number of snowmen that can be built from snowballs where each snowman needs 3 balls with pairwise different radii.\n\nStrategy:\n1. Count frequency of each radius using a map\n2. Greedily form snowmen by selecting radii with highest frequencies first (this maximizes snowmen)\n3. Each snowman uses 3 balls with different radii\n4. Continue until we can't form more snowmen\n\nThe key insight: To maximize snowmen, we should prioritize using radii that appear most frequently. This greedy approach ensures we don't leave too many balls of the same radius unused.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Use a map to count frequency of each radius value\n// 2. To maximize snowmen, we use a greedy approach: repeatedly pick 3 radii with highest counts\n// 3. This ensures we don't get stuck with too many balls of the same radius\n// 4. Continue until we can't find 3 different radii with available balls\n// 5. For string operations, use regex:split from ballerina/regex module or manual parsing\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to find maximum snowmen and their configurations\nfunction findMaxSnowmen(int[] radii) returns [int, int[][]] {\n    // Count frequency of each radius\n    map<int> frequency = {};\n    \n    foreach int radius in radii {\n        string key = radius.toString();\n        if frequency.hasKey(key) {\n            frequency[key] = frequency.get(key) + 1;\n        } else {\n            frequency[key] = 1;\n        }\n    }\n    \n    int[][] snowmen = [];\n    \n    // Keep building snowmen while possible\n    while true {\n        // Find all radii with available balls and sort by frequency (descending)\n        int[] availableRadii = [];\n        int[] frequencies = [];\n        \n        foreach string key in frequency.keys() {\n            int count = frequency.get(key);\n            if count > 0 {\n                int|error radius = 'int:fromString(key);\n                if radius is int {\n                    availableRadii.push(radius);\n                    frequencies.push(count);\n                }\n            }\n        }\n        \n        // Need at least 3 different radii\n        if availableRadii.length() < 3 {\n            break;\n        }\n        \n        // Sort by frequency (descending) to greedily pick most frequent ones\n        // Using simple bubble sort\n        int len = availableRadii.length();\n        foreach int i in 0 ..< len {\n            foreach int j in 0 ..< (len - i - 1) {\n                if frequencies[j] < frequencies[j + 1] {\n                    // Swap frequencies\n                    int tempFreq = frequencies[j];\n                    frequencies[j] = frequencies[j + 1];\n                    frequencies[j + 1] = tempFreq;\n                    // Swap radii\n                    int tempRad = availableRadii[j];\n                    availableRadii[j] = availableRadii[j + 1];\n                    availableRadii[j + 1] = tempRad;\n                }\n            }\n        }\n        \n        // Take top 3 radii by frequency\n        int[] selectedRadii = [availableRadii[0], availableRadii[1], availableRadii[2]];\n        \n        // Sort selected radii in descending order for output (big, medium, small)\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        if selectedRadii[1] < selectedRadii[2] {\n            int temp = selectedRadii[1];\n            selectedRadii[1] = selectedRadii[2];\n            selectedRadii[2] = temp;\n        }\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        \n        // Add snowman (big, medium, small)\n        snowmen.push([selectedRadii[0], selectedRadii[1], selectedRadii[2]]);\n        \n        // Decrease frequency for used radii\n        foreach int radius in selectedRadii {\n            string key = radius.toString();\n            frequency[key] = frequency.get(key) - 1;\n        }\n    }\n    \n    return [snowmen.length(), snowmen];\n}\n\npublic function main() returns error? {\n    // Read number of snowballs\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    // Read radii\n    string? radiiLine = io:readln();\n    if radiiLine is () {\n        return error(\"Failed to read radii\");\n    }\n    \n    // Use regex:split instead of string.split\n    string[] parts = regex:split(radiiLine.trim(), \" \");\n    int[] radii = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int|error radius = 'int:fromString(trimmedPart);\n            if radius is error {\n                return error(\"Invalid radius format\");\n            }\n            radii.push(radius);\n        }\n    }\n    \n    // Find snowmen\n    [int, int[][]] result = findMaxSnowmen(radii);\n    int count = result[0];\n    int[][] snowmen = result[1];\n    \n    // Output result\n    io:println(count);\n    foreach int[] snowman in snowmen {\n        io:println(snowman[0].toString() + \" \" + snowman[1].toString() + \" \" + snowman[2].toString());\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxSnowmen1() {\n    int[] radii = [1, 2, 3, 4, 5, 6, 7];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 2, \"Should create 2 snowmen from 7 balls\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen2() {\n    int[] radii = [2, 2, 3];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - not enough different radii\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen3() {\n    int[] radii = [1, 1, 1, 2, 2, 2, 3, 3, 3];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 3, \"Should create 3 snowmen from 9 balls with 3 of each size\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen4() {\n    int[] radii = [1, 2];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - only 2 balls\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen5() {\n    int[] radii = [5, 4, 3, 2, 1];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 1, \"Should create 1 snowman from 5 different radii\");\n}\n\n@test:Config {}\nfunction testMaxSnowmenSingleRadius() {\n    int[] radii = [1, 1, 1, 1, 1];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - all same radius\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Use a map to count frequency of each radius value\n// 2. To maximize snowmen, we use a greedy approach: repeatedly pick 3 radii with highest counts\n// 3. This ensures we don't get stuck with too many balls of the same radius\n// 4. Continue until we can't find 3 different radii with available balls\n// 5. For string operations, use regex:split from ballerina/regex module or manual parsing\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to find maximum snowmen and their configurations\nfunction findMaxSnowmen(int[] radii) returns [int, int[][]] {\n    // Count frequency of each radius\n    map<int> frequency = {};\n    \n    foreach int radius in radii {\n        string key = radius.toString();\n        if frequency.hasKey(key) {\n            frequency[key] = frequency.get(key) + 1;\n        } else {\n            frequency[key] = 1;\n        }\n    }\n    \n    int[][] snowmen = [];\n    \n    // Keep building snowmen while possible\n    while true {\n        // Find all radii with available balls and sort by frequency (descending)\n        int[] availableRadii = [];\n        int[] frequencies = [];\n        \n        foreach string key in frequency.keys() {\n            int count = frequency.get(key);\n            if count > 0 {\n                int|error radius = 'int:fromString(key);\n                if radius is int {\n                    availableRadii.push(radius);\n                    frequencies.push(count);\n                }\n            }\n        }\n        \n        // Need at least 3 different radii\n        if availableRadii.length() < 3 {\n            break;\n        }\n        \n        // Sort by frequency (descending) to greedily pick most frequent ones\n        // Using simple bubble sort\n        int len = availableRadii.length();\n        foreach int i in 0 ..< len {\n            foreach int j in 0 ..< (len - i - 1) {\n                if frequencies[j] < frequencies[j + 1] {\n                    // Swap frequencies\n                    int tempFreq = frequencies[j];\n                    frequencies[j] = frequencies[j + 1];\n                    frequencies[j + 1] = tempFreq;\n                    // Swap radii\n                    int tempRad = availableRadii[j];\n                    availableRadii[j] = availableRadii[j + 1];\n                    availableRadii[j + 1] = tempRad;\n                }\n            }\n        }\n        \n        // Take top 3 radii by frequency\n        int[] selectedRadii = [availableRadii[0], availableRadii[1], availableRadii[2]];\n        \n        // Sort selected radii in descending order for output (big, medium, small)\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        if selectedRadii[1] < selectedRadii[2] {\n            int temp = selectedRadii[1];\n            selectedRadii[1] = selectedRadii[2];\n            selectedRadii[2] = temp;\n        }\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        \n        // Add snowman (big, medium, small)\n        snowmen.push([selectedRadii[0], selectedRadii[1], selectedRadii[2]]);\n        \n        // Decrease frequency for used radii\n        foreach int radius in selectedRadii {\n            string key = radius.toString();\n            frequency[key] = frequency.get(key) - 1;\n        }\n    }\n    \n    return [snowmen.length(), snowmen];\n}\n\npublic function main() returns error? {\n    // Read number of snowballs\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    // Read radii\n    string? radiiLine = io:readln();\n    if radiiLine is () {\n        return error(\"Failed to read radii\");\n    }\n    \n    // Use regex:split instead of string.split\n    string[] parts = regex:split(radiiLine.trim(), \" \");\n    int[] radii = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int|error radius = 'int:fromString(trimmedPart);\n            if radius is error {\n                return error(\"Invalid radius format\");\n            }\n            radii.push(radius);\n        }\n    }\n    \n    // Find snowmen\n    [int, int[][]] result = findMaxSnowmen(radii);\n    int count = result[0];\n    int[][] snowmen = result[1];\n    \n    // Output result\n    io:println(count);\n    foreach int[] snowman in snowmen {\n        io:println(snowman[0].toString() + \" \" + snowman[1].toString() + \" \" + snowman[2].toString());\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:31:57.744157",
      "status": "failed",
      "completion": "# Overview\nThe problem asks us to find the maximum number of snowmen that can be built from snowballs. Each snowman needs 3 snowballs with pairwise different radii. The strategy is to:\n1. Count the frequency of each radius\n2. Greedily form snowmen by taking three balls with different radii\n3. The maximum snowmen possible is limited by the total balls divided by 3, but also by availability of distinct radii\n\nThe approach:\n- Count frequency of each radius value\n- While we can form snowmen (need at least 3 different radii with available balls), pick any 3 different radii\n- Repeat until we can't form more snowmen\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read the number of snowballs and their radii\n// 2. Count frequency of each radius value using a map\n// 3. Greedily construct snowmen by selecting 3 balls with different radii\n// 4. The key insight: we need to pick 3 different radius values that have available balls\n// 5. Keep forming snowmen until we can't find 3 different radii with available balls\n// 6. Store each snowman configuration and output at the end\n\nimport ballerina/io;\n\n// Function to find maximum snowmen and their configurations\nfunction findMaxSnowmen(int[] radii) returns [int, int[][]] {\n    // Count frequency of each radius\n    map<int> frequency = {};\n    \n    foreach int radius in radii {\n        string key = radius.toString();\n        if frequency.hasKey(key) {\n            frequency[key] = frequency.get(key) + 1;\n        } else {\n            frequency[key] = 1;\n        }\n    }\n    \n    int[][] snowmen = [];\n    \n    // Keep building snowmen while possible\n    while true {\n        // Find 3 different radii with available balls\n        int[] availableRadii = [];\n        \n        foreach string key in frequency.keys() {\n            int count = frequency.get(key);\n            if count > 0 {\n                int|error radius = 'int:fromString(key);\n                if radius is int {\n                    availableRadii.push(radius);\n                }\n            }\n        }\n        \n        // Need at least 3 different radii\n        if availableRadii.length() < 3 {\n            break;\n        }\n        \n        // Sort to get largest, medium, smallest for output\n        int[] sorted = availableRadii.slice(0, 3);\n        // Simple bubble sort for 3 elements\n        if sorted[0] < sorted[1] {\n            int temp = sorted[0];\n            sorted[0] = sorted[1];\n            sorted[1] = temp;\n        }\n        if sorted[1] < sorted[2] {\n            int temp = sorted[1];\n            sorted[1] = sorted[2];\n            sorted[2] = temp;\n        }\n        if sorted[0] < sorted[1] {\n            int temp = sorted[0];\n            sorted[0] = sorted[1];\n            sorted[1] = temp;\n        }\n        \n        // Add snowman (big, medium, small)\n        snowmen.push([sorted[0], sorted[1], sorted[2]]);\n        \n        // Decrease frequency for used radii\n        frequency[sorted[0].toString()] = frequency.get(sorted[0].toString()) - 1;\n        frequency[sorted[1].toString()] = frequency.get(sorted[1].toString()) - 1;\n        frequency[sorted[2].toString()] = frequency.get(sorted[2].toString()) - 1;\n    }\n    \n    return [snowmen.length(), snowmen];\n}\n\npublic function main() returns error? {\n    // Read number of snowballs\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    // Read radii\n    string? radiiLine = io:readln();\n    if radiiLine is () {\n        return error(\"Failed to read radii\");\n    }\n    \n    string[] parts = radiiLine.trim().split(\" \");\n    int[] radii = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int|error radius = 'int:fromString(part.trim());\n            if radius is error {\n                return error(\"Invalid radius format\");\n            }\n            radii.push(radius);\n        }\n    }\n    \n    // Find snowmen\n    [int, int[][]] result = findMaxSnowmen(radii);\n    int count = result[0];\n    int[][] snowmen = result[1];\n    \n    // Output result\n    io:println(count);\n    foreach int[] snowman in snowmen {\n        io:println(snowman[0].toString() + \" \" + snowman[1].toString() + \" \" + snowman[2].toString());\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxSnowmen1() {\n    int[] radii = [1, 2, 3, 4, 5, 6, 7];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 2, \"Should create 2 snowmen from 7 balls\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen2() {\n    int[] radii = [2, 2, 3];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - not enough different radii\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen3() {\n    int[] radii = [1, 1, 1, 2, 2, 2, 3, 3, 3];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 3, \"Should create 3 snowmen from 9 balls with 3 of each size\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen4() {\n    int[] radii = [1, 2];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - only 2 balls\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen5() {\n    int[] radii = [5, 4, 3, 2, 1];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 1, \"Should create 1 snowman from 5 different radii\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read the number of snowballs and their radii\n// 2. Count frequency of each radius value using a map\n// 3. Greedily construct snowmen by selecting 3 balls with different radii\n// 4. The key insight: we need to pick 3 different radius values that have available balls\n// 5. Keep forming snowmen until we can't find 3 different radii with available balls\n// 6. Store each snowman configuration and output at the end\n\nimport ballerina/io;\n\n// Function to find maximum snowmen and their configurations\nfunction findMaxSnowmen(int[] radii) returns [int, int[][]] {\n    // Count frequency of each radius\n    map<int> frequency = {};\n    \n    foreach int radius in radii {\n        string key = radius.toString();\n        if frequency.hasKey(key) {\n            frequency[key] = frequency.get(key) + 1;\n        } else {\n            frequency[key] = 1;\n        }\n    }\n    \n    int[][] snowmen = [];\n    \n    // Keep building snowmen while possible\n    while true {\n        // Find 3 different radii with available balls\n        int[] availableRadii = [];\n        \n        foreach string key in frequency.keys() {\n            int count = frequency.get(key);\n            if count > 0 {\n                int|error radius = 'int:fromString(key);\n                if radius is int {\n                    availableRadii.push(radius);\n                }\n            }\n        }\n        \n        // Need at least 3 different radii\n        if availableRadii.length() < 3 {\n            break;\n        }\n        \n        // Sort to get largest, medium, smallest for output\n        int[] sorted = availableRadii.slice(0, 3);\n        // Simple bubble sort for 3 elements\n        if sorted[0] < sorted[1] {\n            int temp = sorted[0];\n            sorted[0] = sorted[1];\n            sorted[1] = temp;\n        }\n        if sorted[1] < sorted[2] {\n            int temp = sorted[1];\n            sorted[1] = sorted[2];\n            sorted[2] = temp;\n        }\n        if sorted[0] < sorted[1] {\n            int temp = sorted[0];\n            sorted[0] = sorted[1];\n            sorted[1] = temp;\n        }\n        \n        // Add snowman (big, medium, small)\n        snowmen.push([sorted[0], sorted[1], sorted[2]]);\n        \n        // Decrease frequency for used radii\n        frequency[sorted[0].toString()] = frequency.get(sorted[0].toString()) - 1;\n        frequency[sorted[1].toString()] = frequency.get(sorted[1].toString()) - 1;\n        frequency[sorted[2].toString()] = frequency.get(sorted[2].toString()) - 1;\n    }\n    \n    return [snowmen.length(), snowmen];\n}\n\npublic function main() returns error? {\n    // Read number of snowballs\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    // Read radii\n    string? radiiLine = io:readln();\n    if radiiLine is () {\n        return error(\"Failed to read radii\");\n    }\n    \n    string[] parts = radiiLine.trim().split(\" \");\n    int[] radii = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int|error radius = 'int:fromString(part.trim());\n            if radius is error {\n                return error(\"Invalid radius format\");\n            }\n            radii.push(radius);\n        }\n    }\n    \n    // Find snowmen\n    [int, int[][]] result = findMaxSnowmen(radii);\n    int count = result[0];\n    int[][] snowmen = result[1];\n    \n    // Output result\n    io:println(count);\n    foreach int[] snowman in snowmen {\n        io:println(snowman[0].toString() + \" \" + snowman[1].toString() + \" \" + snowman[2].toString());\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(96:39,96:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(96:39,96:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(96:39,96:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:32:26.209624",
      "status": "success",
      "completion": "# Overview\n\nThe problem requires finding the maximum number of snowmen that can be built from snowballs where each snowman needs 3 balls with pairwise different radii.\n\nStrategy:\n1. Count frequency of each radius using a map\n2. Greedily form snowmen by selecting radii with highest frequencies first (this maximizes snowmen)\n3. Each snowman uses 3 balls with different radii\n4. Continue until we can't form more snowmen\n\nThe key insight: To maximize snowmen, we should prioritize using radii that appear most frequently. This greedy approach ensures we don't leave too many balls of the same radius unused.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Use a map to count frequency of each radius value\n// 2. To maximize snowmen, we use a greedy approach: repeatedly pick 3 radii with highest counts\n// 3. This ensures we don't get stuck with too many balls of the same radius\n// 4. Continue until we can't find 3 different radii with available balls\n// 5. For string operations, use regex:split from ballerina/regex module or manual parsing\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to find maximum snowmen and their configurations\nfunction findMaxSnowmen(int[] radii) returns [int, int[][]] {\n    // Count frequency of each radius\n    map<int> frequency = {};\n    \n    foreach int radius in radii {\n        string key = radius.toString();\n        if frequency.hasKey(key) {\n            frequency[key] = frequency.get(key) + 1;\n        } else {\n            frequency[key] = 1;\n        }\n    }\n    \n    int[][] snowmen = [];\n    \n    // Keep building snowmen while possible\n    while true {\n        // Find all radii with available balls and sort by frequency (descending)\n        int[] availableRadii = [];\n        int[] frequencies = [];\n        \n        foreach string key in frequency.keys() {\n            int count = frequency.get(key);\n            if count > 0 {\n                int|error radius = 'int:fromString(key);\n                if radius is int {\n                    availableRadii.push(radius);\n                    frequencies.push(count);\n                }\n            }\n        }\n        \n        // Need at least 3 different radii\n        if availableRadii.length() < 3 {\n            break;\n        }\n        \n        // Sort by frequency (descending) to greedily pick most frequent ones\n        // Using simple bubble sort\n        int len = availableRadii.length();\n        foreach int i in 0 ..< len {\n            foreach int j in 0 ..< (len - i - 1) {\n                if frequencies[j] < frequencies[j + 1] {\n                    // Swap frequencies\n                    int tempFreq = frequencies[j];\n                    frequencies[j] = frequencies[j + 1];\n                    frequencies[j + 1] = tempFreq;\n                    // Swap radii\n                    int tempRad = availableRadii[j];\n                    availableRadii[j] = availableRadii[j + 1];\n                    availableRadii[j + 1] = tempRad;\n                }\n            }\n        }\n        \n        // Take top 3 radii by frequency\n        int[] selectedRadii = [availableRadii[0], availableRadii[1], availableRadii[2]];\n        \n        // Sort selected radii in descending order for output (big, medium, small)\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        if selectedRadii[1] < selectedRadii[2] {\n            int temp = selectedRadii[1];\n            selectedRadii[1] = selectedRadii[2];\n            selectedRadii[2] = temp;\n        }\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        \n        // Add snowman (big, medium, small)\n        snowmen.push([selectedRadii[0], selectedRadii[1], selectedRadii[2]]);\n        \n        // Decrease frequency for used radii\n        foreach int radius in selectedRadii {\n            string key = radius.toString();\n            frequency[key] = frequency.get(key) - 1;\n        }\n    }\n    \n    return [snowmen.length(), snowmen];\n}\n\npublic function main() returns error? {\n    // Read number of snowballs\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    // Read radii\n    string? radiiLine = io:readln();\n    if radiiLine is () {\n        return error(\"Failed to read radii\");\n    }\n    \n    // Use regex:split instead of string.split\n    string[] parts = regex:split(radiiLine.trim(), \" \");\n    int[] radii = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int|error radius = 'int:fromString(trimmedPart);\n            if radius is error {\n                return error(\"Invalid radius format\");\n            }\n            radii.push(radius);\n        }\n    }\n    \n    // Find snowmen\n    [int, int[][]] result = findMaxSnowmen(radii);\n    int count = result[0];\n    int[][] snowmen = result[1];\n    \n    // Output result\n    io:println(count);\n    foreach int[] snowman in snowmen {\n        io:println(snowman[0].toString() + \" \" + snowman[1].toString() + \" \" + snowman[2].toString());\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxSnowmen1() {\n    int[] radii = [1, 2, 3, 4, 5, 6, 7];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 2, \"Should create 2 snowmen from 7 balls\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen2() {\n    int[] radii = [2, 2, 3];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - not enough different radii\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen3() {\n    int[] radii = [1, 1, 1, 2, 2, 2, 3, 3, 3];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 3, \"Should create 3 snowmen from 9 balls with 3 of each size\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen4() {\n    int[] radii = [1, 2];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - only 2 balls\");\n}\n\n@test:Config {}\nfunction testMaxSnowmen5() {\n    int[] radii = [5, 4, 3, 2, 1];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 1, \"Should create 1 snowman from 5 different radii\");\n}\n\n@test:Config {}\nfunction testMaxSnowmenSingleRadius() {\n    int[] radii = [1, 1, 1, 1, 1];\n    [int, int[][]] result = findMaxSnowmen(radii);\n    test:assertEquals(result[0], 0, \"Should create 0 snowmen - all same radius\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Use a map to count frequency of each radius value\n// 2. To maximize snowmen, we use a greedy approach: repeatedly pick 3 radii with highest counts\n// 3. This ensures we don't get stuck with too many balls of the same radius\n// 4. Continue until we can't find 3 different radii with available balls\n// 5. For string operations, use regex:split from ballerina/regex module or manual parsing\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to find maximum snowmen and their configurations\nfunction findMaxSnowmen(int[] radii) returns [int, int[][]] {\n    // Count frequency of each radius\n    map<int> frequency = {};\n    \n    foreach int radius in radii {\n        string key = radius.toString();\n        if frequency.hasKey(key) {\n            frequency[key] = frequency.get(key) + 1;\n        } else {\n            frequency[key] = 1;\n        }\n    }\n    \n    int[][] snowmen = [];\n    \n    // Keep building snowmen while possible\n    while true {\n        // Find all radii with available balls and sort by frequency (descending)\n        int[] availableRadii = [];\n        int[] frequencies = [];\n        \n        foreach string key in frequency.keys() {\n            int count = frequency.get(key);\n            if count > 0 {\n                int|error radius = 'int:fromString(key);\n                if radius is int {\n                    availableRadii.push(radius);\n                    frequencies.push(count);\n                }\n            }\n        }\n        \n        // Need at least 3 different radii\n        if availableRadii.length() < 3 {\n            break;\n        }\n        \n        // Sort by frequency (descending) to greedily pick most frequent ones\n        // Using simple bubble sort\n        int len = availableRadii.length();\n        foreach int i in 0 ..< len {\n            foreach int j in 0 ..< (len - i - 1) {\n                if frequencies[j] < frequencies[j + 1] {\n                    // Swap frequencies\n                    int tempFreq = frequencies[j];\n                    frequencies[j] = frequencies[j + 1];\n                    frequencies[j + 1] = tempFreq;\n                    // Swap radii\n                    int tempRad = availableRadii[j];\n                    availableRadii[j] = availableRadii[j + 1];\n                    availableRadii[j + 1] = tempRad;\n                }\n            }\n        }\n        \n        // Take top 3 radii by frequency\n        int[] selectedRadii = [availableRadii[0], availableRadii[1], availableRadii[2]];\n        \n        // Sort selected radii in descending order for output (big, medium, small)\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        if selectedRadii[1] < selectedRadii[2] {\n            int temp = selectedRadii[1];\n            selectedRadii[1] = selectedRadii[2];\n            selectedRadii[2] = temp;\n        }\n        if selectedRadii[0] < selectedRadii[1] {\n            int temp = selectedRadii[0];\n            selectedRadii[0] = selectedRadii[1];\n            selectedRadii[1] = temp;\n        }\n        \n        // Add snowman (big, medium, small)\n        snowmen.push([selectedRadii[0], selectedRadii[1], selectedRadii[2]]);\n        \n        // Decrease frequency for used radii\n        foreach int radius in selectedRadii {\n            string key = radius.toString();\n            frequency[key] = frequency.get(key) - 1;\n        }\n    }\n    \n    return [snowmen.length(), snowmen];\n}\n\npublic function main() returns error? {\n    // Read number of snowballs\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    // Read radii\n    string? radiiLine = io:readln();\n    if radiiLine is () {\n        return error(\"Failed to read radii\");\n    }\n    \n    // Use regex:split instead of string.split\n    string[] parts = regex:split(radiiLine.trim(), \" \");\n    int[] radii = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int|error radius = 'int:fromString(trimmedPart);\n            if radius is error {\n                return error(\"Invalid radius format\");\n            }\n            radii.push(radius);\n        }\n    }\n    \n    // Find snowmen\n    [int, int[][]] result = findMaxSnowmen(radii);\n    int count = result[0];\n    int[][] snowmen = result[1];\n    \n    // Output result\n    io:println(count);\n    foreach int[] snowman in snowmen {\n        io:println(snowman[0].toString() + \" \" + snowman[1].toString() + \" \" + snowman[2].toString());\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:33:00.844579"
}