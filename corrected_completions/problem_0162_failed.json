{
  "entry_id": "problem_0162",
  "problem_index": 162,
  "prompt": "Title: Voltage Keepsake\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou have *n* devices that you want to use simultaneously.\n\nThe *i*-th device uses *a**i* units of power per second. This usage is continuous. That is, in λ seconds, the device will use λ·*a**i* units of power. The *i*-th device currently has *b**i* units of power stored. All devices can store an arbitrary amount of power.\n\nYou have a single charger that can plug to any single device. The charger will add *p* units of power per second to a device. This charging is continuous. That is, if you plug in a device for λ seconds, it will gain λ·*p* units of power. You can switch which device is charging at any arbitrary unit of time (including real numbers), and the time it takes to switch is negligible.\n\nYou are wondering, what is the maximum amount of time you can use the devices until one of them hits 0 units of power.\n\nIf you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.\n\nInput Specification:\nThe first line contains two integers, *n* and *p* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*p*<=≤<=109) — the number of devices and the power of the charger.\n\nThis is followed by *n* lines which contain two integers each. Line *i* contains the integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100<=000) — the power of the device and the amount of power stored in the device in the beginning.\n\nOutput Specification:\nIf you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.\n\nYour answer will be considered correct if its absolute or relative error does not exceed 10<=-<=4.\n\nNamely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .\n\nDemo Input:\n['2 1\\n2 2\\n2 1000\\n', '1 100\\n1 1\\n', '3 5\\n4 3\\n5 2\\n6 1\\n']\n\nDemo Output:\n['2.0000000000', '-1\\n', '0.5000000000']\n\nNote:\nIn sample test 1, you can charge the first device for the entire time until it hits zero power. The second device has enough power to last this time without being charged.\n\nIn sample test 2, you can use the device indefinitely.\n\nIn sample test 3, we can charge the third device for 2 / 5 of a second, then switch to charge the second device for a 1 / 10 of a second.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:49:12.716249",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to find the maximum time we can keep all devices running simultaneously given a single charger. We need to use binary search on the answer (time). For a given time `t`, we check if it's possible to keep all devices running by optimally distributing the charger among devices that would run out of power.\n\nKey insights:\n- If total power consumption is <= charger power, we can run indefinitely (-1)\n- Otherwise, use binary search to find the maximum feasible time\n- For a given time `t`, check if we can distribute charger time to keep all devices alive\n- A device needs charging if `b[i] < a[i] * t`\n- The charger time needed for device i is `(a[i] * t - b[i]) / p`\n- Sum of all charger times needed must be <= t\n\n<CODE>\n```ballerina\n// Problem: Find maximum time to keep all devices running with one charger\n// \n// Strategy:\n// 1. Calculate total power consumption vs charger power\n// 2. If total consumption <= charger power, return -1 (infinite)\n// 3. Otherwise, use binary search on time to find maximum feasible time\n// 4. For each candidate time, check if it's feasible by calculating required charger time\n// 5. A time is feasible if sum of required charger times <= available time\n\nimport ballerina/io;\n\n// Check if we can sustain all devices for time t\nfunction isFeasible(float t, int[] a, int[] b, int p) returns boolean {\n    float totalChargerTimeNeeded = 0.0;\n    \n    foreach int i in 0 ..< a.length() {\n        float powerNeeded = <float>a[i] * t;\n        float powerAvailable = <float>b[i];\n        \n        // If device needs charging\n        if powerNeeded > powerAvailable {\n            float deficit = powerNeeded - powerAvailable;\n            float chargerTimeNeeded = deficit / <float>p;\n            totalChargerTimeNeeded += chargerTimeNeeded;\n        }\n    }\n    \n    // Check if total charger time needed is within available time\n    return totalChargerTimeNeeded <= t;\n}\n\nfunction solveVoltageKeepsake(int n, int p, int[] a, int[] b) returns float {\n    // Calculate total power consumption\n    int totalConsumption = 0;\n    foreach int ai in a {\n        totalConsumption += ai;\n    }\n    \n    // If charger can cover all consumption, infinite time\n    if (totalConsumption <= p) {\n        return -1.0;\n    }\n    \n    // Binary search on time\n    float left = 0.0;\n    float right = 2e9; // Large enough upper bound\n    float epsilon = 1e-7;\n    \n    // Binary search for maximum feasible time\n    while (right - left > epsilon) {\n        float mid = (left + right) / 2.0;\n        \n        if (isFeasible(mid, a, b, p)) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for n and p\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int p = check 'int:fromString(parts1[1]);\n    \n    int[] a = [];\n    int[] b = [];\n    \n    // Read n lines of device specifications\n    foreach int i in 0 ..< n {\n        string? deviceLine = io:readln();\n        if deviceLine is () {\n            return error(\"Failed to read device input\");\n        }\n        \n        string[] deviceParts = deviceLine.trim().split(\" \");\n        if deviceParts.length() != 2 {\n            return error(\"Invalid device input format\");\n        }\n        \n        int ai = check 'int:fromString(deviceParts[0]);\n        int bi = check 'int:fromString(deviceParts[1]);\n        \n        a.push(ai);\n        b.push(bi);\n    }\n    \n    // Solve and output\n    float result = solveVoltageKeepsake(n, p, a, b);\n    \n    if (result < 0.0) {\n        io:println(\"-1\");\n    } else {\n        io:println(result.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testVoltageKeepsakeCase1() {\n    // Test case 1: 2 devices, charger power 1\n    // Device 1: a=2, b=2\n    // Device 2: a=2, b=1000\n    int[] a = [2, 2];\n    int[] b = [2, 1000];\n    float result = solveVoltageKeepsake(2, 1, a, b);\n    // Expected: 2.0\n    test:assertTrue((result - 2.0).abs() < 0.001, \"Test case 1 failed\");\n}\n\n@test:Config {}\nfunction testVoltageKeepsakeCase2() {\n    // Test case 2: 1 device, charger power 100\n    // Device 1: a=1, b=1\n    int[] a = [1];\n    int[] b = [1];\n    float result = solveVoltageKeepsake(1, 100, a, b);\n    // Expected: -1 (infinite)\n    test:assertEquals(result, -1.0, \"Test case 2 failed - should be infinite\");\n}\n\n@test:Config {}\nfunction testVoltageKeepsakeCase3() {\n    // Test case 3: 3 devices, charger power 5\n    // Device 1: a=4, b=3\n    // Device 2: a=5, b=2\n    // Device 3: a=6, b=1\n    int[] a = [4, 5, 6];\n    int[] b = [3, 2, 1];\n    float result = solveVoltageKeepsake(3, 5, a, b);\n    // Expected: 0.5\n    test:assertTrue((result - 0.5).abs() < 0.001, \"Test case 3 failed\");\n}\n\n@test:Config {}\nfunction testVoltageKeepsakeInfinite() {\n    // Test case: charger power exceeds total consumption\n    int[] a = [10, 20];\n    int[] b = [100, 200];\n    float result = solveVoltageKeepsake(2, 50, a, b);\n    // Expected: -1 (infinite) since 10+20=30 <= 50\n    test:assertEquals(result, -1.0, \"Infinite case failed\");\n}\n```\n</TESTS>",
      "code": "// Problem: Find maximum time to keep all devices running with one charger\n// \n// Strategy:\n// 1. Calculate total power consumption vs charger power\n// 2. If total consumption <= charger power, return -1 (infinite)\n// 3. Otherwise, use binary search on time to find maximum feasible time\n// 4. For each candidate time, check if it's feasible by calculating required charger time\n// 5. A time is feasible if sum of required charger times <= available time\n\nimport ballerina/io;\n\n// Check if we can sustain all devices for time t\nfunction isFeasible(float t, int[] a, int[] b, int p) returns boolean {\n    float totalChargerTimeNeeded = 0.0;\n    \n    foreach int i in 0 ..< a.length() {\n        float powerNeeded = <float>a[i] * t;\n        float powerAvailable = <float>b[i];\n        \n        // If device needs charging\n        if powerNeeded > powerAvailable {\n            float deficit = powerNeeded - powerAvailable;\n            float chargerTimeNeeded = deficit / <float>p;\n            totalChargerTimeNeeded += chargerTimeNeeded;\n        }\n    }\n    \n    // Check if total charger time needed is within available time\n    return totalChargerTimeNeeded <= t;\n}\n\nfunction solveVoltageKeepsake(int n, int p, int[] a, int[] b) returns float {\n    // Calculate total power consumption\n    int totalConsumption = 0;\n    foreach int ai in a {\n        totalConsumption += ai;\n    }\n    \n    // If charger can cover all consumption, infinite time\n    if (totalConsumption <= p) {\n        return -1.0;\n    }\n    \n    // Binary search on time\n    float left = 0.0;\n    float right = 2e9; // Large enough upper bound\n    float epsilon = 1e-7;\n    \n    // Binary search for maximum feasible time\n    while (right - left > epsilon) {\n        float mid = (left + right) / 2.0;\n        \n        if (isFeasible(mid, a, b, p)) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for n and p\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int p = check 'int:fromString(parts1[1]);\n    \n    int[] a = [];\n    int[] b = [];\n    \n    // Read n lines of device specifications\n    foreach int i in 0 ..< n {\n        string? deviceLine = io:readln();\n        if deviceLine is () {\n            return error(\"Failed to read device input\");\n        }\n        \n        string[] deviceParts = deviceLine.trim().split(\" \");\n        if deviceParts.length() != 2 {\n            return error(\"Invalid device input format\");\n        }\n        \n        int ai = check 'int:fromString(deviceParts[0]);\n        int bi = check 'int:fromString(deviceParts[1]);\n        \n        a.push(ai);\n        b.push(bi);\n    }\n    \n    // Solve and output\n    float result = solveVoltageKeepsake(n, p, a, b);\n    \n    if (result < 0.0) {\n        io:println(\"-1\");\n    } else {\n        io:println(result.toString());\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(70:36,70:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(88:50,88:55)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(70:36,70:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(88:50,88:55)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(70:36,70:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(88:50,88:55)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:49:41.725551",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires finding the maximum time we can keep all devices running with a single charger. The solution uses binary search on the time value. For each candidate time, we verify if it's feasible by calculating whether the charger can provide enough power to all devices that would otherwise run out.\n\nKey points:\n- If total power consumption ≤ charger power, devices can run indefinitely (-1)\n- Otherwise, binary search on time to find the maximum feasible duration\n- For a given time t, a device needs charging if its consumption exceeds stored power\n- The charger time needed must not exceed the available time t\n\nThe compilation error was due to using `split()` on strings. In Ballerina, we need to use `regex:split()` from the `ballerina/regex` module.\n\n<CODE>\n```ballerina\n// Problem: Find maximum time to keep all devices running with one charger\n// \n// Approach:\n// 1. If total power consumption <= charger power, return -1 (can run forever)\n// 2. Otherwise, binary search on the time duration\n// 3. For each candidate time t, check feasibility:\n//    - Calculate how much charger time each device needs\n//    - If device i consumes a[i]*t but only has b[i] stored, it needs charging\n//    - Charger time needed for device i = (a[i]*t - b[i])/p\n//    - Sum of all charger times must be <= t\n// 4. Binary search finds the maximum feasible time with precision 1e-7\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Check if we can sustain all devices for time t\nfunction isFeasible(float t, int[] a, int[] b, int p) returns boolean {\n    float totalChargerTimeNeeded = 0.0;\n    \n    foreach int i in 0 ..< a.length() {\n        float powerNeeded = <float>a[i] * t;\n        float powerAvailable = <float>b[i];\n        \n        // If device needs more power than it has stored\n        if powerNeeded > powerAvailable {\n            float deficit = powerNeeded - powerAvailable;\n            float chargerTimeNeeded = deficit / <float>p;\n            totalChargerTimeNeeded += chargerTimeNeeded;\n        }\n    }\n    \n    // Feasible if total charger time needed doesn't exceed available time\n    return totalChargerTimeNeeded <= t;\n}\n\nfunction solveVoltageKeepsake(int n, int p, int[] a, int[] b) returns float {\n    // Calculate total power consumption across all devices\n    int totalConsumption = 0;\n    foreach int ai in a {\n        totalConsumption += ai;\n    }\n    \n    // If charger can cover all consumption, we can run indefinitely\n    if totalConsumption <= p {\n        return -1.0;\n    }\n    \n    // Binary search on time\n    float left = 0.0;\n    float right = 2.0e9; // Upper bound (large enough for the constraints)\n    float epsilon = 1.0e-7; // Precision requirement\n    \n    // Binary search for maximum feasible time\n    while right - left > epsilon {\n        float mid = (left + right) / 2.0;\n        \n        if isFeasible(mid, a, b, p) {\n            left = mid; // Can achieve this time, try for more\n        } else {\n            right = mid; // Cannot achieve this time, try less\n        }\n    }\n    \n    return left;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for n and p\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int p = check 'int:fromString(parts1[1]);\n    \n    int[] a = [];\n    int[] b = [];\n    \n    // Read n lines of device specifications\n    foreach int i in 0 ..< n {\n        string? deviceLine = io:readln();\n        if deviceLine is () {\n            return error(\"Failed to read device input\");\n        }\n        \n        string[] deviceParts = regex:split(deviceLine.trim(), \" \");\n        if deviceParts.length() != 2 {\n            return error(\"Invalid device input format\");\n        }\n        \n        int ai = check 'int:fromString(deviceParts[0]);\n        int bi = check 'int:fromString(deviceParts[1]);\n        \n        a.push(ai);\n        b.push(bi);\n    }\n    \n    // Solve and output the result\n    float result = solveVoltageKeepsake(n, p, a, b);\n    \n    if result < 0.0 {\n        io:println(\"-1\");\n    } else {\n        io:println(result.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testVoltageKeepsakeCase1() {\n    // Test case 1: 2 devices, charger power 1\n    // Device 1: a=2, b=2\n    // Device 2: a=2, b=1000\n    // Total consumption = 4, charger = 1, so need to charge\n    int[] a = [2, 2];\n    int[] b = [2, 1000];\n    float result = solveVoltageKeepsake(2, 1, a, b);\n    // Expected: 2.0\n    test:assertTrue((result - 2.0).abs() < 0.001, \"Test case 1 failed\");\n}\n\n@test:Config {}\nfunction testVoltageKeepsakeCase2() {\n    // Test case 2: 1 device, charger power 100\n    // Device 1: a=1, b=1\n    // Total consumption = 1, charger = 100, so infinite\n    int[] a = [1];\n    int[] b = [1];\n    float result = solveVoltageKeepsake(1, 100, a, b);\n    // Expected: -1 (infinite)\n    test:assertEquals(result, -1.0, \"Test case 2 failed - should be infinite\");\n}\n\n@test:Config {}\nfunction testVoltageKeepsakeCase3() {\n    // Test case 3: 3 devices, charger power 5\n    // Device 1: a=4, b=3\n    // Device 2: a=5, b=2\n    // Device 3: a=6, b=1\n    // Total consumption = 15, charger = 5\n    int[] a = [4, 5, 6];\n    int[] b = [3, 2, 1];\n    float result = solveVoltageKeepsake(3, 5, a, b);\n    // Expected: 0.5\n    test:assertTrue((result - 0.5).abs() < 0.001, \"Test case 3 failed\");\n}\n\n@test:Config {}\nfunction testVoltageKeepsakeInfinite() {\n    // Test case: charger power exceeds total consumption\n    int[] a = [10, 20];\n    int[] b = [100, 200];\n    float result = solveVoltageKeepsake(2, 50, a, b);\n    // Expected: -1 (infinite) since 10+20=30 <= 50\n    test:assertEquals(result, -1.0, \"Infinite case failed\");\n}\n```\n</TESTS>",
      "code": "// Problem: Find maximum time to keep all devices running with one charger\n// \n// Approach:\n// 1. If total power consumption <= charger power, return -1 (can run forever)\n// 2. Otherwise, binary search on the time duration\n// 3. For each candidate time t, check feasibility:\n//    - Calculate how much charger time each device needs\n//    - If device i consumes a[i]*t but only has b[i] stored, it needs charging\n//    - Charger time needed for device i = (a[i]*t - b[i])/p\n//    - Sum of all charger times must be <= t\n// 4. Binary search finds the maximum feasible time with precision 1e-7\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Check if we can sustain all devices for time t\nfunction isFeasible(float t, int[] a, int[] b, int p) returns boolean {\n    float totalChargerTimeNeeded = 0.0;\n    \n    foreach int i in 0 ..< a.length() {\n        float powerNeeded = <float>a[i] * t;\n        float powerAvailable = <float>b[i];\n        \n        // If device needs more power than it has stored\n        if powerNeeded > powerAvailable {\n            float deficit = powerNeeded - powerAvailable;\n            float chargerTimeNeeded = deficit / <float>p;\n            totalChargerTimeNeeded += chargerTimeNeeded;\n        }\n    }\n    \n    // Feasible if total charger time needed doesn't exceed available time\n    return totalChargerTimeNeeded <= t;\n}\n\nfunction solveVoltageKeepsake(int n, int p, int[] a, int[] b) returns float {\n    // Calculate total power consumption across all devices\n    int totalConsumption = 0;\n    foreach int ai in a {\n        totalConsumption += ai;\n    }\n    \n    // If charger can cover all consumption, we can run indefinitely\n    if totalConsumption <= p {\n        return -1.0;\n    }\n    \n    // Binary search on time\n    float left = 0.0;\n    float right = 2.0e9; // Upper bound (large enough for the constraints)\n    float epsilon = 1.0e-7; // Precision requirement\n    \n    // Binary search for maximum feasible time\n    while right - left > epsilon {\n        float mid = (left + right) / 2.0;\n        \n        if isFeasible(mid, a, b, p) {\n            left = mid; // Can achieve this time, try for more\n        } else {\n            right = mid; // Cannot achieve this time, try less\n        }\n    }\n    \n    return left;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for n and p\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int p = check 'int:fromString(parts1[1]);\n    \n    int[] a = [];\n    int[] b = [];\n    \n    // Read n lines of device specifications\n    foreach int i in 0 ..< n {\n        string? deviceLine = io:readln();\n        if deviceLine is () {\n            return error(\"Failed to read device input\");\n        }\n        \n        string[] deviceParts = regex:split(deviceLine.trim(), \" \");\n        if deviceParts.length() != 2 {\n            return error(\"Invalid device input format\");\n        }\n        \n        int ai = check 'int:fromString(deviceParts[0]);\n        int bi = check 'int:fromString(deviceParts[1]);\n        \n        a.push(ai);\n        b.push(bi);\n    }\n    \n    // Solve and output the result\n    float result = solveVoltageKeepsake(n, p, a, b);\n    \n    if result < 0.0 {\n        io:println(\"-1\");\n    } else {\n        io:println(result.toString());\n    }\n    \n    return;\n}",
      "tests_passed": 1,
      "tests_total": 3,
      "tests_pass_rate": 0.3333333333333333,
      "validation_msg": "Only passed 1/3 tests (33.3%), need 75%",
      "error": "Only passed 1/3 tests (33.3%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "2 1\n2 2\n2 1000\n",
          "expected_output": "2.0000000000",
          "actual_output": "1.9999999989472883\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/3 tests (33.3%), need 75%",
  "timestamp": "2026-01-05T02:50:18.114857"
}