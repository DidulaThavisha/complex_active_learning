{
  "entry_id": "problem_0043",
  "problem_index": 43,
  "prompt": "Title: Reberland Linguistics\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nFirst-rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. \n\nFor example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the \"root\" of the word — some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction —  it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word (this time we use word \"suffix\" to describe a morpheme but not the few last characters of the string as you may used to). \n\nHere is one exercise that you have found in your task list. You are given the word *s*. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. \n\nTwo strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. \n\nLet's look at the example: the word *abacabaca* is given. This word can be obtained in the following ways: , where the root of the word is overlined, and suffixes are marked by \"corners\". Thus, the set of possible suffixes for this word is {*aca*,<=*ba*,<=*ca*}.\n\nInput Specification:\nThe only line contains a string *s* (5<=≤<=|*s*|<=≤<=104) consisting of lowercase English letters.\n\nOutput Specification:\nOn the first line print integer *k* — a number of distinct possible suffixes. On the next *k* lines print suffixes. \n\nPrint suffixes in lexicographical (alphabetical) order.\n\nDemo Input:\n['abacabaca\\n', 'abaca\\n']\n\nDemo Output:\n['3\\naca\\nba\\nca\\n', '0\\n']\n\nNote:\nThe first test was analysed in the problem statement. \n\nIn the second example the length of the string equals 5. The length of the root equals 5, so no string can be used as a suffix.",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem requires finding all possible suffixes (of length 2 or 3) that can be used to construct a given word according to Reberland language rules. The word must have a root of at least 5 characters, and suffixes are appended with the restriction that the same suffix cannot appear twice consecutively. We'll use dynamic programming to track which suffixes are possible at each position, working backwards from the end of the string.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. The root must be at least 5 characters, so suffixes start from position 5 onwards\n// 2. We need to find all possible suffixes of length 2 or 3 that can form the word\n// 3. The constraint is that the same suffix cannot appear twice in a row\n// 4. We'll use dynamic programming working backwards from the end:\n//    - dp[i][len][suffix] = true if we can form the string from position i to end\n//      where we just used a suffix of given length and value\n// 5. We work backwards: for each position >= 5, try adding suffix of length 2 or 3\n// 6. Check that we don't use the same suffix twice in a row\n// 7. Collect all valid suffixes and sort them lexicographically\n\nimport ballerina/io;\n\nfunction findPossibleSuffixes(string s) returns string[] {\n    int n = s.length();\n    \n    // If string length is 5 or less, no suffixes possible (root needs 5+ chars)\n    if n <= 5 {\n        return [];\n    }\n    \n    // dp[i][len] stores the last suffix used when we can reach position i with suffix of length len\n    // We'll use a map to track reachable states\n    map<map<boolean>> dp = {};\n    \n    // Start from the end - we can always reach the end\n    dp[n.toString()] = {\"\": true};\n    \n    // Set to collect all valid suffixes\n    map<boolean> validSuffixes = {};\n    \n    // Work backwards from position n to position 5 (need at least 5 chars for root)\n    int i = n;\n    while i >= 5 {\n        // Try suffix of length 2\n        if i + 2 <= n {\n            string suffix2 = s.substring(i, i + 2);\n            int nextPos = i + 2;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    // Check each possible previous suffix at nextPos\n                    foreach string prevSuffix in nextStates.keys() {\n                        // Can use this suffix if it's different from previous or previous is empty\n                        if prevSuffix == \"\" || prevSuffix != suffix2 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix2] = true;\n                            validSuffixes[suffix2] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Try suffix of length 3\n        if i + 3 <= n {\n            string suffix3 = s.substring(i, i + 3);\n            int nextPos = i + 3;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    foreach string prevSuffix in nextStates.keys() {\n                        if prevSuffix == \"\" || prevSuffix != suffix3 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix3] = true;\n                            validSuffixes[suffix3] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        i = i - 1;\n    }\n    \n    // Convert to sorted array\n    string[] result = validSuffixes.keys();\n    result = result.sort();\n    \n    return result;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    string s = input_line.trim();\n    \n    string[] suffixes = findPossibleSuffixes(s);\n    \n    io:println(suffixes.length());\n    foreach string suffix in suffixes {\n        io:println(suffix);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    string[] result = findPossibleSuffixes(\"abacabaca\");\n    test:assertEquals(result.length(), 3);\n    test:assertEquals(result[0], \"aca\");\n    test:assertEquals(result[1], \"ba\");\n    test:assertEquals(result[2], \"ca\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    string[] result = findPossibleSuffixes(\"abaca\");\n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testMinimumWithSuffixes() {\n    // \"aaaaaa\" - root \"aaaaa\" + suffix \"a\" is not valid (suffix must be 2-3 chars)\n    // but \"aaaa\" + \"aa\" works\n    string[] result = findPossibleSuffixes(\"aaaaaa\");\n    test:assertEquals(result.length(), 1);\n    test:assertEquals(result[0], \"aa\");\n}\n\n@test:Config {}\nfunction testNoConsecutiveDuplicates() {\n    // \"abcabab\" - root \"abcab\" + \"ab\" or root \"abc\" + \"ab\" + \"ab\" (not allowed - consecutive)\n    // So we should get \"ab\" as valid\n    string[] result = findPossibleSuffixes(\"abcabab\");\n    test:assertTrue(result.length() > 0);\n    boolean hasAb = false;\n    foreach string suffix in result {\n        if suffix == \"ab\" {\n            hasAb = true;\n        }\n    }\n    test:assertTrue(hasAb);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. The root must be at least 5 characters, so suffixes start from position 5 onwards\n// 2. We need to find all possible suffixes of length 2 or 3 that can form the word\n// 3. The constraint is that the same suffix cannot appear twice in a row\n// 4. We'll use dynamic programming working backwards from the end:\n//    - dp[i][len][suffix] = true if we can form the string from position i to end\n//      where we just used a suffix of given length and value\n// 5. We work backwards: for each position >= 5, try adding suffix of length 2 or 3\n// 6. Check that we don't use the same suffix twice in a row\n// 7. Collect all valid suffixes and sort them lexicographically\n\nimport ballerina/io;\n\nfunction findPossibleSuffixes(string s) returns string[] {\n    int n = s.length();\n    \n    // If string length is 5 or less, no suffixes possible (root needs 5+ chars)\n    if n <= 5 {\n        return [];\n    }\n    \n    // dp[i][len] stores the last suffix used when we can reach position i with suffix of length len\n    // We'll use a map to track reachable states\n    map<map<boolean>> dp = {};\n    \n    // Start from the end - we can always reach the end\n    dp[n.toString()] = {\"\": true};\n    \n    // Set to collect all valid suffixes\n    map<boolean> validSuffixes = {};\n    \n    // Work backwards from position n to position 5 (need at least 5 chars for root)\n    int i = n;\n    while i >= 5 {\n        // Try suffix of length 2\n        if i + 2 <= n {\n            string suffix2 = s.substring(i, i + 2);\n            int nextPos = i + 2;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    // Check each possible previous suffix at nextPos\n                    foreach string prevSuffix in nextStates.keys() {\n                        // Can use this suffix if it's different from previous or previous is empty\n                        if prevSuffix == \"\" || prevSuffix != suffix2 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix2] = true;\n                            validSuffixes[suffix2] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Try suffix of length 3\n        if i + 3 <= n {\n            string suffix3 = s.substring(i, i + 3);\n            int nextPos = i + 3;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    foreach string prevSuffix in nextStates.keys() {\n                        if prevSuffix == \"\" || prevSuffix != suffix3 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix3] = true;\n                            validSuffixes[suffix3] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        i = i - 1;\n    }\n    \n    // Convert to sorted array\n    string[] result = validSuffixes.keys();\n    result = result.sort();\n    \n    return result;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    string s = input_line.trim();\n    \n    string[] suffixes = findPossibleSuffixes(s);\n    \n    io:println(suffixes.length());\n    foreach string suffix in suffixes {\n        io:println(suffix);\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:41:46.148111",
      "status": "success",
      "completion": "# Overview\nThis problem requires finding all possible suffixes (of length 2 or 3) that can be used to construct a given word according to Reberland language rules. The word must have a root of at least 5 characters, and suffixes are appended with the restriction that the same suffix cannot appear twice consecutively. We'll use dynamic programming to track which suffixes are possible at each position, working backwards from the end of the string.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. The root must be at least 5 characters, so suffixes start from position 5 onwards\n// 2. We need to find all possible suffixes of length 2 or 3 that can form the word\n// 3. The constraint is that the same suffix cannot appear twice in a row\n// 4. We'll use dynamic programming working backwards from the end:\n//    - dp[i][len][suffix] = true if we can form the string from position i to end\n//      where we just used a suffix of given length and value\n// 5. We work backwards: for each position >= 5, try adding suffix of length 2 or 3\n// 6. Check that we don't use the same suffix twice in a row\n// 7. Collect all valid suffixes and sort them lexicographically\n\nimport ballerina/io;\n\nfunction findPossibleSuffixes(string s) returns string[] {\n    int n = s.length();\n    \n    // If string length is 5 or less, no suffixes possible (root needs 5+ chars)\n    if n <= 5 {\n        return [];\n    }\n    \n    // dp[i][len] stores the last suffix used when we can reach position i with suffix of length len\n    // We'll use a map to track reachable states\n    map<map<boolean>> dp = {};\n    \n    // Start from the end - we can always reach the end\n    dp[n.toString()] = {\"\": true};\n    \n    // Set to collect all valid suffixes\n    map<boolean> validSuffixes = {};\n    \n    // Work backwards from position n to position 5 (need at least 5 chars for root)\n    int i = n;\n    while i >= 5 {\n        // Try suffix of length 2\n        if i + 2 <= n {\n            string suffix2 = s.substring(i, i + 2);\n            int nextPos = i + 2;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    // Check each possible previous suffix at nextPos\n                    foreach string prevSuffix in nextStates.keys() {\n                        // Can use this suffix if it's different from previous or previous is empty\n                        if prevSuffix == \"\" || prevSuffix != suffix2 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix2] = true;\n                            validSuffixes[suffix2] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Try suffix of length 3\n        if i + 3 <= n {\n            string suffix3 = s.substring(i, i + 3);\n            int nextPos = i + 3;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    foreach string prevSuffix in nextStates.keys() {\n                        if prevSuffix == \"\" || prevSuffix != suffix3 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix3] = true;\n                            validSuffixes[suffix3] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        i = i - 1;\n    }\n    \n    // Convert to sorted array\n    string[] result = validSuffixes.keys();\n    result = result.sort();\n    \n    return result;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    string s = input_line.trim();\n    \n    string[] suffixes = findPossibleSuffixes(s);\n    \n    io:println(suffixes.length());\n    foreach string suffix in suffixes {\n        io:println(suffix);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    string[] result = findPossibleSuffixes(\"abacabaca\");\n    test:assertEquals(result.length(), 3);\n    test:assertEquals(result[0], \"aca\");\n    test:assertEquals(result[1], \"ba\");\n    test:assertEquals(result[2], \"ca\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    string[] result = findPossibleSuffixes(\"abaca\");\n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testMinimumWithSuffixes() {\n    // \"aaaaaa\" - root \"aaaaa\" + suffix \"a\" is not valid (suffix must be 2-3 chars)\n    // but \"aaaa\" + \"aa\" works\n    string[] result = findPossibleSuffixes(\"aaaaaa\");\n    test:assertEquals(result.length(), 1);\n    test:assertEquals(result[0], \"aa\");\n}\n\n@test:Config {}\nfunction testNoConsecutiveDuplicates() {\n    // \"abcabab\" - root \"abcab\" + \"ab\" or root \"abc\" + \"ab\" + \"ab\" (not allowed - consecutive)\n    // So we should get \"ab\" as valid\n    string[] result = findPossibleSuffixes(\"abcabab\");\n    test:assertTrue(result.length() > 0);\n    boolean hasAb = false;\n    foreach string suffix in result {\n        if suffix == \"ab\" {\n            hasAb = true;\n        }\n    }\n    test:assertTrue(hasAb);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. The root must be at least 5 characters, so suffixes start from position 5 onwards\n// 2. We need to find all possible suffixes of length 2 or 3 that can form the word\n// 3. The constraint is that the same suffix cannot appear twice in a row\n// 4. We'll use dynamic programming working backwards from the end:\n//    - dp[i][len][suffix] = true if we can form the string from position i to end\n//      where we just used a suffix of given length and value\n// 5. We work backwards: for each position >= 5, try adding suffix of length 2 or 3\n// 6. Check that we don't use the same suffix twice in a row\n// 7. Collect all valid suffixes and sort them lexicographically\n\nimport ballerina/io;\n\nfunction findPossibleSuffixes(string s) returns string[] {\n    int n = s.length();\n    \n    // If string length is 5 or less, no suffixes possible (root needs 5+ chars)\n    if n <= 5 {\n        return [];\n    }\n    \n    // dp[i][len] stores the last suffix used when we can reach position i with suffix of length len\n    // We'll use a map to track reachable states\n    map<map<boolean>> dp = {};\n    \n    // Start from the end - we can always reach the end\n    dp[n.toString()] = {\"\": true};\n    \n    // Set to collect all valid suffixes\n    map<boolean> validSuffixes = {};\n    \n    // Work backwards from position n to position 5 (need at least 5 chars for root)\n    int i = n;\n    while i >= 5 {\n        // Try suffix of length 2\n        if i + 2 <= n {\n            string suffix2 = s.substring(i, i + 2);\n            int nextPos = i + 2;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    // Check each possible previous suffix at nextPos\n                    foreach string prevSuffix in nextStates.keys() {\n                        // Can use this suffix if it's different from previous or previous is empty\n                        if prevSuffix == \"\" || prevSuffix != suffix2 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix2] = true;\n                            validSuffixes[suffix2] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Try suffix of length 3\n        if i + 3 <= n {\n            string suffix3 = s.substring(i, i + 3);\n            int nextPos = i + 3;\n            \n            // Check if we can continue from nextPos\n            if dp.hasKey(nextPos.toString()) {\n                map<boolean>? nextStates = dp[nextPos.toString()];\n                if nextStates is map<boolean> {\n                    foreach string prevSuffix in nextStates.keys() {\n                        if prevSuffix == \"\" || prevSuffix != suffix3 {\n                            if !dp.hasKey(i.toString()) {\n                                dp[i.toString()] = {};\n                            }\n                            map<boolean> currentMap = <map<boolean>>dp[i.toString()];\n                            currentMap[suffix3] = true;\n                            validSuffixes[suffix3] = true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        i = i - 1;\n    }\n    \n    // Convert to sorted array\n    string[] result = validSuffixes.keys();\n    result = result.sort();\n    \n    return result;\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    string s = input_line.trim();\n    \n    string[] suffixes = findPossibleSuffixes(s);\n    \n    io:println(suffixes.length());\n    foreach string suffix in suffixes {\n        io:println(suffix);\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T00:42:24.134787"
}