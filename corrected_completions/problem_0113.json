{
  "entry_id": "problem_0113",
  "problem_index": 113,
  "prompt": "Title: Consecutive Subsequence\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou are given an integer array of length $n$.\n\nYou have to choose some subsequence of this array of maximum length such that this subsequence forms a increasing sequence of consecutive integers. In other words the required sequence should be equal to $[x, x + 1, \\dots, x + k - 1]$ for some value $x$ and length $k$.\n\nSubsequence of an array can be obtained by erasing some (possibly zero) elements from the array. You can erase any elements, not necessarily going successively. The remaining elements preserve their order. For example, for the array $[5, 3, 1, 2, 4]$ the following arrays are subsequences: $[3]$, $[5, 3, 1, 2, 4]$, $[5, 1, 4]$, but the array $[1, 3]$ is not.\n\nInput Specification:\nThe first line of the input containing integer number $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the array. The second line of the input containing $n$ integer numbers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — the array itself.\n\nOutput Specification:\nOn the first line print $k$ — the maximum length of the subsequence of the given array that forms an increasing sequence of consecutive integers.\n\nOn the second line print the sequence of the indices of the any maximum length subsequence of the given array that forms an increasing sequence of consecutive integers.\n\nDemo Input:\n['7\\n3 3 4 7 5 6 8\\n', '6\\n1 3 5 2 4 6\\n', '4\\n10 9 8 7\\n', '9\\n6 7 8 3 4 5 9 10 11\\n']\n\nDemo Output:\n['4\\n2 3 5 6 \\n', '2\\n1 4 \\n', '1\\n1 \\n', '6\\n1 2 3 7 8 9 \\n']\n\nNote:\nAll valid answers for the first example (as sequences of indices): \n -  $[1, 3, 5, 6]$ -  $[2, 3, 5, 6]$ \nAll valid answers for the second example: \n -  $[1, 4]$ -  $[2, 5]$ -  $[3, 6]$ \nAll valid answers for the third example: \n -  $[1]$ -  $[2]$ -  $[3]$ -  $[4]$ \nAll valid answers for the fourth example: \n -  $[1, 2, 3, 7, 8, 9]$",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem asks us to find the longest subsequence of consecutive integers in an array. The key insight is to use a map to track consecutive sequences - for each value, we check if (value-1) exists to extend that sequence. We track the length and indices of sequences ending at each value, then return the maximum length sequence with 1-indexed positions.\n\nThe main issue in the previous code was using `split()` which doesn't exist in Ballerina's string type. We need to use `string:split()` from the standard library or use regex functions.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For each number 'n' in the array, check if we've seen 'n-1' before\n// - If 'n-1' exists in our map, extend that sequence by appending current index\n// - If not, start a new sequence with just this number\n// - Track the maximum length sequence found\n// - Use a map where key is the integer value and value is sequence info\n// - Need to handle duplicate values properly - only extend if we can form consecutive sequence\n// - Return 1-indexed positions\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype SequenceInfo record {\n    int length;\n    int[] indices;\n};\n\nfunction findConsecutiveSubsequence(int[] arr) returns [int, int[]] {\n    int n = arr.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Map from value to sequence info (length and indices ending at that value)\n    map<SequenceInfo> sequences = {};\n    \n    int maxLength = 1;\n    int[] maxIndices = [1];\n    \n    int i = 0;\n    while i < n {\n        int value = arr[i];\n        int index = i + 1; // 1-indexed\n        \n        // Check if we can extend a sequence ending at (value - 1)\n        int prevValue = value - 1;\n        string prevKey = prevValue.toString();\n        string currentKey = value.toString();\n        \n        if sequences.hasKey(prevKey) {\n            SequenceInfo? prevSeq = sequences[prevKey];\n            if prevSeq is SequenceInfo {\n                // Extend the previous sequence\n                int newLength = prevSeq.length + 1;\n                int[] newIndices = [...prevSeq.indices, index];\n                \n                SequenceInfo newSeq = {\n                    length: newLength,\n                    indices: newIndices\n                };\n                \n                // Only update if this value doesn't have a sequence or current is better\n                if !sequences.hasKey(currentKey) {\n                    sequences[currentKey] = newSeq;\n                } else {\n                    SequenceInfo? existingSeq = sequences[currentKey];\n                    if existingSeq is SequenceInfo {\n                        if newLength > existingSeq.length {\n                            sequences[currentKey] = newSeq;\n                        }\n                    }\n                }\n                \n                // Update max if needed\n                if newLength > maxLength {\n                    maxLength = newLength;\n                    maxIndices = newIndices;\n                }\n            }\n        } else {\n            // Start a new sequence with this value if not exists or keep existing\n            if !sequences.hasKey(currentKey) {\n                SequenceInfo newSeq = {\n                    length: 1,\n                    indices: [index]\n                };\n                sequences[currentKey] = newSeq;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return [maxLength, maxIndices];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    if n <= 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the array\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line2.trim(), \" \");\n    int[] arr = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int num = check 'int:fromString(trimmedPart);\n            arr.push(num);\n        }\n    }\n    \n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    int length = result[0];\n    int[] indices = result[1];\n    \n    // Output\n    io:println(length.toString());\n    \n    string output = \"\";\n    foreach int idx in indices {\n        output += idx.toString() + \" \";\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testConsecutiveSubsequence1() {\n    int[] arr = [3, 3, 4, 7, 5, 6, 8];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 4);\n    // Should be one of the valid sequences with length 4\n    test:assertTrue(result[1].length() == 4);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence2() {\n    int[] arr = [1, 3, 5, 2, 4, 6];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 2);\n    test:assertTrue(result[1].length() == 2);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence3() {\n    int[] arr = [10, 9, 8, 7];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1].length(), 1);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence4() {\n    int[] arr = [6, 7, 8, 3, 4, 5, 9, 10, 11];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 6);\n    test:assertEquals(result[1].length(), 6);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequenceEmpty() {\n    int[] arr = [];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1].length(), 0);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequenceSingle() {\n    int[] arr = [42];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1][0], 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - For each number 'n' in the array, check if we've seen 'n-1' before\n// - If 'n-1' exists in our map, extend that sequence by appending current index\n// - If not, start a new sequence with just this number\n// - Track the maximum length sequence found\n// - Use a map where key is the integer value and value is sequence info\n// - Need to handle duplicate values properly - only extend if we can form consecutive sequence\n// - Return 1-indexed positions\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype SequenceInfo record {\n    int length;\n    int[] indices;\n};\n\nfunction findConsecutiveSubsequence(int[] arr) returns [int, int[]] {\n    int n = arr.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Map from value to sequence info (length and indices ending at that value)\n    map<SequenceInfo> sequences = {};\n    \n    int maxLength = 1;\n    int[] maxIndices = [1];\n    \n    int i = 0;\n    while i < n {\n        int value = arr[i];\n        int index = i + 1; // 1-indexed\n        \n        // Check if we can extend a sequence ending at (value - 1)\n        int prevValue = value - 1;\n        string prevKey = prevValue.toString();\n        string currentKey = value.toString();\n        \n        if sequences.hasKey(prevKey) {\n            SequenceInfo? prevSeq = sequences[prevKey];\n            if prevSeq is SequenceInfo {\n                // Extend the previous sequence\n                int newLength = prevSeq.length + 1;\n                int[] newIndices = [...prevSeq.indices, index];\n                \n                SequenceInfo newSeq = {\n                    length: newLength,\n                    indices: newIndices\n                };\n                \n                // Only update if this value doesn't have a sequence or current is better\n                if !sequences.hasKey(currentKey) {\n                    sequences[currentKey] = newSeq;\n                } else {\n                    SequenceInfo? existingSeq = sequences[currentKey];\n                    if existingSeq is SequenceInfo {\n                        if newLength > existingSeq.length {\n                            sequences[currentKey] = newSeq;\n                        }\n                    }\n                }\n                \n                // Update max if needed\n                if newLength > maxLength {\n                    maxLength = newLength;\n                    maxIndices = newIndices;\n                }\n            }\n        } else {\n            // Start a new sequence with this value if not exists or keep existing\n            if !sequences.hasKey(currentKey) {\n                SequenceInfo newSeq = {\n                    length: 1,\n                    indices: [index]\n                };\n                sequences[currentKey] = newSeq;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return [maxLength, maxIndices];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    if n <= 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the array\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line2.trim(), \" \");\n    int[] arr = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int num = check 'int:fromString(trimmedPart);\n            arr.push(num);\n        }\n    }\n    \n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    int length = result[0];\n    int[] indices = result[1];\n    \n    // Output\n    io:println(length.toString());\n    \n    string output = \"\";\n    foreach int idx in indices {\n        output += idx.toString() + \" \";\n    }\n    io:println(output);\n}",
  "tests_passed": 3,
  "tests_total": 4,
  "tests_pass_rate": 0.75,
  "validation_msg": "Passed 3/4 tests (75.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:59:05.991341",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the longest subsequence of consecutive integers in an array. We need to track which elements can form consecutive sequences and return the maximum length sequence along with the indices (1-indexed) of the elements forming that sequence.\n\nThe approach:\n1. Use a map to track the length of consecutive sequences ending at each value\n2. Also track the starting value and indices for each sequence\n3. For each element, check if (element-1) exists in our map to extend that sequence\n4. Keep track of the maximum length sequence found\n5. Return the length and indices (1-indexed)\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We need to find the longest subsequence that forms consecutive integers [x, x+1, x+2, ...]\n// - Key insight: For each number 'n', check if 'n-1' was already processed\n// - If 'n-1' exists, we can extend that sequence by adding 'n'\n// - Use a map to store: for each value, what's the length of sequence ending at that value\n// - Also track the indices that form each sequence\n// - After processing all elements, find which sequence has maximum length\n\nimport ballerina/io;\n\ntype SequenceInfo record {\n    int length;\n    int[] indices;\n};\n\nfunction findConsecutiveSubsequence(int[] arr) returns [int, int[]] {\n    int n = arr.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Map from value to sequence info (length and indices ending at that value)\n    map<SequenceInfo> sequences = {};\n    \n    int maxLength = 1;\n    int[] maxIndices = [1];\n    \n    int i = 0;\n    while i < n {\n        int value = arr[i];\n        int index = i + 1; // 1-indexed\n        \n        // Check if we can extend a sequence ending at (value - 1)\n        int prevValue = value - 1;\n        \n        if sequences.hasKey(prevValue.toString()) {\n            SequenceInfo? prevSeq = sequences[prevValue.toString()];\n            if prevSeq is SequenceInfo {\n                // Extend the previous sequence\n                int newLength = prevSeq.length + 1;\n                int[] newIndices = [...prevSeq.indices, index];\n                \n                SequenceInfo newSeq = {\n                    length: newLength,\n                    indices: newIndices\n                };\n                sequences[value.toString()] = newSeq;\n                \n                // Update max if needed\n                if newLength > maxLength {\n                    maxLength = newLength;\n                    maxIndices = newIndices;\n                }\n            }\n        } else {\n            // Start a new sequence with this value\n            SequenceInfo newSeq = {\n                length: 1,\n                indices: [index]\n            };\n            sequences[value.toString()] = newSeq;\n        }\n        \n        i += 1;\n    }\n    \n    return [maxLength, maxIndices];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    if n <= 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the array\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    int[] arr = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int num = check 'int:fromString(part.trim());\n            arr.push(num);\n        }\n    }\n    \n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    int length = result[0];\n    int[] indices = result[1];\n    \n    // Output\n    io:println(length.toString());\n    \n    string output = \"\";\n    foreach int idx in indices {\n        output += idx.toString() + \" \";\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testConsecutiveSubsequence1() {\n    int[] arr = [3, 3, 4, 7, 5, 6, 8];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 4);\n    // Should be one of the valid sequences with length 4\n    test:assertTrue(result[1].length() == 4);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence2() {\n    int[] arr = [1, 3, 5, 2, 4, 6];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 2);\n    test:assertTrue(result[1].length() == 2);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence3() {\n    int[] arr = [10, 9, 8, 7];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1].length(), 1);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence4() {\n    int[] arr = [6, 7, 8, 3, 4, 5, 9, 10, 11];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 6);\n    test:assertEquals(result[1].length(), 6);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequenceEmpty() {\n    int[] arr = [];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1].length(), 0);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequenceSingle() {\n    int[] arr = [42];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1][0], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We need to find the longest subsequence that forms consecutive integers [x, x+1, x+2, ...]\n// - Key insight: For each number 'n', check if 'n-1' was already processed\n// - If 'n-1' exists, we can extend that sequence by adding 'n'\n// - Use a map to store: for each value, what's the length of sequence ending at that value\n// - Also track the indices that form each sequence\n// - After processing all elements, find which sequence has maximum length\n\nimport ballerina/io;\n\ntype SequenceInfo record {\n    int length;\n    int[] indices;\n};\n\nfunction findConsecutiveSubsequence(int[] arr) returns [int, int[]] {\n    int n = arr.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Map from value to sequence info (length and indices ending at that value)\n    map<SequenceInfo> sequences = {};\n    \n    int maxLength = 1;\n    int[] maxIndices = [1];\n    \n    int i = 0;\n    while i < n {\n        int value = arr[i];\n        int index = i + 1; // 1-indexed\n        \n        // Check if we can extend a sequence ending at (value - 1)\n        int prevValue = value - 1;\n        \n        if sequences.hasKey(prevValue.toString()) {\n            SequenceInfo? prevSeq = sequences[prevValue.toString()];\n            if prevSeq is SequenceInfo {\n                // Extend the previous sequence\n                int newLength = prevSeq.length + 1;\n                int[] newIndices = [...prevSeq.indices, index];\n                \n                SequenceInfo newSeq = {\n                    length: newLength,\n                    indices: newIndices\n                };\n                sequences[value.toString()] = newSeq;\n                \n                // Update max if needed\n                if newLength > maxLength {\n                    maxLength = newLength;\n                    maxIndices = newIndices;\n                }\n            }\n        } else {\n            // Start a new sequence with this value\n            SequenceInfo newSeq = {\n                length: 1,\n                indices: [index]\n            };\n            sequences[value.toString()] = newSeq;\n        }\n        \n        i += 1;\n    }\n    \n    return [maxLength, maxIndices];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    if n <= 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the array\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    int[] arr = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int num = check 'int:fromString(part.trim());\n            arr.push(num);\n        }\n    }\n    \n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    int length = result[0];\n    int[] indices = result[1];\n    \n    // Output\n    io:println(length.toString());\n    \n    string output = \"\";\n    foreach int idx in indices {\n        output += idx.toString() + \" \";\n    }\n    io:println(output);\n}",
      "tests_passed": 0,
      "tests_total": 4,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(92:35,92:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(92:35,92:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(92:35,92:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:59:32.746431",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to find the longest subsequence of consecutive integers in an array. The key insight is to use a map to track consecutive sequences - for each value, we check if (value-1) exists to extend that sequence. We track the length and indices of sequences ending at each value, then return the maximum length sequence with 1-indexed positions.\n\nThe main issue in the previous code was using `split()` which doesn't exist in Ballerina's string type. We need to use `string:split()` from the standard library or use regex functions.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For each number 'n' in the array, check if we've seen 'n-1' before\n// - If 'n-1' exists in our map, extend that sequence by appending current index\n// - If not, start a new sequence with just this number\n// - Track the maximum length sequence found\n// - Use a map where key is the integer value and value is sequence info\n// - Need to handle duplicate values properly - only extend if we can form consecutive sequence\n// - Return 1-indexed positions\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype SequenceInfo record {\n    int length;\n    int[] indices;\n};\n\nfunction findConsecutiveSubsequence(int[] arr) returns [int, int[]] {\n    int n = arr.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Map from value to sequence info (length and indices ending at that value)\n    map<SequenceInfo> sequences = {};\n    \n    int maxLength = 1;\n    int[] maxIndices = [1];\n    \n    int i = 0;\n    while i < n {\n        int value = arr[i];\n        int index = i + 1; // 1-indexed\n        \n        // Check if we can extend a sequence ending at (value - 1)\n        int prevValue = value - 1;\n        string prevKey = prevValue.toString();\n        string currentKey = value.toString();\n        \n        if sequences.hasKey(prevKey) {\n            SequenceInfo? prevSeq = sequences[prevKey];\n            if prevSeq is SequenceInfo {\n                // Extend the previous sequence\n                int newLength = prevSeq.length + 1;\n                int[] newIndices = [...prevSeq.indices, index];\n                \n                SequenceInfo newSeq = {\n                    length: newLength,\n                    indices: newIndices\n                };\n                \n                // Only update if this value doesn't have a sequence or current is better\n                if !sequences.hasKey(currentKey) {\n                    sequences[currentKey] = newSeq;\n                } else {\n                    SequenceInfo? existingSeq = sequences[currentKey];\n                    if existingSeq is SequenceInfo {\n                        if newLength > existingSeq.length {\n                            sequences[currentKey] = newSeq;\n                        }\n                    }\n                }\n                \n                // Update max if needed\n                if newLength > maxLength {\n                    maxLength = newLength;\n                    maxIndices = newIndices;\n                }\n            }\n        } else {\n            // Start a new sequence with this value if not exists or keep existing\n            if !sequences.hasKey(currentKey) {\n                SequenceInfo newSeq = {\n                    length: 1,\n                    indices: [index]\n                };\n                sequences[currentKey] = newSeq;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return [maxLength, maxIndices];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    if n <= 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the array\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line2.trim(), \" \");\n    int[] arr = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int num = check 'int:fromString(trimmedPart);\n            arr.push(num);\n        }\n    }\n    \n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    int length = result[0];\n    int[] indices = result[1];\n    \n    // Output\n    io:println(length.toString());\n    \n    string output = \"\";\n    foreach int idx in indices {\n        output += idx.toString() + \" \";\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testConsecutiveSubsequence1() {\n    int[] arr = [3, 3, 4, 7, 5, 6, 8];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 4);\n    // Should be one of the valid sequences with length 4\n    test:assertTrue(result[1].length() == 4);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence2() {\n    int[] arr = [1, 3, 5, 2, 4, 6];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 2);\n    test:assertTrue(result[1].length() == 2);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence3() {\n    int[] arr = [10, 9, 8, 7];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1].length(), 1);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequence4() {\n    int[] arr = [6, 7, 8, 3, 4, 5, 9, 10, 11];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 6);\n    test:assertEquals(result[1].length(), 6);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequenceEmpty() {\n    int[] arr = [];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1].length(), 0);\n}\n\n@test:Config {}\nfunction testConsecutiveSubsequenceSingle() {\n    int[] arr = [42];\n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1][0], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - For each number 'n' in the array, check if we've seen 'n-1' before\n// - If 'n-1' exists in our map, extend that sequence by appending current index\n// - If not, start a new sequence with just this number\n// - Track the maximum length sequence found\n// - Use a map where key is the integer value and value is sequence info\n// - Need to handle duplicate values properly - only extend if we can form consecutive sequence\n// - Return 1-indexed positions\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype SequenceInfo record {\n    int length;\n    int[] indices;\n};\n\nfunction findConsecutiveSubsequence(int[] arr) returns [int, int[]] {\n    int n = arr.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Map from value to sequence info (length and indices ending at that value)\n    map<SequenceInfo> sequences = {};\n    \n    int maxLength = 1;\n    int[] maxIndices = [1];\n    \n    int i = 0;\n    while i < n {\n        int value = arr[i];\n        int index = i + 1; // 1-indexed\n        \n        // Check if we can extend a sequence ending at (value - 1)\n        int prevValue = value - 1;\n        string prevKey = prevValue.toString();\n        string currentKey = value.toString();\n        \n        if sequences.hasKey(prevKey) {\n            SequenceInfo? prevSeq = sequences[prevKey];\n            if prevSeq is SequenceInfo {\n                // Extend the previous sequence\n                int newLength = prevSeq.length + 1;\n                int[] newIndices = [...prevSeq.indices, index];\n                \n                SequenceInfo newSeq = {\n                    length: newLength,\n                    indices: newIndices\n                };\n                \n                // Only update if this value doesn't have a sequence or current is better\n                if !sequences.hasKey(currentKey) {\n                    sequences[currentKey] = newSeq;\n                } else {\n                    SequenceInfo? existingSeq = sequences[currentKey];\n                    if existingSeq is SequenceInfo {\n                        if newLength > existingSeq.length {\n                            sequences[currentKey] = newSeq;\n                        }\n                    }\n                }\n                \n                // Update max if needed\n                if newLength > maxLength {\n                    maxLength = newLength;\n                    maxIndices = newIndices;\n                }\n            }\n        } else {\n            // Start a new sequence with this value if not exists or keep existing\n            if !sequences.hasKey(currentKey) {\n                SequenceInfo newSeq = {\n                    length: 1,\n                    indices: [index]\n                };\n                sequences[currentKey] = newSeq;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return [maxLength, maxIndices];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    if n <= 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the array\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line2.trim(), \" \");\n    int[] arr = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int num = check 'int:fromString(trimmedPart);\n            arr.push(num);\n        }\n    }\n    \n    [int, int[]] result = findConsecutiveSubsequence(arr);\n    int length = result[0];\n    int[] indices = result[1];\n    \n    // Output\n    io:println(length.toString());\n    \n    string output = \"\";\n    foreach int idx in indices {\n        output += idx.toString() + \" \";\n    }\n    io:println(output);\n}",
      "tests_passed": 3,
      "tests_total": 4,
      "tests_pass_rate": 0.75,
      "validation_msg": "Passed 3/4 tests (75.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T02:00:12.504523"
}