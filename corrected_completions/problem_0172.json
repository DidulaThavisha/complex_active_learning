{
  "entry_id": "problem_0172",
  "problem_index": 172,
  "prompt": "Title: Travel Card\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nA new innovative ticketing systems for public transport is introduced in Bytesburg. Now there is a single travel card for all transport. To make a trip a passenger scan his card and then he is charged according to the fare.\n\nThe fare is constructed in the following manner. There are three types of tickets: \n 1.  a ticket for one trip costs 20 byteland rubles, 1.  a ticket for 90 minutes costs 50 byteland rubles, 1.  a ticket for one day (1440 minutes) costs 120 byteland rubles. \nNote that a ticket for *x* minutes activated at time *t* can be used for trips started in time range from *t* to *t*<=+<=*x*<=-<=1, inclusive. Assume that all trips take exactly one minute.\n\nTo simplify the choice for the passenger, the system automatically chooses the optimal tickets. After each trip starts, the system analyses all the previous trips and the current trip and chooses a set of tickets for these trips with a minimum total cost. Let the minimum total cost of tickets to cover all trips from the first to the current is *a*, and the total sum charged before is *b*. Then the system charges the passenger the sum *a*<=-<=*b*.\n\nYou have to write a program that, for given trips made by a passenger, calculates the sum the passenger is charged after each trip.\n\nInput Specification:\nThe first line of input contains integer number *n* (1<=≤<=*n*<=≤<=105) — the number of trips made by passenger.\n\nEach of the following *n* lines contains the time of trip *t**i* (0<=≤<=*t**i*<=≤<=109), measured in minutes from the time of starting the system. All *t**i* are different, given in ascending order, i. e. *t**i*<=+<=1<=&gt;<=*t**i* holds for all 1<=≤<=*i*<=&lt;<=*n*.\n\nOutput Specification:\nOutput *n* integers. For each trip, print the sum the passenger is charged after it.\n\nDemo Input:\n['3\\n10\\n20\\n30\\n', '10\\n13\\n45\\n46\\n60\\n103\\n115\\n126\\n150\\n256\\n516\\n']\n\nDemo Output:\n['20\\n20\\n10\\n', '20\\n20\\n10\\n0\\n20\\n0\\n0\\n20\\n20\\n10\\n']\n\nNote:\nIn the first example, the system works as follows: for the first and second trips it is cheaper to pay for two one-trip tickets, so each time 20 rubles is charged, after the third trip the system understands that it would be cheaper to buy a ticket for 90 minutes. This ticket costs 50 rubles, and the passenger had already paid 40 rubles, so it is necessary to charge 10 rubles only.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem requires finding the minimum cost to cover all trips from the beginning up to each trip, using dynamic programming. For each trip, we calculate the minimum cost by considering three options: buying a single-trip ticket (20), a 90-minute ticket (50), or a 1-day ticket (120). We track the cumulative minimum cost and output the incremental charge after each trip.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For each trip i at time t[i], we need to find the minimum cost to cover trips 0..i\n// - We use dynamic programming where dp[i] = minimum cost to cover first i+1 trips\n// - For each trip, we consider three options:\n//   1. Buy a single trip ticket (cost 20) - covers only this trip\n//   2. Buy a 90-minute ticket (cost 50) - covers all trips in [t[i]-89, t[i]]\n//   3. Buy a 1440-minute ticket (cost 120) - covers all trips in [t[i]-1439, t[i]]\n// - For options 2 and 3, find the earliest trip covered by that ticket\n// - dp[i] = min(dp[i-1] + 20, dp[j-1] + 50, dp[k-1] + 120) where j and k are boundaries\n// - After each trip, output the incremental charge (dp[i] - dp[i-1])\n\nimport ballerina/io;\n\nfunction calculateCharges(int[] tripTimes) returns int[] {\n    int n = tripTimes.length();\n    if n == 0 {\n        return [];\n    }\n    \n    // dp[i] represents minimum cost to cover trips 0 to i (inclusive)\n    int[] dp = [];\n    int[] charges = [];\n    \n    foreach int i in 0 ..< n {\n        int currentTime = tripTimes[i];\n        \n        // Option 1: Buy single trip ticket (20 rubles)\n        int prevCost = i == 0 ? 0 : dp[i - 1];\n        int minCost = prevCost + 20;\n        \n        // Option 2: Buy 90-minute ticket (50 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 89) to currentTime\n        int startTime90 = currentTime - 89;\n        int j = i;\n        while j > 0 && tripTimes[j - 1] >= startTime90 {\n            j -= 1;\n        }\n        int costBefore90 = j == 0 ? 0 : dp[j - 1];\n        int cost90 = costBefore90 + 50;\n        if cost90 < minCost {\n            minCost = cost90;\n        }\n        \n        // Option 3: Buy 1440-minute ticket (120 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 1439) to currentTime\n        int startTime1440 = currentTime - 1439;\n        int k = i;\n        while k > 0 && tripTimes[k - 1] >= startTime1440 {\n            k -= 1;\n        }\n        int costBefore1440 = k == 0 ? 0 : dp[k - 1];\n        int cost1440 = costBefore1440 + 120;\n        if cost1440 < minCost {\n            minCost = cost1440;\n        }\n        \n        dp.push(minCost);\n        \n        // Calculate the charge for this trip\n        int charge = minCost - prevCost;\n        charges.push(charge);\n    }\n    \n    return charges;\n}\n\npublic function main() returns error? {\n    // Read number of trips\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of trips\");\n    }\n    \n    int|error nResult = 'int:fromString(nLine.trim());\n    if nResult is error {\n        return error(\"Invalid number of trips\");\n    }\n    \n    int n = nResult;\n    if n <= 0 {\n        return;\n    }\n    \n    // Read trip times\n    int[] tripTimes = [];\n    foreach int i in 0 ..< n {\n        string? timeLine = io:readln();\n        if timeLine is () {\n            return error(\"Failed to read trip time\");\n        }\n        \n        int|error timeResult = 'int:fromString(timeLine.trim());\n        if timeResult is error {\n            return error(\"Invalid trip time\");\n        }\n        \n        tripTimes.push(timeResult);\n    }\n    \n    // Calculate and output charges\n    int[] charges = calculateCharges(tripTimes);\n    foreach int charge in charges {\n        io:println(charge);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] tripTimes = [10, 20, 30];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 3);\n    test:assertEquals(charges[0], 20);\n    test:assertEquals(charges[1], 20);\n    test:assertEquals(charges[2], 10);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] tripTimes = [13, 45, 46, 60, 103, 115, 126, 150, 256, 516];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 10);\n    test:assertEquals(charges[0], 20);\n    test:assertEquals(charges[1], 20);\n    test:assertEquals(charges[2], 10);\n    test:assertEquals(charges[3], 0);\n}\n\n@test:Config {}\nfunction testSingleTrip() {\n    int[] tripTimes = [100];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 1);\n    test:assertEquals(charges[0], 20);\n}\n\n@test:Config {}\nfunction testDailyTicketOptimal() {\n    // Trips within 1440 minutes, enough to make daily ticket optimal\n    int[] tripTimes = [0, 100, 200, 300, 400, 500, 600];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 7);\n    // First trip costs 20\n    test:assertEquals(charges[0], 20);\n    // Eventually the daily ticket (120) becomes cheaper than multiple single tickets\n    int total = 0;\n    foreach int charge in charges {\n        total += charge;\n    }\n    test:assertEquals(total, 120); // Should be exactly 120 for daily ticket\n}\n\n@test:Config {}\nfunction testEmptyTrips() {\n    int[] tripTimes = [];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 0);\n}\n\n@test:Config {}\nfunction testFarApartTrips() {\n    // Trips far apart, each needs separate single ticket\n    int[] tripTimes = [0, 2000, 4000];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 3);\n    test:assertEquals(charges[0], 20);\n    test:assertEquals(charges[1], 20);\n    test:assertEquals(charges[2], 20);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - For each trip i at time t[i], we need to find the minimum cost to cover trips 0..i\n// - We use dynamic programming where dp[i] = minimum cost to cover first i+1 trips\n// - For each trip, we consider three options:\n//   1. Buy a single trip ticket (cost 20) - covers only this trip\n//   2. Buy a 90-minute ticket (cost 50) - covers all trips in [t[i]-89, t[i]]\n//   3. Buy a 1440-minute ticket (cost 120) - covers all trips in [t[i]-1439, t[i]]\n// - For options 2 and 3, find the earliest trip covered by that ticket\n// - dp[i] = min(dp[i-1] + 20, dp[j-1] + 50, dp[k-1] + 120) where j and k are boundaries\n// - After each trip, output the incremental charge (dp[i] - dp[i-1])\n\nimport ballerina/io;\n\nfunction calculateCharges(int[] tripTimes) returns int[] {\n    int n = tripTimes.length();\n    if n == 0 {\n        return [];\n    }\n    \n    // dp[i] represents minimum cost to cover trips 0 to i (inclusive)\n    int[] dp = [];\n    int[] charges = [];\n    \n    foreach int i in 0 ..< n {\n        int currentTime = tripTimes[i];\n        \n        // Option 1: Buy single trip ticket (20 rubles)\n        int prevCost = i == 0 ? 0 : dp[i - 1];\n        int minCost = prevCost + 20;\n        \n        // Option 2: Buy 90-minute ticket (50 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 89) to currentTime\n        int startTime90 = currentTime - 89;\n        int j = i;\n        while j > 0 && tripTimes[j - 1] >= startTime90 {\n            j -= 1;\n        }\n        int costBefore90 = j == 0 ? 0 : dp[j - 1];\n        int cost90 = costBefore90 + 50;\n        if cost90 < minCost {\n            minCost = cost90;\n        }\n        \n        // Option 3: Buy 1440-minute ticket (120 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 1439) to currentTime\n        int startTime1440 = currentTime - 1439;\n        int k = i;\n        while k > 0 && tripTimes[k - 1] >= startTime1440 {\n            k -= 1;\n        }\n        int costBefore1440 = k == 0 ? 0 : dp[k - 1];\n        int cost1440 = costBefore1440 + 120;\n        if cost1440 < minCost {\n            minCost = cost1440;\n        }\n        \n        dp.push(minCost);\n        \n        // Calculate the charge for this trip\n        int charge = minCost - prevCost;\n        charges.push(charge);\n    }\n    \n    return charges;\n}\n\npublic function main() returns error? {\n    // Read number of trips\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of trips\");\n    }\n    \n    int|error nResult = 'int:fromString(nLine.trim());\n    if nResult is error {\n        return error(\"Invalid number of trips\");\n    }\n    \n    int n = nResult;\n    if n <= 0 {\n        return;\n    }\n    \n    // Read trip times\n    int[] tripTimes = [];\n    foreach int i in 0 ..< n {\n        string? timeLine = io:readln();\n        if timeLine is () {\n            return error(\"Failed to read trip time\");\n        }\n        \n        int|error timeResult = 'int:fromString(timeLine.trim());\n        if timeResult is error {\n            return error(\"Invalid trip time\");\n        }\n        \n        tripTimes.push(timeResult);\n    }\n    \n    // Calculate and output charges\n    int[] charges = calculateCharges(tripTimes);\n    foreach int charge in charges {\n        io:println(charge);\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:59:48.478473",
      "status": "success",
      "completion": "# Overview\nThis problem requires finding the minimum cost to cover all trips from the beginning up to each trip, using dynamic programming. For each trip, we calculate the minimum cost by considering three options: buying a single-trip ticket (20), a 90-minute ticket (50), or a 1-day ticket (120). We track the cumulative minimum cost and output the incremental charge after each trip.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For each trip i at time t[i], we need to find the minimum cost to cover trips 0..i\n// - We use dynamic programming where dp[i] = minimum cost to cover first i+1 trips\n// - For each trip, we consider three options:\n//   1. Buy a single trip ticket (cost 20) - covers only this trip\n//   2. Buy a 90-minute ticket (cost 50) - covers all trips in [t[i]-89, t[i]]\n//   3. Buy a 1440-minute ticket (cost 120) - covers all trips in [t[i]-1439, t[i]]\n// - For options 2 and 3, find the earliest trip covered by that ticket\n// - dp[i] = min(dp[i-1] + 20, dp[j-1] + 50, dp[k-1] + 120) where j and k are boundaries\n// - After each trip, output the incremental charge (dp[i] - dp[i-1])\n\nimport ballerina/io;\n\nfunction calculateCharges(int[] tripTimes) returns int[] {\n    int n = tripTimes.length();\n    if n == 0 {\n        return [];\n    }\n    \n    // dp[i] represents minimum cost to cover trips 0 to i (inclusive)\n    int[] dp = [];\n    int[] charges = [];\n    \n    foreach int i in 0 ..< n {\n        int currentTime = tripTimes[i];\n        \n        // Option 1: Buy single trip ticket (20 rubles)\n        int prevCost = i == 0 ? 0 : dp[i - 1];\n        int minCost = prevCost + 20;\n        \n        // Option 2: Buy 90-minute ticket (50 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 89) to currentTime\n        int startTime90 = currentTime - 89;\n        int j = i;\n        while j > 0 && tripTimes[j - 1] >= startTime90 {\n            j -= 1;\n        }\n        int costBefore90 = j == 0 ? 0 : dp[j - 1];\n        int cost90 = costBefore90 + 50;\n        if cost90 < minCost {\n            minCost = cost90;\n        }\n        \n        // Option 3: Buy 1440-minute ticket (120 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 1439) to currentTime\n        int startTime1440 = currentTime - 1439;\n        int k = i;\n        while k > 0 && tripTimes[k - 1] >= startTime1440 {\n            k -= 1;\n        }\n        int costBefore1440 = k == 0 ? 0 : dp[k - 1];\n        int cost1440 = costBefore1440 + 120;\n        if cost1440 < minCost {\n            minCost = cost1440;\n        }\n        \n        dp.push(minCost);\n        \n        // Calculate the charge for this trip\n        int charge = minCost - prevCost;\n        charges.push(charge);\n    }\n    \n    return charges;\n}\n\npublic function main() returns error? {\n    // Read number of trips\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of trips\");\n    }\n    \n    int|error nResult = 'int:fromString(nLine.trim());\n    if nResult is error {\n        return error(\"Invalid number of trips\");\n    }\n    \n    int n = nResult;\n    if n <= 0 {\n        return;\n    }\n    \n    // Read trip times\n    int[] tripTimes = [];\n    foreach int i in 0 ..< n {\n        string? timeLine = io:readln();\n        if timeLine is () {\n            return error(\"Failed to read trip time\");\n        }\n        \n        int|error timeResult = 'int:fromString(timeLine.trim());\n        if timeResult is error {\n            return error(\"Invalid trip time\");\n        }\n        \n        tripTimes.push(timeResult);\n    }\n    \n    // Calculate and output charges\n    int[] charges = calculateCharges(tripTimes);\n    foreach int charge in charges {\n        io:println(charge);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] tripTimes = [10, 20, 30];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 3);\n    test:assertEquals(charges[0], 20);\n    test:assertEquals(charges[1], 20);\n    test:assertEquals(charges[2], 10);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] tripTimes = [13, 45, 46, 60, 103, 115, 126, 150, 256, 516];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 10);\n    test:assertEquals(charges[0], 20);\n    test:assertEquals(charges[1], 20);\n    test:assertEquals(charges[2], 10);\n    test:assertEquals(charges[3], 0);\n}\n\n@test:Config {}\nfunction testSingleTrip() {\n    int[] tripTimes = [100];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 1);\n    test:assertEquals(charges[0], 20);\n}\n\n@test:Config {}\nfunction testDailyTicketOptimal() {\n    // Trips within 1440 minutes, enough to make daily ticket optimal\n    int[] tripTimes = [0, 100, 200, 300, 400, 500, 600];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 7);\n    // First trip costs 20\n    test:assertEquals(charges[0], 20);\n    // Eventually the daily ticket (120) becomes cheaper than multiple single tickets\n    int total = 0;\n    foreach int charge in charges {\n        total += charge;\n    }\n    test:assertEquals(total, 120); // Should be exactly 120 for daily ticket\n}\n\n@test:Config {}\nfunction testEmptyTrips() {\n    int[] tripTimes = [];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 0);\n}\n\n@test:Config {}\nfunction testFarApartTrips() {\n    // Trips far apart, each needs separate single ticket\n    int[] tripTimes = [0, 2000, 4000];\n    int[] charges = calculateCharges(tripTimes);\n    test:assertEquals(charges.length(), 3);\n    test:assertEquals(charges[0], 20);\n    test:assertEquals(charges[1], 20);\n    test:assertEquals(charges[2], 20);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - For each trip i at time t[i], we need to find the minimum cost to cover trips 0..i\n// - We use dynamic programming where dp[i] = minimum cost to cover first i+1 trips\n// - For each trip, we consider three options:\n//   1. Buy a single trip ticket (cost 20) - covers only this trip\n//   2. Buy a 90-minute ticket (cost 50) - covers all trips in [t[i]-89, t[i]]\n//   3. Buy a 1440-minute ticket (cost 120) - covers all trips in [t[i]-1439, t[i]]\n// - For options 2 and 3, find the earliest trip covered by that ticket\n// - dp[i] = min(dp[i-1] + 20, dp[j-1] + 50, dp[k-1] + 120) where j and k are boundaries\n// - After each trip, output the incremental charge (dp[i] - dp[i-1])\n\nimport ballerina/io;\n\nfunction calculateCharges(int[] tripTimes) returns int[] {\n    int n = tripTimes.length();\n    if n == 0 {\n        return [];\n    }\n    \n    // dp[i] represents minimum cost to cover trips 0 to i (inclusive)\n    int[] dp = [];\n    int[] charges = [];\n    \n    foreach int i in 0 ..< n {\n        int currentTime = tripTimes[i];\n        \n        // Option 1: Buy single trip ticket (20 rubles)\n        int prevCost = i == 0 ? 0 : dp[i - 1];\n        int minCost = prevCost + 20;\n        \n        // Option 2: Buy 90-minute ticket (50 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 89) to currentTime\n        int startTime90 = currentTime - 89;\n        int j = i;\n        while j > 0 && tripTimes[j - 1] >= startTime90 {\n            j -= 1;\n        }\n        int costBefore90 = j == 0 ? 0 : dp[j - 1];\n        int cost90 = costBefore90 + 50;\n        if cost90 < minCost {\n            minCost = cost90;\n        }\n        \n        // Option 3: Buy 1440-minute ticket (120 rubles)\n        // This ticket activated at currentTime covers trips from (currentTime - 1439) to currentTime\n        int startTime1440 = currentTime - 1439;\n        int k = i;\n        while k > 0 && tripTimes[k - 1] >= startTime1440 {\n            k -= 1;\n        }\n        int costBefore1440 = k == 0 ? 0 : dp[k - 1];\n        int cost1440 = costBefore1440 + 120;\n        if cost1440 < minCost {\n            minCost = cost1440;\n        }\n        \n        dp.push(minCost);\n        \n        // Calculate the charge for this trip\n        int charge = minCost - prevCost;\n        charges.push(charge);\n    }\n    \n    return charges;\n}\n\npublic function main() returns error? {\n    // Read number of trips\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of trips\");\n    }\n    \n    int|error nResult = 'int:fromString(nLine.trim());\n    if nResult is error {\n        return error(\"Invalid number of trips\");\n    }\n    \n    int n = nResult;\n    if n <= 0 {\n        return;\n    }\n    \n    // Read trip times\n    int[] tripTimes = [];\n    foreach int i in 0 ..< n {\n        string? timeLine = io:readln();\n        if timeLine is () {\n            return error(\"Failed to read trip time\");\n        }\n        \n        int|error timeResult = 'int:fromString(timeLine.trim());\n        if timeResult is error {\n            return error(\"Invalid trip time\");\n        }\n        \n        tripTimes.push(timeResult);\n    }\n    \n    // Calculate and output charges\n    int[] charges = calculateCharges(tripTimes);\n    foreach int charge in charges {\n        io:println(charge);\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T03:00:25.833954"
}