{
  "entry_id": "problem_0044",
  "problem_index": 44,
  "prompt": "Title: Thor\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nThor is getting used to the Earth. As a gift Loki gave him a smartphone. There are *n* applications on this phone. Thor is fascinated by this phone. He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).\n\n*q* events are about to happen (in chronological order). They are of three types:\n 1.  Application *x* generates a notification (this new notification is unread). 1.  Thor reads all notifications generated so far by application *x* (he may re-read some notifications). 1.  Thor reads the first *t* notifications generated by phone applications (notifications generated in first *t* events of the first type). It's guaranteed that there were at least *t* events of the first type before this event. Please note that he doesn't read first *t* unread notifications, he just reads the very first *t* notifications generated on his phone and he may re-read some of them in this operation. \nPlease help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.\n\nInput Specification:\nThe first line of input contains two integers *n* and *q* (1<=≤<=*n*,<=*q*<=≤<=300<=000) — the number of applications and the number of events to happen.\n\nThe next *q* lines contain the events. The *i*-th of these lines starts with an integer *type**i* — type of the *i*-th event. If *type**i*<==<=1 or *type**i*<==<=2 then it is followed by an integer *x**i*. Otherwise it is followed by an integer *t**i* (1<=≤<=*type**i*<=≤<=3,<=1<=≤<=*x**i*<=≤<=*n*,<=1<=≤<=*t**i*<=≤<=*q*).\n\nOutput Specification:\nPrint the number of unread notifications after each event.\n\nDemo Input:\n['3 4\\n1 3\\n1 1\\n1 2\\n2 3\\n', '4 6\\n1 2\\n1 4\\n1 2\\n3 3\\n1 3\\n1 3\\n']\n\nDemo Output:\n['1\\n2\\n3\\n2\\n', '1\\n2\\n3\\n0\\n1\\n2\\n']\n\nNote:\nIn the first sample:\n 1.  Application 3 generates a notification (there is 1 unread notification). 1.  Application 1 generates a notification (there are 2 unread notifications). 1.  Application 2 generates a notification (there are 3 unread notifications). 1.  Thor reads the notification generated by application 3, there are 2 unread notifications left. \nIn the second sample test:\n 1.  Application 2 generates a notification (there is 1 unread notification). 1.  Application 4 generates a notification (there are 2 unread notifications). 1.  Application 2 generates a notification (there are 3 unread notifications). 1.  Thor reads first three notifications and since there are only three of them so far, there will be no unread notification left. 1.  Application 3 generates a notification (there is 1 unread notification). 1.  Application 3 generates a notification (there are 2 unread notifications).",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the compilation errors, the issue is that `split` is not a built-in method on strings in Ballerina. I need to use the `regex` module from the standard library to split strings.\n\nLet me analyze the problem:\n1. We need to track notifications in chronological order\n2. Each notification has an app ID and read/unread status\n3. Type 1: Add notification (unread)\n4. Type 2: Mark all notifications from app x as read\n5. Type 3: Mark first t notifications (chronologically) as read\n6. Output unread count after each operation\n\nThe key insight is that we need to maintain the order of notifications and track their read status individually.\n\n# Overview\nThis solution tracks Thor's smartphone notifications. We maintain a list of notifications in chronological order, where each notification stores its app ID and read status. For each event, we either add a new notification, mark notifications from a specific app as read, or mark the first t notifications as read, then output the current unread count.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Store notifications as records with appId and isRead status\n// - Maintain notifications in a list to preserve chronological order\n// - Type 1: Add new unread notification, increment unread counter\n// - Type 2: Iterate through all notifications, mark those from app x as read\n// - Type 3: Mark first t notifications as read (may already be read)\n// - Track unread count separately for O(1) output\n// - Use regex:split from standard library for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Represents a single notification\ntype Notification record {\n    int appId;\n    boolean isRead;\n};\n\nfunction solveThorsNotifications(int n, int q, int[][] events) returns int[]|error {\n    Notification[] notifications = [];\n    int[] results = [];\n    int unreadCount = 0;\n    \n    foreach int[] event in events {\n        int eventType = event[0];\n        \n        if eventType == 1 {\n            // New notification from app x\n            int appId = event[1];\n            notifications.push({appId: appId, isRead: false});\n            unreadCount += 1;\n            results.push(unreadCount);\n        } else if eventType == 2 {\n            // Read all notifications from app x\n            int appId = event[1];\n            foreach int i in 0 ..< notifications.length() {\n                if notifications[i].appId == appId && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        } else if eventType == 3 {\n            // Read first t notifications\n            int t = event[1];\n            foreach int i in 0 ..< t {\n                if i < notifications.length() && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        }\n    }\n    \n    return results;\n}\n\npublic function main() returns error? {\n    // Read first line: n and q\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] firstParts = regex:split(firstLine.trim(), \" \");\n    if firstParts.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(firstParts[0]);\n    int q = check 'int:fromString(firstParts[1]);\n    \n    // Read q events\n    int[][] events = [];\n    foreach int i in 0 ..< q {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read event line\");\n        }\n        \n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() < 2 {\n            return error(\"Invalid event format\");\n        }\n        \n        int eventType = check 'int:fromString(parts[0]);\n        int value = check 'int:fromString(parts[1]);\n        \n        events.push([eventType, value]);\n    }\n    \n    // Solve and output results\n    int[] results = check solveThorsNotifications(n, q, events);\n    foreach int result in results {\n        io:println(result);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSample1() returns error? {\n    int[][] events = [\n        [1, 3],\n        [1, 1],\n        [1, 2],\n        [2, 3]\n    ];\n    \n    int[] result = check solveThorsNotifications(3, 4, events);\n    test:assertEquals(result, [1, 2, 3, 2]);\n}\n\n@test:Config {}\nfunction testSample2() returns error? {\n    int[][] events = [\n        [1, 2],\n        [1, 4],\n        [1, 2],\n        [3, 3],\n        [1, 3],\n        [1, 3]\n    ];\n    \n    int[] result = check solveThorsNotifications(4, 6, events);\n    test:assertEquals(result, [1, 2, 3, 0, 1, 2]);\n}\n\n@test:Config {}\nfunction testSingleNotification() returns error? {\n    int[][] events = [\n        [1, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(1, 1, events);\n    test:assertEquals(result, [1]);\n}\n\n@test:Config {}\nfunction testReadThenGenerate() returns error? {\n    int[][] events = [\n        [1, 1],\n        [2, 1],\n        [1, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(2, 3, events);\n    test:assertEquals(result, [1, 0, 1]);\n}\n\n@test:Config {}\nfunction testType3ReadFirst() returns error? {\n    int[][] events = [\n        [1, 1],\n        [1, 2],\n        [1, 3],\n        [3, 2]\n    ];\n    \n    int[] result = check solveThorsNotifications(3, 4, events);\n    test:assertEquals(result, [1, 2, 3, 1]);\n}\n\n@test:Config {}\nfunction testRereadNotifications() returns error? {\n    int[][] events = [\n        [1, 1],\n        [2, 1],\n        [2, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(1, 3, events);\n    test:assertEquals(result, [1, 0, 0]);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - Store notifications as records with appId and isRead status\n// - Maintain notifications in a list to preserve chronological order\n// - Type 1: Add new unread notification, increment unread counter\n// - Type 2: Iterate through all notifications, mark those from app x as read\n// - Type 3: Mark first t notifications as read (may already be read)\n// - Track unread count separately for O(1) output\n// - Use regex:split from standard library for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Represents a single notification\ntype Notification record {\n    int appId;\n    boolean isRead;\n};\n\nfunction solveThorsNotifications(int n, int q, int[][] events) returns int[]|error {\n    Notification[] notifications = [];\n    int[] results = [];\n    int unreadCount = 0;\n    \n    foreach int[] event in events {\n        int eventType = event[0];\n        \n        if eventType == 1 {\n            // New notification from app x\n            int appId = event[1];\n            notifications.push({appId: appId, isRead: false});\n            unreadCount += 1;\n            results.push(unreadCount);\n        } else if eventType == 2 {\n            // Read all notifications from app x\n            int appId = event[1];\n            foreach int i in 0 ..< notifications.length() {\n                if notifications[i].appId == appId && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        } else if eventType == 3 {\n            // Read first t notifications\n            int t = event[1];\n            foreach int i in 0 ..< t {\n                if i < notifications.length() && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        }\n    }\n    \n    return results;\n}\n\npublic function main() returns error? {\n    // Read first line: n and q\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] firstParts = regex:split(firstLine.trim(), \" \");\n    if firstParts.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(firstParts[0]);\n    int q = check 'int:fromString(firstParts[1]);\n    \n    // Read q events\n    int[][] events = [];\n    foreach int i in 0 ..< q {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read event line\");\n        }\n        \n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() < 2 {\n            return error(\"Invalid event format\");\n        }\n        \n        int eventType = check 'int:fromString(parts[0]);\n        int value = check 'int:fromString(parts[1]);\n        \n        events.push([eventType, value]);\n    }\n    \n    // Solve and output results\n    int[] results = check solveThorsNotifications(n, q, events);\n    foreach int result in results {\n        io:println(result);\n    }\n    \n    return;\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:42:24.136323",
      "status": "failed",
      "completion": "# Overview\nThis problem requires tracking notifications from multiple applications and handling three types of operations:\n1. Add a new notification from app x (unread)\n2. Mark all notifications from app x as read\n3. Mark the first t notifications (by generation order) as read\n\nWe need to track each notification's read/unread status and which app generated it, maintaining chronological order.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We need to track notifications in order of generation\n// - Each notification has: app_id, read status, and position in sequence\n// - Type 1: Add notification to list, increment unread count\n// - Type 2: Mark all notifications from app x as read, decrement unread count accordingly\n// - Type 3: Mark first t notifications as read (if not already), decrement unread count\n// - Use a list to store notifications with their metadata\n// - Track unread count separately for efficiency\n\nimport ballerina/io;\n\n// Represents a single notification\ntype Notification record {\n    int appId;\n    boolean isRead;\n};\n\nfunction solveThorsNotifications(int n, int q, int[][] events) returns int[]|error {\n    Notification[] notifications = [];\n    int[] results = [];\n    int unreadCount = 0;\n    \n    foreach int[] event in events {\n        int eventType = event[0];\n        \n        if eventType == 1 {\n            // New notification from app x\n            int appId = event[1];\n            notifications.push({appId: appId, isRead: false});\n            unreadCount += 1;\n            results.push(unreadCount);\n        } else if eventType == 2 {\n            // Read all notifications from app x\n            int appId = event[1];\n            foreach int i in 0 ..< notifications.length() {\n                if notifications[i].appId == appId && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        } else if eventType == 3 {\n            // Read first t notifications\n            int t = event[1];\n            foreach int i in 0 ..< t {\n                if i < notifications.length() && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        }\n    }\n    \n    return results;\n}\n\npublic function main() returns error? {\n    // Read first line: n and q\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] firstParts = firstLine.trim().split(\" \");\n    if firstParts.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(firstParts[0]);\n    int q = check 'int:fromString(firstParts[1]);\n    \n    // Read q events\n    int[][] events = [];\n    foreach int i in 0 ..< q {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read event line\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() < 2 {\n            return error(\"Invalid event format\");\n        }\n        \n        int eventType = check 'int:fromString(parts[0]);\n        int value = check 'int:fromString(parts[1]);\n        \n        events.push([eventType, value]);\n    }\n    \n    // Solve and output results\n    int[] results = check solveThorsNotifications(n, q, events);\n    foreach int result in results {\n        io:println(result);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSample1() returns error? {\n    int[][] events = [\n        [1, 3],\n        [1, 1],\n        [1, 2],\n        [2, 3]\n    ];\n    \n    int[] result = check solveThorsNotifications(3, 4, events);\n    test:assertEquals(result, [1, 2, 3, 2]);\n}\n\n@test:Config {}\nfunction testSample2() returns error? {\n    int[][] events = [\n        [1, 2],\n        [1, 4],\n        [1, 2],\n        [3, 3],\n        [1, 3],\n        [1, 3]\n    ];\n    \n    int[] result = check solveThorsNotifications(4, 6, events);\n    test:assertEquals(result, [1, 2, 3, 0, 1, 2]);\n}\n\n@test:Config {}\nfunction testSingleNotification() returns error? {\n    int[][] events = [\n        [1, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(1, 1, events);\n    test:assertEquals(result, [1]);\n}\n\n@test:Config {}\nfunction testReadThenGenerate() returns error? {\n    int[][] events = [\n        [1, 1],\n        [2, 1],\n        [1, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(2, 3, events);\n    test:assertEquals(result, [1, 0, 1]);\n}\n\n@test:Config {}\nfunction testType3ReadFirst() returns error? {\n    int[][] events = [\n        [1, 1],\n        [1, 2],\n        [1, 3],\n        [3, 2]\n    ];\n    \n    int[] result = check solveThorsNotifications(3, 4, events);\n    test:assertEquals(result, [1, 2, 3, 1]);\n}\n\n@test:Config {}\nfunction testRereadNotifications() returns error? {\n    int[][] events = [\n        [1, 1],\n        [2, 1],\n        [2, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(1, 3, events);\n    test:assertEquals(result, [1, 0, 0]);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We need to track notifications in order of generation\n// - Each notification has: app_id, read status, and position in sequence\n// - Type 1: Add notification to list, increment unread count\n// - Type 2: Mark all notifications from app x as read, decrement unread count accordingly\n// - Type 3: Mark first t notifications as read (if not already), decrement unread count\n// - Use a list to store notifications with their metadata\n// - Track unread count separately for efficiency\n\nimport ballerina/io;\n\n// Represents a single notification\ntype Notification record {\n    int appId;\n    boolean isRead;\n};\n\nfunction solveThorsNotifications(int n, int q, int[][] events) returns int[]|error {\n    Notification[] notifications = [];\n    int[] results = [];\n    int unreadCount = 0;\n    \n    foreach int[] event in events {\n        int eventType = event[0];\n        \n        if eventType == 1 {\n            // New notification from app x\n            int appId = event[1];\n            notifications.push({appId: appId, isRead: false});\n            unreadCount += 1;\n            results.push(unreadCount);\n        } else if eventType == 2 {\n            // Read all notifications from app x\n            int appId = event[1];\n            foreach int i in 0 ..< notifications.length() {\n                if notifications[i].appId == appId && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        } else if eventType == 3 {\n            // Read first t notifications\n            int t = event[1];\n            foreach int i in 0 ..< t {\n                if i < notifications.length() && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        }\n    }\n    \n    return results;\n}\n\npublic function main() returns error? {\n    // Read first line: n and q\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] firstParts = firstLine.trim().split(\" \");\n    if firstParts.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(firstParts[0]);\n    int q = check 'int:fromString(firstParts[1]);\n    \n    // Read q events\n    int[][] events = [];\n    foreach int i in 0 ..< q {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read event line\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() < 2 {\n            return error(\"Invalid event format\");\n        }\n        \n        int eventType = check 'int:fromString(parts[0]);\n        int value = check 'int:fromString(parts[1]);\n        \n        events.push([eventType, value]);\n    }\n    \n    // Solve and output results\n    int[] results = check solveThorsNotifications(n, q, events);\n    foreach int result in results {\n        io:println(result);\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(65:44,65:49)] undefined function 'split' in type 'string'\nERROR [main.bal:(81:38,81:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(65:44,65:49)] undefined function 'split' in type 'string'\nERROR [main.bal:(81:38,81:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(65:44,65:49)] undefined function 'split' in type 'string'\nERROR [main.bal:(81:38,81:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:42:48.747433",
      "status": "success",
      "completion": "Looking at the compilation errors, the issue is that `split` is not a built-in method on strings in Ballerina. I need to use the `regex` module from the standard library to split strings.\n\nLet me analyze the problem:\n1. We need to track notifications in chronological order\n2. Each notification has an app ID and read/unread status\n3. Type 1: Add notification (unread)\n4. Type 2: Mark all notifications from app x as read\n5. Type 3: Mark first t notifications (chronologically) as read\n6. Output unread count after each operation\n\nThe key insight is that we need to maintain the order of notifications and track their read status individually.\n\n# Overview\nThis solution tracks Thor's smartphone notifications. We maintain a list of notifications in chronological order, where each notification stores its app ID and read status. For each event, we either add a new notification, mark notifications from a specific app as read, or mark the first t notifications as read, then output the current unread count.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Store notifications as records with appId and isRead status\n// - Maintain notifications in a list to preserve chronological order\n// - Type 1: Add new unread notification, increment unread counter\n// - Type 2: Iterate through all notifications, mark those from app x as read\n// - Type 3: Mark first t notifications as read (may already be read)\n// - Track unread count separately for O(1) output\n// - Use regex:split from standard library for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Represents a single notification\ntype Notification record {\n    int appId;\n    boolean isRead;\n};\n\nfunction solveThorsNotifications(int n, int q, int[][] events) returns int[]|error {\n    Notification[] notifications = [];\n    int[] results = [];\n    int unreadCount = 0;\n    \n    foreach int[] event in events {\n        int eventType = event[0];\n        \n        if eventType == 1 {\n            // New notification from app x\n            int appId = event[1];\n            notifications.push({appId: appId, isRead: false});\n            unreadCount += 1;\n            results.push(unreadCount);\n        } else if eventType == 2 {\n            // Read all notifications from app x\n            int appId = event[1];\n            foreach int i in 0 ..< notifications.length() {\n                if notifications[i].appId == appId && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        } else if eventType == 3 {\n            // Read first t notifications\n            int t = event[1];\n            foreach int i in 0 ..< t {\n                if i < notifications.length() && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        }\n    }\n    \n    return results;\n}\n\npublic function main() returns error? {\n    // Read first line: n and q\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] firstParts = regex:split(firstLine.trim(), \" \");\n    if firstParts.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(firstParts[0]);\n    int q = check 'int:fromString(firstParts[1]);\n    \n    // Read q events\n    int[][] events = [];\n    foreach int i in 0 ..< q {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read event line\");\n        }\n        \n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() < 2 {\n            return error(\"Invalid event format\");\n        }\n        \n        int eventType = check 'int:fromString(parts[0]);\n        int value = check 'int:fromString(parts[1]);\n        \n        events.push([eventType, value]);\n    }\n    \n    // Solve and output results\n    int[] results = check solveThorsNotifications(n, q, events);\n    foreach int result in results {\n        io:println(result);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSample1() returns error? {\n    int[][] events = [\n        [1, 3],\n        [1, 1],\n        [1, 2],\n        [2, 3]\n    ];\n    \n    int[] result = check solveThorsNotifications(3, 4, events);\n    test:assertEquals(result, [1, 2, 3, 2]);\n}\n\n@test:Config {}\nfunction testSample2() returns error? {\n    int[][] events = [\n        [1, 2],\n        [1, 4],\n        [1, 2],\n        [3, 3],\n        [1, 3],\n        [1, 3]\n    ];\n    \n    int[] result = check solveThorsNotifications(4, 6, events);\n    test:assertEquals(result, [1, 2, 3, 0, 1, 2]);\n}\n\n@test:Config {}\nfunction testSingleNotification() returns error? {\n    int[][] events = [\n        [1, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(1, 1, events);\n    test:assertEquals(result, [1]);\n}\n\n@test:Config {}\nfunction testReadThenGenerate() returns error? {\n    int[][] events = [\n        [1, 1],\n        [2, 1],\n        [1, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(2, 3, events);\n    test:assertEquals(result, [1, 0, 1]);\n}\n\n@test:Config {}\nfunction testType3ReadFirst() returns error? {\n    int[][] events = [\n        [1, 1],\n        [1, 2],\n        [1, 3],\n        [3, 2]\n    ];\n    \n    int[] result = check solveThorsNotifications(3, 4, events);\n    test:assertEquals(result, [1, 2, 3, 1]);\n}\n\n@test:Config {}\nfunction testRereadNotifications() returns error? {\n    int[][] events = [\n        [1, 1],\n        [2, 1],\n        [2, 1]\n    ];\n    \n    int[] result = check solveThorsNotifications(1, 3, events);\n    test:assertEquals(result, [1, 0, 0]);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Store notifications as records with appId and isRead status\n// - Maintain notifications in a list to preserve chronological order\n// - Type 1: Add new unread notification, increment unread counter\n// - Type 2: Iterate through all notifications, mark those from app x as read\n// - Type 3: Mark first t notifications as read (may already be read)\n// - Track unread count separately for O(1) output\n// - Use regex:split from standard library for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Represents a single notification\ntype Notification record {\n    int appId;\n    boolean isRead;\n};\n\nfunction solveThorsNotifications(int n, int q, int[][] events) returns int[]|error {\n    Notification[] notifications = [];\n    int[] results = [];\n    int unreadCount = 0;\n    \n    foreach int[] event in events {\n        int eventType = event[0];\n        \n        if eventType == 1 {\n            // New notification from app x\n            int appId = event[1];\n            notifications.push({appId: appId, isRead: false});\n            unreadCount += 1;\n            results.push(unreadCount);\n        } else if eventType == 2 {\n            // Read all notifications from app x\n            int appId = event[1];\n            foreach int i in 0 ..< notifications.length() {\n                if notifications[i].appId == appId && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        } else if eventType == 3 {\n            // Read first t notifications\n            int t = event[1];\n            foreach int i in 0 ..< t {\n                if i < notifications.length() && !notifications[i].isRead {\n                    notifications[i].isRead = true;\n                    unreadCount -= 1;\n                }\n            }\n            results.push(unreadCount);\n        }\n    }\n    \n    return results;\n}\n\npublic function main() returns error? {\n    // Read first line: n and q\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] firstParts = regex:split(firstLine.trim(), \" \");\n    if firstParts.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(firstParts[0]);\n    int q = check 'int:fromString(firstParts[1]);\n    \n    // Read q events\n    int[][] events = [];\n    foreach int i in 0 ..< q {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read event line\");\n        }\n        \n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() < 2 {\n            return error(\"Invalid event format\");\n        }\n        \n        int eventType = check 'int:fromString(parts[0]);\n        int value = check 'int:fromString(parts[1]);\n        \n        events.push([eventType, value]);\n    }\n    \n    // Solve and output results\n    int[] results = check solveThorsNotifications(n, q, events);\n    foreach int result in results {\n        io:println(result);\n    }\n    \n    return;\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T00:43:19.902398"
}