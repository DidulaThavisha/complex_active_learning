{
  "entry_id": "problem_0090",
  "problem_index": 90,
  "prompt": "Title: Restaurant\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nA restaurant received *n* orders for the rental. Each rental order reserve the restaurant for a continuous period of time, the *i*-th order is characterized by two time values — the start time *l**i* and the finish time *r**i* (*l**i*<=≤<=*r**i*).\n\nRestaurant management can accept and reject orders. What is the maximal number of orders the restaurant can accept?\n\nNo two accepted orders can intersect, i.e. they can't share even a moment of time. If one order ends in the moment other starts, they can't be accepted both.\n\nInput Specification:\nThe first line contains integer number *n* (1<=≤<=*n*<=≤<=5·105) — number of orders. The following *n* lines contain integer values *l**i* and *r**i* each (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109).\n\nOutput Specification:\nPrint the maximal number of orders that can be accepted.\n\nDemo Input:\n['2\\n7 11\\n4 7\\n', '5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n', '6\\n4 8\\n1 5\\n4 7\\n2 5\\n1 3\\n6 8\\n']\n\nDemo Output:\n['1\\n', '3\\n', '2\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis is a classic interval scheduling maximization problem. The optimal greedy approach is to:\n1. Sort all orders by their finish time (end time)\n2. Greedily select orders that don't overlap with previously selected orders\n3. An order can be selected if its start time is strictly greater than the finish time of the last selected order\n\nThe key fix needed: In Ballerina, string splitting is done using `regex:split()` from the `ballerina/regex` module, not a method on the string type.\n\n<CODE>\n```ballerina\n// Reasoning:\n// This is an interval scheduling problem where we need to maximize the number of non-overlapping intervals.\n// \n// Algorithm:\n// 1. Parse input to get all rental orders with their start and end times\n// 2. Sort orders by their finish time (end time) in ascending order\n// 3. Use greedy approach: select the first order, then keep selecting orders whose start time\n//    is strictly greater than the finish time of the last selected order\n// 4. Count and return the total number of accepted orders\n//\n// The greedy approach works because selecting the order that finishes earliest leaves\n// the maximum room for subsequent orders.\n//\n// Important: Use ballerina/regex for string splitting, not string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Order record {|\n    int startTime;\n    int endTime;\n|};\n\nfunction maxOrders(Order[] orders) returns int {\n    if orders.length() == 0 {\n        return 0;\n    }\n    \n    // Sort orders by finish time (endTime)\n    Order[] sortedOrders = orders.clone();\n    \n    // Simple bubble sort by end time\n    int n = sortedOrders.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sortedOrders[j].endTime > sortedOrders[j + 1].endTime {\n                Order temp = sortedOrders[j];\n                sortedOrders[j] = sortedOrders[j + 1];\n                sortedOrders[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Greedy selection: pick first order, then pick orders that don't overlap\n    int count = 1;\n    int lastEndTime = sortedOrders[0].endTime;\n    \n    foreach int i in 1 ..< sortedOrders.length() {\n        // If current order starts after the last selected order ends\n        if sortedOrders[i].startTime > lastEndTime {\n            count += 1;\n            lastEndTime = sortedOrders[i].endTime;\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read number of orders\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of orders\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of orders\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of orders must be at least 1\");\n    }\n    \n    // Read all orders\n    Order[] orders = [];\n    foreach int i in 0 ..< n {\n        string? orderLine = io:readln();\n        if orderLine is () {\n            return error(\"Failed to read order line\");\n        }\n        \n        // Use regex:split instead of string.split()\n        string[] parts = regex:split(orderLine.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid order format\");\n        }\n        \n        int|error startTime = 'int:fromString(parts[0]);\n        int|error endTime = 'int:fromString(parts[1]);\n        \n        if startTime is error || endTime is error {\n            return error(\"Invalid time values\");\n        }\n        \n        if startTime > endTime {\n            return error(\"Start time cannot be greater than end time\");\n        }\n        \n        orders.push({startTime: startTime, endTime: endTime});\n    }\n    \n    // Calculate and print result\n    int result = maxOrders(orders);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxOrdersSimple() {\n    Order[] orders = [\n        {startTime: 7, endTime: 11},\n        {startTime: 4, endTime: 7}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testMaxOrdersNonOverlapping() {\n    Order[] orders = [\n        {startTime: 1, endTime: 2},\n        {startTime: 2, endTime: 3},\n        {startTime: 3, endTime: 4},\n        {startTime: 4, endTime: 5},\n        {startTime: 5, endTime: 6}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testMaxOrdersMultipleOverlaps() {\n    Order[] orders = [\n        {startTime: 4, endTime: 8},\n        {startTime: 1, endTime: 5},\n        {startTime: 4, endTime: 7},\n        {startTime: 2, endTime: 5},\n        {startTime: 1, endTime: 3},\n        {startTime: 6, endTime: 8}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxOrdersSingleOrder() {\n    Order[] orders = [\n        {startTime: 1, endTime: 10}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testMaxOrdersEmptyList() {\n    Order[] orders = [];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMaxOrdersAllSameInterval() {\n    Order[] orders = [\n        {startTime: 1, endTime: 5},\n        {startTime: 1, endTime: 5},\n        {startTime: 1, endTime: 5}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// This is an interval scheduling problem where we need to maximize the number of non-overlapping intervals.\n// \n// Algorithm:\n// 1. Parse input to get all rental orders with their start and end times\n// 2. Sort orders by their finish time (end time) in ascending order\n// 3. Use greedy approach: select the first order, then keep selecting orders whose start time\n//    is strictly greater than the finish time of the last selected order\n// 4. Count and return the total number of accepted orders\n//\n// The greedy approach works because selecting the order that finishes earliest leaves\n// the maximum room for subsequent orders.\n//\n// Important: Use ballerina/regex for string splitting, not string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Order record {|\n    int startTime;\n    int endTime;\n|};\n\nfunction maxOrders(Order[] orders) returns int {\n    if orders.length() == 0 {\n        return 0;\n    }\n    \n    // Sort orders by finish time (endTime)\n    Order[] sortedOrders = orders.clone();\n    \n    // Simple bubble sort by end time\n    int n = sortedOrders.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sortedOrders[j].endTime > sortedOrders[j + 1].endTime {\n                Order temp = sortedOrders[j];\n                sortedOrders[j] = sortedOrders[j + 1];\n                sortedOrders[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Greedy selection: pick first order, then pick orders that don't overlap\n    int count = 1;\n    int lastEndTime = sortedOrders[0].endTime;\n    \n    foreach int i in 1 ..< sortedOrders.length() {\n        // If current order starts after the last selected order ends\n        if sortedOrders[i].startTime > lastEndTime {\n            count += 1;\n            lastEndTime = sortedOrders[i].endTime;\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read number of orders\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of orders\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of orders\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of orders must be at least 1\");\n    }\n    \n    // Read all orders\n    Order[] orders = [];\n    foreach int i in 0 ..< n {\n        string? orderLine = io:readln();\n        if orderLine is () {\n            return error(\"Failed to read order line\");\n        }\n        \n        // Use regex:split instead of string.split()\n        string[] parts = regex:split(orderLine.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid order format\");\n        }\n        \n        int|error startTime = 'int:fromString(parts[0]);\n        int|error endTime = 'int:fromString(parts[1]);\n        \n        if startTime is error || endTime is error {\n            return error(\"Invalid time values\");\n        }\n        \n        if startTime > endTime {\n            return error(\"Start time cannot be greater than end time\");\n        }\n        \n        orders.push({startTime: startTime, endTime: endTime});\n    }\n    \n    // Calculate and print result\n    int result = maxOrders(orders);\n    io:println(result);\n    \n    return;\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:33:36.096433",
      "status": "failed",
      "completion": "# Overview\nThis is a classic interval scheduling maximization problem. The optimal greedy approach is to:\n1. Sort all orders by their finish time (end time)\n2. Greedily select orders that don't overlap with previously selected orders\n3. An order can be selected if its start time is strictly greater than the finish time of the last selected order\n\nThe greedy algorithm works because by always choosing the order that finishes earliest, we leave the maximum amount of time available for future orders.\n\n<CODE>\n```ballerina\n// Reasoning:\n// This is an interval scheduling problem where we need to maximize the number of non-overlapping intervals.\n// \n// Algorithm:\n// 1. Parse input to get all rental orders with their start and end times\n// 2. Sort orders by their finish time (end time) in ascending order\n// 3. Use greedy approach: select the first order, then keep selecting orders whose start time\n//    is strictly greater than the finish time of the last selected order\n// 4. Count and return the total number of accepted orders\n//\n// The greedy approach works because selecting the order that finishes earliest leaves\n// the maximum room for subsequent orders.\n\nimport ballerina/io;\n\ntype Order record {|\n    int startTime;\n    int endTime;\n|};\n\nfunction maxOrders(Order[] orders) returns int {\n    if orders.length() == 0 {\n        return 0;\n    }\n    \n    // Sort orders by finish time (endTime)\n    Order[] sortedOrders = orders.clone();\n    \n    // Simple bubble sort by end time\n    int n = sortedOrders.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sortedOrders[j].endTime > sortedOrders[j + 1].endTime {\n                Order temp = sortedOrders[j];\n                sortedOrders[j] = sortedOrders[j + 1];\n                sortedOrders[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Greedy selection: pick first order, then pick orders that don't overlap\n    int count = 1;\n    int lastEndTime = sortedOrders[0].endTime;\n    \n    foreach int i in 1 ..< sortedOrders.length() {\n        // If current order starts after the last selected order ends\n        if sortedOrders[i].startTime > lastEndTime {\n            count += 1;\n            lastEndTime = sortedOrders[i].endTime;\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read number of orders\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of orders\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of orders\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of orders must be at least 1\");\n    }\n    \n    // Read all orders\n    Order[] orders = [];\n    foreach int i in 0 ..< n {\n        string? orderLine = io:readln();\n        if orderLine is () {\n            return error(\"Failed to read order line\");\n        }\n        \n        string[] parts = orderLine.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid order format\");\n        }\n        \n        int|error startTime = 'int:fromString(parts[0]);\n        int|error endTime = 'int:fromString(parts[1]);\n        \n        if startTime is error || endTime is error {\n            return error(\"Invalid time values\");\n        }\n        \n        if startTime > endTime {\n            return error(\"Start time cannot be greater than end time\");\n        }\n        \n        orders.push({startTime: startTime, endTime: endTime});\n    }\n    \n    // Calculate and print result\n    int result = maxOrders(orders);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxOrdersSimple() {\n    Order[] orders = [\n        {startTime: 7, endTime: 11},\n        {startTime: 4, endTime: 7}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testMaxOrdersNonOverlapping() {\n    Order[] orders = [\n        {startTime: 1, endTime: 2},\n        {startTime: 2, endTime: 3},\n        {startTime: 3, endTime: 4},\n        {startTime: 4, endTime: 5},\n        {startTime: 5, endTime: 6}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testMaxOrdersMultipleOverlaps() {\n    Order[] orders = [\n        {startTime: 4, endTime: 8},\n        {startTime: 1, endTime: 5},\n        {startTime: 4, endTime: 7},\n        {startTime: 2, endTime: 5},\n        {startTime: 1, endTime: 3},\n        {startTime: 6, endTime: 8}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxOrdersSingleOrder() {\n    Order[] orders = [\n        {startTime: 1, endTime: 10}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testMaxOrdersEmptyList() {\n    Order[] orders = [];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMaxOrdersAllSameInterval() {\n    Order[] orders = [\n        {startTime: 1, endTime: 5},\n        {startTime: 1, endTime: 5},\n        {startTime: 1, endTime: 5}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// This is an interval scheduling problem where we need to maximize the number of non-overlapping intervals.\n// \n// Algorithm:\n// 1. Parse input to get all rental orders with their start and end times\n// 2. Sort orders by their finish time (end time) in ascending order\n// 3. Use greedy approach: select the first order, then keep selecting orders whose start time\n//    is strictly greater than the finish time of the last selected order\n// 4. Count and return the total number of accepted orders\n//\n// The greedy approach works because selecting the order that finishes earliest leaves\n// the maximum room for subsequent orders.\n\nimport ballerina/io;\n\ntype Order record {|\n    int startTime;\n    int endTime;\n|};\n\nfunction maxOrders(Order[] orders) returns int {\n    if orders.length() == 0 {\n        return 0;\n    }\n    \n    // Sort orders by finish time (endTime)\n    Order[] sortedOrders = orders.clone();\n    \n    // Simple bubble sort by end time\n    int n = sortedOrders.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sortedOrders[j].endTime > sortedOrders[j + 1].endTime {\n                Order temp = sortedOrders[j];\n                sortedOrders[j] = sortedOrders[j + 1];\n                sortedOrders[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Greedy selection: pick first order, then pick orders that don't overlap\n    int count = 1;\n    int lastEndTime = sortedOrders[0].endTime;\n    \n    foreach int i in 1 ..< sortedOrders.length() {\n        // If current order starts after the last selected order ends\n        if sortedOrders[i].startTime > lastEndTime {\n            count += 1;\n            lastEndTime = sortedOrders[i].endTime;\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read number of orders\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of orders\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of orders\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of orders must be at least 1\");\n    }\n    \n    // Read all orders\n    Order[] orders = [];\n    foreach int i in 0 ..< n {\n        string? orderLine = io:readln();\n        if orderLine is () {\n            return error(\"Failed to read order line\");\n        }\n        \n        string[] parts = orderLine.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid order format\");\n        }\n        \n        int|error startTime = 'int:fromString(parts[0]);\n        int|error endTime = 'int:fromString(parts[1]);\n        \n        if startTime is error || endTime is error {\n            return error(\"Invalid time values\");\n        }\n        \n        if startTime > endTime {\n            return error(\"Start time cannot be greater than end time\");\n        }\n        \n        orders.push({startTime: startTime, endTime: endTime});\n    }\n    \n    // Calculate and print result\n    int result = maxOrders(orders);\n    io:println(result);\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(80:43,80:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(80:43,80:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(80:43,80:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:34:00.020092",
      "status": "success",
      "completion": "# Overview\nThis is a classic interval scheduling maximization problem. The optimal greedy approach is to:\n1. Sort all orders by their finish time (end time)\n2. Greedily select orders that don't overlap with previously selected orders\n3. An order can be selected if its start time is strictly greater than the finish time of the last selected order\n\nThe key fix needed: In Ballerina, string splitting is done using `regex:split()` from the `ballerina/regex` module, not a method on the string type.\n\n<CODE>\n```ballerina\n// Reasoning:\n// This is an interval scheduling problem where we need to maximize the number of non-overlapping intervals.\n// \n// Algorithm:\n// 1. Parse input to get all rental orders with their start and end times\n// 2. Sort orders by their finish time (end time) in ascending order\n// 3. Use greedy approach: select the first order, then keep selecting orders whose start time\n//    is strictly greater than the finish time of the last selected order\n// 4. Count and return the total number of accepted orders\n//\n// The greedy approach works because selecting the order that finishes earliest leaves\n// the maximum room for subsequent orders.\n//\n// Important: Use ballerina/regex for string splitting, not string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Order record {|\n    int startTime;\n    int endTime;\n|};\n\nfunction maxOrders(Order[] orders) returns int {\n    if orders.length() == 0 {\n        return 0;\n    }\n    \n    // Sort orders by finish time (endTime)\n    Order[] sortedOrders = orders.clone();\n    \n    // Simple bubble sort by end time\n    int n = sortedOrders.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sortedOrders[j].endTime > sortedOrders[j + 1].endTime {\n                Order temp = sortedOrders[j];\n                sortedOrders[j] = sortedOrders[j + 1];\n                sortedOrders[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Greedy selection: pick first order, then pick orders that don't overlap\n    int count = 1;\n    int lastEndTime = sortedOrders[0].endTime;\n    \n    foreach int i in 1 ..< sortedOrders.length() {\n        // If current order starts after the last selected order ends\n        if sortedOrders[i].startTime > lastEndTime {\n            count += 1;\n            lastEndTime = sortedOrders[i].endTime;\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read number of orders\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of orders\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of orders\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of orders must be at least 1\");\n    }\n    \n    // Read all orders\n    Order[] orders = [];\n    foreach int i in 0 ..< n {\n        string? orderLine = io:readln();\n        if orderLine is () {\n            return error(\"Failed to read order line\");\n        }\n        \n        // Use regex:split instead of string.split()\n        string[] parts = regex:split(orderLine.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid order format\");\n        }\n        \n        int|error startTime = 'int:fromString(parts[0]);\n        int|error endTime = 'int:fromString(parts[1]);\n        \n        if startTime is error || endTime is error {\n            return error(\"Invalid time values\");\n        }\n        \n        if startTime > endTime {\n            return error(\"Start time cannot be greater than end time\");\n        }\n        \n        orders.push({startTime: startTime, endTime: endTime});\n    }\n    \n    // Calculate and print result\n    int result = maxOrders(orders);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxOrdersSimple() {\n    Order[] orders = [\n        {startTime: 7, endTime: 11},\n        {startTime: 4, endTime: 7}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testMaxOrdersNonOverlapping() {\n    Order[] orders = [\n        {startTime: 1, endTime: 2},\n        {startTime: 2, endTime: 3},\n        {startTime: 3, endTime: 4},\n        {startTime: 4, endTime: 5},\n        {startTime: 5, endTime: 6}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testMaxOrdersMultipleOverlaps() {\n    Order[] orders = [\n        {startTime: 4, endTime: 8},\n        {startTime: 1, endTime: 5},\n        {startTime: 4, endTime: 7},\n        {startTime: 2, endTime: 5},\n        {startTime: 1, endTime: 3},\n        {startTime: 6, endTime: 8}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxOrdersSingleOrder() {\n    Order[] orders = [\n        {startTime: 1, endTime: 10}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testMaxOrdersEmptyList() {\n    Order[] orders = [];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMaxOrdersAllSameInterval() {\n    Order[] orders = [\n        {startTime: 1, endTime: 5},\n        {startTime: 1, endTime: 5},\n        {startTime: 1, endTime: 5}\n    ];\n    int result = maxOrders(orders);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// This is an interval scheduling problem where we need to maximize the number of non-overlapping intervals.\n// \n// Algorithm:\n// 1. Parse input to get all rental orders with their start and end times\n// 2. Sort orders by their finish time (end time) in ascending order\n// 3. Use greedy approach: select the first order, then keep selecting orders whose start time\n//    is strictly greater than the finish time of the last selected order\n// 4. Count and return the total number of accepted orders\n//\n// The greedy approach works because selecting the order that finishes earliest leaves\n// the maximum room for subsequent orders.\n//\n// Important: Use ballerina/regex for string splitting, not string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Order record {|\n    int startTime;\n    int endTime;\n|};\n\nfunction maxOrders(Order[] orders) returns int {\n    if orders.length() == 0 {\n        return 0;\n    }\n    \n    // Sort orders by finish time (endTime)\n    Order[] sortedOrders = orders.clone();\n    \n    // Simple bubble sort by end time\n    int n = sortedOrders.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sortedOrders[j].endTime > sortedOrders[j + 1].endTime {\n                Order temp = sortedOrders[j];\n                sortedOrders[j] = sortedOrders[j + 1];\n                sortedOrders[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Greedy selection: pick first order, then pick orders that don't overlap\n    int count = 1;\n    int lastEndTime = sortedOrders[0].endTime;\n    \n    foreach int i in 1 ..< sortedOrders.length() {\n        // If current order starts after the last selected order ends\n        if sortedOrders[i].startTime > lastEndTime {\n            count += 1;\n            lastEndTime = sortedOrders[i].endTime;\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read number of orders\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of orders\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of orders\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of orders must be at least 1\");\n    }\n    \n    // Read all orders\n    Order[] orders = [];\n    foreach int i in 0 ..< n {\n        string? orderLine = io:readln();\n        if orderLine is () {\n            return error(\"Failed to read order line\");\n        }\n        \n        // Use regex:split instead of string.split()\n        string[] parts = regex:split(orderLine.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid order format\");\n        }\n        \n        int|error startTime = 'int:fromString(parts[0]);\n        int|error endTime = 'int:fromString(parts[1]);\n        \n        if startTime is error || endTime is error {\n            return error(\"Invalid time values\");\n        }\n        \n        if startTime > endTime {\n            return error(\"Start time cannot be greater than end time\");\n        }\n        \n        orders.push({startTime: startTime, endTime: endTime});\n    }\n    \n    // Calculate and print result\n    int result = maxOrders(orders);\n    io:println(result);\n    \n    return;\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T01:34:31.475744"
}