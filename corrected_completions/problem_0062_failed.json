{
  "entry_id": "problem_0062",
  "problem_index": 62,
  "prompt": "Title: Tell Your World\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nConnect the countless points with lines, till we reach the faraway yonder.\n\nThere are *n* points on a coordinate plane, the *i*-th of which being (*i*,<=*y**i*).\n\nDetermine whether it's possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.\n\nInput Specification:\nThe first line of input contains a positive integer *n* (3<=≤<=*n*<=≤<=1<=000) — the number of points.\n\nThe second line contains *n* space-separated integers *y*1,<=*y*2,<=...,<=*y**n* (<=-<=109<=≤<=*y**i*<=≤<=109) — the vertical coordinates of each point.\n\nOutput Specification:\nOutput \"Yes\" (without quotes) if it's possible to fulfill the requirements, and \"No\" otherwise.\n\nYou can print each letter in any case (upper or lower).\n\nDemo Input:\n['5\\n7 5 8 6 9\\n', '5\\n-1 -2 0 0 -5\\n', '5\\n5 4 3 2 1\\n', '5\\n1000000000 0 0 0 0\\n']\n\nDemo Output:\n['Yes\\n', 'No\\n', 'No\\n', 'Yes\\n']\n\nNote:\nIn the first example, there are five points: (1, 7), (2, 5), (3, 8), (4, 6) and (5, 9). It's possible to draw a line that passes through points 1, 3, 5, and another one that passes through points 2, 4 and is parallel to the first one.\n\nIn the second example, while it's possible to draw two lines that cover all points, they cannot be made parallel.\n\nIn the third example, it's impossible to satisfy both requirements at the same time.",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:03:14.327054",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to determine if we can draw two parallel non-overlapping lines such that every point lies on exactly one line, and each line has at least one point.\n\nKey insights:\n- Points are at coordinates (i, y_i) where i goes from 1 to n\n- Two lines are parallel if they have the same slope\n- The slope between points (i, y_i) and (j, y_j) is (y_j - y_i) / (j - i)\n- We need to partition points into two groups where all points in each group are collinear\n- The two lines must have the same slope but different y-intercepts\n\nStrategy:\n1. Calculate the slope using the first two points (this will be our target slope)\n2. Try to partition remaining points into two lines with this slope\n3. The first line contains point 1, the second line contains point 2\n4. For each remaining point, check if it's collinear with line 1 or line 2\n5. If a point doesn't fit either line, return \"No\"\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We have n points at (1, y1), (2, y2), ..., (n, yn)\n// - Two parallel lines have the same slope\n// - We need to partition all points into exactly 2 groups (lines)\n// - Each line must have at least one point\n//\n// Approach:\n// 1. The slope is determined by the first two points\n// 2. Try to place point 1 on line 1 and point 2 on line 2\n// 3. For each remaining point, check if it fits on line 1 or line 2\n// 4. A point (i, yi) fits on a line through (j, yj) with slope m if:\n//    (yi - yj) / (i - j) == m, or equivalently: (yi - yj) * 1 == m * (i - j)\n// 5. To avoid floating point, use cross multiplication for slope comparison\n\nimport ballerina/io;\n\nfunction canDrawTwoParallelLines(int[] yCoords) returns boolean {\n    int n = yCoords.length();\n    \n    // Need at least 3 points\n    if n < 3 {\n        return false;\n    }\n    \n    // Line 1 contains point (1, y[0])\n    // Line 2 contains point (2, y[1])\n    // Slope is (y[1] - y[0]) / (2 - 1) = y[1] - y[0]\n    \n    int x1 = 1;\n    int y1 = yCoords[0];\n    int x2 = 2;\n    int y2 = yCoords[1];\n    \n    // Track which line each point belongs to\n    // -1: not assigned, 1: line1, 2: line2\n    int[] assignment = [];\n    assignment.push(1); // Point 1 on line 1\n    assignment.push(2); // Point 2 on line 2\n    \n    // Try to assign remaining points\n    foreach int i in 2 ... n - 1 {\n        int xi = i + 1; // x-coordinate is 1-indexed\n        int yi = yCoords[i];\n        \n        // Check if point (xi, yi) is collinear with line 1\n        // Line 1 passes through (x1, y1) and has slope (y2 - y1) / (x2 - x1)\n        // Point (xi, yi) is on line 1 if: (yi - y1) / (xi - x1) == (y2 - y1) / (x2 - x1)\n        // Cross multiply: (yi - y1) * (x2 - x1) == (y2 - y1) * (xi - x1)\n        \n        boolean fitsLine1 = (yi - y1) * (x2 - x1) == (y2 - y1) * (xi - x1);\n        \n        // For line 2, we need another point on it to define it fully\n        // But line 2 is parallel to line 1, so it has the same slope\n        // Line 2 passes through (x2, y2) with slope (y2 - y1) / (x2 - x1)\n        // Point (xi, yi) is on line 2 if: (yi - y2) / (xi - x2) == (y2 - y1) / (x2 - x1)\n        // Cross multiply: (yi - y2) * (x2 - x1) == (y2 - y1) * (xi - x2)\n        \n        boolean fitsLine2 = (yi - y2) * (x2 - x1) == (y2 - y1) * (xi - x2);\n        \n        // Point must fit exactly one line (non-overlapping requirement)\n        if fitsLine1 && fitsLine2 {\n            // Lines would overlap\n            return false;\n        } else if fitsLine1 {\n            assignment.push(1);\n        } else if fitsLine2 {\n            assignment.push(2);\n        } else {\n            // Point fits neither line\n            return false;\n        }\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read number of points\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read y-coordinates\n    string? coordsLine = io:readln();\n    if coordsLine is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    string[] parts = coordsLine.trim().split(\" \");\n    if parts.length() != n {\n        return error(\"Invalid number of coordinates\");\n    }\n    \n    int[] yCoords = [];\n    foreach string part in parts {\n        int coord = check 'int:fromString(part.trim());\n        yCoords.push(coord);\n    }\n    \n    boolean result = canDrawTwoParallelLines(yCoords);\n    io:println(result ? \"Yes\" : \"No\");\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // Example 1: [7, 5, 8, 6, 9] -> Yes\n    int[] coords = [7, 5, 8, 6, 9];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n\n@test:Config {}\nfunction testExample2() {\n    // Example 2: [-1, -2, 0, 0, -5] -> No\n    int[] coords = [-1, -2, 0, 0, -5];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, false);\n}\n\n@test:Config {}\nfunction testExample3() {\n    // Example 3: [5, 4, 3, 2, 1] -> No (all collinear, can't split into 2 lines)\n    int[] coords = [5, 4, 3, 2, 1];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, false);\n}\n\n@test:Config {}\nfunction testExample4() {\n    // Example 4: [1000000000, 0, 0, 0, 0] -> Yes\n    int[] coords = [1000000000, 0, 0, 0, 0];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    // Simple case: three points where first two define slope, third fits one line\n    int[] coords = [1, 2, 3];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n\n@test:Config {}\nfunction testParallelLines() {\n    // Two clear parallel lines with slope 0\n    int[] coords = [5, 3, 5, 3, 5];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We have n points at (1, y1), (2, y2), ..., (n, yn)\n// - Two parallel lines have the same slope\n// - We need to partition all points into exactly 2 groups (lines)\n// - Each line must have at least one point\n//\n// Approach:\n// 1. The slope is determined by the first two points\n// 2. Try to place point 1 on line 1 and point 2 on line 2\n// 3. For each remaining point, check if it fits on line 1 or line 2\n// 4. A point (i, yi) fits on a line through (j, yj) with slope m if:\n//    (yi - yj) / (i - j) == m, or equivalently: (yi - yj) * 1 == m * (i - j)\n// 5. To avoid floating point, use cross multiplication for slope comparison\n\nimport ballerina/io;\n\nfunction canDrawTwoParallelLines(int[] yCoords) returns boolean {\n    int n = yCoords.length();\n    \n    // Need at least 3 points\n    if n < 3 {\n        return false;\n    }\n    \n    // Line 1 contains point (1, y[0])\n    // Line 2 contains point (2, y[1])\n    // Slope is (y[1] - y[0]) / (2 - 1) = y[1] - y[0]\n    \n    int x1 = 1;\n    int y1 = yCoords[0];\n    int x2 = 2;\n    int y2 = yCoords[1];\n    \n    // Track which line each point belongs to\n    // -1: not assigned, 1: line1, 2: line2\n    int[] assignment = [];\n    assignment.push(1); // Point 1 on line 1\n    assignment.push(2); // Point 2 on line 2\n    \n    // Try to assign remaining points\n    foreach int i in 2 ... n - 1 {\n        int xi = i + 1; // x-coordinate is 1-indexed\n        int yi = yCoords[i];\n        \n        // Check if point (xi, yi) is collinear with line 1\n        // Line 1 passes through (x1, y1) and has slope (y2 - y1) / (x2 - x1)\n        // Point (xi, yi) is on line 1 if: (yi - y1) / (xi - x1) == (y2 - y1) / (x2 - x1)\n        // Cross multiply: (yi - y1) * (x2 - x1) == (y2 - y1) * (xi - x1)\n        \n        boolean fitsLine1 = (yi - y1) * (x2 - x1) == (y2 - y1) * (xi - x1);\n        \n        // For line 2, we need another point on it to define it fully\n        // But line 2 is parallel to line 1, so it has the same slope\n        // Line 2 passes through (x2, y2) with slope (y2 - y1) / (x2 - x1)\n        // Point (xi, yi) is on line 2 if: (yi - y2) / (xi - x2) == (y2 - y1) / (x2 - x1)\n        // Cross multiply: (yi - y2) * (x2 - x1) == (y2 - y1) * (xi - x2)\n        \n        boolean fitsLine2 = (yi - y2) * (x2 - x1) == (y2 - y1) * (xi - x2);\n        \n        // Point must fit exactly one line (non-overlapping requirement)\n        if fitsLine1 && fitsLine2 {\n            // Lines would overlap\n            return false;\n        } else if fitsLine1 {\n            assignment.push(1);\n        } else if fitsLine2 {\n            assignment.push(2);\n        } else {\n            // Point fits neither line\n            return false;\n        }\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read number of points\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read y-coordinates\n    string? coordsLine = io:readln();\n    if coordsLine is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    string[] parts = coordsLine.trim().split(\" \");\n    if parts.length() != n {\n        return error(\"Invalid number of coordinates\");\n    }\n    \n    int[] yCoords = [];\n    foreach string part in parts {\n        int coord = check 'int:fromString(part.trim());\n        yCoords.push(coord);\n    }\n    \n    boolean result = canDrawTwoParallelLines(yCoords);\n    io:println(result ? \"Yes\" : \"No\");\n}",
      "tests_passed": 0,
      "tests_total": 4,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(92:40,92:45)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(92:40,92:45)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(92:40,92:45)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:03:47.752635",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to determine if we can draw two parallel non-overlapping lines such that every point lies on exactly one line, and each line has at least one point.\n\nKey insights:\n- Points are at coordinates (i, y_i) where i goes from 1 to n\n- Two lines are parallel if they have the same slope\n- We need to partition points into two groups where all points in each group are collinear\n- The two lines must have the same slope but different y-intercepts\n\nStrategy:\n1. Try using the first two points to establish the slope\n2. Check if we can partition all points into two parallel lines with this slope\n3. One line goes through point 1, another through point 2\n4. For remaining points, check if they lie on either line\n5. Use cross multiplication to avoid floating point issues\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We have n points at (1, y1), (2, y2), ..., (n, yn)\n// - Two parallel lines have the same slope\n// - We need to partition all points into exactly 2 groups (lines)\n// - Each line must have at least one point\n//\n// Approach:\n// 1. The slope is determined by the first two points (they define the parallel direction)\n// 2. Place point 1 on line 1 and point 2 on line 2\n// 3. For each remaining point, check if it fits on line 1 or line 2\n// 4. A point (i, yi) fits on a line through (j, yj) with slope m if:\n//    (yi - yj) / (i - j) == m\n// 5. To avoid floating point errors, use cross multiplication for slope comparison\n//    (yi - yj) / (i - j) == (y2 - y1) / (x2 - x1)\n//    becomes: (yi - yj) * (x2 - x1) == (y2 - y1) * (i - j)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction canDrawTwoParallelLines(int[] yCoords) returns boolean {\n    int n = yCoords.length();\n    \n    // Need at least 3 points\n    if n < 3 {\n        return false;\n    }\n    \n    // Line 1 contains point (1, y[0])\n    // Line 2 contains point (2, y[1])\n    // The slope between them is (y[1] - y[0]) / (2 - 1) = y[1] - y[0]\n    \n    int x1 = 1;\n    int y1 = yCoords[0];\n    int x2 = 2;\n    int y2 = yCoords[1];\n    \n    // The common slope numerator and denominator\n    int slopeNum = y2 - y1;\n    int slopeDen = x2 - x1; // This is always 1, but kept for clarity\n    \n    // Try to assign remaining points\n    foreach int i in 2 ... n - 1 {\n        int xi = i + 1; // x-coordinate is 1-indexed (point index + 1)\n        int yi = yCoords[i];\n        \n        // Check if point (xi, yi) is collinear with line 1 through (x1, y1)\n        // Point is on line 1 if: (yi - y1) / (xi - x1) == slopeNum / slopeDen\n        // Cross multiply: (yi - y1) * slopeDen == slopeNum * (xi - x1)\n        \n        boolean fitsLine1 = (yi - y1) * slopeDen == slopeNum * (xi - x1);\n        \n        // Check if point (xi, yi) is collinear with line 2 through (x2, y2)\n        // Line 2 has the same slope as line 1 (parallel lines)\n        // Point is on line 2 if: (yi - y2) / (xi - x2) == slopeNum / slopeDen\n        // Cross multiply: (yi - y2) * slopeDen == slopeNum * (xi - x2)\n        \n        boolean fitsLine2 = (yi - y2) * slopeDen == slopeNum * (xi - x2);\n        \n        // Point must fit exactly one line (non-overlapping requirement)\n        if fitsLine1 && fitsLine2 {\n            // Lines would overlap (same line)\n            return false;\n        } else if !fitsLine1 && !fitsLine2 {\n            // Point fits neither line\n            return false;\n        }\n        // If it fits exactly one line, we're good, continue\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read number of points\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read y-coordinates\n    string? coordsLine = io:readln();\n    if coordsLine is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    string[] parts = regex:split(coordsLine.trim(), \" \");\n    if parts.length() != n {\n        return error(\"Invalid number of coordinates\");\n    }\n    \n    int[] yCoords = [];\n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int coord = check 'int:fromString(part.trim());\n            yCoords.push(coord);\n        }\n    }\n    \n    boolean result = canDrawTwoParallelLines(yCoords);\n    io:println(result ? \"Yes\" : \"No\");\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // Example 1: [7, 5, 8, 6, 9] -> Yes\n    // Points: (1,7), (2,5), (3,8), (4,6), (5,9)\n    // Line 1: points 1,3,5 with slope 1\n    // Line 2: points 2,4 with slope 1\n    int[] coords = [7, 5, 8, 6, 9];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n\n@test:Config {}\nfunction testExample2() {\n    // Example 2: [-1, -2, 0, 0, -5] -> No\n    // Cannot partition into two parallel lines\n    int[] coords = [-1, -2, 0, 0, -5];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, false);\n}\n\n@test:Config {}\nfunction testExample3() {\n    // Example 3: [5, 4, 3, 2, 1] -> No\n    // All points are collinear, can't split into 2 separate lines\n    int[] coords = [5, 4, 3, 2, 1];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, false);\n}\n\n@test:Config {}\nfunction testExample4() {\n    // Example 4: [1000000000, 0, 0, 0, 0] -> Yes\n    // Point 1 on one line, all others on another parallel line\n    int[] coords = [1000000000, 0, 0, 0, 0];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    // Simple case: [1, 2, 3] - points (1,1), (2,2), (3,3) all collinear\n    int[] coords = [1, 2, 3];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, false);\n}\n\n@test:Config {}\nfunction testParallelLinesHorizontal() {\n    // Two horizontal parallel lines: (1,5), (2,3), (3,5), (4,3), (5,5)\n    // Line 1: y=5, Line 2: y=3\n    int[] coords = [5, 3, 5, 3, 5];\n    boolean result = canDrawTwoParallelLines(coords);\n    test:assertEquals(result, true);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We have n points at (1, y1), (2, y2), ..., (n, yn)\n// - Two parallel lines have the same slope\n// - We need to partition all points into exactly 2 groups (lines)\n// - Each line must have at least one point\n//\n// Approach:\n// 1. The slope is determined by the first two points (they define the parallel direction)\n// 2. Place point 1 on line 1 and point 2 on line 2\n// 3. For each remaining point, check if it fits on line 1 or line 2\n// 4. A point (i, yi) fits on a line through (j, yj) with slope m if:\n//    (yi - yj) / (i - j) == m\n// 5. To avoid floating point errors, use cross multiplication for slope comparison\n//    (yi - yj) / (i - j) == (y2 - y1) / (x2 - x1)\n//    becomes: (yi - yj) * (x2 - x1) == (y2 - y1) * (i - j)\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction canDrawTwoParallelLines(int[] yCoords) returns boolean {\n    int n = yCoords.length();\n    \n    // Need at least 3 points\n    if n < 3 {\n        return false;\n    }\n    \n    // Line 1 contains point (1, y[0])\n    // Line 2 contains point (2, y[1])\n    // The slope between them is (y[1] - y[0]) / (2 - 1) = y[1] - y[0]\n    \n    int x1 = 1;\n    int y1 = yCoords[0];\n    int x2 = 2;\n    int y2 = yCoords[1];\n    \n    // The common slope numerator and denominator\n    int slopeNum = y2 - y1;\n    int slopeDen = x2 - x1; // This is always 1, but kept for clarity\n    \n    // Try to assign remaining points\n    foreach int i in 2 ... n - 1 {\n        int xi = i + 1; // x-coordinate is 1-indexed (point index + 1)\n        int yi = yCoords[i];\n        \n        // Check if point (xi, yi) is collinear with line 1 through (x1, y1)\n        // Point is on line 1 if: (yi - y1) / (xi - x1) == slopeNum / slopeDen\n        // Cross multiply: (yi - y1) * slopeDen == slopeNum * (xi - x1)\n        \n        boolean fitsLine1 = (yi - y1) * slopeDen == slopeNum * (xi - x1);\n        \n        // Check if point (xi, yi) is collinear with line 2 through (x2, y2)\n        // Line 2 has the same slope as line 1 (parallel lines)\n        // Point is on line 2 if: (yi - y2) / (xi - x2) == slopeNum / slopeDen\n        // Cross multiply: (yi - y2) * slopeDen == slopeNum * (xi - x2)\n        \n        boolean fitsLine2 = (yi - y2) * slopeDen == slopeNum * (xi - x2);\n        \n        // Point must fit exactly one line (non-overlapping requirement)\n        if fitsLine1 && fitsLine2 {\n            // Lines would overlap (same line)\n            return false;\n        } else if !fitsLine1 && !fitsLine2 {\n            // Point fits neither line\n            return false;\n        }\n        // If it fits exactly one line, we're good, continue\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    // Read number of points\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read y-coordinates\n    string? coordsLine = io:readln();\n    if coordsLine is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    string[] parts = regex:split(coordsLine.trim(), \" \");\n    if parts.length() != n {\n        return error(\"Invalid number of coordinates\");\n    }\n    \n    int[] yCoords = [];\n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int coord = check 'int:fromString(part.trim());\n            yCoords.push(coord);\n        }\n    }\n    \n    boolean result = canDrawTwoParallelLines(yCoords);\n    io:println(result ? \"Yes\" : \"No\");\n}",
      "tests_passed": 2,
      "tests_total": 4,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 2/4 tests (50.0%), need 75%",
      "error": "Only passed 2/4 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5\n7 5 8 6 9\n",
          "expected_output": "Yes\n",
          "actual_output": "No\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 2/4 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T01:04:30.904581"
}