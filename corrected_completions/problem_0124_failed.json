{
  "entry_id": "problem_0124",
  "problem_index": 124,
  "prompt": "Title: Wizards and Huge Prize\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nOne must train much to do well on wizardry contests. So, there are numerous wizardry schools and magic fees.\n\nOne of such magic schools consists of *n* tours. A winner of each tour gets a huge prize. The school is organised quite far away, so one will have to take all the prizes home in one go. And the bags that you've brought with you have space for no more than *k* huge prizes.\n\nBesides the fact that you want to take all the prizes home, you also want to perform well. You will consider your performance good if you win at least *l* tours.\n\nIn fact, years of organizing contests proved to the organizers that transporting huge prizes is an issue for the participants. Alas, no one has ever invented a spell that would shrink the prizes... So, here's the solution: for some tours the winner gets a bag instead of a huge prize. Each bag is characterized by number *a**i* — the number of huge prizes that will fit into it.\n\nYou already know the subject of all tours, so you can estimate the probability *p**i* of winning the *i*-th tour. You cannot skip the tour under any circumstances.\n\nFind the probability that you will perform well on the contest and will be able to take all won prizes home (that is, that you will be able to fit all the huge prizes that you won into the bags that you either won or brought from home).\n\nInput Specification:\nThe first line contains three integers *n*, *l*, *k* (1<=≤<=*n*<=≤<=200,<=0<=≤<=*l*,<=*k*<=≤<=200) — the number of tours, the minimum number of tours to win, and the number of prizes that you can fit in the bags brought from home, correspondingly.\n\nThe second line contains *n* space-separated integers, *p**i* (0<=≤<=*p**i*<=≤<=100) — the probability to win the *i*-th tour, in percents.\n\nThe third line contains *n* space-separated integers, *a**i* (1<=≤<=*a**i*<=≤<=200) — the capacity of the bag that will be awarded to you for winning the *i*-th tour, or else -1, if the prize for the *i*-th tour is a huge prize and not a bag.\n\nOutput Specification:\nPrint a single real number — the answer to the problem. The answer will be accepted if the absolute or relative error does not exceed 10<=-<=6.\n\nDemo Input:\n['3 1 0\\n10 20 30\\n-1 -1 2\\n', '1 1 1\\n100\\n123\\n']\n\nDemo Output:\n['0.300000000000\\n', '1.000000000000\\n']\n\nNote:\nIn the first sample we need either win no tour or win the third one. If we win nothing we wouldn't perform well. So, we must to win the third tour. Other conditions will be satisfied in this case. Probability of wining the third tour is 0.3.\n\nIn the second sample we win the only tour with probability 1.0, and go back home with bag for it.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:11:28.192381",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires calculating the probability of winning at least `l` tours out of `n` tours while being able to carry all the huge prizes home. We use dynamic programming where `dp[i][j][c]` represents the probability of winning exactly `j` tours after `i` tours with capacity `c` to carry huge prizes.\n\nThe key insights:\n1. Each tour either gives a bag (if `a[i] != -1`) or a huge prize (if `a[i] == -1`)\n2. If we win a tour with a huge prize, we need available capacity\n3. If we win a tour with a bag, we increase our capacity\n4. We need to track: tours completed, tours won, and current capacity\n5. Final answer sums probabilities where tours won >= l and capacity >= 0\n\n<CODE>\n```ballerina\n// Dynamic Programming Approach:\n// State: dp[i][j][c] = probability of winning exactly j tours after i tours with capacity c\n// Transition: For each tour i, we either win (probability p[i]/100) or lose (1 - p[i]/100)\n// - If we win and it's a huge prize (a[i] == -1): need capacity > 0, capacity decreases by 1\n// - If we win and it's a bag (a[i] != -1): capacity increases by a[i]\n// - If we lose: capacity stays same\n// Answer: sum of dp[n][j][c] for all j >= l and c >= 0\n\nimport ballerina/io;\n\nfunction solveWizards(int n, int l, int k, int[] p, int[] a) returns float|error {\n    // dp[i][j][c] = probability after i tours, won j tours, capacity c\n    // We limit capacity to a reasonable max (sum of all bag capacities + k)\n    int maxCapacity = k;\n    foreach int ai in a {\n        if ai > 0 {\n            maxCapacity += ai;\n        }\n    }\n    maxCapacity = int:min(maxCapacity, 400); // Cap to avoid memory issues\n    \n    // Initialize DP table\n    float[][][] dp = [];\n    int i = 0;\n    while i <= n {\n        float[][] dpI = [];\n        int j = 0;\n        while j <= n {\n            float[] dpIJ = [];\n            int c = 0;\n            while c <= maxCapacity {\n                dpIJ.push(0.0);\n                c += 1;\n            }\n            dpI.push(dpIJ);\n            j += 1;\n        }\n        dp.push(dpI);\n        i += 1;\n    }\n    \n    // Base case: 0 tours, 0 wins, k capacity\n    if k <= maxCapacity {\n        dp[0][0][k] = 1.0;\n    }\n    \n    // Fill DP table\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j <= i {\n            int c = 0;\n            while c <= maxCapacity {\n                if dp[i][j][c] > 0.0 {\n                    float prob = dp[i][j][c];\n                    float winProb = <float>p[i] / 100.0;\n                    float loseProb = 1.0 - winProb;\n                    \n                    // Case 1: Lose this tour\n                    if c <= maxCapacity {\n                        dp[i + 1][j][c] += prob * loseProb;\n                    }\n                    \n                    // Case 2: Win this tour\n                    if a[i] == -1 {\n                        // Huge prize - need capacity\n                        if c > 0 {\n                            dp[i + 1][j + 1][c - 1] += prob * winProb;\n                        }\n                    } else {\n                        // Bag - increase capacity\n                        int newCapacity = c + a[i];\n                        if newCapacity > maxCapacity {\n                            newCapacity = maxCapacity;\n                        }\n                        dp[i + 1][j + 1][newCapacity] += prob * winProb;\n                    }\n                }\n                c += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Calculate answer: sum probabilities where j >= l\n    float answer = 0.0;\n    int j = l;\n    while j <= n {\n        int c = 0;\n        while c <= maxCapacity {\n            answer += dp[n][j][c];\n            c += 1;\n        }\n        j += 1;\n    }\n    \n    return answer;\n}\n\npublic function main() returns error? {\n    // Read first line: n, l, k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"No input provided\");\n    }\n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int l = check 'int:fromString(parts1[1]);\n    int k = check 'int:fromString(parts1[2]);\n    \n    // Read second line: probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"No probabilities provided\");\n    }\n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of probabilities\");\n    }\n    \n    int[] p = [];\n    foreach string part in parts2 {\n        p.push(check 'int:fromString(part));\n    }\n    \n    // Read third line: bag capacities or -1\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"No capacities provided\");\n    }\n    string[] parts3 = line3.trim().split(\" \");\n    if parts3.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts3 {\n        a.push(check 'int:fromString(part));\n    }\n    \n    float result = check solveWizards(n, l, k, p, a);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSample1() {\n    int n = 3;\n    int l = 1;\n    int k = 0;\n    int[] p = [10, 20, 30];\n    int[] a = [-1, -1, 2];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertEquals(result, 0.3, 0.000001);\n    }\n}\n\n@test:Config {}\nfunction testSample2() {\n    int n = 1;\n    int l = 1;\n    int k = 1;\n    int[] p = [100];\n    int[] a = [123];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertEquals(result, 1.0, 0.000001);\n    }\n}\n\n@test:Config {}\nfunction testNoWinsRequired() {\n    int n = 2;\n    int l = 0;\n    int k = 1;\n    int[] p = [50, 50];\n    int[] a = [-1, -1];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        // Should be 1.0 since we can lose all tours and still satisfy l = 0\n        test:assertTrue(result > 0.9);\n    }\n}\n\n@test:Config {}\nfunction testAllBags() {\n    int n = 2;\n    int l = 2;\n    int k = 0;\n    int[] p = [100, 100];\n    int[] a = [1, 1];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertEquals(result, 1.0, 0.000001);\n    }\n}\n```\n</TESTS>",
      "code": "// Dynamic Programming Approach:\n// State: dp[i][j][c] = probability of winning exactly j tours after i tours with capacity c\n// Transition: For each tour i, we either win (probability p[i]/100) or lose (1 - p[i]/100)\n// - If we win and it's a huge prize (a[i] == -1): need capacity > 0, capacity decreases by 1\n// - If we win and it's a bag (a[i] != -1): capacity increases by a[i]\n// - If we lose: capacity stays same\n// Answer: sum of dp[n][j][c] for all j >= l and c >= 0\n\nimport ballerina/io;\n\nfunction solveWizards(int n, int l, int k, int[] p, int[] a) returns float|error {\n    // dp[i][j][c] = probability after i tours, won j tours, capacity c\n    // We limit capacity to a reasonable max (sum of all bag capacities + k)\n    int maxCapacity = k;\n    foreach int ai in a {\n        if ai > 0 {\n            maxCapacity += ai;\n        }\n    }\n    maxCapacity = int:min(maxCapacity, 400); // Cap to avoid memory issues\n    \n    // Initialize DP table\n    float[][][] dp = [];\n    int i = 0;\n    while i <= n {\n        float[][] dpI = [];\n        int j = 0;\n        while j <= n {\n            float[] dpIJ = [];\n            int c = 0;\n            while c <= maxCapacity {\n                dpIJ.push(0.0);\n                c += 1;\n            }\n            dpI.push(dpIJ);\n            j += 1;\n        }\n        dp.push(dpI);\n        i += 1;\n    }\n    \n    // Base case: 0 tours, 0 wins, k capacity\n    if k <= maxCapacity {\n        dp[0][0][k] = 1.0;\n    }\n    \n    // Fill DP table\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j <= i {\n            int c = 0;\n            while c <= maxCapacity {\n                if dp[i][j][c] > 0.0 {\n                    float prob = dp[i][j][c];\n                    float winProb = <float>p[i] / 100.0;\n                    float loseProb = 1.0 - winProb;\n                    \n                    // Case 1: Lose this tour\n                    if c <= maxCapacity {\n                        dp[i + 1][j][c] += prob * loseProb;\n                    }\n                    \n                    // Case 2: Win this tour\n                    if a[i] == -1 {\n                        // Huge prize - need capacity\n                        if c > 0 {\n                            dp[i + 1][j + 1][c - 1] += prob * winProb;\n                        }\n                    } else {\n                        // Bag - increase capacity\n                        int newCapacity = c + a[i];\n                        if newCapacity > maxCapacity {\n                            newCapacity = maxCapacity;\n                        }\n                        dp[i + 1][j + 1][newCapacity] += prob * winProb;\n                    }\n                }\n                c += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Calculate answer: sum probabilities where j >= l\n    float answer = 0.0;\n    int j = l;\n    while j <= n {\n        int c = 0;\n        while c <= maxCapacity {\n            answer += dp[n][j][c];\n            c += 1;\n        }\n        j += 1;\n    }\n    \n    return answer;\n}\n\npublic function main() returns error? {\n    // Read first line: n, l, k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"No input provided\");\n    }\n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int l = check 'int:fromString(parts1[1]);\n    int k = check 'int:fromString(parts1[2]);\n    \n    // Read second line: probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"No probabilities provided\");\n    }\n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of probabilities\");\n    }\n    \n    int[] p = [];\n    foreach string part in parts2 {\n        p.push(check 'int:fromString(part));\n    }\n    \n    // Read third line: bag capacities or -1\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"No capacities provided\");\n    }\n    string[] parts3 = line3.trim().split(\" \");\n    if parts3.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts3 {\n        a.push(check 'int:fromString(part));\n    }\n    \n    float result = check solveWizards(n, l, k, p, a);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(107:36,107:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(121:36,121:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(136:36,136:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(107:36,107:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(121:36,121:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(136:36,136:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(107:36,107:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(121:36,121:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(136:36,136:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:12:00.309824",
      "status": "failed",
      "completion": "I need to fix the compilation errors. The main issue is that I'm using `split()` on strings, but in Ballerina the correct method is `regex:split()` from the `ballerina/regex` module, or I can use `string:split()` from `ballerina/lang.string`.\n\nLet me analyze the problem again:\n1. We have n tours with probabilities p[i] and prizes a[i]\n2. a[i] = -1 means huge prize (takes 1 space), a[i] > 0 means bag with capacity a[i]\n3. We start with k capacity\n4. We need to win at least l tours and be able to carry all huge prizes\n5. Use DP: dp[i][j][c] = probability after i tours, won j tours, with capacity c\n\nThe key fix: Use `re \"\"` syntax or import proper string splitting functionality.\n\n# Overview\n\nThis problem uses dynamic programming to calculate the probability of winning at least `l` tours while being able to carry all huge prizes home. The state is `dp[i][j][c]` representing the probability of winning exactly `j` tours after completing `i` tours with capacity `c` remaining. We transition by either winning or losing each tour, updating capacity accordingly.\n\n<CODE>\n```ballerina\n// Dynamic Programming Solution:\n// State: dp[i][j][c] = probability of being in state (i tours done, j tours won, c capacity remaining)\n// \n// For each tour i:\n//   - Win with probability p[i]/100:\n//     * If a[i] == -1 (huge prize): need c > 0, new capacity = c - 1\n//     * If a[i] > 0 (bag): new capacity = c + a[i]\n//   - Lose with probability (1 - p[i]/100): capacity unchanged\n//\n// Answer: Sum all dp[n][j][c] where j >= l (we won enough tours)\n\nimport ballerina/io;\nimport ballerina/lang.'int;\nimport ballerina/regex;\n\nfunction solveWizards(int n, int l, int k, int[] p, int[] a) returns float|error {\n    // Calculate maximum possible capacity to limit array size\n    int maxCapacity = k;\n    foreach int ai in a {\n        if ai > 0 {\n            maxCapacity += ai;\n        }\n    }\n    maxCapacity = int:min(maxCapacity, 400);\n    \n    // Initialize 3D DP array: dp[tours][wins][capacity]\n    float[][][] dp = [];\n    int i = 0;\n    while i <= n {\n        float[][] dpI = [];\n        int j = 0;\n        while j <= n {\n            float[] dpIJ = [];\n            int c = 0;\n            while c <= maxCapacity {\n                dpIJ.push(0.0);\n                c += 1;\n            }\n            dpI.push(dpIJ);\n            j += 1;\n        }\n        dp.push(dpI);\n        i += 1;\n    }\n    \n    // Base case: before any tour, 0 wins, k capacity\n    if k <= maxCapacity {\n        dp[0][0][k] = 1.0;\n    }\n    \n    // Fill DP table tour by tour\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j <= i {\n            int c = 0;\n            while c <= maxCapacity {\n                float currentProb = dp[i][j][c];\n                if currentProb > 0.0 {\n                    float winProb = <float>p[i] / 100.0;\n                    float loseProb = 1.0 - winProb;\n                    \n                    // Case 1: Lose this tour (capacity unchanged, wins unchanged)\n                    dp[i + 1][j][c] += currentProb * loseProb;\n                    \n                    // Case 2: Win this tour\n                    if a[i] == -1 {\n                        // Huge prize: need capacity > 0, lose 1 capacity\n                        if c > 0 {\n                            dp[i + 1][j + 1][c - 1] += currentProb * winProb;\n                        }\n                        // If c == 0, we can't take the prize, so we lose this scenario\n                    } else {\n                        // Bag: gain a[i] capacity\n                        int newCapacity = c + a[i];\n                        if newCapacity > maxCapacity {\n                            newCapacity = maxCapacity;\n                        }\n                        dp[i + 1][j + 1][newCapacity] += currentProb * winProb;\n                    }\n                }\n                c += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Sum probabilities where we won at least l tours\n    float answer = 0.0;\n    int j = l;\n    while j <= n {\n        int c = 0;\n        while c <= maxCapacity {\n            answer += dp[n][j][c];\n            c += 1;\n        }\n        j += 1;\n    }\n    \n    return answer;\n}\n\npublic function main() returns error? {\n    // Read first line: n l k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"No input provided\");\n    }\n    string trimmed1 = line1.trim();\n    string[] parts1 = regex:split(trimmed1, \" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int l = check 'int:fromString(parts1[1]);\n    int k = check 'int:fromString(parts1[2]);\n    \n    // Read second line: probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"No probabilities provided\");\n    }\n    string trimmed2 = line2.trim();\n    string[] parts2 = regex:split(trimmed2, \" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of probabilities\");\n    }\n    \n    int[] p = [];\n    foreach string part in parts2 {\n        p.push(check 'int:fromString(part));\n    }\n    \n    // Read third line: bag capacities or -1 for huge prizes\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"No capacities provided\");\n    }\n    string trimmed3 = line3.trim();\n    string[] parts3 = regex:split(trimmed3, \" \");\n    if parts3.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts3 {\n        a.push(check 'int:fromString(part));\n    }\n    \n    float result = check solveWizards(n, l, k, p, a);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSample1() {\n    int n = 3;\n    int l = 1;\n    int k = 0;\n    int[] p = [10, 20, 30];\n    int[] a = [-1, -1, 2];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertTrue((result - 0.3) < 0.000001 && (result - 0.3) > -0.000001);\n    }\n}\n\n@test:Config {}\nfunction testSample2() {\n    int n = 1;\n    int l = 1;\n    int k = 1;\n    int[] p = [100];\n    int[] a = [123];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertTrue((result - 1.0) < 0.000001 && (result - 1.0) > -0.000001);\n    }\n}\n\n@test:Config {}\nfunction testNoWinsRequired() {\n    int n = 2;\n    int l = 0;\n    int k = 1;\n    int[] p = [50, 50];\n    int[] a = [-1, -1];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        // With l=0, any outcome where we can carry prizes is valid\n        // This should be high probability\n        test:assertTrue(result > 0.5);\n    }\n}\n\n@test:Config {}\nfunction testAllBags() {\n    int n = 2;\n    int l = 2;\n    int k = 0;\n    int[] p = [100, 100];\n    int[] a = [1, 1];\n    \n    float|error result = solveWizards(n, l, k, p, a);\n    test:assertTrue(result is float);\n    if result is float {\n        // Win both tours (100% each), both give bags, so we can always carry\n        test:assertTrue((result - 1.0) < 0.000001 && (result - 1.0) > -0.000001);\n    }\n}\n```\n</TESTS>",
      "code": "// Dynamic Programming Solution:\n// State: dp[i][j][c] = probability of being in state (i tours done, j tours won, c capacity remaining)\n// \n// For each tour i:\n//   - Win with probability p[i]/100:\n//     * If a[i] == -1 (huge prize): need c > 0, new capacity = c - 1\n//     * If a[i] > 0 (bag): new capacity = c + a[i]\n//   - Lose with probability (1 - p[i]/100): capacity unchanged\n//\n// Answer: Sum all dp[n][j][c] where j >= l (we won enough tours)\n\nimport ballerina/io;\nimport ballerina/lang.'int;\nimport ballerina/regex;\n\nfunction solveWizards(int n, int l, int k, int[] p, int[] a) returns float|error {\n    // Calculate maximum possible capacity to limit array size\n    int maxCapacity = k;\n    foreach int ai in a {\n        if ai > 0 {\n            maxCapacity += ai;\n        }\n    }\n    maxCapacity = int:min(maxCapacity, 400);\n    \n    // Initialize 3D DP array: dp[tours][wins][capacity]\n    float[][][] dp = [];\n    int i = 0;\n    while i <= n {\n        float[][] dpI = [];\n        int j = 0;\n        while j <= n {\n            float[] dpIJ = [];\n            int c = 0;\n            while c <= maxCapacity {\n                dpIJ.push(0.0);\n                c += 1;\n            }\n            dpI.push(dpIJ);\n            j += 1;\n        }\n        dp.push(dpI);\n        i += 1;\n    }\n    \n    // Base case: before any tour, 0 wins, k capacity\n    if k <= maxCapacity {\n        dp[0][0][k] = 1.0;\n    }\n    \n    // Fill DP table tour by tour\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j <= i {\n            int c = 0;\n            while c <= maxCapacity {\n                float currentProb = dp[i][j][c];\n                if currentProb > 0.0 {\n                    float winProb = <float>p[i] / 100.0;\n                    float loseProb = 1.0 - winProb;\n                    \n                    // Case 1: Lose this tour (capacity unchanged, wins unchanged)\n                    dp[i + 1][j][c] += currentProb * loseProb;\n                    \n                    // Case 2: Win this tour\n                    if a[i] == -1 {\n                        // Huge prize: need capacity > 0, lose 1 capacity\n                        if c > 0 {\n                            dp[i + 1][j + 1][c - 1] += currentProb * winProb;\n                        }\n                        // If c == 0, we can't take the prize, so we lose this scenario\n                    } else {\n                        // Bag: gain a[i] capacity\n                        int newCapacity = c + a[i];\n                        if newCapacity > maxCapacity {\n                            newCapacity = maxCapacity;\n                        }\n                        dp[i + 1][j + 1][newCapacity] += currentProb * winProb;\n                    }\n                }\n                c += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Sum probabilities where we won at least l tours\n    float answer = 0.0;\n    int j = l;\n    while j <= n {\n        int c = 0;\n        while c <= maxCapacity {\n            answer += dp[n][j][c];\n            c += 1;\n        }\n        j += 1;\n    }\n    \n    return answer;\n}\n\npublic function main() returns error? {\n    // Read first line: n l k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"No input provided\");\n    }\n    string trimmed1 = line1.trim();\n    string[] parts1 = regex:split(trimmed1, \" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int l = check 'int:fromString(parts1[1]);\n    int k = check 'int:fromString(parts1[2]);\n    \n    // Read second line: probabilities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"No probabilities provided\");\n    }\n    string trimmed2 = line2.trim();\n    string[] parts2 = regex:split(trimmed2, \" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of probabilities\");\n    }\n    \n    int[] p = [];\n    foreach string part in parts2 {\n        p.push(check 'int:fromString(part));\n    }\n    \n    // Read third line: bag capacities or -1 for huge prizes\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"No capacities provided\");\n    }\n    string trimmed3 = line3.trim();\n    string[] parts3 = regex:split(trimmed3, \" \");\n    if parts3.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts3 {\n        a.push(check 'int:fromString(part));\n    }\n    \n    float result = check solveWizards(n, l, k, p, a);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "3 1 0\n10 20 30\n-1 -1 2\n",
          "expected_output": "0.300000000000\n",
          "actual_output": "0.21600000000000003\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T02:12:40.365731"
}