{
  "entry_id": "problem_0269",
  "problem_index": 269,
  "prompt": "Title: Treasure Hunt\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAfter the big birthday party, Katie still wanted Shiro to have some more fun. Later, she came up with a game called treasure hunt. Of course, she invited her best friends Kuro and Shiro to play with her.\n\nThe three friends are very smart so they passed all the challenges very quickly and finally reached the destination. But the treasure can only belong to one cat so they started to think of something which can determine who is worthy of the treasure. Instantly, Kuro came up with some ribbons.\n\nA random colorful ribbon is given to each of the cats. Each color of the ribbon can be represented as an uppercase or lowercase Latin letter. Let's call a consecutive subsequence of colors that appears in the ribbon a subribbon. The beauty of a ribbon is defined as the maximum number of times one of its subribbon appears in the ribbon. The more the subribbon appears, the more beautiful is the ribbon. For example, the ribbon aaaaaaa has the beauty of $7$ because its subribbon a appears $7$ times, and the ribbon abcdabc has the beauty of $2$ because its subribbon abc appears twice.\n\nThe rules are simple. The game will have $n$ turns. Every turn, each of the cats must change strictly one color (at one position) in his/her ribbon to an arbitrary color which is different from the unchanged one. For example, a ribbon aaab can be changed into acab in one turn. The one having the most beautiful ribbon after $n$ turns wins the treasure.\n\nCould you find out who is going to be the winner if they all play optimally?\n\nInput Specification:\nThe first line contains an integer $n$ ($0 \\leq n \\leq 10^{9}$) — the number of turns.\n\nNext 3 lines contain 3 ribbons of Kuro, Shiro and Katie one per line, respectively. Each ribbon is a string which contains no more than $10^{5}$ uppercase and lowercase Latin letters and is not empty. It is guaranteed that the length of all ribbons are equal for the purpose of fairness. Note that uppercase and lowercase letters are considered different colors.\n\nOutput Specification:\nPrint the name of the winner (\"Kuro\", \"Shiro\" or \"Katie\"). If there are at least two cats that share the maximum beauty, print \"Draw\".\n\nDemo Input:\n['3\\nKuroo\\nShiro\\nKatie\\n', '7\\ntreasurehunt\\nthreefriends\\nhiCodeforces\\n', '1\\nabcabc\\ncbabac\\nababca\\n', '15\\nfoPaErcvJ\\nmZaxowpbt\\nmkuOlaHRE\\n']\n\nDemo Output:\n['Kuro\\n', 'Shiro\\n', 'Katie\\n', 'Draw\\n']\n\nNote:\nIn the first example, after $3$ turns, Kuro can change his ribbon into ooooo, which has the beauty of $5$, while reaching such beauty for Shiro and Katie is impossible (both Shiro and Katie can reach the beauty of at most $4$, for example by changing Shiro's ribbon into SSiSS and changing Katie's ribbon into Kaaaa). Therefore, the winner is Kuro.\n\nIn the fourth example, since the length of each of the string is $9$ and the number of turn is $15$, everyone can change their ribbons in some way to reach the maximal beauty of $9$ by changing their strings into zzzzzzzzz after 9 turns, and repeatedly change their strings into azzzzzzzz and then into zzzzzzzzz thrice. Therefore, the game ends in a draw.",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem involves finding the winner of a treasure hunt game based on ribbon beauty optimization. The beauty of a ribbon is the maximum number of times a consecutive subsequence appears. After n turns where each cat changes exactly one character per turn, we need to determine who can achieve the highest beauty.\n\nKey insights:\n1. Initial beauty: Find the maximum count of any consecutive subsequence in each ribbon\n2. After n turns: Each cat can potentially increase their beauty by changing different characters to match\n3. The maximum achievable beauty is limited by the string length\n4. Special case: If n=0, use initial beauty; if n >= length, all can reach max beauty (length)\n5. If current max consecutive is (length-1) and n=1, changing one character gives length, but if n>1, we need to change back and forth, limiting us to (length-1)\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Calculate initial beauty: maximum count of any consecutive character subsequence\n// 2. For each ribbon, calculate potential beauty after n turns\n// 3. Special cases:\n//    - If n=0: use initial beauty\n//    - If initial has all same chars (beauty=length): stay at length (must change then change back)\n//    - If can reach length in <= n turns: check if n parity allows staying at length\n//    - Otherwise: can improve by min(n, length - current_max_consecutive)\n\nimport ballerina/io;\n\n// Find maximum consecutive character count in a string\nfunction maxConsecutive(string s) returns int {\n    if s.length() == 0 {\n        return 0;\n    }\n    \n    int maxCount = 1;\n    int currentCount = 1;\n    \n    int i = 1;\n    while i < s.length() {\n        if s[i] == s[i - 1] {\n            currentCount += 1;\n            if currentCount > maxCount {\n                maxCount = currentCount;\n            }\n        } else {\n            currentCount = 1;\n        }\n        i += 1;\n    }\n    \n    return maxCount;\n}\n\n// Calculate beauty after n turns\nfunction beautyAfterNTurns(string ribbon, int n) returns int {\n    int len = ribbon.length();\n    int initialBeauty = maxConsecutive(ribbon);\n    \n    // No turns, return initial beauty\n    if n == 0 {\n        return initialBeauty;\n    }\n    \n    // Maximum possible beauty is the length\n    int maxPossible = len;\n    \n    // If already at max, we must change one, so best is len-1\n    if initialBeauty == len {\n        return len - 1;\n    }\n    \n    // Calculate turns needed to reach max beauty\n    int turnsToMax = len - initialBeauty;\n    \n    // If we can reach max and have even number of remaining turns (or exactly right turns)\n    if n >= turnsToMax {\n        // Special case: if we need 1 turn to reach max but have more turns\n        // we must keep changing, so we oscillate between len and len-1\n        if turnsToMax == 1 && n > 1 {\n            return len - 1;\n        }\n        return maxPossible;\n    }\n    \n    // Otherwise, we can improve by n characters\n    return initialBeauty + n;\n}\n\npublic function main() returns error? {\n    // Read number of turns\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of turns\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read three ribbons\n    string? kuroLine = io:readln();\n    if kuroLine is () {\n        return error(\"Failed to read Kuro's ribbon\");\n    }\n    string kuro = kuroLine.trim();\n    \n    string? shiroLine = io:readln();\n    if shiroLine is () {\n        return error(\"Failed to read Shiro's ribbon\");\n    }\n    string shiro = shiroLine.trim();\n    \n    string? katieLine = io:readln();\n    if katieLine is () {\n        return error(\"Failed to read Katie's ribbon\");\n    }\n    string katie = katieLine.trim();\n    \n    // Calculate beauties after n turns\n    int kuroBeauty = beautyAfterNTurns(kuro, n);\n    int shiroBeauty = beautyAfterNTurns(shiro, n);\n    int katieBeauty = beautyAfterNTurns(katie, n);\n    \n    // Determine winner\n    int maxBeauty = kuroBeauty;\n    if shiroBeauty > maxBeauty {\n        maxBeauty = shiroBeauty;\n    }\n    if katieBeauty > maxBeauty {\n        maxBeauty = katieBeauty;\n    }\n    \n    int winners = 0;\n    if kuroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if shiroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if katieBeauty == maxBeauty {\n        winners += 1;\n    }\n    \n    if winners >= 2 {\n        io:println(\"Draw\");\n    } else if kuroBeauty == maxBeauty {\n        io:println(\"Kuro\");\n    } else if shiroBeauty == maxBeauty {\n        io:println(\"Shiro\");\n    } else {\n        io:println(\"Katie\");\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxConsecutive() {\n    test:assertEquals(maxConsecutive(\"aaaaaaa\"), 7);\n    test:assertEquals(maxConsecutive(\"abcdabc\"), 1);\n    test:assertEquals(maxConsecutive(\"aabbcc\"), 2);\n    test:assertEquals(maxConsecutive(\"a\"), 1);\n}\n\n@test:Config {}\nfunction testBeautyAfterNTurns() {\n    // Test with n=0, should return initial beauty\n    test:assertEquals(beautyAfterNTurns(\"Kuroo\", 0), 1);\n    \n    // Test where we can reach max length\n    test:assertEquals(beautyAfterNTurns(\"Kuroo\", 3), 5);\n    \n    // Test with string already at max (all same)\n    test:assertEquals(beautyAfterNTurns(\"aaaaa\", 1), 4);\n    \n    // Test with n=1 when one change reaches max\n    test:assertEquals(beautyAfterNTurns(\"aaab\", 1), 4);\n}\n\n@test:Config {}\nfunction testBeautyScenarios() {\n    // Test case from example 1: Kuro with n=3\n    int kuroBeauty = beautyAfterNTurns(\"Kuroo\", 3);\n    test:assertEquals(kuroBeauty, 5);\n    \n    // Test case with partial improvement\n    int beauty = beautyAfterNTurns(\"abc\", 1);\n    test:assertEquals(beauty, 2);\n    \n    // Test case with already maximum consecutive\n    int maxBeauty = beautyAfterNTurns(\"zzz\", 5);\n    test:assertEquals(maxBeauty, 2);\n    \n    // Test edge case with single character\n    int singleChar = beautyAfterNTurns(\"a\", 0);\n    test:assertEquals(singleChar, 1);\n}\n\n@test:Config {}\nfunction testWinnerLogic() {\n    // Simulate example 4: all should reach same max beauty\n    int len = 9;\n    int n = 15;\n    int beauty1 = beautyAfterNTurns(\"foPaErcvJ\", n);\n    int beauty2 = beautyAfterNTurns(\"mZaxowpbt\", n);\n    int beauty3 = beautyAfterNTurns(\"mkuOlaHRE\", n);\n    \n    // All should be equal (draw scenario)\n    test:assertEquals(beauty1, beauty2);\n    test:assertEquals(beauty2, beauty3);\n    test:assertEquals(beauty1, 9);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Calculate initial beauty: maximum count of any consecutive character subsequence\n// 2. For each ribbon, calculate potential beauty after n turns\n// 3. Special cases:\n//    - If n=0: use initial beauty\n//    - If initial has all same chars (beauty=length): stay at length (must change then change back)\n//    - If can reach length in <= n turns: check if n parity allows staying at length\n//    - Otherwise: can improve by min(n, length - current_max_consecutive)\n\nimport ballerina/io;\n\n// Find maximum consecutive character count in a string\nfunction maxConsecutive(string s) returns int {\n    if s.length() == 0 {\n        return 0;\n    }\n    \n    int maxCount = 1;\n    int currentCount = 1;\n    \n    int i = 1;\n    while i < s.length() {\n        if s[i] == s[i - 1] {\n            currentCount += 1;\n            if currentCount > maxCount {\n                maxCount = currentCount;\n            }\n        } else {\n            currentCount = 1;\n        }\n        i += 1;\n    }\n    \n    return maxCount;\n}\n\n// Calculate beauty after n turns\nfunction beautyAfterNTurns(string ribbon, int n) returns int {\n    int len = ribbon.length();\n    int initialBeauty = maxConsecutive(ribbon);\n    \n    // No turns, return initial beauty\n    if n == 0 {\n        return initialBeauty;\n    }\n    \n    // Maximum possible beauty is the length\n    int maxPossible = len;\n    \n    // If already at max, we must change one, so best is len-1\n    if initialBeauty == len {\n        return len - 1;\n    }\n    \n    // Calculate turns needed to reach max beauty\n    int turnsToMax = len - initialBeauty;\n    \n    // If we can reach max and have even number of remaining turns (or exactly right turns)\n    if n >= turnsToMax {\n        // Special case: if we need 1 turn to reach max but have more turns\n        // we must keep changing, so we oscillate between len and len-1\n        if turnsToMax == 1 && n > 1 {\n            return len - 1;\n        }\n        return maxPossible;\n    }\n    \n    // Otherwise, we can improve by n characters\n    return initialBeauty + n;\n}\n\npublic function main() returns error? {\n    // Read number of turns\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of turns\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read three ribbons\n    string? kuroLine = io:readln();\n    if kuroLine is () {\n        return error(\"Failed to read Kuro's ribbon\");\n    }\n    string kuro = kuroLine.trim();\n    \n    string? shiroLine = io:readln();\n    if shiroLine is () {\n        return error(\"Failed to read Shiro's ribbon\");\n    }\n    string shiro = shiroLine.trim();\n    \n    string? katieLine = io:readln();\n    if katieLine is () {\n        return error(\"Failed to read Katie's ribbon\");\n    }\n    string katie = katieLine.trim();\n    \n    // Calculate beauties after n turns\n    int kuroBeauty = beautyAfterNTurns(kuro, n);\n    int shiroBeauty = beautyAfterNTurns(shiro, n);\n    int katieBeauty = beautyAfterNTurns(katie, n);\n    \n    // Determine winner\n    int maxBeauty = kuroBeauty;\n    if shiroBeauty > maxBeauty {\n        maxBeauty = shiroBeauty;\n    }\n    if katieBeauty > maxBeauty {\n        maxBeauty = katieBeauty;\n    }\n    \n    int winners = 0;\n    if kuroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if shiroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if katieBeauty == maxBeauty {\n        winners += 1;\n    }\n    \n    if winners >= 2 {\n        io:println(\"Draw\");\n    } else if kuroBeauty == maxBeauty {\n        io:println(\"Kuro\");\n    } else if shiroBeauty == maxBeauty {\n        io:println(\"Shiro\");\n    } else {\n        io:println(\"Katie\");\n    }\n    \n    return;\n}",
  "tests_passed": 3,
  "tests_total": 4,
  "tests_pass_rate": 0.75,
  "validation_msg": "Passed 3/4 tests (75.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:56:02.162989",
      "status": "success",
      "completion": "# Overview\nThis problem involves finding the winner of a treasure hunt game based on ribbon beauty optimization. The beauty of a ribbon is the maximum number of times a consecutive subsequence appears. After n turns where each cat changes exactly one character per turn, we need to determine who can achieve the highest beauty.\n\nKey insights:\n1. Initial beauty: Find the maximum count of any consecutive subsequence in each ribbon\n2. After n turns: Each cat can potentially increase their beauty by changing different characters to match\n3. The maximum achievable beauty is limited by the string length\n4. Special case: If n=0, use initial beauty; if n >= length, all can reach max beauty (length)\n5. If current max consecutive is (length-1) and n=1, changing one character gives length, but if n>1, we need to change back and forth, limiting us to (length-1)\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Calculate initial beauty: maximum count of any consecutive character subsequence\n// 2. For each ribbon, calculate potential beauty after n turns\n// 3. Special cases:\n//    - If n=0: use initial beauty\n//    - If initial has all same chars (beauty=length): stay at length (must change then change back)\n//    - If can reach length in <= n turns: check if n parity allows staying at length\n//    - Otherwise: can improve by min(n, length - current_max_consecutive)\n\nimport ballerina/io;\n\n// Find maximum consecutive character count in a string\nfunction maxConsecutive(string s) returns int {\n    if s.length() == 0 {\n        return 0;\n    }\n    \n    int maxCount = 1;\n    int currentCount = 1;\n    \n    int i = 1;\n    while i < s.length() {\n        if s[i] == s[i - 1] {\n            currentCount += 1;\n            if currentCount > maxCount {\n                maxCount = currentCount;\n            }\n        } else {\n            currentCount = 1;\n        }\n        i += 1;\n    }\n    \n    return maxCount;\n}\n\n// Calculate beauty after n turns\nfunction beautyAfterNTurns(string ribbon, int n) returns int {\n    int len = ribbon.length();\n    int initialBeauty = maxConsecutive(ribbon);\n    \n    // No turns, return initial beauty\n    if n == 0 {\n        return initialBeauty;\n    }\n    \n    // Maximum possible beauty is the length\n    int maxPossible = len;\n    \n    // If already at max, we must change one, so best is len-1\n    if initialBeauty == len {\n        return len - 1;\n    }\n    \n    // Calculate turns needed to reach max beauty\n    int turnsToMax = len - initialBeauty;\n    \n    // If we can reach max and have even number of remaining turns (or exactly right turns)\n    if n >= turnsToMax {\n        // Special case: if we need 1 turn to reach max but have more turns\n        // we must keep changing, so we oscillate between len and len-1\n        if turnsToMax == 1 && n > 1 {\n            return len - 1;\n        }\n        return maxPossible;\n    }\n    \n    // Otherwise, we can improve by n characters\n    return initialBeauty + n;\n}\n\npublic function main() returns error? {\n    // Read number of turns\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of turns\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read three ribbons\n    string? kuroLine = io:readln();\n    if kuroLine is () {\n        return error(\"Failed to read Kuro's ribbon\");\n    }\n    string kuro = kuroLine.trim();\n    \n    string? shiroLine = io:readln();\n    if shiroLine is () {\n        return error(\"Failed to read Shiro's ribbon\");\n    }\n    string shiro = shiroLine.trim();\n    \n    string? katieLine = io:readln();\n    if katieLine is () {\n        return error(\"Failed to read Katie's ribbon\");\n    }\n    string katie = katieLine.trim();\n    \n    // Calculate beauties after n turns\n    int kuroBeauty = beautyAfterNTurns(kuro, n);\n    int shiroBeauty = beautyAfterNTurns(shiro, n);\n    int katieBeauty = beautyAfterNTurns(katie, n);\n    \n    // Determine winner\n    int maxBeauty = kuroBeauty;\n    if shiroBeauty > maxBeauty {\n        maxBeauty = shiroBeauty;\n    }\n    if katieBeauty > maxBeauty {\n        maxBeauty = katieBeauty;\n    }\n    \n    int winners = 0;\n    if kuroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if shiroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if katieBeauty == maxBeauty {\n        winners += 1;\n    }\n    \n    if winners >= 2 {\n        io:println(\"Draw\");\n    } else if kuroBeauty == maxBeauty {\n        io:println(\"Kuro\");\n    } else if shiroBeauty == maxBeauty {\n        io:println(\"Shiro\");\n    } else {\n        io:println(\"Katie\");\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxConsecutive() {\n    test:assertEquals(maxConsecutive(\"aaaaaaa\"), 7);\n    test:assertEquals(maxConsecutive(\"abcdabc\"), 1);\n    test:assertEquals(maxConsecutive(\"aabbcc\"), 2);\n    test:assertEquals(maxConsecutive(\"a\"), 1);\n}\n\n@test:Config {}\nfunction testBeautyAfterNTurns() {\n    // Test with n=0, should return initial beauty\n    test:assertEquals(beautyAfterNTurns(\"Kuroo\", 0), 1);\n    \n    // Test where we can reach max length\n    test:assertEquals(beautyAfterNTurns(\"Kuroo\", 3), 5);\n    \n    // Test with string already at max (all same)\n    test:assertEquals(beautyAfterNTurns(\"aaaaa\", 1), 4);\n    \n    // Test with n=1 when one change reaches max\n    test:assertEquals(beautyAfterNTurns(\"aaab\", 1), 4);\n}\n\n@test:Config {}\nfunction testBeautyScenarios() {\n    // Test case from example 1: Kuro with n=3\n    int kuroBeauty = beautyAfterNTurns(\"Kuroo\", 3);\n    test:assertEquals(kuroBeauty, 5);\n    \n    // Test case with partial improvement\n    int beauty = beautyAfterNTurns(\"abc\", 1);\n    test:assertEquals(beauty, 2);\n    \n    // Test case with already maximum consecutive\n    int maxBeauty = beautyAfterNTurns(\"zzz\", 5);\n    test:assertEquals(maxBeauty, 2);\n    \n    // Test edge case with single character\n    int singleChar = beautyAfterNTurns(\"a\", 0);\n    test:assertEquals(singleChar, 1);\n}\n\n@test:Config {}\nfunction testWinnerLogic() {\n    // Simulate example 4: all should reach same max beauty\n    int len = 9;\n    int n = 15;\n    int beauty1 = beautyAfterNTurns(\"foPaErcvJ\", n);\n    int beauty2 = beautyAfterNTurns(\"mZaxowpbt\", n);\n    int beauty3 = beautyAfterNTurns(\"mkuOlaHRE\", n);\n    \n    // All should be equal (draw scenario)\n    test:assertEquals(beauty1, beauty2);\n    test:assertEquals(beauty2, beauty3);\n    test:assertEquals(beauty1, 9);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Calculate initial beauty: maximum count of any consecutive character subsequence\n// 2. For each ribbon, calculate potential beauty after n turns\n// 3. Special cases:\n//    - If n=0: use initial beauty\n//    - If initial has all same chars (beauty=length): stay at length (must change then change back)\n//    - If can reach length in <= n turns: check if n parity allows staying at length\n//    - Otherwise: can improve by min(n, length - current_max_consecutive)\n\nimport ballerina/io;\n\n// Find maximum consecutive character count in a string\nfunction maxConsecutive(string s) returns int {\n    if s.length() == 0 {\n        return 0;\n    }\n    \n    int maxCount = 1;\n    int currentCount = 1;\n    \n    int i = 1;\n    while i < s.length() {\n        if s[i] == s[i - 1] {\n            currentCount += 1;\n            if currentCount > maxCount {\n                maxCount = currentCount;\n            }\n        } else {\n            currentCount = 1;\n        }\n        i += 1;\n    }\n    \n    return maxCount;\n}\n\n// Calculate beauty after n turns\nfunction beautyAfterNTurns(string ribbon, int n) returns int {\n    int len = ribbon.length();\n    int initialBeauty = maxConsecutive(ribbon);\n    \n    // No turns, return initial beauty\n    if n == 0 {\n        return initialBeauty;\n    }\n    \n    // Maximum possible beauty is the length\n    int maxPossible = len;\n    \n    // If already at max, we must change one, so best is len-1\n    if initialBeauty == len {\n        return len - 1;\n    }\n    \n    // Calculate turns needed to reach max beauty\n    int turnsToMax = len - initialBeauty;\n    \n    // If we can reach max and have even number of remaining turns (or exactly right turns)\n    if n >= turnsToMax {\n        // Special case: if we need 1 turn to reach max but have more turns\n        // we must keep changing, so we oscillate between len and len-1\n        if turnsToMax == 1 && n > 1 {\n            return len - 1;\n        }\n        return maxPossible;\n    }\n    \n    // Otherwise, we can improve by n characters\n    return initialBeauty + n;\n}\n\npublic function main() returns error? {\n    // Read number of turns\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of turns\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read three ribbons\n    string? kuroLine = io:readln();\n    if kuroLine is () {\n        return error(\"Failed to read Kuro's ribbon\");\n    }\n    string kuro = kuroLine.trim();\n    \n    string? shiroLine = io:readln();\n    if shiroLine is () {\n        return error(\"Failed to read Shiro's ribbon\");\n    }\n    string shiro = shiroLine.trim();\n    \n    string? katieLine = io:readln();\n    if katieLine is () {\n        return error(\"Failed to read Katie's ribbon\");\n    }\n    string katie = katieLine.trim();\n    \n    // Calculate beauties after n turns\n    int kuroBeauty = beautyAfterNTurns(kuro, n);\n    int shiroBeauty = beautyAfterNTurns(shiro, n);\n    int katieBeauty = beautyAfterNTurns(katie, n);\n    \n    // Determine winner\n    int maxBeauty = kuroBeauty;\n    if shiroBeauty > maxBeauty {\n        maxBeauty = shiroBeauty;\n    }\n    if katieBeauty > maxBeauty {\n        maxBeauty = katieBeauty;\n    }\n    \n    int winners = 0;\n    if kuroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if shiroBeauty == maxBeauty {\n        winners += 1;\n    }\n    if katieBeauty == maxBeauty {\n        winners += 1;\n    }\n    \n    if winners >= 2 {\n        io:println(\"Draw\");\n    } else if kuroBeauty == maxBeauty {\n        io:println(\"Kuro\");\n    } else if shiroBeauty == maxBeauty {\n        io:println(\"Shiro\");\n    } else {\n        io:println(\"Katie\");\n    }\n    \n    return;\n}",
      "tests_passed": 3,
      "tests_total": 4,
      "tests_pass_rate": 0.75,
      "validation_msg": "Passed 3/4 tests (75.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T04:56:53.297434"
}