{
  "entry_id": "problem_0051",
  "problem_index": 51,
  "prompt": "Title: New Year Contest\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAs Gerald sets the table, Alexander sends the greeting cards, and Sergey and his twins create an army of clone snowmen, Gennady writes a New Year contest.\n\nThe New Year contest begins at 18:00 (6.00 P.M.) on December 31 and ends at 6:00 (6.00 A.M.) on January 1. There are *n* problems for the contest. The penalty time for each solved problem is set as the distance from the moment of solution submission to the New Year in minutes. For example, the problem submitted at 21:00 (9.00 P.M.) gets penalty time 180, as well as the problem submitted at 3:00 (3.00 A.M.). The total penalty time is calculated as the sum of penalty time for all solved problems. It is allowed to submit a problem exactly at the end of the contest, at 6:00 (6.00 A.M.).\n\nGennady opened the problems exactly at 18:00 (6.00 P.M.) and managed to estimate their complexity during the first 10 minutes of the contest. He believes that writing a solution for the *i*-th problem will take *a**i* minutes. Gennady can submit a solution for evaluation at any time after he completes writing it. Probably he will have to distract from writing some solution to send the solutions of other problems for evaluation. The time needed to send the solutions can be neglected, i.e. this time can be considered to equal zero. Gennady can simultaneously submit multiple solutions. Besides, he can move at any time from writing one problem to another, and then return to the first problem from the very same place, where he has left it. Thus the total solution writing time of the *i*-th problem always equals *a**i* minutes. Of course, Gennady does not commit wrong attempts, and his solutions are always correct and are accepted from the first attempt. He can begin to write the solutions starting from 18:10 (6.10 P.M.).\n\nHelp Gennady choose from the strategies that help him solve the maximum possible number of problems, the one with which his total penalty time will be minimum.\n\nInput Specification:\nThe first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of the problems. The next line contains *n* space-separated integers *a**i* (1<=≤<=*a**i*<=≤<=720) — each number shows how much time in minutes Gennady will spend writing a solution to the problem.\n\nOutput Specification:\nPrint two integers — the number of problems Gennady will solve and the total penalty time considering that he chooses the optimal strategy.\n\nDemo Input:\n['3\\n30 330 720\\n']\n\nDemo Output:\n['2 10\\n']\n\nNote:\nIn the sample, one of Gennady's possible optimal strategies is as follows. At 18:10 (6:10 PM) he begins to write the first problem and solves it in 30 minutes (18:40 or 6.40 P.M.). At 18:40 (6.40 P.M.) he begins to write the second problem. There are 320 minutes left before the New Year, so Gennady does not have the time to finish writing the second problem before the New Year. At 0:00 (12.00 A.M.) he distracts from the second problem, submits the first one, and returns immediately to writing the second problem. At 0:10 (0.10 A.M.), he completes the solution for the second problem, submits it and gets 10 minute penalty time. Note that as the total duration of the contest is 720 minutes and Gennady has already spent 10 minutes on reading the problems, he will not have time to solve the third problem during the contest. Yes, such problems happen to exist.\n\nCompetitions by the given rules are held annually on the site http://b23.ru/3wvc",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\n\nThis problem is about optimizing the submission strategy for a New Year programming contest. The key insights are:\n\n1. Contest runs from 18:00 (Dec 31) to 6:00 (Jan 1) = 720 minutes total\n2. First 10 minutes spent reading problems, so 710 minutes available for solving\n3. Penalty is the distance from submission time to midnight (New Year at 0:00)\n4. Problems submitted before midnight get penalty = (minutes until midnight)\n5. Problems submitted after midnight get penalty = (minutes after midnight)\n6. Optimal strategy: solve problems in ascending order of time (greedy), and submit strategically to minimize penalty\n\nKey insight for penalty calculation:\n- If we complete a problem at time T (from 18:10):\n  - If T <= 350 (before midnight): penalty = 350 - T (submit immediately, penalty is time to midnight)\n  - If T > 350 (after midnight): penalty = T - 350 (submit immediately, penalty is time after midnight)\n- BUT we can also hold submissions! Submit all problems completed before midnight AT midnight (0 penalty), and problems after midnight immediately.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Contest: 720 minutes total (18:00 to 6:00), first 10 minutes for reading = 710 minutes for solving\n// 2. Time from 18:10 to midnight is 350 minutes\n// 3. Penalty calculation: distance from submission time to midnight\n//    - Problems completed before midnight: can be submitted at midnight (0 penalty)\n//    - Problems completed after midnight: submitted immediately (penalty = time after midnight)\n// 4. Strategy: Sort problems by time (greedy), solve as many as possible, minimize penalty\n// 5. For problems finished before midnight, we submit them all at midnight (0 penalty each)\n// 6. For problems finished after midnight, we submit immediately (penalty accumulates)\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction solveNewYearContest(int[] times) returns [int, int] {\n    // Sort times in ascending order to minimize penalty (greedy approach)\n    int[] sortedTimes = times.clone();\n    int n = sortedTimes.length();\n    \n    // Bubble sort (simple and works for n <= 100)\n    int i = 0;\n    while i < n {\n        int j = 0;\n        while j < n - 1 - i {\n            if sortedTimes[j] > sortedTimes[j + 1] {\n                int temp = sortedTimes[j];\n                sortedTimes[j] = sortedTimes[j + 1];\n                sortedTimes[j + 1] = temp;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    int availableTime = 710; // Total time available (720 - 10 for reading)\n    int timeToMidnight = 350; // Time from 18:10 to 00:00\n    \n    int problemsSolved = 0;\n    int totalPenalty = 0;\n    int currentTime = 0; // Time elapsed from 18:10\n    \n    foreach int problemTime in sortedTimes {\n        // Check if we can solve this problem within available time\n        if currentTime + problemTime <= availableTime {\n            currentTime += problemTime;\n            problemsSolved += 1;\n            \n            // Calculate penalty for this problem\n            // Strategy: Submit problems completed before midnight AT midnight (0 penalty)\n            // Submit problems completed after midnight immediately\n            if currentTime <= timeToMidnight {\n                // Problem completed before midnight, submit at midnight (0 penalty)\n                totalPenalty += 0;\n            } else {\n                // Problem completed after midnight, submit immediately\n                // Penalty = time after midnight\n                int timeAfterMidnight = currentTime - timeToMidnight;\n                totalPenalty += timeAfterMidnight;\n            }\n        } else {\n            // Cannot solve this problem within available time\n            break;\n        }\n    }\n    \n    return [problemsSolved, totalPenalty];\n}\n\npublic function main() returns error? {\n    // Read number of problems\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read problem times\n    string? timesLine = io:readln();\n    if timesLine is () {\n        io:println(\"Error: No times provided\");\n        return;\n    }\n    \n    // Parse the times using regex:split\n    string:RegExp regex = re ` `;\n    string[] timeParts = regex.split(timesLine.trim());\n    int[] times = [];\n    \n    foreach string part in timeParts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int time = check langint:fromString(trimmedPart);\n            times.push(time);\n        }\n    }\n    \n    // Solve the problem\n    [int, int] result = solveNewYearContest(times);\n    io:println(result[0].toString() + \" \" + result[1].toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSampleCase() {\n    int[] times = [30, 330, 720];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 2, \"Should solve 2 problems\");\n    test:assertEquals(result[1], 10, \"Total penalty should be 10\");\n}\n\n@test:Config {}\nfunction testAllProblemsBeforeMidnight() {\n    // All problems can be completed before midnight\n    int[] times = [50, 100, 150];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 3, \"Should solve 3 problems\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0 (all submitted at midnight)\");\n}\n\n@test:Config {}\nfunction testSingleProblemAfterMidnight() {\n    // One problem that takes 400 minutes (finishes 50 minutes after midnight)\n    int[] times = [400];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 1, \"Should solve 1 problem\");\n    test:assertEquals(result[1], 50, \"Penalty should be 50 minutes\");\n}\n\n@test:Config {}\nfunction testNoProblemsCanBeSolved() {\n    // Problem that takes more than available time\n    int[] times = [720];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 0, \"Should solve 0 problems\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0\");\n}\n\n@test:Config {}\nfunction testMultipleProblemsAfterMidnight() {\n    // Multiple problems, some before, some after midnight\n    int[] times = [200, 200, 200];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 3, \"Should solve 3 problems\");\n    // First: 200 (before midnight, 0 penalty), Second: 400 (50 after, penalty 50), Third: 600 (250 after, penalty 250)\n    // Total penalty = 0 + 50 + 250 = 300\n    test:assertEquals(result[1], 300, \"Total penalty should be 300\");\n}\n\n@test:Config {}\nfunction testExactlyAtMidnight() {\n    // Problem completed exactly at midnight\n    int[] times = [350];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 1, \"Should solve 1 problem\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0 (submitted at midnight)\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Contest: 720 minutes total (18:00 to 6:00), first 10 minutes for reading = 710 minutes for solving\n// 2. Time from 18:10 to midnight is 350 minutes\n// 3. Penalty calculation: distance from submission time to midnight\n//    - Problems completed before midnight: can be submitted at midnight (0 penalty)\n//    - Problems completed after midnight: submitted immediately (penalty = time after midnight)\n// 4. Strategy: Sort problems by time (greedy), solve as many as possible, minimize penalty\n// 5. For problems finished before midnight, we submit them all at midnight (0 penalty each)\n// 6. For problems finished after midnight, we submit immediately (penalty accumulates)\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction solveNewYearContest(int[] times) returns [int, int] {\n    // Sort times in ascending order to minimize penalty (greedy approach)\n    int[] sortedTimes = times.clone();\n    int n = sortedTimes.length();\n    \n    // Bubble sort (simple and works for n <= 100)\n    int i = 0;\n    while i < n {\n        int j = 0;\n        while j < n - 1 - i {\n            if sortedTimes[j] > sortedTimes[j + 1] {\n                int temp = sortedTimes[j];\n                sortedTimes[j] = sortedTimes[j + 1];\n                sortedTimes[j + 1] = temp;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    int availableTime = 710; // Total time available (720 - 10 for reading)\n    int timeToMidnight = 350; // Time from 18:10 to 00:00\n    \n    int problemsSolved = 0;\n    int totalPenalty = 0;\n    int currentTime = 0; // Time elapsed from 18:10\n    \n    foreach int problemTime in sortedTimes {\n        // Check if we can solve this problem within available time\n        if currentTime + problemTime <= availableTime {\n            currentTime += problemTime;\n            problemsSolved += 1;\n            \n            // Calculate penalty for this problem\n            // Strategy: Submit problems completed before midnight AT midnight (0 penalty)\n            // Submit problems completed after midnight immediately\n            if currentTime <= timeToMidnight {\n                // Problem completed before midnight, submit at midnight (0 penalty)\n                totalPenalty += 0;\n            } else {\n                // Problem completed after midnight, submit immediately\n                // Penalty = time after midnight\n                int timeAfterMidnight = currentTime - timeToMidnight;\n                totalPenalty += timeAfterMidnight;\n            }\n        } else {\n            // Cannot solve this problem within available time\n            break;\n        }\n    }\n    \n    return [problemsSolved, totalPenalty];\n}\n\npublic function main() returns error? {\n    // Read number of problems\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read problem times\n    string? timesLine = io:readln();\n    if timesLine is () {\n        io:println(\"Error: No times provided\");\n        return;\n    }\n    \n    // Parse the times using regex:split\n    string:RegExp regex = re ` `;\n    string[] timeParts = regex.split(timesLine.trim());\n    int[] times = [];\n    \n    foreach string part in timeParts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int time = check langint:fromString(trimmedPart);\n            times.push(time);\n        }\n    }\n    \n    // Solve the problem\n    [int, int] result = solveNewYearContest(times);\n    io:println(result[0].toString() + \" \" + result[1].toString());\n}",
  "tests_passed": 1,
  "tests_total": 1,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 1/1 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:49:23.803274",
      "status": "failed",
      "completion": "# Overview\n\nThis problem is about optimizing the submission strategy for a programming contest. The key insights are:\n1. Contest runs from 18:00 (Dec 31) to 6:00 (Jan 1) = 720 minutes total\n2. First 10 minutes spent reading problems, so 710 minutes available for solving\n3. Penalty is the distance from submission time to midnight (0:00)\n4. We want to maximize problems solved, then minimize total penalty\n5. Optimal strategy: solve problems in ascending order of time (greedy approach)\n6. Submit problems strategically - before midnight if they finish before, or after midnight\n\nThe strategy is:\n- Sort problems by time required (ascending)\n- Solve as many as possible within 710 minutes\n- For penalty calculation: if a problem is completed before midnight (350 minutes from start), submit at midnight (0 penalty). Otherwise, submit immediately after completion (penalty = time after midnight).\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Contest duration: 720 minutes (18:00 to 6:00), first 10 minutes for reading, so 710 minutes available\n// 2. Time from 18:10 to midnight (0:00) is 350 minutes\n// 3. To minimize penalty: complete problems in order of increasing time (greedy)\n// 4. For each problem:\n//    - If completed before midnight: submit at midnight (0 penalty)\n//    - If completed after midnight: submit immediately (penalty = minutes after midnight)\n// 5. We want to maximize problems solved first, then minimize penalty\n\nimport ballerina/io;\n\nfunction solveNewYearContest(int[] times) returns [int, int] {\n    // Sort times in ascending order to minimize penalty\n    int[] sortedTimes = times.clone();\n    sortedTimes.sort();\n    \n    int availableTime = 710; // Total time available (720 - 10 for reading)\n    int timeToMidnight = 350; // Time from 18:10 to 00:00\n    \n    int problemsSolved = 0;\n    int totalPenalty = 0;\n    int currentTime = 0; // Time elapsed from 18:10\n    \n    foreach int problemTime in sortedTimes {\n        // Check if we can solve this problem within available time\n        if currentTime + problemTime <= availableTime {\n            currentTime += problemTime;\n            problemsSolved += 1;\n            \n            // Calculate penalty for this problem\n            if currentTime <= timeToMidnight {\n                // Problem completed before midnight, submit at midnight (0 penalty)\n                totalPenalty += 0;\n            } else {\n                // Problem completed after midnight, penalty = time after midnight\n                int timeAfterMidnight = currentTime - timeToMidnight;\n                totalPenalty += timeAfterMidnight;\n            }\n        } else {\n            // Cannot solve this problem, stop\n            break;\n        }\n    }\n    \n    return [problemsSolved, totalPenalty];\n}\n\npublic function main() returns error? {\n    // Read number of problems\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read problem times\n    string? timesLine = io:readln();\n    if timesLine is () {\n        io:println(\"Error: No times provided\");\n        return;\n    }\n    \n    string[] timeParts = timesLine.trim().split(\" \");\n    int[] times = [];\n    \n    foreach string part in timeParts {\n        int time = check 'int:fromString(part.trim());\n        times.push(time);\n    }\n    \n    // Solve the problem\n    [int, int] result = solveNewYearContest(times);\n    io:println(result[0].toString() + \" \" + result[1].toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSampleCase() {\n    int[] times = [30, 330, 720];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 2, \"Should solve 2 problems\");\n    test:assertEquals(result[1], 10, \"Total penalty should be 10\");\n}\n\n@test:Config {}\nfunction testAllProblemsBeforeMidnight() {\n    // All problems can be completed before midnight\n    int[] times = [50, 100, 150];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 3, \"Should solve 3 problems\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0 (all submitted at midnight)\");\n}\n\n@test:Config {}\nfunction testSingleProblemAfterMidnight() {\n    // One problem that takes 400 minutes (finishes 50 minutes after midnight)\n    int[] times = [400];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 1, \"Should solve 1 problem\");\n    test:assertEquals(result[1], 50, \"Penalty should be 50 minutes\");\n}\n\n@test:Config {}\nfunction testNoProblemsCanBeSolved() {\n    // Problem that takes more than available time\n    int[] times = [720];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 0, \"Should solve 0 problems\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0\");\n}\n\n@test:Config {}\nfunction testMultipleProblemsAfterMidnight() {\n    // Multiple problems, some before, some after midnight\n    int[] times = [200, 200, 200];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 3, \"Should solve 3 problems\");\n    // First: 200 (before midnight), Second: 400 (50 after), Third: 600 (250 after)\n    // Penalty = 0 + 50 + 250 = 300\n    test:assertEquals(result[1], 300, \"Total penalty should be 300\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Contest duration: 720 minutes (18:00 to 6:00), first 10 minutes for reading, so 710 minutes available\n// 2. Time from 18:10 to midnight (0:00) is 350 minutes\n// 3. To minimize penalty: complete problems in order of increasing time (greedy)\n// 4. For each problem:\n//    - If completed before midnight: submit at midnight (0 penalty)\n//    - If completed after midnight: submit immediately (penalty = minutes after midnight)\n// 5. We want to maximize problems solved first, then minimize penalty\n\nimport ballerina/io;\n\nfunction solveNewYearContest(int[] times) returns [int, int] {\n    // Sort times in ascending order to minimize penalty\n    int[] sortedTimes = times.clone();\n    sortedTimes.sort();\n    \n    int availableTime = 710; // Total time available (720 - 10 for reading)\n    int timeToMidnight = 350; // Time from 18:10 to 00:00\n    \n    int problemsSolved = 0;\n    int totalPenalty = 0;\n    int currentTime = 0; // Time elapsed from 18:10\n    \n    foreach int problemTime in sortedTimes {\n        // Check if we can solve this problem within available time\n        if currentTime + problemTime <= availableTime {\n            currentTime += problemTime;\n            problemsSolved += 1;\n            \n            // Calculate penalty for this problem\n            if currentTime <= timeToMidnight {\n                // Problem completed before midnight, submit at midnight (0 penalty)\n                totalPenalty += 0;\n            } else {\n                // Problem completed after midnight, penalty = time after midnight\n                int timeAfterMidnight = currentTime - timeToMidnight;\n                totalPenalty += timeAfterMidnight;\n            }\n        } else {\n            // Cannot solve this problem, stop\n            break;\n        }\n    }\n    \n    return [problemsSolved, totalPenalty];\n}\n\npublic function main() returns error? {\n    // Read number of problems\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read problem times\n    string? timesLine = io:readln();\n    if timesLine is () {\n        io:println(\"Error: No times provided\");\n        return;\n    }\n    \n    string[] timeParts = timesLine.trim().split(\" \");\n    int[] times = [];\n    \n    foreach string part in timeParts {\n        int time = check 'int:fromString(part.trim());\n        times.push(time);\n    }\n    \n    // Solve the problem\n    [int, int] result = solveNewYearContest(times);\n    io:println(result[0].toString() + \" \" + result[1].toString());\n}",
      "tests_passed": 0,
      "tests_total": 1,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(15:5,15:24)] variable assignment is required\nERROR [main.bal:(65:43,65:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(15:5,15:24)] variable assignment is required\nERROR [main.bal:(65:43,65:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(15:5,15:24)] variable assignment is required\nERROR [main.bal:(65:43,65:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:49:53.372923",
      "status": "success",
      "completion": "# Overview\n\nThis problem is about optimizing the submission strategy for a New Year programming contest. The key insights are:\n\n1. Contest runs from 18:00 (Dec 31) to 6:00 (Jan 1) = 720 minutes total\n2. First 10 minutes spent reading problems, so 710 minutes available for solving\n3. Penalty is the distance from submission time to midnight (New Year at 0:00)\n4. Problems submitted before midnight get penalty = (minutes until midnight)\n5. Problems submitted after midnight get penalty = (minutes after midnight)\n6. Optimal strategy: solve problems in ascending order of time (greedy), and submit strategically to minimize penalty\n\nKey insight for penalty calculation:\n- If we complete a problem at time T (from 18:10):\n  - If T <= 350 (before midnight): penalty = 350 - T (submit immediately, penalty is time to midnight)\n  - If T > 350 (after midnight): penalty = T - 350 (submit immediately, penalty is time after midnight)\n- BUT we can also hold submissions! Submit all problems completed before midnight AT midnight (0 penalty), and problems after midnight immediately.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Contest: 720 minutes total (18:00 to 6:00), first 10 minutes for reading = 710 minutes for solving\n// 2. Time from 18:10 to midnight is 350 minutes\n// 3. Penalty calculation: distance from submission time to midnight\n//    - Problems completed before midnight: can be submitted at midnight (0 penalty)\n//    - Problems completed after midnight: submitted immediately (penalty = time after midnight)\n// 4. Strategy: Sort problems by time (greedy), solve as many as possible, minimize penalty\n// 5. For problems finished before midnight, we submit them all at midnight (0 penalty each)\n// 6. For problems finished after midnight, we submit immediately (penalty accumulates)\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction solveNewYearContest(int[] times) returns [int, int] {\n    // Sort times in ascending order to minimize penalty (greedy approach)\n    int[] sortedTimes = times.clone();\n    int n = sortedTimes.length();\n    \n    // Bubble sort (simple and works for n <= 100)\n    int i = 0;\n    while i < n {\n        int j = 0;\n        while j < n - 1 - i {\n            if sortedTimes[j] > sortedTimes[j + 1] {\n                int temp = sortedTimes[j];\n                sortedTimes[j] = sortedTimes[j + 1];\n                sortedTimes[j + 1] = temp;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    int availableTime = 710; // Total time available (720 - 10 for reading)\n    int timeToMidnight = 350; // Time from 18:10 to 00:00\n    \n    int problemsSolved = 0;\n    int totalPenalty = 0;\n    int currentTime = 0; // Time elapsed from 18:10\n    \n    foreach int problemTime in sortedTimes {\n        // Check if we can solve this problem within available time\n        if currentTime + problemTime <= availableTime {\n            currentTime += problemTime;\n            problemsSolved += 1;\n            \n            // Calculate penalty for this problem\n            // Strategy: Submit problems completed before midnight AT midnight (0 penalty)\n            // Submit problems completed after midnight immediately\n            if currentTime <= timeToMidnight {\n                // Problem completed before midnight, submit at midnight (0 penalty)\n                totalPenalty += 0;\n            } else {\n                // Problem completed after midnight, submit immediately\n                // Penalty = time after midnight\n                int timeAfterMidnight = currentTime - timeToMidnight;\n                totalPenalty += timeAfterMidnight;\n            }\n        } else {\n            // Cannot solve this problem within available time\n            break;\n        }\n    }\n    \n    return [problemsSolved, totalPenalty];\n}\n\npublic function main() returns error? {\n    // Read number of problems\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read problem times\n    string? timesLine = io:readln();\n    if timesLine is () {\n        io:println(\"Error: No times provided\");\n        return;\n    }\n    \n    // Parse the times using regex:split\n    string:RegExp regex = re ` `;\n    string[] timeParts = regex.split(timesLine.trim());\n    int[] times = [];\n    \n    foreach string part in timeParts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int time = check langint:fromString(trimmedPart);\n            times.push(time);\n        }\n    }\n    \n    // Solve the problem\n    [int, int] result = solveNewYearContest(times);\n    io:println(result[0].toString() + \" \" + result[1].toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSampleCase() {\n    int[] times = [30, 330, 720];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 2, \"Should solve 2 problems\");\n    test:assertEquals(result[1], 10, \"Total penalty should be 10\");\n}\n\n@test:Config {}\nfunction testAllProblemsBeforeMidnight() {\n    // All problems can be completed before midnight\n    int[] times = [50, 100, 150];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 3, \"Should solve 3 problems\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0 (all submitted at midnight)\");\n}\n\n@test:Config {}\nfunction testSingleProblemAfterMidnight() {\n    // One problem that takes 400 minutes (finishes 50 minutes after midnight)\n    int[] times = [400];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 1, \"Should solve 1 problem\");\n    test:assertEquals(result[1], 50, \"Penalty should be 50 minutes\");\n}\n\n@test:Config {}\nfunction testNoProblemsCanBeSolved() {\n    // Problem that takes more than available time\n    int[] times = [720];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 0, \"Should solve 0 problems\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0\");\n}\n\n@test:Config {}\nfunction testMultipleProblemsAfterMidnight() {\n    // Multiple problems, some before, some after midnight\n    int[] times = [200, 200, 200];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 3, \"Should solve 3 problems\");\n    // First: 200 (before midnight, 0 penalty), Second: 400 (50 after, penalty 50), Third: 600 (250 after, penalty 250)\n    // Total penalty = 0 + 50 + 250 = 300\n    test:assertEquals(result[1], 300, \"Total penalty should be 300\");\n}\n\n@test:Config {}\nfunction testExactlyAtMidnight() {\n    // Problem completed exactly at midnight\n    int[] times = [350];\n    [int, int] result = solveNewYearContest(times);\n    test:assertEquals(result[0], 1, \"Should solve 1 problem\");\n    test:assertEquals(result[1], 0, \"Penalty should be 0 (submitted at midnight)\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Contest: 720 minutes total (18:00 to 6:00), first 10 minutes for reading = 710 minutes for solving\n// 2. Time from 18:10 to midnight is 350 minutes\n// 3. Penalty calculation: distance from submission time to midnight\n//    - Problems completed before midnight: can be submitted at midnight (0 penalty)\n//    - Problems completed after midnight: submitted immediately (penalty = time after midnight)\n// 4. Strategy: Sort problems by time (greedy), solve as many as possible, minimize penalty\n// 5. For problems finished before midnight, we submit them all at midnight (0 penalty each)\n// 6. For problems finished after midnight, we submit immediately (penalty accumulates)\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction solveNewYearContest(int[] times) returns [int, int] {\n    // Sort times in ascending order to minimize penalty (greedy approach)\n    int[] sortedTimes = times.clone();\n    int n = sortedTimes.length();\n    \n    // Bubble sort (simple and works for n <= 100)\n    int i = 0;\n    while i < n {\n        int j = 0;\n        while j < n - 1 - i {\n            if sortedTimes[j] > sortedTimes[j + 1] {\n                int temp = sortedTimes[j];\n                sortedTimes[j] = sortedTimes[j + 1];\n                sortedTimes[j + 1] = temp;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    int availableTime = 710; // Total time available (720 - 10 for reading)\n    int timeToMidnight = 350; // Time from 18:10 to 00:00\n    \n    int problemsSolved = 0;\n    int totalPenalty = 0;\n    int currentTime = 0; // Time elapsed from 18:10\n    \n    foreach int problemTime in sortedTimes {\n        // Check if we can solve this problem within available time\n        if currentTime + problemTime <= availableTime {\n            currentTime += problemTime;\n            problemsSolved += 1;\n            \n            // Calculate penalty for this problem\n            // Strategy: Submit problems completed before midnight AT midnight (0 penalty)\n            // Submit problems completed after midnight immediately\n            if currentTime <= timeToMidnight {\n                // Problem completed before midnight, submit at midnight (0 penalty)\n                totalPenalty += 0;\n            } else {\n                // Problem completed after midnight, submit immediately\n                // Penalty = time after midnight\n                int timeAfterMidnight = currentTime - timeToMidnight;\n                totalPenalty += timeAfterMidnight;\n            }\n        } else {\n            // Cannot solve this problem within available time\n            break;\n        }\n    }\n    \n    return [problemsSolved, totalPenalty];\n}\n\npublic function main() returns error? {\n    // Read number of problems\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read problem times\n    string? timesLine = io:readln();\n    if timesLine is () {\n        io:println(\"Error: No times provided\");\n        return;\n    }\n    \n    // Parse the times using regex:split\n    string:RegExp regex = re ` `;\n    string[] timeParts = regex.split(timesLine.trim());\n    int[] times = [];\n    \n    foreach string part in timeParts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int time = check langint:fromString(trimmedPart);\n            times.push(time);\n        }\n    }\n    \n    // Solve the problem\n    [int, int] result = solveNewYearContest(times);\n    io:println(result[0].toString() + \" \" + result[1].toString());\n}",
      "tests_passed": 1,
      "tests_total": 1,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 1/1 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T00:50:24.752605"
}