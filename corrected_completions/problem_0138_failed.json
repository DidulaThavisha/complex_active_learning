{
  "entry_id": "problem_0138",
  "problem_index": 138,
  "prompt": "Title: Sereja and Contest\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nDuring the last Sereja's Codesecrof round the server crashed many times, so the round was decided to be made unrated for some participants. \n\nLet's assume that *n* people took part in the contest. Let's assume that the participant who got the first place has rating *a*1, the second place participant has rating *a*2, ..., the *n*-th place participant has rating *a**n*. Then changing the rating on the Codesecrof site is calculated by the formula .\n\nAfter the round was over, the Codesecrof management published the participants' results table. They decided that if for a participant *d**i*<=&lt;<=*k*, then the round can be considered unrated for him. But imagine the management's surprise when they found out that the participants' rating table is dynamic. In other words, when some participant is removed from the rating, he is removed from the results' table and the rating is recalculated according to the new table. And of course, all applications for exclusion from the rating are considered in view of the current table.\n\nWe know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank (the rank with the minimum number), for who *d**i*<=&lt;<=*k*. We also know that the applications for exclusion from rating were submitted by all participants.\n\nNow Sereja wonders, what is the number of participants to be excluded from the contest rating, and the numbers of the participants in the original table in the order of their exclusion from the rating. Pay attention to the analysis of the first test case for a better understanding of the statement.\n\nInput Specification:\nThe first line contains two integers *n*, *k* (1<=≤<=*n*<=≤<=2·105,<=<=-<=109<=≤<=*k*<=≤<=0). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — ratings of the participants in the initial table.\n\nOutput Specification:\nPrint the numbers of participants in the order in which they were removed from the table. Print the initial numbers of the participants, that is, the numbers that the participants had in the initial table.\n\nDemo Input:\n['5 0\\n5 3 4 1 2\\n', '10 -10\\n5 5 1 7 5 1 2 4 9 2\\n']\n\nDemo Output:\n['2\\n3\\n4\\n', '2\\n4\\n5\\n7\\n8\\n9\\n']\n\nNote:\nConsider the first test sample. \n1.  Initially the sequence of the contest participants' ratings equals [5, 3, 4, 1, 2]. You can use this sequence to calculate the sequence of rating changes: [0, -9, -13, 8, 14]. According to the problem statement, the application of the participant who won the second place will be considered first.1.  As soon as the second place winner is out from the ratings, the participants' rating sequence will equal [5, 4, 1, 2]. By this sequence you can count the new sequence of rating changes: [0, -8, 2, 6]. According to the problem statement, the application of the participant who won the second place will be considered. Initially this participant won third place.1.  The new rating sequence equals [5, 1, 2], the new sequence of rating changes equals [0, -1, 1]. The second place participant's application is taken into consideration, initially this participant won the fourth place.1.  The new rating sequence equals [5, 2], the new sequence of rating changes equals [0, 0]. No more applications will be considered. \nThus, you should print 2, 3, 4.",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:25:51.548519",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires simulating a contest rating adjustment process where participants are removed from the rating table based on a specific criterion. For each participant at position i, we calculate their rating change `d_i` using the formula that sums up the differences between their rating and all other participants' ratings. If `d_i <= k`, they are eligible for removal. We repeatedly remove the highest-ranked (lowest position number) eligible participant until no more participants satisfy the removal condition.\n\nThe key insight is:\n1. Calculate rating change for each participant: `d_i = sum(a_j - a_i)` for all j != i\n2. Find the first participant (smallest index) where `d_i <= k`\n3. Remove that participant and recalculate for the remaining participants\n4. Repeat until no participant satisfies the condition\n\n<CODE>\n```ballerina\n// Reasoning:\n// For each participant at position i with rating a_i, their rating change is:\n// d_i = sum of (a_j - a_i) for all j != i\n// This can be rewritten as: d_i = (sum of all ratings) - n * a_i\n// \n// Algorithm:\n// 1. Read n, k and the ratings array\n// 2. Keep a list of participants with their original indices and ratings\n// 3. While there are participants:\n//    a. Calculate total sum of remaining ratings\n//    b. For each participant in order, calculate d_i\n//    c. Find first participant where d_i <= k\n//    d. If found, remove them and add to result list\n//    e. If not found, break\n// 4. Output the original indices of removed participants\n\nimport ballerina/io;\n\ntype Participant record {|\n    int originalIndex;\n    int rating;\n|};\n\nfunction solveContest(int n, int k, int[] ratings) returns int[] {\n    Participant[] participants = [];\n    \n    // Initialize participants with original indices (1-based)\n    foreach int i in 0 ..< n {\n        participants.push({originalIndex: i + 1, rating: ratings[i]});\n    }\n    \n    int[] removed = [];\n    \n    while participants.length() > 0 {\n        int currentSize = participants.length();\n        \n        // Calculate sum of all current ratings\n        int totalSum = 0;\n        foreach Participant p in participants {\n            totalSum += p.rating;\n        }\n        \n        // Find first participant where d_i <= k\n        int toRemove = -1;\n        foreach int i in 0 ..< currentSize {\n            int ratingChange = totalSum - currentSize * participants[i].rating;\n            if ratingChange <= k {\n                toRemove = i;\n                break;\n            }\n        }\n        \n        // If found, remove and add to result\n        if toRemove >= 0 {\n            removed.push(participants[toRemove].originalIndex);\n            _ = participants.remove(toRemove);\n        } else {\n            break;\n        }\n    }\n    \n    return removed;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: ratings\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Number of ratings does not match n\");\n    }\n    \n    int[] ratings = [];\n    foreach string part in parts2 {\n        int rating = check 'int:fromString(part);\n        ratings.push(rating);\n    }\n    \n    // Solve and output\n    int[] result = solveContest(n, k, ratings);\n    foreach int idx in result {\n        io:println(idx);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] ratings = [5, 3, 4, 1, 2];\n    int[] result = solveContest(5, 0, ratings);\n    test:assertEquals(result.length(), 3);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 3);\n    test:assertEquals(result[2], 4);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] ratings = [5, 5, 1, 7, 5, 1, 2, 4, 9, 2];\n    int[] result = solveContest(10, -10, ratings);\n    test:assertEquals(result.length(), 6);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 4);\n}\n\n@test:Config {}\nfunction testNoRemoval() {\n    // All participants have positive rating changes, none removed\n    int[] ratings = [1, 100, 200];\n    int[] result = solveContest(3, -1, ratings);\n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testAllRemoved() {\n    // All participants should be removed\n    int[] ratings = [5, 5, 5];\n    int[] result = solveContest(3, 0, ratings);\n    test:assertEquals(result.length(), 2);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1], 2);\n}\n\n@test:Config {}\nfunction testSingleParticipant() {\n    // Single participant, d_i = 0, should be removed if k >= 0\n    int[] ratings = [100];\n    int[] result = solveContest(1, 0, ratings);\n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testTwoParticipants() {\n    // Two participants with different ratings\n    int[] ratings = [10, 5];\n    int[] result = solveContest(2, 0, ratings);\n    // d_0 = 5 - 10*2 = -15, d_1 = 15 - 5*2 = 5\n    // First participant (index 1) has d <= 0\n    test:assertEquals(result.length(), 1);\n    test:assertEquals(result[0], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// For each participant at position i with rating a_i, their rating change is:\n// d_i = sum of (a_j - a_i) for all j != i\n// This can be rewritten as: d_i = (sum of all ratings) - n * a_i\n// \n// Algorithm:\n// 1. Read n, k and the ratings array\n// 2. Keep a list of participants with their original indices and ratings\n// 3. While there are participants:\n//    a. Calculate total sum of remaining ratings\n//    b. For each participant in order, calculate d_i\n//    c. Find first participant where d_i <= k\n//    d. If found, remove them and add to result list\n//    e. If not found, break\n// 4. Output the original indices of removed participants\n\nimport ballerina/io;\n\ntype Participant record {|\n    int originalIndex;\n    int rating;\n|};\n\nfunction solveContest(int n, int k, int[] ratings) returns int[] {\n    Participant[] participants = [];\n    \n    // Initialize participants with original indices (1-based)\n    foreach int i in 0 ..< n {\n        participants.push({originalIndex: i + 1, rating: ratings[i]});\n    }\n    \n    int[] removed = [];\n    \n    while participants.length() > 0 {\n        int currentSize = participants.length();\n        \n        // Calculate sum of all current ratings\n        int totalSum = 0;\n        foreach Participant p in participants {\n            totalSum += p.rating;\n        }\n        \n        // Find first participant where d_i <= k\n        int toRemove = -1;\n        foreach int i in 0 ..< currentSize {\n            int ratingChange = totalSum - currentSize * participants[i].rating;\n            if ratingChange <= k {\n                toRemove = i;\n                break;\n            }\n        }\n        \n        // If found, remove and add to result\n        if toRemove >= 0 {\n            removed.push(participants[toRemove].originalIndex);\n            _ = participants.remove(toRemove);\n        } else {\n            break;\n        }\n    }\n    \n    return removed;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: ratings\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Number of ratings does not match n\");\n    }\n    \n    int[] ratings = [];\n    foreach string part in parts2 {\n        int rating = check 'int:fromString(part);\n        ratings.push(rating);\n    }\n    \n    // Solve and output\n    int[] result = solveContest(n, k, ratings);\n    foreach int idx in result {\n        io:println(idx);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(72:36,72:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(86:36,86:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(72:36,72:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(86:36,86:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(72:36,72:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(86:36,86:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:26:20.292029",
      "status": "failed",
      "completion": "Looking at the compilation error, the issue is that `split` is not a direct method on `string` type in Ballerina. I need to use `string:split` from the `ballerina/lang.string` module or use the proper string splitting approach.\n\nLet me analyze the problem:\n1. Calculate rating change `d_i = sum(a_j - a_i)` for all j != i, which simplifies to `d_i = totalSum - n * a_i`\n2. Repeatedly find and remove the first participant (lowest index) where `d_i <= k`\n3. Recalculate after each removal\n\nI'll fix the compilation error by using `regex:split` from `ballerina/regex` module.\n\n# Overview\n\nThis problem simulates a contest rating adjustment where participants are removed based on their rating change. For participant i with rating a_i, their rating change is d_i = sum of (a_j - a_i) for all j != i. This simplifies to d_i = totalSum - n * a_i. We repeatedly remove the highest-ranked eligible participant (where d_i <= k) until no more participants qualify for removal.\n\n<CODE>\n```ballerina\n// Reasoning:\n// For each participant at position i with rating a_i, their rating change is:\n// d_i = sum of (a_j - a_i) for all j != i\n// This simplifies to: d_i = (sum of all ratings) - n * a_i\n// \n// Algorithm:\n// 1. Read n, k and the ratings array\n// 2. Maintain a list of participants with original indices and ratings\n// 3. Repeatedly:\n//    a. Calculate total sum of current ratings\n//    b. For each participant in current order, calculate d_i\n//    c. Find first participant where d_i <= k\n//    d. If found, remove them and record their original index\n//    e. If none found, stop\n// 4. Output the original indices of removed participants in order\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Participant record {|\n    int originalIndex;\n    int rating;\n|};\n\nfunction solveContest(int n, int k, int[] ratings) returns int[] {\n    Participant[] participants = [];\n    \n    // Initialize participants with original indices (1-based)\n    foreach int i in 0 ..< n {\n        participants.push({originalIndex: i + 1, rating: ratings[i]});\n    }\n    \n    int[] removed = [];\n    \n    // Keep removing participants while conditions are met\n    while participants.length() > 0 {\n        int currentSize = participants.length();\n        \n        // Calculate sum of all current ratings\n        int totalSum = 0;\n        foreach Participant p in participants {\n            totalSum += p.rating;\n        }\n        \n        // Find first participant where d_i <= k\n        int toRemove = -1;\n        foreach int i in 0 ..< currentSize {\n            int ratingChange = totalSum - currentSize * participants[i].rating;\n            if ratingChange <= k {\n                toRemove = i;\n                break;\n            }\n        }\n        \n        // If found, remove and add to result\n        if toRemove >= 0 {\n            removed.push(participants[toRemove].originalIndex);\n            _ = participants.remove(toRemove);\n        } else {\n            // No more participants to remove\n            break;\n        }\n    }\n    \n    return removed;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: ratings\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Number of ratings does not match n\");\n    }\n    \n    int[] ratings = [];\n    foreach string part in parts2 {\n        int rating = check 'int:fromString(part);\n        ratings.push(rating);\n    }\n    \n    // Solve and output\n    int[] result = solveContest(n, k, ratings);\n    foreach int idx in result {\n        io:println(idx);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // Test case from problem: [5, 3, 4, 1, 2] with k=0\n    // Expected output: 2, 3, 4\n    int[] ratings = [5, 3, 4, 1, 2];\n    int[] result = solveContest(5, 0, ratings);\n    test:assertEquals(result.length(), 3);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 3);\n    test:assertEquals(result[2], 4);\n}\n\n@test:Config {}\nfunction testExample2() {\n    // Test case from problem: [5, 5, 1, 7, 5, 1, 2, 4, 9, 2] with k=-10\n    // Expected output starts with: 2, 4, 5, 7, 8, 9\n    int[] ratings = [5, 5, 1, 7, 5, 1, 2, 4, 9, 2];\n    int[] result = solveContest(10, -10, ratings);\n    test:assertEquals(result.length(), 6);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 4);\n}\n\n@test:Config {}\nfunction testNoRemoval() {\n    // All participants have positive rating changes above k, none removed\n    int[] ratings = [1, 100, 200];\n    int[] result = solveContest(3, -50, ratings);\n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testAllEqualRatings() {\n    // All participants have equal ratings, d_i = 0 for all\n    // With k >= 0, all but last should be removed\n    int[] ratings = [5, 5, 5];\n    int[] result = solveContest(3, 0, ratings);\n    test:assertEquals(result.length(), 2);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1], 2);\n}\n\n@test:Config {}\nfunction testSingleParticipant() {\n    // Single participant: d_i = 0, only removed if k >= 0\n    // But with one participant, no one else to compare, so d_0 = 0\n    int[] ratings = [100];\n    int[] result = solveContest(1, 0, ratings);\n    // With only 1 participant, totalSum = 100, d_0 = 100 - 1*100 = 0\n    // Since 0 <= 0, should be removed, but then list is empty\n    test:assertEquals(result.length(), 0);\n}\n\n@test:Config {}\nfunction testTwoParticipantsRemoval() {\n    // Two participants: ratings [10, 5], k=0\n    // totalSum = 15\n    // d_0 = 15 - 2*10 = -5 (remove first)\n    // After removing first: [5], d_0 = 5 - 1*5 = 0 (stop, only one left)\n    int[] ratings = [10, 5];\n    int[] result = solveContest(2, 0, ratings);\n    test:assertEquals(result.length(), 1);\n    test:assertEquals(result[0], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// For each participant at position i with rating a_i, their rating change is:\n// d_i = sum of (a_j - a_i) for all j != i\n// This simplifies to: d_i = (sum of all ratings) - n * a_i\n// \n// Algorithm:\n// 1. Read n, k and the ratings array\n// 2. Maintain a list of participants with original indices and ratings\n// 3. Repeatedly:\n//    a. Calculate total sum of current ratings\n//    b. For each participant in current order, calculate d_i\n//    c. Find first participant where d_i <= k\n//    d. If found, remove them and record their original index\n//    e. If none found, stop\n// 4. Output the original indices of removed participants in order\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Participant record {|\n    int originalIndex;\n    int rating;\n|};\n\nfunction solveContest(int n, int k, int[] ratings) returns int[] {\n    Participant[] participants = [];\n    \n    // Initialize participants with original indices (1-based)\n    foreach int i in 0 ..< n {\n        participants.push({originalIndex: i + 1, rating: ratings[i]});\n    }\n    \n    int[] removed = [];\n    \n    // Keep removing participants while conditions are met\n    while participants.length() > 0 {\n        int currentSize = participants.length();\n        \n        // Calculate sum of all current ratings\n        int totalSum = 0;\n        foreach Participant p in participants {\n            totalSum += p.rating;\n        }\n        \n        // Find first participant where d_i <= k\n        int toRemove = -1;\n        foreach int i in 0 ..< currentSize {\n            int ratingChange = totalSum - currentSize * participants[i].rating;\n            if ratingChange <= k {\n                toRemove = i;\n                break;\n            }\n        }\n        \n        // If found, remove and add to result\n        if toRemove >= 0 {\n            removed.push(participants[toRemove].originalIndex);\n            _ = participants.remove(toRemove);\n        } else {\n            // No more participants to remove\n            break;\n        }\n    }\n    \n    return removed;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: ratings\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Number of ratings does not match n\");\n    }\n    \n    int[] ratings = [];\n    foreach string part in parts2 {\n        int rating = check 'int:fromString(part);\n        ratings.push(rating);\n    }\n    \n    // Solve and output\n    int[] result = solveContest(n, k, ratings);\n    foreach int idx in result {\n        io:println(idx);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5 0\n5 3 4 1 2\n",
          "expected_output": "2\n3\n4\n",
          "actual_output": "1\n2\n3\n5\n4\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T02:26:56.723835"
}