{
  "entry_id": "problem_0028",
  "problem_index": 28,
  "prompt": "Title: Nested Segments\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou are given *n* segments on a line. There are no ends of some segments that coincide. For each segment find the number of segments it contains.\n\nInput Specification:\nThe first line contains a single integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of segments on a line.\n\nEach of the next *n* lines contains two integers *l**i* and *r**i* (<=-<=109<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — the coordinates of the left and the right ends of the *i*-th segment. It is guaranteed that there are no ends of some segments that coincide.\n\nOutput Specification:\nPrint *n* lines. The *j*-th of them should contain the only integer *a**j* — the number of segments contained in the *j*-th segment.\n\nDemo Input:\n['4\\n1 8\\n2 3\\n4 7\\n5 6\\n', '3\\n3 4\\n1 5\\n2 6\\n']\n\nDemo Output:\n['3\\n0\\n1\\n0\\n', '0\\n1\\n1\\n']\n\nNote:\nnone",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem asks us to find, for each segment, how many other segments it completely contains. A segment A contains segment B if B's left end is greater than A's left end AND B's right end is less than A's right end.\n\nThe key issue in the previous attempt was using the `split()` function incorrectly. In Ballerina, we need to use the `regex:split()` function from the `ballerina/regex` module, or use string methods properly.\n\nThe approach:\n1. Read n segments with their left and right coordinates\n2. For each segment, count how many other segments fall completely within its boundaries\n3. A segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Read n (number of segments)\n// - Read n lines, each containing two integers (left and right coordinates)\n// - For each segment i, count how many segments j are contained in it\n// - Segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n// - Output the count for each segment in order\n// \n// Fix: Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Segment record {\n    int left;\n    int right;\n};\n\n// Function to count how many segments each segment contains\nfunction countNestedSegments(Segment[] segments) returns int[] {\n    int n = segments.length();\n    int[] result = [];\n    \n    // For each segment, count how many other segments it contains\n    foreach int i in 0 ..< n {\n        int count = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                // Check if segment i contains segment j\n                // Segment i contains j if: left[i] < left[j] AND right[j] < right[i]\n                if segments[i].left < segments[j].left && segments[j].right < segments[i].right {\n                    count += 1;\n                }\n            }\n        }\n        result.push(count);\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of segments\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of segments\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of segments\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of segments must be at least 1\");\n    }\n    \n    // Read all segments\n    Segment[] segments = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        // Use regex:split to parse the line\n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int|error left = 'int:fromString(parts[0].trim());\n        int|error right = 'int:fromString(parts[1].trim());\n        \n        if left is error || right is error {\n            return error(\"Invalid segment coordinates\");\n        }\n        \n        if left >= right {\n            return error(\"Left coordinate must be less than right coordinate\");\n        }\n        \n        segments.push({left: left, right: right});\n    }\n    \n    // Calculate nested segments\n    int[] results = countNestedSegments(segments);\n    \n    // Output results\n    foreach int count in results {\n        io:println(count.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Segment[] segments = [\n        {left: 1, right: 8},\n        {left: 2, right: 3},\n        {left: 4, right: 7},\n        {left: 5, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 3); // Segment [1,8] contains [2,3], [4,7], [5,6]\n    test:assertEquals(result[1], 0); // Segment [2,3] contains none\n    test:assertEquals(result[2], 1); // Segment [4,7] contains [5,6]\n    test:assertEquals(result[3], 0); // Segment [5,6] contains none\n}\n\n@test:Config {}\nfunction testExample2() {\n    Segment[] segments = [\n        {left: 3, right: 4},\n        {left: 1, right: 5},\n        {left: 2, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0); // Segment [3,4] contains none\n    test:assertEquals(result[1], 1); // Segment [1,5] contains [3,4]\n    test:assertEquals(result[2], 1); // Segment [2,6] contains [3,4]\n}\n\n@test:Config {}\nfunction testNoNesting() {\n    Segment[] segments = [\n        {left: 1, right: 2},\n        {left: 3, right: 4},\n        {left: 5, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1], 0);\n    test:assertEquals(result[2], 0);\n}\n\n@test:Config {}\nfunction testSingleSegment() {\n    Segment[] segments = [\n        {left: 1, right: 10}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0);\n}\n\n@test:Config {}\nfunction testCompleteNesting() {\n    Segment[] segments = [\n        {left: 1, right: 10},\n        {left: 2, right: 9},\n        {left: 3, right: 8}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 2); // [1,10] contains both others\n    test:assertEquals(result[1], 1); // [2,9] contains [3,8]\n    test:assertEquals(result[2], 0); // [3,8] contains none\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - Read n (number of segments)\n// - Read n lines, each containing two integers (left and right coordinates)\n// - For each segment i, count how many segments j are contained in it\n// - Segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n// - Output the count for each segment in order\n// \n// Fix: Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Segment record {\n    int left;\n    int right;\n};\n\n// Function to count how many segments each segment contains\nfunction countNestedSegments(Segment[] segments) returns int[] {\n    int n = segments.length();\n    int[] result = [];\n    \n    // For each segment, count how many other segments it contains\n    foreach int i in 0 ..< n {\n        int count = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                // Check if segment i contains segment j\n                // Segment i contains j if: left[i] < left[j] AND right[j] < right[i]\n                if segments[i].left < segments[j].left && segments[j].right < segments[i].right {\n                    count += 1;\n                }\n            }\n        }\n        result.push(count);\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of segments\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of segments\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of segments\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of segments must be at least 1\");\n    }\n    \n    // Read all segments\n    Segment[] segments = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        // Use regex:split to parse the line\n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int|error left = 'int:fromString(parts[0].trim());\n        int|error right = 'int:fromString(parts[1].trim());\n        \n        if left is error || right is error {\n            return error(\"Invalid segment coordinates\");\n        }\n        \n        if left >= right {\n            return error(\"Left coordinate must be less than right coordinate\");\n        }\n        \n        segments.push({left: left, right: right});\n    }\n    \n    // Calculate nested segments\n    int[] results = countNestedSegments(segments);\n    \n    // Output results\n    foreach int count in results {\n        io:println(count.toString());\n    }\n    \n    return;\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:26:30.217897",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find, for each segment, how many other segments it completely contains. A segment A contains segment B if B's left end is greater than A's left end AND B's right end is less than A's right end.\n\nThe approach:\n1. Read n segments with their left and right coordinates\n2. For each segment, count how many other segments fall completely within its boundaries\n3. A segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Read n (number of segments)\n// - Read n lines, each containing two integers (left and right coordinates)\n// - For each segment i, count how many segments j are contained in it\n// - Segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n// - Output the count for each segment in order\n\nimport ballerina/io;\n\ntype Segment record {\n    int left;\n    int right;\n};\n\n// Function to count how many segments each segment contains\nfunction countNestedSegments(Segment[] segments) returns int[] {\n    int n = segments.length();\n    int[] result = [];\n    \n    // For each segment, count how many other segments it contains\n    foreach int i in 0 ..< n {\n        int count = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                // Check if segment i contains segment j\n                // Segment i contains j if: left[i] < left[j] AND right[j] < right[i]\n                if segments[i].left < segments[j].left && segments[j].right < segments[i].right {\n                    count += 1;\n                }\n            }\n        }\n        result.push(count);\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of segments\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of segments\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of segments\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of segments must be at least 1\");\n    }\n    \n    // Read all segments\n    Segment[] segments = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int|error left = 'int:fromString(parts[0].trim());\n        int|error right = 'int:fromString(parts[1].trim());\n        \n        if left is error || right is error {\n            return error(\"Invalid segment coordinates\");\n        }\n        \n        if left >= right {\n            return error(\"Left coordinate must be less than right coordinate\");\n        }\n        \n        segments.push({left: left, right: right});\n    }\n    \n    // Calculate nested segments\n    int[] results = countNestedSegments(segments);\n    \n    // Output results\n    foreach int count in results {\n        io:println(count.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Segment[] segments = [\n        {left: 1, right: 8},\n        {left: 2, right: 3},\n        {left: 4, right: 7},\n        {left: 5, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 3); // Segment [1,8] contains [2,3], [4,7], [5,6]\n    test:assertEquals(result[1], 0); // Segment [2,3] contains none\n    test:assertEquals(result[2], 1); // Segment [4,7] contains [5,6]\n    test:assertEquals(result[3], 0); // Segment [5,6] contains none\n}\n\n@test:Config {}\nfunction testExample2() {\n    Segment[] segments = [\n        {left: 3, right: 4},\n        {left: 1, right: 5},\n        {left: 2, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0); // Segment [3,4] contains none\n    test:assertEquals(result[1], 1); // Segment [1,5] contains [3,4]\n    test:assertEquals(result[2], 1); // Segment [2,6] contains [3,4]\n}\n\n@test:Config {}\nfunction testNoNesting() {\n    Segment[] segments = [\n        {left: 1, right: 2},\n        {left: 3, right: 4},\n        {left: 5, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1], 0);\n    test:assertEquals(result[2], 0);\n}\n\n@test:Config {}\nfunction testSingleSegment() {\n    Segment[] segments = [\n        {left: 1, right: 10}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0);\n}\n\n@test:Config {}\nfunction testCompleteNesting() {\n    Segment[] segments = [\n        {left: 1, right: 10},\n        {left: 2, right: 9},\n        {left: 3, right: 8}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 2); // [1,10] contains both others\n    test:assertEquals(result[1], 1); // [2,9] contains [3,8]\n    test:assertEquals(result[2], 0); // [3,8] contains none\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Read n (number of segments)\n// - Read n lines, each containing two integers (left and right coordinates)\n// - For each segment i, count how many segments j are contained in it\n// - Segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n// - Output the count for each segment in order\n\nimport ballerina/io;\n\ntype Segment record {\n    int left;\n    int right;\n};\n\n// Function to count how many segments each segment contains\nfunction countNestedSegments(Segment[] segments) returns int[] {\n    int n = segments.length();\n    int[] result = [];\n    \n    // For each segment, count how many other segments it contains\n    foreach int i in 0 ..< n {\n        int count = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                // Check if segment i contains segment j\n                // Segment i contains j if: left[i] < left[j] AND right[j] < right[i]\n                if segments[i].left < segments[j].left && segments[j].right < segments[i].right {\n                    count += 1;\n                }\n            }\n        }\n        result.push(count);\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of segments\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of segments\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of segments\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of segments must be at least 1\");\n    }\n    \n    // Read all segments\n    Segment[] segments = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int|error left = 'int:fromString(parts[0].trim());\n        int|error right = 'int:fromString(parts[1].trim());\n        \n        if left is error || right is error {\n            return error(\"Invalid segment coordinates\");\n        }\n        \n        if left >= right {\n            return error(\"Left coordinate must be less than right coordinate\");\n        }\n        \n        segments.push({left: left, right: right});\n    }\n    \n    // Calculate nested segments\n    int[] results = countNestedSegments(segments);\n    \n    // Output results\n    foreach int count in results {\n        io:println(count.toString());\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(62:38,62:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(62:38,62:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(62:38,62:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:26:52.151903",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to find, for each segment, how many other segments it completely contains. A segment A contains segment B if B's left end is greater than A's left end AND B's right end is less than A's right end.\n\nThe key issue in the previous attempt was using the `split()` function incorrectly. In Ballerina, we need to use the `regex:split()` function from the `ballerina/regex` module, or use string methods properly.\n\nThe approach:\n1. Read n segments with their left and right coordinates\n2. For each segment, count how many other segments fall completely within its boundaries\n3. A segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Read n (number of segments)\n// - Read n lines, each containing two integers (left and right coordinates)\n// - For each segment i, count how many segments j are contained in it\n// - Segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n// - Output the count for each segment in order\n// \n// Fix: Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Segment record {\n    int left;\n    int right;\n};\n\n// Function to count how many segments each segment contains\nfunction countNestedSegments(Segment[] segments) returns int[] {\n    int n = segments.length();\n    int[] result = [];\n    \n    // For each segment, count how many other segments it contains\n    foreach int i in 0 ..< n {\n        int count = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                // Check if segment i contains segment j\n                // Segment i contains j if: left[i] < left[j] AND right[j] < right[i]\n                if segments[i].left < segments[j].left && segments[j].right < segments[i].right {\n                    count += 1;\n                }\n            }\n        }\n        result.push(count);\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of segments\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of segments\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of segments\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of segments must be at least 1\");\n    }\n    \n    // Read all segments\n    Segment[] segments = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        // Use regex:split to parse the line\n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int|error left = 'int:fromString(parts[0].trim());\n        int|error right = 'int:fromString(parts[1].trim());\n        \n        if left is error || right is error {\n            return error(\"Invalid segment coordinates\");\n        }\n        \n        if left >= right {\n            return error(\"Left coordinate must be less than right coordinate\");\n        }\n        \n        segments.push({left: left, right: right});\n    }\n    \n    // Calculate nested segments\n    int[] results = countNestedSegments(segments);\n    \n    // Output results\n    foreach int count in results {\n        io:println(count.toString());\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Segment[] segments = [\n        {left: 1, right: 8},\n        {left: 2, right: 3},\n        {left: 4, right: 7},\n        {left: 5, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 3); // Segment [1,8] contains [2,3], [4,7], [5,6]\n    test:assertEquals(result[1], 0); // Segment [2,3] contains none\n    test:assertEquals(result[2], 1); // Segment [4,7] contains [5,6]\n    test:assertEquals(result[3], 0); // Segment [5,6] contains none\n}\n\n@test:Config {}\nfunction testExample2() {\n    Segment[] segments = [\n        {left: 3, right: 4},\n        {left: 1, right: 5},\n        {left: 2, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0); // Segment [3,4] contains none\n    test:assertEquals(result[1], 1); // Segment [1,5] contains [3,4]\n    test:assertEquals(result[2], 1); // Segment [2,6] contains [3,4]\n}\n\n@test:Config {}\nfunction testNoNesting() {\n    Segment[] segments = [\n        {left: 1, right: 2},\n        {left: 3, right: 4},\n        {left: 5, right: 6}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1], 0);\n    test:assertEquals(result[2], 0);\n}\n\n@test:Config {}\nfunction testSingleSegment() {\n    Segment[] segments = [\n        {left: 1, right: 10}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 0);\n}\n\n@test:Config {}\nfunction testCompleteNesting() {\n    Segment[] segments = [\n        {left: 1, right: 10},\n        {left: 2, right: 9},\n        {left: 3, right: 8}\n    ];\n    \n    int[] result = countNestedSegments(segments);\n    test:assertEquals(result[0], 2); // [1,10] contains both others\n    test:assertEquals(result[1], 1); // [2,9] contains [3,8]\n    test:assertEquals(result[2], 0); // [3,8] contains none\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Read n (number of segments)\n// - Read n lines, each containing two integers (left and right coordinates)\n// - For each segment i, count how many segments j are contained in it\n// - Segment i contains segment j if: left[i] < left[j] AND right[j] < right[i]\n// - Output the count for each segment in order\n// \n// Fix: Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Segment record {\n    int left;\n    int right;\n};\n\n// Function to count how many segments each segment contains\nfunction countNestedSegments(Segment[] segments) returns int[] {\n    int n = segments.length();\n    int[] result = [];\n    \n    // For each segment, count how many other segments it contains\n    foreach int i in 0 ..< n {\n        int count = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                // Check if segment i contains segment j\n                // Segment i contains j if: left[i] < left[j] AND right[j] < right[i]\n                if segments[i].left < segments[j].left && segments[j].right < segments[i].right {\n                    count += 1;\n                }\n            }\n        }\n        result.push(count);\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of segments\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read number of segments\");\n    }\n    \n    int|error n = 'int:fromString(nLine.trim());\n    if n is error {\n        return error(\"Invalid number of segments\");\n    }\n    \n    if n < 1 {\n        return error(\"Number of segments must be at least 1\");\n    }\n    \n    // Read all segments\n    Segment[] segments = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read segment\");\n        }\n        \n        // Use regex:split to parse the line\n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid segment format\");\n        }\n        \n        int|error left = 'int:fromString(parts[0].trim());\n        int|error right = 'int:fromString(parts[1].trim());\n        \n        if left is error || right is error {\n            return error(\"Invalid segment coordinates\");\n        }\n        \n        if left >= right {\n            return error(\"Left coordinate must be less than right coordinate\");\n        }\n        \n        segments.push({left: left, right: right});\n    }\n    \n    // Calculate nested segments\n    int[] results = countNestedSegments(segments);\n    \n    // Output results\n    foreach int count in results {\n        io:println(count.toString());\n    }\n    \n    return;\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T00:27:19.751058"
}