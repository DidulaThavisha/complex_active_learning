{
  "entry_id": "problem_0091",
  "problem_index": 91,
  "prompt": "Title: Divisible by Seven\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou have number *a*, whose decimal representation quite luckily contains digits 1, 6, 8, 9. Rearrange the digits in its decimal representation so that the resulting number will be divisible by 7.\n\nNumber *a* doesn't contain any leading zeroes and contains digits 1, 6, 8, 9 (it also can contain another digits). The resulting number also mustn't contain any leading zeroes.\n\nInput Specification:\nThe first line contains positive integer *a* in the decimal record. It is guaranteed that the record of number *a* contains digits: 1, 6, 8, 9. Number *a* doesn't contain any leading zeroes. The decimal representation of number *a* contains at least 4 and at most 106 characters.\n\nOutput Specification:\nPrint a number in the decimal notation without leading zeroes — the result of the permutation.\n\nIf it is impossible to rearrange the digits of the number *a* in the required manner, print 0.\n\nDemo Input:\n['1689\\n', '18906\\n']\n\nDemo Output:\n['1869\\n', '18690\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:34:31.477394",
      "status": "failed",
      "completion": "# Overview\nThis solution rearranges digits of a number to make it divisible by 7. The approach is to generate permutations of the digits and find the first valid one that is divisible by 7 and doesn't have leading zeros. Since generating all permutations for large numbers (up to 10^6 digits) is computationally infeasible, we'll use a practical approach: try to rearrange digits starting with larger digits to avoid leading zeros, and check divisibility by 7. For efficiency, we'll sort digits and try different arrangements strategically.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read the input number as a string\n// 2. Extract all digits and sort them\n// 3. Try to generate permutations in a smart way:\n//    - Start with non-zero digits to avoid leading zeros\n//    - For large inputs, we can't generate all permutations, so we'll try a greedy approach\n//    - Sort digits in descending order and try rotations/swaps\n// 4. Check each arrangement for divisibility by 7\n// 5. Return the first valid arrangement or 0 if none found\n//\n// Strategy: Since full permutation is expensive, we'll try:\n// - Sorting digits in various orders (desc, asc, mixed)\n// - For smaller numbers (<= 10 digits), try more permutations\n// - Check divisibility by 7 for each arrangement\n\nimport ballerina/io;\n\n// Convert string number to int for modulo check\nfunction isDivisibleBy7(string num) returns boolean|error {\n    // For large numbers, we need to calculate mod 7 digit by digit\n    int remainder = 0;\n    foreach int i in 0 ..< num.length() {\n        string digit = num.substring(i, i + 1);\n        int|error digitVal = 'int:fromString(digit);\n        if digitVal is error {\n            return digitVal;\n        }\n        remainder = (remainder * 10 + digitVal) % 7;\n    }\n    return remainder == 0;\n}\n\n// Generate next permutation lexicographically\nfunction nextPermutation(int[] arr) returns boolean {\n    int n = arr.length();\n    int i = n - 2;\n    \n    // Find first decreasing element from right\n    while i >= 0 && arr[i] >= arr[i + 1] {\n        i = i - 1;\n    }\n    \n    if i < 0 {\n        return false; // No more permutations\n    }\n    \n    // Find smallest element greater than arr[i] to the right\n    int j = n - 1;\n    while arr[j] <= arr[i] {\n        j = j - 1;\n    }\n    \n    // Swap\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    \n    // Reverse the suffix\n    int left = i + 1;\n    int right = n - 1;\n    while left < right {\n        temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left = left + 1;\n        right = right - 1;\n    }\n    \n    return true;\n}\n\nfunction findDivisibleBy7(string input) returns string {\n    // Convert string to array of digit integers\n    int[] digits = [];\n    foreach int i in 0 ..< input.length() {\n        string ch = input.substring(i, i + 1);\n        int|error digit = 'int:fromString(ch);\n        if digit is int {\n            digits.push(digit);\n        }\n    }\n    \n    // Sort digits to start with smallest lexicographic permutation\n    digits.sort();\n    \n    // If number is too large (> 10 digits), try limited strategies\n    if digits.length() > 10 {\n        // Try a few arrangements: sorted desc, sorted asc, original\n        int[] descDigits = digits.clone();\n        descDigits.sort(\"descending\");\n        \n        // Try descending with non-zero first\n        string candidate = \"\";\n        foreach int d in descDigits {\n            candidate = candidate + d.toString();\n        }\n        boolean|error divisible = isDivisibleBy7(candidate);\n        if divisible is boolean && divisible && candidate.substring(0, 1) != \"0\" {\n            return candidate;\n        }\n        \n        // Try ascending with non-zero first\n        candidate = \"\";\n        // Find first non-zero\n        int firstNonZero = -1;\n        foreach int i in 0 ..< digits.length() {\n            if digits[i] != 0 {\n                firstNonZero = i;\n                break;\n            }\n        }\n        if firstNonZero >= 0 {\n            candidate = digits[firstNonZero].toString();\n            foreach int i in 0 ..< digits.length() {\n                if i != firstNonZero {\n                    candidate = candidate + digits[i].toString();\n                }\n            }\n            divisible = isDivisibleBy7(candidate);\n            if divisible is boolean && divisible {\n                return candidate;\n            }\n        }\n        \n        return \"0\";\n    }\n    \n    // For smaller numbers, try permutations\n    int maxAttempts = 5040; // 7! = reasonable limit\n    int attempts = 0;\n    \n    while attempts < maxAttempts {\n        // Build number from current permutation\n        string candidate = \"\";\n        foreach int d in digits {\n            candidate = candidate + d.toString();\n        }\n        \n        // Check if valid (no leading zero) and divisible by 7\n        if candidate.substring(0, 1) != \"0\" {\n            boolean|error divisible = isDivisibleBy7(candidate);\n            if divisible is boolean && divisible {\n                return candidate;\n            }\n        }\n        \n        // Generate next permutation\n        if !nextPermutation(digits) {\n            break;\n        }\n        attempts = attempts + 1;\n    }\n    \n    return \"0\";\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string trimmed = input_line.trim();\n        if trimmed.length() > 0 {\n            string result = findDivisibleBy7(trimmed);\n            io:println(result);\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    string result = findDivisibleBy7(\"1689\");\n    // 1689 rearranged: possible answers include 1869, 6189, 6981, 8169, 9681, etc.\n    // Check that result is divisible by 7\n    boolean|error divisible = isDivisibleBy7(result);\n    test:assertTrue(divisible is boolean && divisible, \"Result should be divisible by 7\");\n    test:assertNotEquals(result, \"0\", \"Should find a valid arrangement\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    string result = findDivisibleBy7(\"18906\");\n    // Should rearrange to a number divisible by 7\n    boolean|error divisible = isDivisibleBy7(result);\n    test:assertTrue(divisible is boolean && divisible, \"Result should be divisible by 7\");\n    test:assertNotEquals(result, \"0\", \"Should find a valid arrangement\");\n}\n\n@test:Config {}\nfunction testSmallNumber() {\n    string result = findDivisibleBy7(\"1689\");\n    // Verify no leading zeros\n    test:assertNotEquals(result.substring(0, 1), \"0\", \"Result should not have leading zero\");\n    // Verify divisibility\n    boolean|error divisible = isDivisibleBy7(result);\n    test:assertTrue(divisible is boolean && divisible, \"Result should be divisible by 7\");\n}\n\n@test:Config {}\nfunction testDivisibilityCheck() {\n    // Test the helper function\n    boolean|error result1 = isDivisibleBy7(\"1869\");\n    test:assertTrue(result1 is boolean && result1, \"1869 is divisible by 7\");\n    \n    boolean|error result2 = isDivisibleBy7(\"14\");\n    test:assertTrue(result2 is boolean && result2, \"14 is divisible by 7\");\n    \n    boolean|error result3 = isDivisibleBy7(\"15\");\n    test:assertTrue(result3 is boolean && !result3, \"15 is not divisible by 7\");\n    \n    boolean|error result4 = isDivisibleBy7(\"21\");\n    test:assertTrue(result4 is boolean && result4, \"21 is divisible by 7\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read the input number as a string\n// 2. Extract all digits and sort them\n// 3. Try to generate permutations in a smart way:\n//    - Start with non-zero digits to avoid leading zeros\n//    - For large inputs, we can't generate all permutations, so we'll try a greedy approach\n//    - Sort digits in descending order and try rotations/swaps\n// 4. Check each arrangement for divisibility by 7\n// 5. Return the first valid arrangement or 0 if none found\n//\n// Strategy: Since full permutation is expensive, we'll try:\n// - Sorting digits in various orders (desc, asc, mixed)\n// - For smaller numbers (<= 10 digits), try more permutations\n// - Check divisibility by 7 for each arrangement\n\nimport ballerina/io;\n\n// Convert string number to int for modulo check\nfunction isDivisibleBy7(string num) returns boolean|error {\n    // For large numbers, we need to calculate mod 7 digit by digit\n    int remainder = 0;\n    foreach int i in 0 ..< num.length() {\n        string digit = num.substring(i, i + 1);\n        int|error digitVal = 'int:fromString(digit);\n        if digitVal is error {\n            return digitVal;\n        }\n        remainder = (remainder * 10 + digitVal) % 7;\n    }\n    return remainder == 0;\n}\n\n// Generate next permutation lexicographically\nfunction nextPermutation(int[] arr) returns boolean {\n    int n = arr.length();\n    int i = n - 2;\n    \n    // Find first decreasing element from right\n    while i >= 0 && arr[i] >= arr[i + 1] {\n        i = i - 1;\n    }\n    \n    if i < 0 {\n        return false; // No more permutations\n    }\n    \n    // Find smallest element greater than arr[i] to the right\n    int j = n - 1;\n    while arr[j] <= arr[i] {\n        j = j - 1;\n    }\n    \n    // Swap\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    \n    // Reverse the suffix\n    int left = i + 1;\n    int right = n - 1;\n    while left < right {\n        temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left = left + 1;\n        right = right - 1;\n    }\n    \n    return true;\n}\n\nfunction findDivisibleBy7(string input) returns string {\n    // Convert string to array of digit integers\n    int[] digits = [];\n    foreach int i in 0 ..< input.length() {\n        string ch = input.substring(i, i + 1);\n        int|error digit = 'int:fromString(ch);\n        if digit is int {\n            digits.push(digit);\n        }\n    }\n    \n    // Sort digits to start with smallest lexicographic permutation\n    digits.sort();\n    \n    // If number is too large (> 10 digits), try limited strategies\n    if digits.length() > 10 {\n        // Try a few arrangements: sorted desc, sorted asc, original\n        int[] descDigits = digits.clone();\n        descDigits.sort(\"descending\");\n        \n        // Try descending with non-zero first\n        string candidate = \"\";\n        foreach int d in descDigits {\n            candidate = candidate + d.toString();\n        }\n        boolean|error divisible = isDivisibleBy7(candidate);\n        if divisible is boolean && divisible && candidate.substring(0, 1) != \"0\" {\n            return candidate;\n        }\n        \n        // Try ascending with non-zero first\n        candidate = \"\";\n        // Find first non-zero\n        int firstNonZero = -1;\n        foreach int i in 0 ..< digits.length() {\n            if digits[i] != 0 {\n                firstNonZero = i;\n                break;\n            }\n        }\n        if firstNonZero >= 0 {\n            candidate = digits[firstNonZero].toString();\n            foreach int i in 0 ..< digits.length() {\n                if i != firstNonZero {\n                    candidate = candidate + digits[i].toString();\n                }\n            }\n            divisible = isDivisibleBy7(candidate);\n            if divisible is boolean && divisible {\n                return candidate;\n            }\n        }\n        \n        return \"0\";\n    }\n    \n    // For smaller numbers, try permutations\n    int maxAttempts = 5040; // 7! = reasonable limit\n    int attempts = 0;\n    \n    while attempts < maxAttempts {\n        // Build number from current permutation\n        string candidate = \"\";\n        foreach int d in digits {\n            candidate = candidate + d.toString();\n        }\n        \n        // Check if valid (no leading zero) and divisible by 7\n        if candidate.substring(0, 1) != \"0\" {\n            boolean|error divisible = isDivisibleBy7(candidate);\n            if divisible is boolean && divisible {\n                return candidate;\n            }\n        }\n        \n        // Generate next permutation\n        if !nextPermutation(digits) {\n            break;\n        }\n        attempts = attempts + 1;\n    }\n    \n    return \"0\";\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string trimmed = input_line.trim();\n        if trimmed.length() > 0 {\n            string result = findDivisibleBy7(trimmed);\n            io:println(result);\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(84:5,84:19)] variable assignment is required\nERROR [main.bal:(90:9,90:39)] variable assignment is required\nERROR [main.bal:(141:27,141:36)] redeclared symbol 'divisible'\nERROR [main.bal:(142:16,142:49)] operator '&&' not defined for 'boolean' and 'other'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(84:5,84:19)] variable assignment is required\nERROR [main.bal:(90:9,90:39)] variable assignment is required\nERROR [main.bal:(141:27,141:36)] redeclared symbol 'divisible'\nERROR [main.bal:(142:16,142:49)] operator '&&' not defined for 'boolean' and 'other'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(84:5,84:19)] variable assignment is required\nERROR [main.bal:(90:9,90:39)] variable assignment is required\nERROR [main.bal:(141:27,141:36)] redeclared symbol 'divisible'\nERROR [main.bal:(142:16,142:49)] operator '&&' not defined for 'boolean' and 'other'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:35:06.900771",
      "status": "failed",
      "completion": "# Overview\nThis solution rearranges digits of a number to make it divisible by 7. For numbers with many digits (up to 10^6), we cannot generate all permutations. Instead, we use a smart strategy: try permutations for small numbers (≤10 digits) and use heuristic approaches for larger numbers by trying different sorting orders and rotations.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read input number as string\n// 2. For small numbers (≤10 digits): generate permutations and check divisibility\n// 3. For large numbers: try multiple heuristic arrangements (sorted, rotated, etc.)\n// 4. Check divisibility by 7 using modular arithmetic (digit by digit for large numbers)\n// 5. Ensure no leading zeros\n// 6. Return first valid arrangement or \"0\"\n//\n// Key fixes from previous attempt:\n// - Properly handle array sort() which is void, not returning a value\n// - Fix variable shadowing in tests\n// - Properly check boolean conditions\n\nimport ballerina/io;\n\n// Calculate if a number string is divisible by 7 using modular arithmetic\nfunction isDivisibleBy7(string num) returns boolean|error {\n    if num.length() == 0 {\n        return false;\n    }\n    int remainder = 0;\n    foreach int i in 0 ..< num.length() {\n        string digitStr = num.substring(i, i + 1);\n        int|error digitVal = int:fromString(digitStr);\n        if digitVal is error {\n            return digitVal;\n        }\n        remainder = (remainder * 10 + digitVal) % 7;\n    }\n    return remainder == 0;\n}\n\n// Generate next lexicographic permutation\nfunction nextPermutation(int[] arr) returns boolean {\n    int n = arr.length();\n    int i = n - 2;\n    \n    // Find rightmost element that is smaller than its next element\n    while i >= 0 && arr[i] >= arr[i + 1] {\n        i = i - 1;\n    }\n    \n    if i < 0 {\n        return false; // No more permutations\n    }\n    \n    // Find smallest element to right of i that is greater than arr[i]\n    int j = n - 1;\n    while arr[j] <= arr[i] {\n        j = j - 1;\n    }\n    \n    // Swap elements at i and j\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    \n    // Reverse suffix starting at i+1\n    int left = i + 1;\n    int right = n - 1;\n    while left < right {\n        temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left = left + 1;\n        right = right - 1;\n    }\n    \n    return true;\n}\n\n// Convert digit array to string\nfunction digitsToString(int[] digits) returns string {\n    string result = \"\";\n    foreach int d in digits {\n        result = result + d.toString();\n    }\n    return result;\n}\n\n// Try to find arrangement divisible by 7\nfunction findDivisibleBy7(string input) returns string {\n    // Convert string to array of digits\n    int[] digits = [];\n    foreach int i in 0 ..< input.length() {\n        string ch = input.substring(i, i + 1);\n        int|error digit = int:fromString(ch);\n        if digit is int {\n            digits.push(digit);\n        }\n    }\n    \n    if digits.length() == 0 {\n        return \"0\";\n    }\n    \n    // For large numbers, try heuristic approaches\n    if digits.length() > 10 {\n        // Strategy 1: Try sorted ascending with non-zero first\n        int[] sortedDigits = digits.clone();\n        int[] tempArray = sortedDigits.clone();\n        _ = tempArray.sort();\n        sortedDigits = tempArray;\n        \n        int firstNonZeroIdx = -1;\n        foreach int idx in 0 ..< sortedDigits.length() {\n            if sortedDigits[idx] != 0 {\n                firstNonZeroIdx = idx;\n                break;\n            }\n        }\n        \n        if firstNonZeroIdx >= 0 {\n            // Move first non-zero to front\n            int[] arranged = [sortedDigits[firstNonZeroIdx]];\n            foreach int idx in 0 ..< sortedDigits.length() {\n                if idx != firstNonZeroIdx {\n                    arranged.push(sortedDigits[idx]);\n                }\n            }\n            string candidate = digitsToString(arranged);\n            boolean|error div = isDivisibleBy7(candidate);\n            if div is boolean && div {\n                return candidate;\n            }\n        }\n        \n        // Strategy 2: Try different rotations\n        foreach int rotation in 0 ..< (sortedDigits.length() < 100 ? sortedDigits.length() : 100) {\n            string candidate = digitsToString(sortedDigits);\n            if candidate.substring(0, 1) != \"0\" {\n                boolean|error div2 = isDivisibleBy7(candidate);\n                if div2 is boolean && div2 {\n                    return candidate;\n                }\n            }\n            // Rotate by moving last to first\n            if sortedDigits.length() > 1 {\n                int last = sortedDigits[sortedDigits.length() - 1];\n                int[] rotated = [last];\n                foreach int idx in 0 ..< sortedDigits.length() - 1 {\n                    rotated.push(sortedDigits[idx]);\n                }\n                sortedDigits = rotated;\n            }\n        }\n        \n        return \"0\";\n    }\n    \n    // For small numbers, try permutations\n    int[] workingDigits = digits.clone();\n    int[] tempArr = workingDigits.clone();\n    _ = tempArr.sort();\n    workingDigits = tempArr;\n    \n    int maxAttempts = 100000; // Reasonable limit\n    int attempts = 0;\n    \n    while attempts < maxAttempts {\n        string candidate = digitsToString(workingDigits);\n        \n        // Check no leading zero and divisibility by 7\n        if candidate.substring(0, 1) != \"0\" {\n            boolean|error div3 = isDivisibleBy7(candidate);\n            if div3 is boolean && div3 {\n                return candidate;\n            }\n        }\n        \n        // Try next permutation\n        boolean hasNext = nextPermutation(workingDigits);\n        if !hasNext {\n            break;\n        }\n        attempts = attempts + 1;\n    }\n    \n    return \"0\";\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string trimmed = input_line.trim();\n        if trimmed.length() > 0 {\n            string result = findDivisibleBy7(trimmed);\n            io:println(result);\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    string result = findDivisibleBy7(\"1689\");\n    // Check that result is divisible by 7\n    boolean|error divCheck = isDivisibleBy7(result);\n    test:assertTrue(divCheck is boolean);\n    if divCheck is boolean {\n        test:assertTrue(divCheck, \"Result should be divisible by 7\");\n    }\n    test:assertNotEquals(result, \"0\", \"Should find a valid arrangement\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    string result = findDivisibleBy7(\"18906\");\n    // Should rearrange to a number divisible by 7\n    boolean|error divCheck = isDivisibleBy7(result);\n    test:assertTrue(divCheck is boolean);\n    if divCheck is boolean {\n        test:assertTrue(divCheck, \"Result should be divisible by 7\");\n    }\n    test:assertNotEquals(result, \"0\", \"Should find a valid arrangement\");\n}\n\n@test:Config {}\nfunction testNoLeadingZero() {\n    string result = findDivisibleBy7(\"1689\");\n    // Verify no leading zeros\n    test:assertNotEquals(result.substring(0, 1), \"0\", \"Result should not have leading zero\");\n    // Verify divisibility\n    boolean|error divCheck = isDivisibleBy7(result);\n    test:assertTrue(divCheck is boolean);\n    if divCheck is boolean {\n        test:assertTrue(divCheck, \"Result should be divisible by 7\");\n    }\n}\n\n@test:Config {}\nfunction testDivisibilityHelper() {\n    // Test the helper function\n    boolean|error r1 = isDivisibleBy7(\"1869\");\n    test:assertTrue(r1 is boolean);\n    if r1 is boolean {\n        test:assertTrue(r1, \"1869 is divisible by 7\");\n    }\n    \n    boolean|error r2 = isDivisibleBy7(\"14\");\n    test:assertTrue(r2 is boolean);\n    if r2 is boolean {\n        test:assertTrue(r2, \"14 is divisible by 7\");\n    }\n    \n    boolean|error r3 = isDivisibleBy7(\"15\");\n    test:assertTrue(r3 is boolean);\n    if r3 is boolean {\n        test:assertFalse(r3, \"15 is not divisible by 7\");\n    }\n    \n    boolean|error r4 = isDivisibleBy7(\"21\");\n    test:assertTrue(r4 is boolean);\n    if r4 is boolean {\n        test:assertTrue(r4, \"21 is divisible by 7\");\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read input number as string\n// 2. For small numbers (≤10 digits): generate permutations and check divisibility\n// 3. For large numbers: try multiple heuristic arrangements (sorted, rotated, etc.)\n// 4. Check divisibility by 7 using modular arithmetic (digit by digit for large numbers)\n// 5. Ensure no leading zeros\n// 6. Return first valid arrangement or \"0\"\n//\n// Key fixes from previous attempt:\n// - Properly handle array sort() which is void, not returning a value\n// - Fix variable shadowing in tests\n// - Properly check boolean conditions\n\nimport ballerina/io;\n\n// Calculate if a number string is divisible by 7 using modular arithmetic\nfunction isDivisibleBy7(string num) returns boolean|error {\n    if num.length() == 0 {\n        return false;\n    }\n    int remainder = 0;\n    foreach int i in 0 ..< num.length() {\n        string digitStr = num.substring(i, i + 1);\n        int|error digitVal = int:fromString(digitStr);\n        if digitVal is error {\n            return digitVal;\n        }\n        remainder = (remainder * 10 + digitVal) % 7;\n    }\n    return remainder == 0;\n}\n\n// Generate next lexicographic permutation\nfunction nextPermutation(int[] arr) returns boolean {\n    int n = arr.length();\n    int i = n - 2;\n    \n    // Find rightmost element that is smaller than its next element\n    while i >= 0 && arr[i] >= arr[i + 1] {\n        i = i - 1;\n    }\n    \n    if i < 0 {\n        return false; // No more permutations\n    }\n    \n    // Find smallest element to right of i that is greater than arr[i]\n    int j = n - 1;\n    while arr[j] <= arr[i] {\n        j = j - 1;\n    }\n    \n    // Swap elements at i and j\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    \n    // Reverse suffix starting at i+1\n    int left = i + 1;\n    int right = n - 1;\n    while left < right {\n        temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left = left + 1;\n        right = right - 1;\n    }\n    \n    return true;\n}\n\n// Convert digit array to string\nfunction digitsToString(int[] digits) returns string {\n    string result = \"\";\n    foreach int d in digits {\n        result = result + d.toString();\n    }\n    return result;\n}\n\n// Try to find arrangement divisible by 7\nfunction findDivisibleBy7(string input) returns string {\n    // Convert string to array of digits\n    int[] digits = [];\n    foreach int i in 0 ..< input.length() {\n        string ch = input.substring(i, i + 1);\n        int|error digit = int:fromString(ch);\n        if digit is int {\n            digits.push(digit);\n        }\n    }\n    \n    if digits.length() == 0 {\n        return \"0\";\n    }\n    \n    // For large numbers, try heuristic approaches\n    if digits.length() > 10 {\n        // Strategy 1: Try sorted ascending with non-zero first\n        int[] sortedDigits = digits.clone();\n        int[] tempArray = sortedDigits.clone();\n        _ = tempArray.sort();\n        sortedDigits = tempArray;\n        \n        int firstNonZeroIdx = -1;\n        foreach int idx in 0 ..< sortedDigits.length() {\n            if sortedDigits[idx] != 0 {\n                firstNonZeroIdx = idx;\n                break;\n            }\n        }\n        \n        if firstNonZeroIdx >= 0 {\n            // Move first non-zero to front\n            int[] arranged = [sortedDigits[firstNonZeroIdx]];\n            foreach int idx in 0 ..< sortedDigits.length() {\n                if idx != firstNonZeroIdx {\n                    arranged.push(sortedDigits[idx]);\n                }\n            }\n            string candidate = digitsToString(arranged);\n            boolean|error div = isDivisibleBy7(candidate);\n            if div is boolean && div {\n                return candidate;\n            }\n        }\n        \n        // Strategy 2: Try different rotations\n        foreach int rotation in 0 ..< (sortedDigits.length() < 100 ? sortedDigits.length() : 100) {\n            string candidate = digitsToString(sortedDigits);\n            if candidate.substring(0, 1) != \"0\" {\n                boolean|error div2 = isDivisibleBy7(candidate);\n                if div2 is boolean && div2 {\n                    return candidate;\n                }\n            }\n            // Rotate by moving last to first\n            if sortedDigits.length() > 1 {\n                int last = sortedDigits[sortedDigits.length() - 1];\n                int[] rotated = [last];\n                foreach int idx in 0 ..< sortedDigits.length() - 1 {\n                    rotated.push(sortedDigits[idx]);\n                }\n                sortedDigits = rotated;\n            }\n        }\n        \n        return \"0\";\n    }\n    \n    // For small numbers, try permutations\n    int[] workingDigits = digits.clone();\n    int[] tempArr = workingDigits.clone();\n    _ = tempArr.sort();\n    workingDigits = tempArr;\n    \n    int maxAttempts = 100000; // Reasonable limit\n    int attempts = 0;\n    \n    while attempts < maxAttempts {\n        string candidate = digitsToString(workingDigits);\n        \n        // Check no leading zero and divisibility by 7\n        if candidate.substring(0, 1) != \"0\" {\n            boolean|error div3 = isDivisibleBy7(candidate);\n            if div3 is boolean && div3 {\n                return candidate;\n            }\n        }\n        \n        // Try next permutation\n        boolean hasNext = nextPermutation(workingDigits);\n        if !hasNext {\n            break;\n        }\n        attempts = attempts + 1;\n    }\n    \n    return \"0\";\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string trimmed = input_line.trim();\n        if trimmed.length() > 0 {\n            string result = findDivisibleBy7(trimmed);\n            io:println(result);\n        }\n    }\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "18906\n",
          "expected_output": "18690\n",
          "actual_output": "19068\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T01:35:46.236120"
}