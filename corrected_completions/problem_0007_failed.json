{
  "entry_id": "problem_0007",
  "problem_index": 7,
  "prompt": "Title: View Angle\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nFlatland has recently introduced a new type of an eye check for the driver's licence. The check goes like that: there is a plane with mannequins standing on it. You should tell the value of the minimum angle with the vertex at the origin of coordinates and with all mannequins standing inside or on the boarder of this angle. \n\nAs you spend lots of time \"glued to the screen\", your vision is impaired. So you have to write a program that will pass the check for you.\n\nInput Specification:\nThe first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of mannequins.\n\nNext *n* lines contain two space-separated integers each: *x**i*,<=*y**i* (|*x**i*|,<=|*y**i*|<=≤<=1000) — the coordinates of the *i*-th mannequin. It is guaranteed that the origin of the coordinates has no mannequin. It is guaranteed that no two mannequins are located in the same point on the plane.\n\nOutput Specification:\nPrint a single real number — the value of the sought angle in degrees. The answer will be considered valid if the relative or absolute error doesn't exceed 10<=-<=6.\n\nDemo Input:\n['2\\n2 0\\n0 2\\n', '3\\n2 0\\n0 2\\n-2 2\\n', '4\\n2 0\\n0 2\\n-2 0\\n0 -2\\n', '2\\n2 1\\n1 2\\n']\n\nDemo Output:\n['90.0000000000\\n', '135.0000000000\\n', '270.0000000000\\n', '36.8698976458\\n']\n\nNote:\nSolution for the first sample test is shown below: \n\nSolution for the second sample test is shown below: \n\nSolution for the third sample test is shown below: \n\nSolution for the fourth sample test is shown below:",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:02:36.707397",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to find the minimum angle with vertex at the origin that contains all given points (mannequins). \n\nThe key insight is:\n1. Calculate the angle of each point from the positive x-axis\n2. Sort these angles\n3. The minimum angle is either:\n   - The angle between the first and last point (going the \"short way\")\n   - OR the maximum gap between consecutive sorted angles, and the answer would be 360 - that gap\n\nThe algorithm:\n- Convert each point to polar angle using atan2\n- Sort all angles\n- Check gaps between consecutive angles\n- The minimum containing angle = 360 - (maximum gap between consecutive angles)\n\n<CODE>\n```ballerina\n// Problem: Find minimum angle with vertex at origin containing all points\n// \n// Reasoning:\n// 1. Convert each point (x, y) to its polar angle using atan2(y, x)\n// 2. Sort all angles in ascending order\n// 3. Find the maximum gap between consecutive angles (including wrap-around from last to first)\n// 4. The minimum containing angle = 360 - maximum_gap\n// 5. Special case: if there's only 1 point, angle is 0\n// \n// atan2 returns angle in radians from -PI to PI\n// We'll convert to degrees (0 to 360) for easier handling\n\nimport ballerina/io;\nimport ballerina/math;\n\nfunction findMinimumAngle(float[][] points) returns float|error {\n    int n = points.length();\n    \n    // Special case: only one point\n    if n == 1 {\n        return 0.0;\n    }\n    \n    // Convert each point to angle in degrees [0, 360)\n    float[] angles = [];\n    foreach float[] point in points {\n        float x = point[0];\n        float y = point[1];\n        float angleRad = math:atan2(y, x);\n        // Convert to degrees and normalize to [0, 360)\n        float angleDeg = angleRad * 180.0 / math:PI;\n        if angleDeg < 0.0 {\n            angleDeg = angleDeg + 360.0;\n        }\n        angles.push(angleDeg);\n    }\n    \n    // Sort angles\n    float[] sortedAngles = angles.sort();\n    \n    // Find maximum gap between consecutive angles\n    float maxGap = 0.0;\n    foreach int i in 0 ..< n - 1 {\n        float gap = sortedAngles[i + 1] - sortedAngles[i];\n        if gap > maxGap {\n            maxGap = gap;\n        }\n    }\n    \n    // Check wrap-around gap (from last to first)\n    float wrapGap = 360.0 - sortedAngles[n - 1] + sortedAngles[0];\n    if wrapGap > maxGap {\n        maxGap = wrapGap;\n    }\n    \n    // Minimum containing angle\n    float minAngle = 360.0 - maxGap;\n    \n    return minAngle;\n}\n\npublic function main() returns error? {\n    // Read number of mannequins\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n < 1 {\n        return error(\"Number of mannequins must be at least 1\");\n    }\n    \n    // Read coordinates of each mannequin\n    float[][] points = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read coordinate line\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Each coordinate line must have exactly 2 numbers\");\n        }\n        \n        float x = check float:fromString(parts[0]);\n        float y = check float:fromString(parts[1]);\n        \n        points.push([x, y]);\n    }\n    \n    // Calculate and output result\n    float result = check findMinimumAngle(points);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMinimumAngle90Degrees() returns error? {\n    // Two points at 90 degrees apart\n    float[][] points = [[2.0, 0.0], [0.0, 2.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 90.0, 0.000001));\n}\n\n@test:Config {}\nfunction testMinimumAngle135Degrees() returns error? {\n    // Three points requiring 135 degree angle\n    float[][] points = [[2.0, 0.0], [0.0, 2.0], [-2.0, 2.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 135.0, 0.000001));\n}\n\n@test:Config {}\nfunction testMinimumAngle270Degrees() returns error? {\n    // Four points at cardinal directions\n    float[][] points = [[2.0, 0.0], [0.0, 2.0], [-2.0, 0.0], [0.0, -2.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 270.0, 0.000001));\n}\n\n@test:Config {}\nfunction testMinimumAngleArbitrary() returns error? {\n    // Two points at arbitrary positions\n    float[][] points = [[2.0, 1.0], [1.0, 2.0]];\n    float result = check findMinimumAngle(points);\n    // Expected angle is approximately 36.87 degrees\n    test:assertTrue(isApproximatelyEqual(result, 36.8698976458, 0.0001));\n}\n\n@test:Config {}\nfunction testSinglePoint() returns error? {\n    // Single point should return 0\n    float[][] points = [[1.0, 1.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 0.0, 0.000001));\n}\n\n@test:Config {}\nfunction testPointsInAllQuadrants() returns error? {\n    // Points spread across all quadrants\n    float[][] points = [[1.0, 1.0], [-1.0, 1.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 90.0, 0.000001));\n}\n\n// Helper function to compare floats with tolerance\nfunction isApproximatelyEqual(float a, float b, float tolerance) returns boolean {\n    float diff = a - b;\n    if diff < 0.0 {\n        diff = -diff;\n    }\n    return diff < tolerance;\n}\n```\n</TESTS>",
      "code": "// Problem: Find minimum angle with vertex at origin containing all points\n// \n// Reasoning:\n// 1. Convert each point (x, y) to its polar angle using atan2(y, x)\n// 2. Sort all angles in ascending order\n// 3. Find the maximum gap between consecutive angles (including wrap-around from last to first)\n// 4. The minimum containing angle = 360 - maximum_gap\n// 5. Special case: if there's only 1 point, angle is 0\n// \n// atan2 returns angle in radians from -PI to PI\n// We'll convert to degrees (0 to 360) for easier handling\n\nimport ballerina/io;\nimport ballerina/math;\n\nfunction findMinimumAngle(float[][] points) returns float|error {\n    int n = points.length();\n    \n    // Special case: only one point\n    if n == 1 {\n        return 0.0;\n    }\n    \n    // Convert each point to angle in degrees [0, 360)\n    float[] angles = [];\n    foreach float[] point in points {\n        float x = point[0];\n        float y = point[1];\n        float angleRad = math:atan2(y, x);\n        // Convert to degrees and normalize to [0, 360)\n        float angleDeg = angleRad * 180.0 / math:PI;\n        if angleDeg < 0.0 {\n            angleDeg = angleDeg + 360.0;\n        }\n        angles.push(angleDeg);\n    }\n    \n    // Sort angles\n    float[] sortedAngles = angles.sort();\n    \n    // Find maximum gap between consecutive angles\n    float maxGap = 0.0;\n    foreach int i in 0 ..< n - 1 {\n        float gap = sortedAngles[i + 1] - sortedAngles[i];\n        if gap > maxGap {\n            maxGap = gap;\n        }\n    }\n    \n    // Check wrap-around gap (from last to first)\n    float wrapGap = 360.0 - sortedAngles[n - 1] + sortedAngles[0];\n    if wrapGap > maxGap {\n        maxGap = wrapGap;\n    }\n    \n    // Minimum containing angle\n    float minAngle = 360.0 - maxGap;\n    \n    return minAngle;\n}\n\npublic function main() returns error? {\n    // Read number of mannequins\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    if n < 1 {\n        return error(\"Number of mannequins must be at least 1\");\n    }\n    \n    // Read coordinates of each mannequin\n    float[][] points = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read coordinate line\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Each coordinate line must have exactly 2 numbers\");\n        }\n        \n        float x = check float:fromString(parts[0]);\n        float y = check float:fromString(parts[1]);\n        \n        points.push([x, y]);\n    }\n    \n    // Calculate and output result\n    float result = check findMinimumAngle(points);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 4,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(14:1,14:23)] cannot resolve module 'ballerina/math'\nERROR [main.bal:(29:26,29:42)] undefined function 'atan2'\nERROR [main.bal:(29:26,29:42)] undefined module 'math'\nERROR [main.bal:(31:45,31:52)] undefined module 'math'\nERROR [main.bal:(83:38,83:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(14:1,14:23)] cannot resolve module 'ballerina/math'\nERROR [main.bal:(29:26,29:42)] undefined function 'atan2'\nERROR [main.bal:(29:26,29:42)] undefined module 'math'\nERROR [main.bal:(31:45,31:52)] undefined module 'math'\nERROR [main.bal:(83:38,83:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(14:1,14:23)] cannot resolve module 'ballerina/math'\nERROR [main.bal:(29:26,29:42)] undefined function 'atan2'\nERROR [main.bal:(29:26,29:42)] undefined module 'math'\nERROR [main.bal:(31:45,31:52)] undefined module 'math'\nERROR [main.bal:(83:38,83:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:03:05.886990",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires finding the minimum angle with vertex at the origin that contains all given points. The key insight is to:\n1. Calculate polar angles for all points\n2. Sort these angles\n3. Find the maximum gap between consecutive angles\n4. The minimum containing angle = 360° - maximum gap\n\nSince Ballerina doesn't have a built-in math library with atan2, I'll implement custom trigonometric functions using basic arithmetic operations and the standard library.\n\n<CODE>\n```ballerina\n// Problem: Find minimum angle with vertex at origin containing all points\n// \n// Reasoning:\n// 1. We need to calculate atan2(y, x) for each point to get polar angles\n// 2. Since ballerina/math is not available, we'll implement our own atan2 using:\n//    - atan approximation using Taylor series or rational approximation\n//    - Handle different quadrants based on signs of x and y\n// 3. Convert angles to degrees [0, 360)\n// 4. Sort angles and find maximum gap between consecutive angles\n// 5. Minimum containing angle = 360 - max_gap\n//\n// Special cases:\n// - Single point: return 0\n// - All points at same angle: return 0\n//\n// For atan2(y, x):\n// - Returns angle in radians from -PI to PI\n// - We need to handle all four quadrants correctly\n\nimport ballerina/io;\n\nconst float PI = 3.14159265358979323846;\n\n// Compute arctangent using rational approximation\n// This approximation works for |x| <= 1\nfunction atanApprox(float x) returns float {\n    // Using polynomial approximation for atan\n    // atan(x) ≈ x - x^3/3 + x^5/5 - x^7/7 + x^9/9 for small x\n    float x2 = x * x;\n    float result = x * (1.0 - x2 * (0.3333333 - x2 * (0.2 - x2 * (0.142857 - x2 * 0.111111))));\n    return result;\n}\n\n// Compute atan(y/x) handling all cases\nfunction atan2(float y, float x) returns float {\n    if x == 0.0 {\n        if y > 0.0 {\n            return PI / 2.0;\n        } else if y < 0.0 {\n            return -PI / 2.0;\n        } else {\n            return 0.0;\n        }\n    }\n    \n    if x > 0.0 {\n        // First or fourth quadrant\n        float ratio = y / x;\n        if ratio > 1.0 {\n            return PI / 2.0 - atanApprox(x / y);\n        } else if ratio < -1.0 {\n            return -PI / 2.0 - atanApprox(x / y);\n        } else {\n            return atanApprox(ratio);\n        }\n    } else {\n        // Second or third quadrant (x < 0)\n        float ratio = y / x;\n        if ratio > 1.0 {\n            return PI / 2.0 - atanApprox(x / y);\n        } else if ratio < -1.0 {\n            return -PI / 2.0 - atanApprox(x / y);\n        } else {\n            if y >= 0.0 {\n                return atanApprox(ratio) + PI;\n            } else {\n                return atanApprox(ratio) - PI;\n            }\n        }\n    }\n}\n\nfunction findMinimumAngle(float[][] points) returns float|error {\n    int n = points.length();\n    \n    // Special case: only one point\n    if n == 1 {\n        return 0.0;\n    }\n    \n    // Convert each point to angle in degrees [0, 360)\n    float[] angles = [];\n    foreach float[] point in points {\n        float x = point[0];\n        float y = point[1];\n        float angleRad = atan2(y, x);\n        // Convert to degrees and normalize to [0, 360)\n        float angleDeg = angleRad * 180.0 / PI;\n        if angleDeg < 0.0 {\n            angleDeg = angleDeg + 360.0;\n        }\n        angles.push(angleDeg);\n    }\n    \n    // Sort angles using simple bubble sort (to avoid library dependencies)\n    float[] sortedAngles = angles.clone();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - 1 - i {\n            if sortedAngles[j] > sortedAngles[j + 1] {\n                float temp = sortedAngles[j];\n                sortedAngles[j] = sortedAngles[j + 1];\n                sortedAngles[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Find maximum gap between consecutive angles\n    float maxGap = 0.0;\n    foreach int i in 0 ..< n - 1 {\n        float gap = sortedAngles[i + 1] - sortedAngles[i];\n        if gap > maxGap {\n            maxGap = gap;\n        }\n    }\n    \n    // Check wrap-around gap (from last to first)\n    float wrapGap = 360.0 - sortedAngles[n - 1] + sortedAngles[0];\n    if wrapGap > maxGap {\n        maxGap = wrapGap;\n    }\n    \n    // Minimum containing angle\n    float minAngle = 360.0 - maxGap;\n    \n    return minAngle;\n}\n\npublic function main() returns error? {\n    // Read number of mannequins\n    string? nLine = io:readln(\"Enter number of points: \");\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string nStr = nLine.trim();\n    int n = check int:fromString(nStr);\n    \n    if n < 1 {\n        return error(\"Number of mannequins must be at least 1\");\n    }\n    \n    // Read coordinates of each mannequin\n    float[][] points = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln(\"Enter x y: \");\n        if line is () {\n            return error(\"Failed to read coordinate line\");\n        }\n        \n        string trimmed = line.trim();\n        int? spaceIdx = trimmed.indexOf(\" \");\n        \n        if spaceIdx is () {\n            return error(\"Each coordinate line must have exactly 2 numbers\");\n        }\n        \n        string xStr = trimmed.substring(0, spaceIdx);\n        string yStr = trimmed.substring(spaceIdx + 1);\n        \n        // Trim any extra spaces in yStr\n        int idx = 0;\n        while idx < yStr.length() && yStr[idx] == \" \" {\n            idx += 1;\n        }\n        yStr = yStr.substring(idx);\n        \n        float x = check float:fromString(xStr);\n        float y = check float:fromString(yStr);\n        \n        points.push([x, y]);\n    }\n    \n    // Calculate and output result\n    float result = check findMinimumAngle(points);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n// Helper function to compare floats with tolerance\nfunction isApproximatelyEqual(float a, float b, float tolerance) returns boolean {\n    float diff = a - b;\n    if diff < 0.0 {\n        diff = -diff;\n    }\n    return diff < tolerance;\n}\n\n@test:Config {}\nfunction testMinimumAngle90Degrees() returns error? {\n    // Two points at 90 degrees apart\n    float[][] points = [[2.0, 0.0], [0.0, 2.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 90.0, 0.01), \n        \"Expected 90.0 but got \" + result.toString());\n}\n\n@test:Config {}\nfunction testMinimumAngle135Degrees() returns error? {\n    // Three points requiring 135 degree angle\n    float[][] points = [[2.0, 0.0], [0.0, 2.0], [-2.0, 2.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 135.0, 0.01), \n        \"Expected 135.0 but got \" + result.toString());\n}\n\n@test:Config {}\nfunction testMinimumAngle270Degrees() returns error? {\n    // Four points at cardinal directions\n    float[][] points = [[2.0, 0.0], [0.0, 2.0], [-2.0, 0.0], [0.0, -2.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 270.0, 0.01), \n        \"Expected 270.0 but got \" + result.toString());\n}\n\n@test:Config {}\nfunction testMinimumAngleArbitrary() returns error? {\n    // Two points at arbitrary positions\n    float[][] points = [[2.0, 1.0], [1.0, 2.0]];\n    float result = check findMinimumAngle(points);\n    // Expected angle is approximately 36.87 degrees\n    test:assertTrue(isApproximatelyEqual(result, 36.8698976458, 0.01), \n        \"Expected ~36.87 but got \" + result.toString());\n}\n\n@test:Config {}\nfunction testSinglePoint() returns error? {\n    // Single point should return 0\n    float[][] points = [[1.0, 1.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 0.0, 0.01), \n        \"Expected 0.0 but got \" + result.toString());\n}\n\n@test:Config {}\nfunction testPointsInAllQuadrants() returns error? {\n    // Points spread across all quadrants\n    float[][] points = [[1.0, 1.0], [-1.0, 1.0]];\n    float result = check findMinimumAngle(points);\n    test:assertTrue(isApproximatelyEqual(result, 90.0, 0.01), \n        \"Expected 90.0 but got \" + result.toString());\n}\n\n@test:Config {}\nfunction testAtan2Function() {\n    // Test atan2 for known values\n    float angle1 = atan2(1.0, 1.0);  // 45 degrees = PI/4\n    test:assertTrue(isApproximatelyEqual(angle1, PI / 4.0, 0.01));\n    \n    float angle2 = atan2(1.0, 0.0);  // 90 degrees = PI/2\n    test:assertTrue(isApproximatelyEqual(angle2, PI / 2.0, 0.01));\n    \n    float angle3 = atan2(0.0, -1.0); // 180 degrees = PI\n    test:assertTrue(isApproximatelyEqual(angle3, PI, 0.01));\n    \n    float angle4 = atan2(-1.0, 0.0); // -90 degrees = -PI/2\n    test:assertTrue(isApproximatelyEqual(angle4, -PI / 2.0, 0.01));\n}\n```\n</TESTS>",
      "code": "// Problem: Find minimum angle with vertex at origin containing all points\n// \n// Reasoning:\n// 1. We need to calculate atan2(y, x) for each point to get polar angles\n// 2. Since ballerina/math is not available, we'll implement our own atan2 using:\n//    - atan approximation using Taylor series or rational approximation\n//    - Handle different quadrants based on signs of x and y\n// 3. Convert angles to degrees [0, 360)\n// 4. Sort angles and find maximum gap between consecutive angles\n// 5. Minimum containing angle = 360 - max_gap\n//\n// Special cases:\n// - Single point: return 0\n// - All points at same angle: return 0\n//\n// For atan2(y, x):\n// - Returns angle in radians from -PI to PI\n// - We need to handle all four quadrants correctly\n\nimport ballerina/io;\n\nconst float PI = 3.14159265358979323846;\n\n// Compute arctangent using rational approximation\n// This approximation works for |x| <= 1\nfunction atanApprox(float x) returns float {\n    // Using polynomial approximation for atan\n    // atan(x) ≈ x - x^3/3 + x^5/5 - x^7/7 + x^9/9 for small x\n    float x2 = x * x;\n    float result = x * (1.0 - x2 * (0.3333333 - x2 * (0.2 - x2 * (0.142857 - x2 * 0.111111))));\n    return result;\n}\n\n// Compute atan(y/x) handling all cases\nfunction atan2(float y, float x) returns float {\n    if x == 0.0 {\n        if y > 0.0 {\n            return PI / 2.0;\n        } else if y < 0.0 {\n            return -PI / 2.0;\n        } else {\n            return 0.0;\n        }\n    }\n    \n    if x > 0.0 {\n        // First or fourth quadrant\n        float ratio = y / x;\n        if ratio > 1.0 {\n            return PI / 2.0 - atanApprox(x / y);\n        } else if ratio < -1.0 {\n            return -PI / 2.0 - atanApprox(x / y);\n        } else {\n            return atanApprox(ratio);\n        }\n    } else {\n        // Second or third quadrant (x < 0)\n        float ratio = y / x;\n        if ratio > 1.0 {\n            return PI / 2.0 - atanApprox(x / y);\n        } else if ratio < -1.0 {\n            return -PI / 2.0 - atanApprox(x / y);\n        } else {\n            if y >= 0.0 {\n                return atanApprox(ratio) + PI;\n            } else {\n                return atanApprox(ratio) - PI;\n            }\n        }\n    }\n}\n\nfunction findMinimumAngle(float[][] points) returns float|error {\n    int n = points.length();\n    \n    // Special case: only one point\n    if n == 1 {\n        return 0.0;\n    }\n    \n    // Convert each point to angle in degrees [0, 360)\n    float[] angles = [];\n    foreach float[] point in points {\n        float x = point[0];\n        float y = point[1];\n        float angleRad = atan2(y, x);\n        // Convert to degrees and normalize to [0, 360)\n        float angleDeg = angleRad * 180.0 / PI;\n        if angleDeg < 0.0 {\n            angleDeg = angleDeg + 360.0;\n        }\n        angles.push(angleDeg);\n    }\n    \n    // Sort angles using simple bubble sort (to avoid library dependencies)\n    float[] sortedAngles = angles.clone();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - 1 - i {\n            if sortedAngles[j] > sortedAngles[j + 1] {\n                float temp = sortedAngles[j];\n                sortedAngles[j] = sortedAngles[j + 1];\n                sortedAngles[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Find maximum gap between consecutive angles\n    float maxGap = 0.0;\n    foreach int i in 0 ..< n - 1 {\n        float gap = sortedAngles[i + 1] - sortedAngles[i];\n        if gap > maxGap {\n            maxGap = gap;\n        }\n    }\n    \n    // Check wrap-around gap (from last to first)\n    float wrapGap = 360.0 - sortedAngles[n - 1] + sortedAngles[0];\n    if wrapGap > maxGap {\n        maxGap = wrapGap;\n    }\n    \n    // Minimum containing angle\n    float minAngle = 360.0 - maxGap;\n    \n    return minAngle;\n}\n\npublic function main() returns error? {\n    // Read number of mannequins\n    string? nLine = io:readln(\"Enter number of points: \");\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string nStr = nLine.trim();\n    int n = check int:fromString(nStr);\n    \n    if n < 1 {\n        return error(\"Number of mannequins must be at least 1\");\n    }\n    \n    // Read coordinates of each mannequin\n    float[][] points = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln(\"Enter x y: \");\n        if line is () {\n            return error(\"Failed to read coordinate line\");\n        }\n        \n        string trimmed = line.trim();\n        int? spaceIdx = trimmed.indexOf(\" \");\n        \n        if spaceIdx is () {\n            return error(\"Each coordinate line must have exactly 2 numbers\");\n        }\n        \n        string xStr = trimmed.substring(0, spaceIdx);\n        string yStr = trimmed.substring(spaceIdx + 1);\n        \n        // Trim any extra spaces in yStr\n        int idx = 0;\n        while idx < yStr.length() && yStr[idx] == \" \" {\n            idx += 1;\n        }\n        yStr = yStr.substring(idx);\n        \n        float x = check float:fromString(xStr);\n        float y = check float:fromString(yStr);\n        \n        points.push([x, y]);\n    }\n    \n    // Calculate and output result\n    float result = check findMinimumAngle(points);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 4,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/4 tests (0.0%), need 75%",
      "error": "Only passed 0/4 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "2\n2 0\n0 2\n",
          "expected_output": "90.0000000000\n",
          "actual_output": "Enter number of points: Enter x y: Enter x y: 90.0\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/4 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T00:03:57.956549"
}