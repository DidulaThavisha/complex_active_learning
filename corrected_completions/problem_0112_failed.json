{
  "entry_id": "problem_0112",
  "problem_index": 112,
  "prompt": "Title: Three Base Stations\n\nTime Limit: 1 seconds\n\nMemory Limit: 256 megabytes\n\nProblem Description:\nThe New Vasjuki village is stretched along the motorway and that's why every house on it is characterized by its shift relative to some fixed point — the *x**i* coordinate. The village consists of *n* houses, the *i*-th house is located in the point with coordinates of *x**i*.\n\nTELE3, a cellular communication provider planned to locate three base stations so as to provide every house in the village with cellular communication. The base station having power *d* located in the point *t* provides with communication all the houses on the segment [*t*<=-<=*d*,<=*t*<=+<=*d*] (including boundaries).\n\nTo simplify the integration (and simply not to mix anything up) all the three stations are planned to possess the equal power of *d*. Which minimal value of *d* is enough to provide all the houses in the village with cellular communication.\n\nInput Specification:\nThe first line contains an integer *n* (1<=≤<=*n*<=≤<=2·105) which represents the number of houses in the village. The second line contains the coordinates of houses — the sequence *x*1,<=*x*2,<=...,<=*x**n* of integer numbers (1<=≤<=*x**i*<=≤<=109). It is possible that two or more houses are located on one point. The coordinates are given in a arbitrary order.\n\nOutput Specification:\nPrint the required minimal power *d*. In the second line print three numbers — the possible coordinates of the base stations' location. Print the coordinates with 6 digits after the decimal point. The positions of the stations can be any from 0 to 2·109 inclusively. It is accepted for the base stations to have matching coordinates. If there are many solutions, print any of them.\n\nDemo Input:\n['4\\n1 2 3 4\\n', '3\\n10 20 30\\n', '5\\n10003 10004 10001 10002 1\\n']\n\nDemo Output:\n['0.500000\\n1.500000 2.500000 3.500000\\n', '0\\n10.000000 20.000000 30.000000\\n', '0.500000\\n1.000000 10001.500000 10003.500000\\n']\n\nNote:\nnone",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:58:03.595294",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to find the minimum power `d` for three base stations to cover all houses in a village. Each base station at position `t` with power `d` covers the range `[t-d, t+d]`.\n\nThe key insight is that we need to try all possible ways to partition the sorted houses into three groups and find the minimum maximum radius needed. For each partition, we place a station at the center of each group's span.\n\nThe strategy:\n1. Sort the house coordinates\n2. Try all possible ways to split houses into 3 groups (including empty groups for edge cases)\n3. For each group, the optimal station position is at the center of the span\n4. The power needed for a group is half the span (radius from center to edge)\n5. The answer is the maximum power needed among the three stations\n6. Choose the partition that minimizes this maximum power\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Sort all house positions\n// 2. Try all possible ways to partition houses into 3 groups using two dividers\n// 3. For each partition, calculate the minimum radius needed for each group\n// 4. The radius for a group is (max - min) / 2, and station is at (max + min) / 2\n// 5. The power d needed is the maximum radius among the three stations\n// 6. Find the partition that minimizes this maximum radius\n\nimport ballerina/io;\n\nfunction solveThreeBaseStations(int[] houses) returns [float, float, float, float] {\n    // Sort the houses\n    int[] sorted = houses.sort();\n    int n = sorted.length();\n    \n    if n == 0 {\n        return [0.0, 0.0, 0.0, 0.0];\n    }\n    \n    float minPower = <float>(sorted[n-1] - sorted[0]);\n    float station1 = <float>sorted[0];\n    float station2 = <float>sorted[0];\n    float station3 = <float>sorted[0];\n    \n    // Try all possible partitions: [0..i), [i..j), [j..n)\n    // i can be from 0 to n (0 means first group is empty)\n    // j can be from i to n (j=i means second group is empty)\n    int i = 0;\n    while i <= n {\n        int j = i;\n        while j <= n {\n            float maxRadius = 0.0;\n            float s1 = 0.0;\n            float s2 = 0.0;\n            float s3 = 0.0;\n            \n            // First group: [0..i)\n            if i > 0 {\n                float radius = <float>(sorted[i-1] - sorted[0]) / 2.0;\n                s1 = <float>(sorted[0] + sorted[i-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s1 = <float>sorted[0];\n            }\n            \n            // Second group: [i..j)\n            if j > i {\n                float radius = <float>(sorted[j-1] - sorted[i]) / 2.0;\n                s2 = <float>(sorted[i] + sorted[j-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s2 = <float>sorted[0];\n            }\n            \n            // Third group: [j..n)\n            if n > j {\n                float radius = <float>(sorted[n-1] - sorted[j]) / 2.0;\n                s3 = <float>(sorted[j] + sorted[n-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s3 = <float>sorted[0];\n            }\n            \n            if maxRadius < minPower {\n                minPower = maxRadius;\n                station1 = s1;\n                station2 = s2;\n                station3 = s3;\n            }\n            \n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    \n    return [minPower, station1, station2, station3];\n}\n\npublic function main() returns error? {\n    // Read number of houses\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Read house coordinates\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    int[] houses = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int coord = check 'int:fromString(part.trim());\n            houses.push(coord);\n        }\n    }\n    \n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    \n    io:println(string `${result[0].toFixedString(6)}`);\n    io:println(string `${result[1].toFixedString(6)} ${result[2].toFixedString(6)} ${result[3].toFixedString(6)}`);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBasicCase() {\n    int[] houses = [1, 2, 3, 4];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.5);\n}\n\n@test:Config {}\nfunction testSingleGroupCase() {\n    int[] houses = [10, 20, 30];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n\n@test:Config {}\nfunction testMixedCase() {\n    int[] houses = [1, 10001, 10002, 10003, 10004];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.5);\n}\n\n@test:Config {}\nfunction testSingleHouse() {\n    int[] houses = [100];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n\n@test:Config {}\nfunction testTwoHouses() {\n    int[] houses = [1, 10];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n\n@test:Config {}\nfunction testIdenticalHouses() {\n    int[] houses = [5, 5, 5, 5];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Sort all house positions\n// 2. Try all possible ways to partition houses into 3 groups using two dividers\n// 3. For each partition, calculate the minimum radius needed for each group\n// 4. The radius for a group is (max - min) / 2, and station is at (max + min) / 2\n// 5. The power d needed is the maximum radius among the three stations\n// 6. Find the partition that minimizes this maximum radius\n\nimport ballerina/io;\n\nfunction solveThreeBaseStations(int[] houses) returns [float, float, float, float] {\n    // Sort the houses\n    int[] sorted = houses.sort();\n    int n = sorted.length();\n    \n    if n == 0 {\n        return [0.0, 0.0, 0.0, 0.0];\n    }\n    \n    float minPower = <float>(sorted[n-1] - sorted[0]);\n    float station1 = <float>sorted[0];\n    float station2 = <float>sorted[0];\n    float station3 = <float>sorted[0];\n    \n    // Try all possible partitions: [0..i), [i..j), [j..n)\n    // i can be from 0 to n (0 means first group is empty)\n    // j can be from i to n (j=i means second group is empty)\n    int i = 0;\n    while i <= n {\n        int j = i;\n        while j <= n {\n            float maxRadius = 0.0;\n            float s1 = 0.0;\n            float s2 = 0.0;\n            float s3 = 0.0;\n            \n            // First group: [0..i)\n            if i > 0 {\n                float radius = <float>(sorted[i-1] - sorted[0]) / 2.0;\n                s1 = <float>(sorted[0] + sorted[i-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s1 = <float>sorted[0];\n            }\n            \n            // Second group: [i..j)\n            if j > i {\n                float radius = <float>(sorted[j-1] - sorted[i]) / 2.0;\n                s2 = <float>(sorted[i] + sorted[j-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s2 = <float>sorted[0];\n            }\n            \n            // Third group: [j..n)\n            if n > j {\n                float radius = <float>(sorted[n-1] - sorted[j]) / 2.0;\n                s3 = <float>(sorted[j] + sorted[n-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s3 = <float>sorted[0];\n            }\n            \n            if maxRadius < minPower {\n                minPower = maxRadius;\n                station1 = s1;\n                station2 = s2;\n                station3 = s3;\n            }\n            \n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    \n    return [minPower, station1, station2, station3];\n}\n\npublic function main() returns error? {\n    // Read number of houses\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Read house coordinates\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    int[] houses = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int coord = check 'int:fromString(part.trim());\n            houses.push(coord);\n        }\n    }\n    \n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    \n    io:println(string `${result[0].toFixedString(6)}`);\n    io:println(string `${result[1].toFixedString(6)} ${result[2].toFixedString(6)} ${result[3].toFixedString(6)}`);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(100:35,100:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(100:35,100:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(100:35,100:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:58:33.421824",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires finding the minimum power `d` for three base stations to cover all houses in a village. Each base station at position `t` with power `d` covers the range `[t-d, t+d]`.\n\nThe key insight is to try all possible ways to partition sorted houses into three groups and find the minimum maximum radius needed. For each partition, we place a station at the center of each group's span.\n\nThe main fix needed is using `regex:split()` from ballerina/regex instead of the non-existent `split()` method on strings, or using a different approach like iterating through characters.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Sort all house positions\n// 2. Try all possible ways to partition houses into 3 groups using two dividers\n// 3. For each partition, calculate the minimum radius needed for each group\n// 4. The radius for a group is (max - min) / 2, and station is at (max + min) / 2\n// 5. The power d needed is the maximum radius among the three stations\n// 6. Find the partition that minimizes this maximum radius\n// \n// Fix: Use regex:split() instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveThreeBaseStations(int[] houses) returns [float, float, float, float] {\n    // Sort the houses\n    int[] sorted = houses.sort();\n    int n = sorted.length();\n    \n    if n == 0 {\n        return [0.0, 0.0, 0.0, 0.0];\n    }\n    \n    float minPower = <float>(sorted[n-1] - sorted[0]);\n    float station1 = <float>sorted[0];\n    float station2 = <float>sorted[0];\n    float station3 = <float>sorted[0];\n    \n    // Try all possible partitions: [0..i), [i..j), [j..n)\n    // i can be from 0 to n (0 means first group is empty)\n    // j can be from i to n (j=i means second group is empty)\n    int i = 0;\n    while i <= n {\n        int j = i;\n        while j <= n {\n            float maxRadius = 0.0;\n            float s1 = 0.0;\n            float s2 = 0.0;\n            float s3 = 0.0;\n            \n            // First group: [0..i)\n            if i > 0 {\n                float radius = <float>(sorted[i-1] - sorted[0]) / 2.0;\n                s1 = <float>(sorted[0] + sorted[i-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s1 = <float>sorted[0];\n            }\n            \n            // Second group: [i..j)\n            if j > i {\n                float radius = <float>(sorted[j-1] - sorted[i]) / 2.0;\n                s2 = <float>(sorted[i] + sorted[j-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s2 = <float>sorted[0];\n            }\n            \n            // Third group: [j..n)\n            if n > j {\n                float radius = <float>(sorted[n-1] - sorted[j]) / 2.0;\n                s3 = <float>(sorted[j] + sorted[n-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s3 = <float>sorted[0];\n            }\n            \n            if maxRadius < minPower {\n                minPower = maxRadius;\n                station1 = s1;\n                station2 = s2;\n                station3 = s3;\n            }\n            \n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    \n    return [minPower, station1, station2, station3];\n}\n\npublic function main() returns error? {\n    // Read number of houses\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Read house coordinates\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    // Use regex:split instead of string.split\n    string[] parts = regex:split(line2.trim(), \" \");\n    int[] houses = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int coord = check 'int:fromString(part.trim());\n            houses.push(coord);\n        }\n    }\n    \n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    \n    io:println(string `${result[0].toFixedString(6)}`);\n    io:println(string `${result[1].toFixedString(6)} ${result[2].toFixedString(6)} ${result[3].toFixedString(6)}`);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBasicCase() {\n    int[] houses = [1, 2, 3, 4];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.5);\n}\n\n@test:Config {}\nfunction testSingleGroupCase() {\n    int[] houses = [10, 20, 30];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n\n@test:Config {}\nfunction testMixedCase() {\n    int[] houses = [1, 10001, 10002, 10003, 10004];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.5);\n}\n\n@test:Config {}\nfunction testSingleHouse() {\n    int[] houses = [100];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n\n@test:Config {}\nfunction testTwoHouses() {\n    int[] houses = [1, 10];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n\n@test:Config {}\nfunction testIdenticalHouses() {\n    int[] houses = [5, 5, 5, 5];\n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    test:assertEquals(result[0], 0.0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Sort all house positions\n// 2. Try all possible ways to partition houses into 3 groups using two dividers\n// 3. For each partition, calculate the minimum radius needed for each group\n// 4. The radius for a group is (max - min) / 2, and station is at (max + min) / 2\n// 5. The power d needed is the maximum radius among the three stations\n// 6. Find the partition that minimizes this maximum radius\n// \n// Fix: Use regex:split() instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveThreeBaseStations(int[] houses) returns [float, float, float, float] {\n    // Sort the houses\n    int[] sorted = houses.sort();\n    int n = sorted.length();\n    \n    if n == 0 {\n        return [0.0, 0.0, 0.0, 0.0];\n    }\n    \n    float minPower = <float>(sorted[n-1] - sorted[0]);\n    float station1 = <float>sorted[0];\n    float station2 = <float>sorted[0];\n    float station3 = <float>sorted[0];\n    \n    // Try all possible partitions: [0..i), [i..j), [j..n)\n    // i can be from 0 to n (0 means first group is empty)\n    // j can be from i to n (j=i means second group is empty)\n    int i = 0;\n    while i <= n {\n        int j = i;\n        while j <= n {\n            float maxRadius = 0.0;\n            float s1 = 0.0;\n            float s2 = 0.0;\n            float s3 = 0.0;\n            \n            // First group: [0..i)\n            if i > 0 {\n                float radius = <float>(sorted[i-1] - sorted[0]) / 2.0;\n                s1 = <float>(sorted[0] + sorted[i-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s1 = <float>sorted[0];\n            }\n            \n            // Second group: [i..j)\n            if j > i {\n                float radius = <float>(sorted[j-1] - sorted[i]) / 2.0;\n                s2 = <float>(sorted[i] + sorted[j-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s2 = <float>sorted[0];\n            }\n            \n            // Third group: [j..n)\n            if n > j {\n                float radius = <float>(sorted[n-1] - sorted[j]) / 2.0;\n                s3 = <float>(sorted[j] + sorted[n-1]) / 2.0;\n                if radius > maxRadius {\n                    maxRadius = radius;\n                }\n            } else {\n                s3 = <float>sorted[0];\n            }\n            \n            if maxRadius < minPower {\n                minPower = maxRadius;\n                station1 = s1;\n                station2 = s2;\n                station3 = s3;\n            }\n            \n            j = j + 1;\n        }\n        i = i + 1;\n    }\n    \n    return [minPower, station1, station2, station3];\n}\n\npublic function main() returns error? {\n    // Read number of houses\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Read house coordinates\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read coordinates\");\n    }\n    \n    // Use regex:split instead of string.split\n    string[] parts = regex:split(line2.trim(), \" \");\n    int[] houses = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int coord = check 'int:fromString(part.trim());\n            houses.push(coord);\n        }\n    }\n    \n    [float, float, float, float] result = solveThreeBaseStations(houses);\n    \n    io:println(string `${result[0].toFixedString(6)}`);\n    io:println(string `${result[1].toFixedString(6)} ${result[2].toFixedString(6)} ${result[3].toFixedString(6)}`);\n}",
      "tests_passed": 1,
      "tests_total": 3,
      "tests_pass_rate": 0.3333333333333333,
      "validation_msg": "Only passed 1/3 tests (33.3%), need 75%",
      "error": "Only passed 1/3 tests (33.3%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4\n1 2 3 4\n",
          "expected_output": "0.500000\n1.500000 2.500000 3.500000\n",
          "actual_output": "0.500000\n1.000000 1.500000 3.500000\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/3 tests (33.3%), need 75%",
  "timestamp": "2026-01-05T01:59:05.989408"
}