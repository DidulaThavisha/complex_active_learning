{
  "entry_id": "problem_0206",
  "problem_index": 206,
  "prompt": "Title: Beautiful Numbers\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nVitaly is a very weird man. He's got two favorite digits *a* and *b*. Vitaly calls a positive integer good, if the decimal representation of this integer only contains digits *a* and *b*. Vitaly calls a good number excellent, if the sum of its digits is a good number.\n\nFor example, let's say that Vitaly's favourite digits are 1 and 3, then number 12 isn't good and numbers 13 or 311 are. Also, number 111 is excellent and number 11 isn't. \n\nNow Vitaly is wondering, how many excellent numbers of length exactly *n* are there. As this number can be rather large, he asks you to count the remainder after dividing it by 1000000007 (109<=+<=7).\n\nA number's length is the number of digits in its decimal representation without leading zeroes.\n\nInput Specification:\nThe first line contains three integers: *a*, *b*, *n* (1<=≤<=*a*<=&lt;<=*b*<=≤<=9,<=1<=≤<=*n*<=≤<=106).\n\nOutput Specification:\nPrint a single integer — the answer to the problem modulo 1000000007 (109<=+<=7).\n\nDemo Input:\n['1 3 3\\n', '2 3 10\\n']\n\nDemo Output:\n['1\\n', '165\\n']\n\nNote:\nnone",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\n\nThis problem requires counting \"excellent numbers\" of length n where:\n- A number is \"good\" if it only contains digits a and b\n- A number is \"excellent\" if it's good AND the sum of its digits is also good\n\nKey approach:\n1. For n-digit numbers using only digits a and b, we consider all possible distributions: i occurrences of 'a' and (n-i) occurrences of 'b'\n2. Calculate digit sum for each distribution: i*a + (n-i)*b\n3. Check if this digit sum is \"good\" (contains only digits a and b)\n4. Count combinations using binomial coefficient C(n,i) modulo 10^9+7\n\nThe compilation error was due to using `split()` method incorrectly on string type. In Ballerina, we need to use `regex:split()` from the regex module or use string iteration methods.\n\n<CODE>\n```ballerina\nimport ballerina/io;\nimport ballerina/regex;\n\n// Reasoning:\n// 1. For an n-digit number using only digits a and b, we have 2^n combinations\n// 2. We count how many have a \"good\" digit sum\n// 3. For i occurrences of 'a' and (n-i) occurrences of 'b', digit sum = i*a + (n-i)*b\n// 4. Check if this sum contains only digits a and b\n// 5. The number of ways to arrange i 'a's in n positions is C(n,i)\n// 6. Sum over all valid i values where the digit sum is good\n\nconst int MOD = 1000000007;\n\n// Check if a number contains only digits a and b\nfunction isGoodNumber(int num, int a, int b) returns boolean {\n    if num == 0 {\n        return a == 0 || b == 0;\n    }\n    \n    int temp = num;\n    while temp > 0 {\n        int digit = temp % 10;\n        if digit != a && digit != b {\n            return false;\n        }\n        temp = temp / 10;\n    }\n    return true;\n}\n\n// Calculate binomial coefficient C(n, k) modulo MOD using Pascal's triangle\nfunction binomialCoeff(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    \n    // Use Pascal's triangle approach with modular arithmetic\n    int[] prev = [];\n    int i = 0;\n    while i <= n {\n        prev.push(0);\n        i += 1;\n    }\n    prev[0] = 1;\n    \n    int row = 1;\n    while row <= n {\n        int col = row;\n        while col > 0 {\n            prev[col] = (prev[col] + prev[col - 1]) % MOD;\n            col -= 1;\n        }\n        row += 1;\n    }\n    \n    return prev[k];\n}\n\n// Count excellent numbers of length n using digits a and b\nfunction countExcellentNumbers(int a, int b, int n) returns int|error {\n    if n <= 0 || a < 1 || a >= b || b > 9 {\n        return error(\"Invalid input parameters\");\n    }\n    \n    int count = 0;\n    \n    // Try all possible counts of digit 'a' (from 0 to n)\n    int i = 0;\n    while i <= n {\n        // If we have i occurrences of 'a' and (n-i) occurrences of 'b'\n        // The digit sum will be: i * a + (n - i) * b\n        int digitSum = i * a + (n - i) * b;\n        \n        // Check if this digit sum is a \"good number\"\n        if isGoodNumber(digitSum, a, b) {\n            // Add C(n, i) to the count (number of ways to arrange i 'a's in n positions)\n            int ways = binomialCoeff(n, i);\n            count = (count + ways) % MOD;\n        }\n        \n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() != 3 {\n            io:println(\"Error: Expected 3 integers (a b n)\");\n            return;\n        }\n        \n        int|error a = 'int:fromString(parts[0]);\n        int|error b = 'int:fromString(parts[1]);\n        int|error n = 'int:fromString(parts[2]);\n        \n        if a is error || b is error || n is error {\n            io:println(\"Error: Invalid integer input\");\n            return;\n        }\n        \n        int|error result = countExcellentNumbers(a, b, n);\n        \n        if result is error {\n            io:println(\"Error: \" + result.message());\n        } else {\n            io:println(result.toString());\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testIsGoodNumber() {\n    // Test with a=1, b=3\n    test:assertTrue(isGoodNumber(13, 1, 3));\n    test:assertTrue(isGoodNumber(111, 1, 3));\n    test:assertTrue(isGoodNumber(333, 1, 3));\n    test:assertFalse(isGoodNumber(12, 1, 3));\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersBasic() {\n    // Test case 1: a=1, b=3, n=3\n    int|error result1 = countExcellentNumbers(1, 3, 3);\n    test:assertTrue(result1 is int);\n    if result1 is int {\n        test:assertEquals(result1, 1);\n    }\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersLarger() {\n    // Test case 2: a=2, b=3, n=10\n    int|error result2 = countExcellentNumbers(2, 3, 10);\n    test:assertTrue(result2 is int);\n    if result2 is int {\n        test:assertEquals(result2, 165);\n    }\n}\n\n@test:Config {}\nfunction testBinomialCoeff() {\n    // Test binomial coefficient calculations\n    test:assertEquals(binomialCoeff(5, 2), 10);\n    test:assertEquals(binomialCoeff(10, 5), 252);\n    test:assertEquals(binomialCoeff(3, 0), 1);\n    test:assertEquals(binomialCoeff(3, 3), 1);\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersSmall() {\n    // Test with small values\n    int|error result = countExcellentNumbers(1, 2, 1);\n    test:assertTrue(result is int);\n    if result is int {\n        // With n=1, a=1, b=2: digit sums are 1 and 2, both are good\n        test:assertEquals(result, 2);\n    }\n}\n```\n</TESTS>",
  "code": "import ballerina/io;\nimport ballerina/regex;\n\n// Reasoning:\n// 1. For an n-digit number using only digits a and b, we have 2^n combinations\n// 2. We count how many have a \"good\" digit sum\n// 3. For i occurrences of 'a' and (n-i) occurrences of 'b', digit sum = i*a + (n-i)*b\n// 4. Check if this sum contains only digits a and b\n// 5. The number of ways to arrange i 'a's in n positions is C(n,i)\n// 6. Sum over all valid i values where the digit sum is good\n\nconst int MOD = 1000000007;\n\n// Check if a number contains only digits a and b\nfunction isGoodNumber(int num, int a, int b) returns boolean {\n    if num == 0 {\n        return a == 0 || b == 0;\n    }\n    \n    int temp = num;\n    while temp > 0 {\n        int digit = temp % 10;\n        if digit != a && digit != b {\n            return false;\n        }\n        temp = temp / 10;\n    }\n    return true;\n}\n\n// Calculate binomial coefficient C(n, k) modulo MOD using Pascal's triangle\nfunction binomialCoeff(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    \n    // Use Pascal's triangle approach with modular arithmetic\n    int[] prev = [];\n    int i = 0;\n    while i <= n {\n        prev.push(0);\n        i += 1;\n    }\n    prev[0] = 1;\n    \n    int row = 1;\n    while row <= n {\n        int col = row;\n        while col > 0 {\n            prev[col] = (prev[col] + prev[col - 1]) % MOD;\n            col -= 1;\n        }\n        row += 1;\n    }\n    \n    return prev[k];\n}\n\n// Count excellent numbers of length n using digits a and b\nfunction countExcellentNumbers(int a, int b, int n) returns int|error {\n    if n <= 0 || a < 1 || a >= b || b > 9 {\n        return error(\"Invalid input parameters\");\n    }\n    \n    int count = 0;\n    \n    // Try all possible counts of digit 'a' (from 0 to n)\n    int i = 0;\n    while i <= n {\n        // If we have i occurrences of 'a' and (n-i) occurrences of 'b'\n        // The digit sum will be: i * a + (n - i) * b\n        int digitSum = i * a + (n - i) * b;\n        \n        // Check if this digit sum is a \"good number\"\n        if isGoodNumber(digitSum, a, b) {\n            // Add C(n, i) to the count (number of ways to arrange i 'a's in n positions)\n            int ways = binomialCoeff(n, i);\n            count = (count + ways) % MOD;\n        }\n        \n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() != 3 {\n            io:println(\"Error: Expected 3 integers (a b n)\");\n            return;\n        }\n        \n        int|error a = 'int:fromString(parts[0]);\n        int|error b = 'int:fromString(parts[1]);\n        int|error n = 'int:fromString(parts[2]);\n        \n        if a is error || b is error || n is error {\n            io:println(\"Error: Invalid integer input\");\n            return;\n        }\n        \n        int|error result = countExcellentNumbers(a, b, n);\n        \n        if result is error {\n            io:println(\"Error: \" + result.message());\n        } else {\n            io:println(result.toString());\n        }\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:48:13.924999",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to count \"excellent numbers\" of length n, where:\n- A number is \"good\" if it only contains digits a and b\n- A number is \"excellent\" if it's good AND the sum of its digits is also good\n\nThe approach:\n1. Generate all possible n-digit numbers using only digits a and b (2^n possibilities)\n2. For each combination, calculate the digit sum\n3. Check if the digit sum is \"good\" (only contains digits a and b)\n4. Count valid combinations modulo 10^9+7\n\nKey insight: For a number with i occurrences of digit 'a' and (n-i) occurrences of digit 'b', the digit sum is: i*a + (n-i)*b. We need to check if this sum only contains digits a and b.\n\n<CODE>\n```ballerina\nimport ballerina/io;\n\n// Reasoning:\n// 1. For an n-digit number using only digits a and b, we have 2^n combinations\n// 2. But we need to count how many have a \"good\" digit sum\n// 3. For i occurrences of 'a' and (n-i) occurrences of 'b', digit sum = i*a + (n-i)*b\n// 4. We need to check if this sum contains only digits a and b\n// 5. The number of ways to arrange i 'a's in n positions is C(n,i) (combinations)\n// 6. Sum over all valid i values where the digit sum is good\n\nconst int MOD = 1000000007;\n\n// Check if a number contains only digits a and b\nfunction isGoodNumber(int num, int a, int b) returns boolean {\n    if num == 0 {\n        return a == 0 || b == 0;\n    }\n    \n    int temp = num;\n    while temp > 0 {\n        int digit = temp % 10;\n        if digit != a && digit != b {\n            return false;\n        }\n        temp = temp / 10;\n    }\n    return true;\n}\n\n// Calculate binomial coefficient C(n, k) modulo MOD\nfunction binomialCoeff(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    \n    // Use Pascal's triangle approach with modular arithmetic\n    int[] prev = [];\n    int i = 0;\n    while i <= n {\n        prev.push(0);\n        i += 1;\n    }\n    prev[0] = 1;\n    \n    int row = 1;\n    while row <= n {\n        int col = row;\n        while col > 0 {\n            prev[col] = (prev[col] + prev[col - 1]) % MOD;\n            col -= 1;\n        }\n        row += 1;\n    }\n    \n    return prev[k];\n}\n\n// Count excellent numbers of length n using digits a and b\nfunction countExcellentNumbers(int a, int b, int n) returns int|error {\n    if n <= 0 || a < 1 || a >= b || b > 9 {\n        return error(\"Invalid input parameters\");\n    }\n    \n    int count = 0;\n    \n    // Try all possible counts of digit 'a' (from 0 to n)\n    int i = 0;\n    while i <= n {\n        // If we have i occurrences of 'a' and (n-i) occurrences of 'b'\n        // The digit sum will be: i * a + (n - i) * b\n        int digitSum = i * a + (n - i) * b;\n        \n        // Check if this digit sum is a \"good number\"\n        if isGoodNumber(digitSum, a, b) {\n            // Add C(n, i) to the count (number of ways to arrange i 'a's in n positions)\n            int ways = binomialCoeff(n, i);\n            count = (count + ways) % MOD;\n        }\n        \n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter a b n: \");\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() != 3 {\n            io:println(\"Error: Expected 3 integers (a b n)\");\n            return;\n        }\n        \n        int|error a = 'int:fromString(parts[0]);\n        int|error b = 'int:fromString(parts[1]);\n        int|error n = 'int:fromString(parts[2]);\n        \n        if a is error || b is error || n is error {\n            io:println(\"Error: Invalid integer input\");\n            return;\n        }\n        \n        int|error result = countExcellentNumbers(a, b, n);\n        \n        if result is error {\n            io:println(\"Error: \" + result.message());\n        } else {\n            io:println(result.toString());\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testIsGoodNumber() {\n    // Test with a=1, b=3\n    test:assertTrue(isGoodNumber(13, 1, 3));\n    test:assertTrue(isGoodNumber(111, 1, 3));\n    test:assertTrue(isGoodNumber(333, 1, 3));\n    test:assertFalse(isGoodNumber(12, 1, 3));\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersBasic() {\n    // Test case 1: a=1, b=3, n=3\n    int|error result1 = countExcellentNumbers(1, 3, 3);\n    test:assertTrue(result1 is int);\n    if result1 is int {\n        test:assertEquals(result1, 1);\n    }\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersLarger() {\n    // Test case 2: a=2, b=3, n=10\n    int|error result2 = countExcellentNumbers(2, 3, 10);\n    test:assertTrue(result2 is int);\n    if result2 is int {\n        test:assertEquals(result2, 165);\n    }\n}\n\n@test:Config {}\nfunction testBinomialCoeff() {\n    // Test binomial coefficient calculations\n    test:assertEquals(binomialCoeff(5, 2), 10);\n    test:assertEquals(binomialCoeff(10, 5), 252);\n    test:assertEquals(binomialCoeff(3, 0), 1);\n    test:assertEquals(binomialCoeff(3, 3), 1);\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersSmall() {\n    // Test with small values\n    int|error result = countExcellentNumbers(1, 2, 1);\n    test:assertTrue(result is int);\n    if result is int {\n        // With n=1, a=1, b=2: digit sums are 1 and 2, both are good\n        test:assertEquals(result, 2);\n    }\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\n\n// Reasoning:\n// 1. For an n-digit number using only digits a and b, we have 2^n combinations\n// 2. But we need to count how many have a \"good\" digit sum\n// 3. For i occurrences of 'a' and (n-i) occurrences of 'b', digit sum = i*a + (n-i)*b\n// 4. We need to check if this sum contains only digits a and b\n// 5. The number of ways to arrange i 'a's in n positions is C(n,i) (combinations)\n// 6. Sum over all valid i values where the digit sum is good\n\nconst int MOD = 1000000007;\n\n// Check if a number contains only digits a and b\nfunction isGoodNumber(int num, int a, int b) returns boolean {\n    if num == 0 {\n        return a == 0 || b == 0;\n    }\n    \n    int temp = num;\n    while temp > 0 {\n        int digit = temp % 10;\n        if digit != a && digit != b {\n            return false;\n        }\n        temp = temp / 10;\n    }\n    return true;\n}\n\n// Calculate binomial coefficient C(n, k) modulo MOD\nfunction binomialCoeff(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    \n    // Use Pascal's triangle approach with modular arithmetic\n    int[] prev = [];\n    int i = 0;\n    while i <= n {\n        prev.push(0);\n        i += 1;\n    }\n    prev[0] = 1;\n    \n    int row = 1;\n    while row <= n {\n        int col = row;\n        while col > 0 {\n            prev[col] = (prev[col] + prev[col - 1]) % MOD;\n            col -= 1;\n        }\n        row += 1;\n    }\n    \n    return prev[k];\n}\n\n// Count excellent numbers of length n using digits a and b\nfunction countExcellentNumbers(int a, int b, int n) returns int|error {\n    if n <= 0 || a < 1 || a >= b || b > 9 {\n        return error(\"Invalid input parameters\");\n    }\n    \n    int count = 0;\n    \n    // Try all possible counts of digit 'a' (from 0 to n)\n    int i = 0;\n    while i <= n {\n        // If we have i occurrences of 'a' and (n-i) occurrences of 'b'\n        // The digit sum will be: i * a + (n - i) * b\n        int digitSum = i * a + (n - i) * b;\n        \n        // Check if this digit sum is a \"good number\"\n        if isGoodNumber(digitSum, a, b) {\n            // Add C(n, i) to the count (number of ways to arrange i 'a's in n positions)\n            int ways = binomialCoeff(n, i);\n            count = (count + ways) % MOD;\n        }\n        \n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter a b n: \");\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() != 3 {\n            io:println(\"Error: Expected 3 integers (a b n)\");\n            return;\n        }\n        \n        int|error a = 'int:fromString(parts[0]);\n        int|error b = 'int:fromString(parts[1]);\n        int|error n = 'int:fromString(parts[2]);\n        \n        if a is error || b is error || n is error {\n            io:println(\"Error: Invalid integer input\");\n            return;\n        }\n        \n        int|error result = countExcellentNumbers(a, b, n);\n        \n        if result is error {\n            io:println(\"Error: \" + result.message());\n        } else {\n            io:println(result.toString());\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(93:44,93:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(93:44,93:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(93:44,93:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:48:43.665704",
      "status": "success",
      "completion": "# Overview\n\nThis problem requires counting \"excellent numbers\" of length n where:\n- A number is \"good\" if it only contains digits a and b\n- A number is \"excellent\" if it's good AND the sum of its digits is also good\n\nKey approach:\n1. For n-digit numbers using only digits a and b, we consider all possible distributions: i occurrences of 'a' and (n-i) occurrences of 'b'\n2. Calculate digit sum for each distribution: i*a + (n-i)*b\n3. Check if this digit sum is \"good\" (contains only digits a and b)\n4. Count combinations using binomial coefficient C(n,i) modulo 10^9+7\n\nThe compilation error was due to using `split()` method incorrectly on string type. In Ballerina, we need to use `regex:split()` from the regex module or use string iteration methods.\n\n<CODE>\n```ballerina\nimport ballerina/io;\nimport ballerina/regex;\n\n// Reasoning:\n// 1. For an n-digit number using only digits a and b, we have 2^n combinations\n// 2. We count how many have a \"good\" digit sum\n// 3. For i occurrences of 'a' and (n-i) occurrences of 'b', digit sum = i*a + (n-i)*b\n// 4. Check if this sum contains only digits a and b\n// 5. The number of ways to arrange i 'a's in n positions is C(n,i)\n// 6. Sum over all valid i values where the digit sum is good\n\nconst int MOD = 1000000007;\n\n// Check if a number contains only digits a and b\nfunction isGoodNumber(int num, int a, int b) returns boolean {\n    if num == 0 {\n        return a == 0 || b == 0;\n    }\n    \n    int temp = num;\n    while temp > 0 {\n        int digit = temp % 10;\n        if digit != a && digit != b {\n            return false;\n        }\n        temp = temp / 10;\n    }\n    return true;\n}\n\n// Calculate binomial coefficient C(n, k) modulo MOD using Pascal's triangle\nfunction binomialCoeff(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    \n    // Use Pascal's triangle approach with modular arithmetic\n    int[] prev = [];\n    int i = 0;\n    while i <= n {\n        prev.push(0);\n        i += 1;\n    }\n    prev[0] = 1;\n    \n    int row = 1;\n    while row <= n {\n        int col = row;\n        while col > 0 {\n            prev[col] = (prev[col] + prev[col - 1]) % MOD;\n            col -= 1;\n        }\n        row += 1;\n    }\n    \n    return prev[k];\n}\n\n// Count excellent numbers of length n using digits a and b\nfunction countExcellentNumbers(int a, int b, int n) returns int|error {\n    if n <= 0 || a < 1 || a >= b || b > 9 {\n        return error(\"Invalid input parameters\");\n    }\n    \n    int count = 0;\n    \n    // Try all possible counts of digit 'a' (from 0 to n)\n    int i = 0;\n    while i <= n {\n        // If we have i occurrences of 'a' and (n-i) occurrences of 'b'\n        // The digit sum will be: i * a + (n - i) * b\n        int digitSum = i * a + (n - i) * b;\n        \n        // Check if this digit sum is a \"good number\"\n        if isGoodNumber(digitSum, a, b) {\n            // Add C(n, i) to the count (number of ways to arrange i 'a's in n positions)\n            int ways = binomialCoeff(n, i);\n            count = (count + ways) % MOD;\n        }\n        \n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() != 3 {\n            io:println(\"Error: Expected 3 integers (a b n)\");\n            return;\n        }\n        \n        int|error a = 'int:fromString(parts[0]);\n        int|error b = 'int:fromString(parts[1]);\n        int|error n = 'int:fromString(parts[2]);\n        \n        if a is error || b is error || n is error {\n            io:println(\"Error: Invalid integer input\");\n            return;\n        }\n        \n        int|error result = countExcellentNumbers(a, b, n);\n        \n        if result is error {\n            io:println(\"Error: \" + result.message());\n        } else {\n            io:println(result.toString());\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testIsGoodNumber() {\n    // Test with a=1, b=3\n    test:assertTrue(isGoodNumber(13, 1, 3));\n    test:assertTrue(isGoodNumber(111, 1, 3));\n    test:assertTrue(isGoodNumber(333, 1, 3));\n    test:assertFalse(isGoodNumber(12, 1, 3));\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersBasic() {\n    // Test case 1: a=1, b=3, n=3\n    int|error result1 = countExcellentNumbers(1, 3, 3);\n    test:assertTrue(result1 is int);\n    if result1 is int {\n        test:assertEquals(result1, 1);\n    }\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersLarger() {\n    // Test case 2: a=2, b=3, n=10\n    int|error result2 = countExcellentNumbers(2, 3, 10);\n    test:assertTrue(result2 is int);\n    if result2 is int {\n        test:assertEquals(result2, 165);\n    }\n}\n\n@test:Config {}\nfunction testBinomialCoeff() {\n    // Test binomial coefficient calculations\n    test:assertEquals(binomialCoeff(5, 2), 10);\n    test:assertEquals(binomialCoeff(10, 5), 252);\n    test:assertEquals(binomialCoeff(3, 0), 1);\n    test:assertEquals(binomialCoeff(3, 3), 1);\n}\n\n@test:Config {}\nfunction testCountExcellentNumbersSmall() {\n    // Test with small values\n    int|error result = countExcellentNumbers(1, 2, 1);\n    test:assertTrue(result is int);\n    if result is int {\n        // With n=1, a=1, b=2: digit sums are 1 and 2, both are good\n        test:assertEquals(result, 2);\n    }\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\nimport ballerina/regex;\n\n// Reasoning:\n// 1. For an n-digit number using only digits a and b, we have 2^n combinations\n// 2. We count how many have a \"good\" digit sum\n// 3. For i occurrences of 'a' and (n-i) occurrences of 'b', digit sum = i*a + (n-i)*b\n// 4. Check if this sum contains only digits a and b\n// 5. The number of ways to arrange i 'a's in n positions is C(n,i)\n// 6. Sum over all valid i values where the digit sum is good\n\nconst int MOD = 1000000007;\n\n// Check if a number contains only digits a and b\nfunction isGoodNumber(int num, int a, int b) returns boolean {\n    if num == 0 {\n        return a == 0 || b == 0;\n    }\n    \n    int temp = num;\n    while temp > 0 {\n        int digit = temp % 10;\n        if digit != a && digit != b {\n            return false;\n        }\n        temp = temp / 10;\n    }\n    return true;\n}\n\n// Calculate binomial coefficient C(n, k) modulo MOD using Pascal's triangle\nfunction binomialCoeff(int n, int k) returns int {\n    if k > n || k < 0 {\n        return 0;\n    }\n    if k == 0 || k == n {\n        return 1;\n    }\n    \n    // Use Pascal's triangle approach with modular arithmetic\n    int[] prev = [];\n    int i = 0;\n    while i <= n {\n        prev.push(0);\n        i += 1;\n    }\n    prev[0] = 1;\n    \n    int row = 1;\n    while row <= n {\n        int col = row;\n        while col > 0 {\n            prev[col] = (prev[col] + prev[col - 1]) % MOD;\n            col -= 1;\n        }\n        row += 1;\n    }\n    \n    return prev[k];\n}\n\n// Count excellent numbers of length n using digits a and b\nfunction countExcellentNumbers(int a, int b, int n) returns int|error {\n    if n <= 0 || a < 1 || a >= b || b > 9 {\n        return error(\"Invalid input parameters\");\n    }\n    \n    int count = 0;\n    \n    // Try all possible counts of digit 'a' (from 0 to n)\n    int i = 0;\n    while i <= n {\n        // If we have i occurrences of 'a' and (n-i) occurrences of 'b'\n        // The digit sum will be: i * a + (n - i) * b\n        int digitSum = i * a + (n - i) * b;\n        \n        // Check if this digit sum is a \"good number\"\n        if isGoodNumber(digitSum, a, b) {\n            // Add C(n, i) to the count (number of ways to arrange i 'a's in n positions)\n            int ways = binomialCoeff(n, i);\n            count = (count + ways) % MOD;\n        }\n        \n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() != 3 {\n            io:println(\"Error: Expected 3 integers (a b n)\");\n            return;\n        }\n        \n        int|error a = 'int:fromString(parts[0]);\n        int|error b = 'int:fromString(parts[1]);\n        int|error n = 'int:fromString(parts[2]);\n        \n        if a is error || b is error || n is error {\n            io:println(\"Error: Invalid integer input\");\n            return;\n        }\n        \n        int|error result = countExcellentNumbers(a, b, n);\n        \n        if result is error {\n            io:println(\"Error: \" + result.message());\n        } else {\n            io:println(result.toString());\n        }\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:49:13.430785"
}