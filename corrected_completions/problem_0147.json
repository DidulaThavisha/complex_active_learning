{
  "entry_id": "problem_0147",
  "problem_index": 147,
  "prompt": "Title: Driving Test\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nPolycarp has just attempted to pass the driving test. He ran over the straight road with the signs of four types.\n -  speed limit: this sign comes with a positive integer number — maximal speed of the car after the sign (cancel the action of the previous sign of this type); -  overtake is allowed: this sign means that after some car meets it, it can overtake any other car; -  no speed limit: this sign cancels speed limit if any (car can move with arbitrary speed after this sign); -  no overtake allowed: some car can't overtake any other car after this sign. \nPolycarp goes past the signs consequentially, each new sign cancels the action of all the previous signs of it's kind (speed limit/overtake). It is possible that two or more \"no overtake allowed\" signs go one after another with zero \"overtake is allowed\" signs between them. It works with \"no speed limit\" and \"overtake is allowed\" signs as well.\n\nIn the beginning of the ride overtake is allowed and there is no speed limit.\n\nYou are given the sequence of events in chronological order — events which happened to Polycarp during the ride. There are events of following types:\n 1.  Polycarp changes the speed of his car to specified (this event comes with a positive integer number); 1.  Polycarp's car overtakes the other car; 1.  Polycarp's car goes past the \"speed limit\" sign (this sign comes with a positive integer); 1.  Polycarp's car goes past the \"overtake is allowed\" sign; 1.  Polycarp's car goes past the \"no speed limit\"; 1.  Polycarp's car goes past the \"no overtake allowed\"; \nIt is guaranteed that the first event in chronological order is the event of type 1 (Polycarp changed the speed of his car to specified).\n\nAfter the exam Polycarp can justify his rule violations by telling the driving instructor that he just didn't notice some of the signs. What is the minimal number of signs Polycarp should say he didn't notice, so that he would make no rule violations from his point of view?\n\nInput Specification:\nThe first line contains one integer number *n* (1<=≤<=*n*<=≤<=2·105) — number of events.\n\nEach of the next *n* lines starts with integer *t* (1<=≤<=*t*<=≤<=6) — the type of the event.\n\nAn integer *s* (1<=≤<=*s*<=≤<=300) follows in the query of the first and the third type (if it is the query of first type, then it's new speed of Polycarp's car, if it is the query of third type, then it's new speed limit).\n\nIt is guaranteed that the first event in chronological order is the event of type 1 (Polycarp changed the speed of his car to specified).\n\nOutput Specification:\nPrint the minimal number of road signs Polycarp should say he didn't notice, so that he would make no rule violations from his point of view.\n\nDemo Input:\n['11\\n1 100\\n3 70\\n4\\n2\\n3 120\\n5\\n3 120\\n6\\n1 150\\n4\\n3 300\\n', '5\\n1 100\\n3 200\\n2\\n4\\n5\\n', '7\\n1 20\\n2\\n6\\n4\\n6\\n6\\n2\\n']\n\nDemo Output:\n['2\\n', '0\\n', '2\\n']\n\nNote:\nIn the first example Polycarp should say he didn't notice the \"speed limit\" sign with the limit of 70 and the second \"speed limit\" sign with the limit of 120.\n\nIn the second example Polycarp didn't make any rule violation.\n\nIn the third example Polycarp should say he didn't notice both \"no overtake allowed\" that came after \"overtake is allowed\" sign.",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\n\nThis problem requires us to track Polycarp's driving violations and determine the minimum number of signs he should claim not to have seen to avoid all violations. We need to track:\n1. Current speed and speed limit (if any)\n2. Whether overtaking is allowed\n\nA violation occurs when:\n- Speed exceeds the speed limit (type 1 event with speed > current limit)\n- Overtaking when it's not allowed (type 2 event when overtaking is disabled)\n\nThe strategy is to ignore signs that would cause violations, keeping track of how many signs we ignore.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Track current state: speed, speed_limit (or -1 if none), overtake_allowed\n// - For each event, check if it would cause a violation\n// - If setting a speed limit would cause immediate violation, ignore that sign\n// - If disabling overtake, check future events to see if we need to overtake\n// - If enabling speed limit and current speed violates it, ignore the sign\n// - Count ignored signs\n//\n// Events:\n// 1: Change speed to s\n// 2: Overtake\n// 3: Speed limit sign with value s\n// 4: Overtake allowed sign\n// 5: No speed limit sign\n// 6: No overtake allowed sign\n//\n// Strategy:\n// - Process events sequentially\n// - Track current speed, speed limit state, overtake state\n// - When a speed limit sign appears, check if current speed violates it - if yes, ignore the sign\n// - When a no-overtake sign appears, check if we need to overtake while it's active - if yes, ignore the sign\n// - When we change speed, check if it violates current limit - if yes, ignore the most recent limit sign\n\nimport ballerina/io;\n\nfunction solveDrivingTest(int[][] events) returns int {\n    int ignoredSigns = 0;\n    int currentSpeed = 0;\n    int speedLimit = -1; // -1 means no limit\n    boolean overtakeAllowed = true;\n    \n    int i = 0;\n    while i < events.length() {\n        int eventType = events[i][0];\n        \n        if eventType == 1 {\n            // Change speed\n            int newSpeed = events[i][1];\n            currentSpeed = newSpeed;\n            \n            // Check if this violates current speed limit\n            if speedLimit != -1 && currentSpeed > speedLimit {\n                // Ignore the speed limit sign\n                ignoredSigns += 1;\n                speedLimit = -1;\n            }\n        } else if eventType == 2 {\n            // Overtake\n            if !overtakeAllowed {\n                // This shouldn't happen, we need to ignore the no-overtake sign\n                ignoredSigns += 1;\n                overtakeAllowed = true;\n            }\n        } else if eventType == 3 {\n            // Speed limit sign\n            int newLimit = events[i][1];\n            \n            // Check if current speed violates this new limit\n            if currentSpeed > newLimit {\n                // Ignore this sign\n                ignoredSigns += 1;\n            } else {\n                speedLimit = newLimit;\n            }\n        } else if eventType == 4 {\n            // Overtake allowed sign\n            overtakeAllowed = true;\n        } else if eventType == 5 {\n            // No speed limit sign\n            speedLimit = -1;\n        } else if eventType == 6 {\n            // No overtake allowed sign\n            // Check if we need to overtake while this is active\n            boolean needsOvertake = false;\n            int j = i + 1;\n            while j < events.length() {\n                if events[j][0] == 2 {\n                    // Found an overtake event\n                    needsOvertake = true;\n                    break;\n                } else if events[j][0] == 4 {\n                    // Overtake allowed again, so we're safe\n                    break;\n                } else if events[j][0] == 6 {\n                    // Another no-overtake sign, continue checking\n                }\n                j += 1;\n            }\n            \n            if needsOvertake {\n                // Ignore this no-overtake sign\n                ignoredSigns += 1;\n            } else {\n                overtakeAllowed = false;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return ignoredSigns;\n}\n\npublic function main() returns error? {\n    // Read number of events\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read events\n    int[][] events = [];\n    int idx = 0;\n    while idx < n {\n        string? eventLine = io:readln();\n        if eventLine is () {\n            return error(\"Failed to read event\");\n        }\n        \n        string trimmedLine = eventLine.trim();\n        string[] parts = re `\\s+`.split(trimmedLine);\n        \n        int eventType = check 'int:fromString(parts[0]);\n        \n        if parts.length() == 2 {\n            int value = check 'int:fromString(parts[1]);\n            events.push([eventType, value]);\n        } else {\n            events.push([eventType]);\n        }\n        \n        idx += 1;\n    }\n    \n    int result = solveDrivingTest(events);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] events = [\n        [1, 100],\n        [3, 70],\n        [4],\n        [2],\n        [3, 120],\n        [5],\n        [3, 120],\n        [6],\n        [1, 150],\n        [4],\n        [3, 300]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] events = [\n        [1, 100],\n        [3, 200],\n        [2],\n        [4],\n        [5]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[][] events = [\n        [1, 20],\n        [2],\n        [6],\n        [4],\n        [6],\n        [6],\n        [2]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testSimpleSpeedViolation() {\n    int[][] events = [\n        [1, 100],\n        [3, 50]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - Track current state: speed, speed_limit (or -1 if none), overtake_allowed\n// - For each event, check if it would cause a violation\n// - If setting a speed limit would cause immediate violation, ignore that sign\n// - If disabling overtake, check future events to see if we need to overtake\n// - If enabling speed limit and current speed violates it, ignore the sign\n// - Count ignored signs\n//\n// Events:\n// 1: Change speed to s\n// 2: Overtake\n// 3: Speed limit sign with value s\n// 4: Overtake allowed sign\n// 5: No speed limit sign\n// 6: No overtake allowed sign\n//\n// Strategy:\n// - Process events sequentially\n// - Track current speed, speed limit state, overtake state\n// - When a speed limit sign appears, check if current speed violates it - if yes, ignore the sign\n// - When a no-overtake sign appears, check if we need to overtake while it's active - if yes, ignore the sign\n// - When we change speed, check if it violates current limit - if yes, ignore the most recent limit sign\n\nimport ballerina/io;\n\nfunction solveDrivingTest(int[][] events) returns int {\n    int ignoredSigns = 0;\n    int currentSpeed = 0;\n    int speedLimit = -1; // -1 means no limit\n    boolean overtakeAllowed = true;\n    \n    int i = 0;\n    while i < events.length() {\n        int eventType = events[i][0];\n        \n        if eventType == 1 {\n            // Change speed\n            int newSpeed = events[i][1];\n            currentSpeed = newSpeed;\n            \n            // Check if this violates current speed limit\n            if speedLimit != -1 && currentSpeed > speedLimit {\n                // Ignore the speed limit sign\n                ignoredSigns += 1;\n                speedLimit = -1;\n            }\n        } else if eventType == 2 {\n            // Overtake\n            if !overtakeAllowed {\n                // This shouldn't happen, we need to ignore the no-overtake sign\n                ignoredSigns += 1;\n                overtakeAllowed = true;\n            }\n        } else if eventType == 3 {\n            // Speed limit sign\n            int newLimit = events[i][1];\n            \n            // Check if current speed violates this new limit\n            if currentSpeed > newLimit {\n                // Ignore this sign\n                ignoredSigns += 1;\n            } else {\n                speedLimit = newLimit;\n            }\n        } else if eventType == 4 {\n            // Overtake allowed sign\n            overtakeAllowed = true;\n        } else if eventType == 5 {\n            // No speed limit sign\n            speedLimit = -1;\n        } else if eventType == 6 {\n            // No overtake allowed sign\n            // Check if we need to overtake while this is active\n            boolean needsOvertake = false;\n            int j = i + 1;\n            while j < events.length() {\n                if events[j][0] == 2 {\n                    // Found an overtake event\n                    needsOvertake = true;\n                    break;\n                } else if events[j][0] == 4 {\n                    // Overtake allowed again, so we're safe\n                    break;\n                } else if events[j][0] == 6 {\n                    // Another no-overtake sign, continue checking\n                }\n                j += 1;\n            }\n            \n            if needsOvertake {\n                // Ignore this no-overtake sign\n                ignoredSigns += 1;\n            } else {\n                overtakeAllowed = false;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return ignoredSigns;\n}\n\npublic function main() returns error? {\n    // Read number of events\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read events\n    int[][] events = [];\n    int idx = 0;\n    while idx < n {\n        string? eventLine = io:readln();\n        if eventLine is () {\n            return error(\"Failed to read event\");\n        }\n        \n        string trimmedLine = eventLine.trim();\n        string[] parts = re `\\s+`.split(trimmedLine);\n        \n        int eventType = check 'int:fromString(parts[0]);\n        \n        if parts.length() == 2 {\n            int value = check 'int:fromString(parts[1]);\n            events.push([eventType, value]);\n        } else {\n            events.push([eventType]);\n        }\n        \n        idx += 1;\n    }\n    \n    int result = solveDrivingTest(events);\n    io:println(result);\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:34:42.040318",
      "status": "success",
      "completion": "# Overview\n\nThis problem requires us to track Polycarp's driving violations and determine the minimum number of signs he should claim not to have seen to avoid all violations. We need to track:\n1. Current speed and speed limit (if any)\n2. Whether overtaking is allowed\n\nA violation occurs when:\n- Speed exceeds the speed limit (type 1 event with speed > current limit)\n- Overtaking when it's not allowed (type 2 event when overtaking is disabled)\n\nThe strategy is to ignore signs that would cause violations, keeping track of how many signs we ignore.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Track current state: speed, speed_limit (or -1 if none), overtake_allowed\n// - For each event, check if it would cause a violation\n// - If setting a speed limit would cause immediate violation, ignore that sign\n// - If disabling overtake, check future events to see if we need to overtake\n// - If enabling speed limit and current speed violates it, ignore the sign\n// - Count ignored signs\n//\n// Events:\n// 1: Change speed to s\n// 2: Overtake\n// 3: Speed limit sign with value s\n// 4: Overtake allowed sign\n// 5: No speed limit sign\n// 6: No overtake allowed sign\n//\n// Strategy:\n// - Process events sequentially\n// - Track current speed, speed limit state, overtake state\n// - When a speed limit sign appears, check if current speed violates it - if yes, ignore the sign\n// - When a no-overtake sign appears, check if we need to overtake while it's active - if yes, ignore the sign\n// - When we change speed, check if it violates current limit - if yes, ignore the most recent limit sign\n\nimport ballerina/io;\n\nfunction solveDrivingTest(int[][] events) returns int {\n    int ignoredSigns = 0;\n    int currentSpeed = 0;\n    int speedLimit = -1; // -1 means no limit\n    boolean overtakeAllowed = true;\n    \n    int i = 0;\n    while i < events.length() {\n        int eventType = events[i][0];\n        \n        if eventType == 1 {\n            // Change speed\n            int newSpeed = events[i][1];\n            currentSpeed = newSpeed;\n            \n            // Check if this violates current speed limit\n            if speedLimit != -1 && currentSpeed > speedLimit {\n                // Ignore the speed limit sign\n                ignoredSigns += 1;\n                speedLimit = -1;\n            }\n        } else if eventType == 2 {\n            // Overtake\n            if !overtakeAllowed {\n                // This shouldn't happen, we need to ignore the no-overtake sign\n                ignoredSigns += 1;\n                overtakeAllowed = true;\n            }\n        } else if eventType == 3 {\n            // Speed limit sign\n            int newLimit = events[i][1];\n            \n            // Check if current speed violates this new limit\n            if currentSpeed > newLimit {\n                // Ignore this sign\n                ignoredSigns += 1;\n            } else {\n                speedLimit = newLimit;\n            }\n        } else if eventType == 4 {\n            // Overtake allowed sign\n            overtakeAllowed = true;\n        } else if eventType == 5 {\n            // No speed limit sign\n            speedLimit = -1;\n        } else if eventType == 6 {\n            // No overtake allowed sign\n            // Check if we need to overtake while this is active\n            boolean needsOvertake = false;\n            int j = i + 1;\n            while j < events.length() {\n                if events[j][0] == 2 {\n                    // Found an overtake event\n                    needsOvertake = true;\n                    break;\n                } else if events[j][0] == 4 {\n                    // Overtake allowed again, so we're safe\n                    break;\n                } else if events[j][0] == 6 {\n                    // Another no-overtake sign, continue checking\n                }\n                j += 1;\n            }\n            \n            if needsOvertake {\n                // Ignore this no-overtake sign\n                ignoredSigns += 1;\n            } else {\n                overtakeAllowed = false;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return ignoredSigns;\n}\n\npublic function main() returns error? {\n    // Read number of events\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read events\n    int[][] events = [];\n    int idx = 0;\n    while idx < n {\n        string? eventLine = io:readln();\n        if eventLine is () {\n            return error(\"Failed to read event\");\n        }\n        \n        string trimmedLine = eventLine.trim();\n        string[] parts = re `\\s+`.split(trimmedLine);\n        \n        int eventType = check 'int:fromString(parts[0]);\n        \n        if parts.length() == 2 {\n            int value = check 'int:fromString(parts[1]);\n            events.push([eventType, value]);\n        } else {\n            events.push([eventType]);\n        }\n        \n        idx += 1;\n    }\n    \n    int result = solveDrivingTest(events);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] events = [\n        [1, 100],\n        [3, 70],\n        [4],\n        [2],\n        [3, 120],\n        [5],\n        [3, 120],\n        [6],\n        [1, 150],\n        [4],\n        [3, 300]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] events = [\n        [1, 100],\n        [3, 200],\n        [2],\n        [4],\n        [5]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[][] events = [\n        [1, 20],\n        [2],\n        [6],\n        [4],\n        [6],\n        [6],\n        [2]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testSimpleSpeedViolation() {\n    int[][] events = [\n        [1, 100],\n        [3, 50]\n    ];\n    int result = solveDrivingTest(events);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Track current state: speed, speed_limit (or -1 if none), overtake_allowed\n// - For each event, check if it would cause a violation\n// - If setting a speed limit would cause immediate violation, ignore that sign\n// - If disabling overtake, check future events to see if we need to overtake\n// - If enabling speed limit and current speed violates it, ignore the sign\n// - Count ignored signs\n//\n// Events:\n// 1: Change speed to s\n// 2: Overtake\n// 3: Speed limit sign with value s\n// 4: Overtake allowed sign\n// 5: No speed limit sign\n// 6: No overtake allowed sign\n//\n// Strategy:\n// - Process events sequentially\n// - Track current speed, speed limit state, overtake state\n// - When a speed limit sign appears, check if current speed violates it - if yes, ignore the sign\n// - When a no-overtake sign appears, check if we need to overtake while it's active - if yes, ignore the sign\n// - When we change speed, check if it violates current limit - if yes, ignore the most recent limit sign\n\nimport ballerina/io;\n\nfunction solveDrivingTest(int[][] events) returns int {\n    int ignoredSigns = 0;\n    int currentSpeed = 0;\n    int speedLimit = -1; // -1 means no limit\n    boolean overtakeAllowed = true;\n    \n    int i = 0;\n    while i < events.length() {\n        int eventType = events[i][0];\n        \n        if eventType == 1 {\n            // Change speed\n            int newSpeed = events[i][1];\n            currentSpeed = newSpeed;\n            \n            // Check if this violates current speed limit\n            if speedLimit != -1 && currentSpeed > speedLimit {\n                // Ignore the speed limit sign\n                ignoredSigns += 1;\n                speedLimit = -1;\n            }\n        } else if eventType == 2 {\n            // Overtake\n            if !overtakeAllowed {\n                // This shouldn't happen, we need to ignore the no-overtake sign\n                ignoredSigns += 1;\n                overtakeAllowed = true;\n            }\n        } else if eventType == 3 {\n            // Speed limit sign\n            int newLimit = events[i][1];\n            \n            // Check if current speed violates this new limit\n            if currentSpeed > newLimit {\n                // Ignore this sign\n                ignoredSigns += 1;\n            } else {\n                speedLimit = newLimit;\n            }\n        } else if eventType == 4 {\n            // Overtake allowed sign\n            overtakeAllowed = true;\n        } else if eventType == 5 {\n            // No speed limit sign\n            speedLimit = -1;\n        } else if eventType == 6 {\n            // No overtake allowed sign\n            // Check if we need to overtake while this is active\n            boolean needsOvertake = false;\n            int j = i + 1;\n            while j < events.length() {\n                if events[j][0] == 2 {\n                    // Found an overtake event\n                    needsOvertake = true;\n                    break;\n                } else if events[j][0] == 4 {\n                    // Overtake allowed again, so we're safe\n                    break;\n                } else if events[j][0] == 6 {\n                    // Another no-overtake sign, continue checking\n                }\n                j += 1;\n            }\n            \n            if needsOvertake {\n                // Ignore this no-overtake sign\n                ignoredSigns += 1;\n            } else {\n                overtakeAllowed = false;\n            }\n        }\n        \n        i += 1;\n    }\n    \n    return ignoredSigns;\n}\n\npublic function main() returns error? {\n    // Read number of events\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read events\n    int[][] events = [];\n    int idx = 0;\n    while idx < n {\n        string? eventLine = io:readln();\n        if eventLine is () {\n            return error(\"Failed to read event\");\n        }\n        \n        string trimmedLine = eventLine.trim();\n        string[] parts = re `\\s+`.split(trimmedLine);\n        \n        int eventType = check 'int:fromString(parts[0]);\n        \n        if parts.length() == 2 {\n            int value = check 'int:fromString(parts[1]);\n            events.push([eventType, value]);\n        } else {\n            events.push([eventType]);\n        }\n        \n        idx += 1;\n    }\n    \n    int result = solveDrivingTest(events);\n    io:println(result);\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T02:35:22.182767"
}