{
  "entry_id": "problem_0095",
  "problem_index": 95,
  "prompt": "Title: Hometask\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nFurik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?\n\nYou are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.\n\nEach digit is allowed to occur in the number the same number of times it occurs in the set.\n\nInput Specification:\nA single line contains a single integer *n* (1<=≤<=*n*<=≤<=100000) — the number of digits in the set. The second line contains *n* digits, the digits are separated by a single space.\n\nOutput Specification:\nOn a single line print the answer to the problem. If such number does not exist, then you should print -1.\n\nDemo Input:\n['1\\n0\\n', '11\\n3 4 5 4 5 3 5 3 4 4 0\\n', '8\\n3 2 5 1 5 2 2 3\\n']\n\nDemo Output:\n['0\\n', '5554443330\\n', '-1\\n']\n\nNote:\nIn the first sample there is only one number you can make — 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:38:46.358937",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the maximum integer from a given set of digits that is divisible by 2, 3, and 5. For a number to be divisible by all three, it must be divisible by their LCM which is 30. Key observations:\n- Divisible by 2: must end in an even digit (0, 2, 4, 6, 8)\n- Divisible by 5: must end in 0 or 5\n- Combined (div by 2 and 5): must end in 0\n- Divisible by 3: sum of all digits must be divisible by 3\n\nStrategy: We need to use digits that sum to a multiple of 3, must include at least one 0 (to be divisible by 2 and 5), and arrange remaining digits in descending order for maximum value.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. For divisibility by 2, 3, and 5 simultaneously, the number must be divisible by LCM(2,3,5) = 30\n// 2. Divisible by 2 AND 5 means it must end in 0\n// 3. Divisible by 3 means sum of digits must be divisible by 3\n// 4. To maximize the number, arrange digits in descending order (except the trailing 0)\n// 5. If no 0 exists, return -1\n// 6. If only 0s exist, return 0\n// 7. Remove minimum digits to make sum divisible by 3, prioritizing smaller digits\n\nimport ballerina/io;\n\nfunction findMaxNumber(int[] digits) returns string {\n    // Count occurrences of each digit\n    int[] digitCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    foreach int digit in digits {\n        if digit >= 0 && digit <= 9 {\n            digitCount[digit] += 1;\n        }\n    }\n    \n    // Check if there's at least one zero (required for divisibility by 2 and 5)\n    if digitCount[0] == 0 {\n        return \"-1\";\n    }\n    \n    // Calculate sum of all digits\n    int totalSum = 0;\n    foreach int i in 0...9 {\n        totalSum += i * digitCount[i];\n    }\n    \n    // If sum is 0, only zeros exist\n    if totalSum == 0 {\n        return \"0\";\n    }\n    \n    // Make a working copy of digit counts\n    int[] workingCount = digitCount.clone();\n    \n    // Remove minimum digits to make sum divisible by 3\n    int remainder = totalSum % 3;\n    \n    if remainder != 0 {\n        // Try to remove digits with sum equal to remainder\n        boolean removed = false;\n        \n        // Try removing one digit\n        foreach int digit in 0...9 {\n            if !removed && workingCount[digit] > 0 && digit % 3 == remainder {\n                workingCount[digit] -= 1;\n                removed = true;\n                break;\n            }\n        }\n        \n        // If couldn't remove one digit, try removing two digits\n        if !removed {\n            int targetRemainder = (3 - remainder) % 3;\n            int removedCount = 0;\n            foreach int digit in 0...9 {\n                while workingCount[digit] > 0 && digit % 3 == targetRemainder && removedCount < 2 {\n                    workingCount[digit] -= 1;\n                    removedCount += 1;\n                }\n                if removedCount == 2 {\n                    break;\n                }\n            }\n            if removedCount == 2 {\n                removed = true;\n            }\n        }\n        \n        if !removed {\n            return \"-1\";\n        }\n    }\n    \n    // Check if we still have at least one non-zero digit\n    int nonZeroSum = 0;\n    foreach int i in 1...9 {\n        nonZeroSum += workingCount[i];\n    }\n    \n    if nonZeroSum == 0 {\n        return \"0\";\n    }\n    \n    // Build the result by arranging digits in descending order\n    string result = \"\";\n    foreach int digit in 9...0 {\n        int count = workingCount[digit];\n        foreach int _ in 0..<count {\n            result += digit.toString();\n        }\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of digits\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(line1.trim());\n    if n is error || n < 1 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read the digits\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    int[] digits = [];\n    \n    foreach string part in parts {\n        int|error digit = 'int:fromString(part.trim());\n        if digit is int && digit >= 0 && digit <= 9 {\n            digits.push(digit);\n        }\n    }\n    \n    string result = findMaxNumber(digits);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleZero() {\n    int[] digits = [0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"0\");\n}\n\n@test:Config {}\nfunction testMultipleDigitsWithZero() {\n    int[] digits = [3, 4, 5, 4, 5, 3, 5, 3, 4, 4, 0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"5554443330\");\n}\n\n@test:Config {}\nfunction testNoZero() {\n    int[] digits = [3, 2, 5, 1, 5, 2, 2, 3];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"-1\");\n}\n\n@test:Config {}\nfunction testMultipleZeros() {\n    int[] digits = [0, 0, 0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"0\");\n}\n\n@test:Config {}\nfunction testWithRemovalNeeded() {\n    int[] digits = [9, 0, 3];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"90\");\n}\n\n@test:Config {}\nfunction testLargeNumber() {\n    int[] digits = [9, 9, 9, 0, 0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"99900\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. For divisibility by 2, 3, and 5 simultaneously, the number must be divisible by LCM(2,3,5) = 30\n// 2. Divisible by 2 AND 5 means it must end in 0\n// 3. Divisible by 3 means sum of digits must be divisible by 3\n// 4. To maximize the number, arrange digits in descending order (except the trailing 0)\n// 5. If no 0 exists, return -1\n// 6. If only 0s exist, return 0\n// 7. Remove minimum digits to make sum divisible by 3, prioritizing smaller digits\n\nimport ballerina/io;\n\nfunction findMaxNumber(int[] digits) returns string {\n    // Count occurrences of each digit\n    int[] digitCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    foreach int digit in digits {\n        if digit >= 0 && digit <= 9 {\n            digitCount[digit] += 1;\n        }\n    }\n    \n    // Check if there's at least one zero (required for divisibility by 2 and 5)\n    if digitCount[0] == 0 {\n        return \"-1\";\n    }\n    \n    // Calculate sum of all digits\n    int totalSum = 0;\n    foreach int i in 0...9 {\n        totalSum += i * digitCount[i];\n    }\n    \n    // If sum is 0, only zeros exist\n    if totalSum == 0 {\n        return \"0\";\n    }\n    \n    // Make a working copy of digit counts\n    int[] workingCount = digitCount.clone();\n    \n    // Remove minimum digits to make sum divisible by 3\n    int remainder = totalSum % 3;\n    \n    if remainder != 0 {\n        // Try to remove digits with sum equal to remainder\n        boolean removed = false;\n        \n        // Try removing one digit\n        foreach int digit in 0...9 {\n            if !removed && workingCount[digit] > 0 && digit % 3 == remainder {\n                workingCount[digit] -= 1;\n                removed = true;\n                break;\n            }\n        }\n        \n        // If couldn't remove one digit, try removing two digits\n        if !removed {\n            int targetRemainder = (3 - remainder) % 3;\n            int removedCount = 0;\n            foreach int digit in 0...9 {\n                while workingCount[digit] > 0 && digit % 3 == targetRemainder && removedCount < 2 {\n                    workingCount[digit] -= 1;\n                    removedCount += 1;\n                }\n                if removedCount == 2 {\n                    break;\n                }\n            }\n            if removedCount == 2 {\n                removed = true;\n            }\n        }\n        \n        if !removed {\n            return \"-1\";\n        }\n    }\n    \n    // Check if we still have at least one non-zero digit\n    int nonZeroSum = 0;\n    foreach int i in 1...9 {\n        nonZeroSum += workingCount[i];\n    }\n    \n    if nonZeroSum == 0 {\n        return \"0\";\n    }\n    \n    // Build the result by arranging digits in descending order\n    string result = \"\";\n    foreach int digit in 9...0 {\n        int count = workingCount[digit];\n        foreach int _ in 0..<count {\n            result += digit.toString();\n        }\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of digits\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(line1.trim());\n    if n is error || n < 1 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read the digits\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    string[] parts = line2.trim().split(\" \");\n    int[] digits = [];\n    \n    foreach string part in parts {\n        int|error digit = 'int:fromString(part.trim());\n        if digit is int && digit >= 0 && digit <= 9 {\n            digits.push(digit);\n        }\n    }\n    \n    string result = findMaxNumber(digits);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(122:35,122:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(122:35,122:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(122:35,122:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:39:15.591535",
      "status": "failed",
      "completion": "# Overview\nThis problem requires finding the maximum integer from given digits that is divisible by 2, 3, and 5 (i.e., divisible by 30). Key requirements:\n- Divisible by 2 AND 5: must end in 0\n- Divisible by 3: sum of digits must be divisible by 3\n- Maximize the number: arrange in descending order\n- Must have at least one 0, otherwise return -1\n- If only zeros, return \"0\"\n\nThe main fix needed is using the correct string split method in Ballerina - it's `regex:split()` from the `ballerina/regex` module.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Number must be divisible by LCM(2,3,5) = 30\n// 2. Divisible by 2 AND 5 => must end in 0 (needs at least one 0)\n// 3. Divisible by 3 => sum of all used digits must be divisible by 3\n// 4. To maximize: arrange digits in descending order\n// 5. Strategy:\n//    - Check if at least one 0 exists (otherwise return -1)\n//    - Calculate total sum of all digits\n//    - If sum % 3 != 0, remove minimum digits to make it divisible by 3\n//    - Remove smallest digits with appropriate remainder modulo 3\n//    - Build result in descending order\n// 6. Special case: if only zeros remain, return \"0\"\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction findMaxNumber(int[] digits) returns string {\n    // Count occurrences of each digit (0-9)\n    int[] digitCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    foreach int digit in digits {\n        if digit >= 0 && digit <= 9 {\n            digitCount[digit] += 1;\n        }\n    }\n    \n    // Must have at least one 0 for divisibility by 10 (2*5)\n    if digitCount[0] == 0 {\n        return \"-1\";\n    }\n    \n    // Calculate sum of all digits\n    int totalSum = 0;\n    foreach int i in 0...9 {\n        totalSum += i * digitCount[i];\n    }\n    \n    // If only zeros exist\n    if totalSum == 0 {\n        return \"0\";\n    }\n    \n    // Work with a copy of digit counts\n    int[] workingCount = digitCount.clone();\n    \n    // Adjust to make sum divisible by 3\n    int remainder = totalSum % 3;\n    \n    if remainder != 0 {\n        // We need to remove digits to make sum divisible by 3\n        boolean removed = false;\n        \n        // Strategy 1: Remove one digit with remainder equal to current remainder\n        foreach int digit in 0...9 {\n            if !removed && workingCount[digit] > 0 && digit % 3 == remainder {\n                workingCount[digit] -= 1;\n                removed = true;\n                break;\n            }\n        }\n        \n        // Strategy 2: Remove two digits with remainder = (3 - remainder) % 3\n        if !removed {\n            int targetRemainder = (3 - remainder) % 3;\n            int removedCount = 0;\n            foreach int digit in 0...9 {\n                while workingCount[digit] > 0 && digit % 3 == targetRemainder && removedCount < 2 {\n                    workingCount[digit] -= 1;\n                    removedCount += 1;\n                }\n                if removedCount == 2 {\n                    break;\n                }\n            }\n            if removedCount == 2 {\n                removed = true;\n            }\n        }\n        \n        // If we couldn't make it divisible by 3\n        if !removed {\n            return \"-1\";\n        }\n    }\n    \n    // Check if we still have non-zero digits\n    int nonZeroCount = 0;\n    foreach int i in 1...9 {\n        nonZeroCount += workingCount[i];\n    }\n    \n    // If only zeros remain\n    if nonZeroCount == 0 {\n        return \"0\";\n    }\n    \n    // Build result in descending order\n    string result = \"\";\n    foreach int digit in 9...0 {\n        int count = workingCount[digit];\n        foreach int _ in 0..<count {\n            result += digit.toString();\n        }\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of digits\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    string trimmedLine1 = line1.trim();\n    int|error n = 'int:fromString(trimmedLine1);\n    if n is error || n < 1 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read the digits\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    string trimmedLine2 = line2.trim();\n    string[] parts = regex:split(trimmedLine2, \" \");\n    int[] digits = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int|error digit = 'int:fromString(trimmedPart);\n            if digit is int && digit >= 0 && digit <= 9 {\n                digits.push(digit);\n            }\n        }\n    }\n    \n    string result = findMaxNumber(digits);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleZero() {\n    int[] digits = [0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"0\");\n}\n\n@test:Config {}\nfunction testMultipleDigitsWithZero() {\n    int[] digits = [3, 4, 5, 4, 5, 3, 5, 3, 4, 4, 0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"5554443330\");\n}\n\n@test:Config {}\nfunction testNoZero() {\n    int[] digits = [3, 2, 5, 1, 5, 2, 2, 3];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"-1\");\n}\n\n@test:Config {}\nfunction testMultipleZeros() {\n    int[] digits = [0, 0, 0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"0\");\n}\n\n@test:Config {}\nfunction testWithRemovalNeeded() {\n    int[] digits = [9, 0, 3];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"90\");\n}\n\n@test:Config {}\nfunction testLargeNumber() {\n    int[] digits = [9, 9, 9, 0, 0];\n    string result = findMaxNumber(digits);\n    test:assertEquals(result, \"99900\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Number must be divisible by LCM(2,3,5) = 30\n// 2. Divisible by 2 AND 5 => must end in 0 (needs at least one 0)\n// 3. Divisible by 3 => sum of all used digits must be divisible by 3\n// 4. To maximize: arrange digits in descending order\n// 5. Strategy:\n//    - Check if at least one 0 exists (otherwise return -1)\n//    - Calculate total sum of all digits\n//    - If sum % 3 != 0, remove minimum digits to make it divisible by 3\n//    - Remove smallest digits with appropriate remainder modulo 3\n//    - Build result in descending order\n// 6. Special case: if only zeros remain, return \"0\"\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction findMaxNumber(int[] digits) returns string {\n    // Count occurrences of each digit (0-9)\n    int[] digitCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    foreach int digit in digits {\n        if digit >= 0 && digit <= 9 {\n            digitCount[digit] += 1;\n        }\n    }\n    \n    // Must have at least one 0 for divisibility by 10 (2*5)\n    if digitCount[0] == 0 {\n        return \"-1\";\n    }\n    \n    // Calculate sum of all digits\n    int totalSum = 0;\n    foreach int i in 0...9 {\n        totalSum += i * digitCount[i];\n    }\n    \n    // If only zeros exist\n    if totalSum == 0 {\n        return \"0\";\n    }\n    \n    // Work with a copy of digit counts\n    int[] workingCount = digitCount.clone();\n    \n    // Adjust to make sum divisible by 3\n    int remainder = totalSum % 3;\n    \n    if remainder != 0 {\n        // We need to remove digits to make sum divisible by 3\n        boolean removed = false;\n        \n        // Strategy 1: Remove one digit with remainder equal to current remainder\n        foreach int digit in 0...9 {\n            if !removed && workingCount[digit] > 0 && digit % 3 == remainder {\n                workingCount[digit] -= 1;\n                removed = true;\n                break;\n            }\n        }\n        \n        // Strategy 2: Remove two digits with remainder = (3 - remainder) % 3\n        if !removed {\n            int targetRemainder = (3 - remainder) % 3;\n            int removedCount = 0;\n            foreach int digit in 0...9 {\n                while workingCount[digit] > 0 && digit % 3 == targetRemainder && removedCount < 2 {\n                    workingCount[digit] -= 1;\n                    removedCount += 1;\n                }\n                if removedCount == 2 {\n                    break;\n                }\n            }\n            if removedCount == 2 {\n                removed = true;\n            }\n        }\n        \n        // If we couldn't make it divisible by 3\n        if !removed {\n            return \"-1\";\n        }\n    }\n    \n    // Check if we still have non-zero digits\n    int nonZeroCount = 0;\n    foreach int i in 1...9 {\n        nonZeroCount += workingCount[i];\n    }\n    \n    // If only zeros remain\n    if nonZeroCount == 0 {\n        return \"0\";\n    }\n    \n    // Build result in descending order\n    string result = \"\";\n    foreach int digit in 9...0 {\n        int count = workingCount[digit];\n        foreach int _ in 0..<count {\n            result += digit.toString();\n        }\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read number of digits\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    string trimmedLine1 = line1.trim();\n    int|error n = 'int:fromString(trimmedLine1);\n    if n is error || n < 1 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read the digits\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"-1\");\n        return;\n    }\n    \n    string trimmedLine2 = line2.trim();\n    string[] parts = regex:split(trimmedLine2, \" \");\n    int[] digits = [];\n    \n    foreach string part in parts {\n        string trimmedPart = part.trim();\n        if trimmedPart.length() > 0 {\n            int|error digit = 'int:fromString(trimmedPart);\n            if digit is int && digit >= 0 && digit <= 9 {\n                digits.push(digit);\n            }\n        }\n    }\n    \n    string result = findMaxNumber(digits);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 3,
      "tests_pass_rate": 0.6666666666666666,
      "validation_msg": "Only passed 2/3 tests (66.7%), need 75%",
      "error": "Only passed 2/3 tests (66.7%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "11\n3 4 5 4 5 3 5 3 4 4 0\n",
          "expected_output": "5554443330\n",
          "actual_output": "\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 2/3 tests (66.7%), need 75%",
  "timestamp": "2026-01-05T01:39:51.905127"
}