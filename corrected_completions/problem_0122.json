{
  "entry_id": "problem_0122",
  "problem_index": 122,
  "prompt": "Title: Try and Catch\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nVasya is developing his own programming language VPL (Vasya Programming Language). Right now he is busy making the system of exceptions. He thinks that the system of exceptions must function like that.\n\nThe exceptions are processed by try-catch-blocks. There are two operators that work with the blocks:\n1.  The try operator. It opens a new try-catch-block. 1.  The catch(&lt;exception_type&gt;, &lt;message&gt;) operator. It closes the try-catch-block that was started last and haven't yet been closed. This block can be activated only via exception of type &lt;exception_type&gt;. When we activate this block, the screen displays the &lt;message&gt;. If at the given moment there is no open try-catch-block, then we can't use the catch operator.\nThe exceptions can occur in the program in only one case: when we use the throw operator. The throw(&lt;exception_type&gt;) operator creates the exception of the given type.\n\nLet's suggest that as a result of using some throw operator the program created an exception of type *a*. In this case a try-catch-block is activated, such that this block's try operator was described in the program earlier than the used throw operator. Also, this block's catch operator was given an exception type *a* as a parameter and this block's catch operator is described later that the used throw operator. If there are several such try-catch-blocks, then the system activates the block whose catch operator occurs earlier than others. If no try-catch-block was activated, then the screen displays message \"Unhandled Exception\".\n\nTo test the system, Vasya wrote a program that contains only try, catch and throw operators, one line contains no more than one operator, the whole program contains exactly one throw operator.\n\nYour task is: given a program in VPL, determine, what message will be displayed on the screen.\n\nInput Specification:\nThe first line contains a single integer: *n* (1<=≤<=*n*<=≤<=105) the number of lines in the program. Next *n* lines contain the program in language VPL. Each line contains no more than one operator. It means that input file can contain empty lines and lines, consisting only of spaces.\n\nThe program contains only operators try, catch and throw. It is guaranteed that the program is correct. It means that each started try-catch-block was closed, the catch operators aren't used unless there is an open try-catch-block. The program has exactly one throw operator. The program may have spaces at the beginning of a line, at the end of a line, before and after a bracket, a comma or a quote mark.\n\nThe exception type is a nonempty string, that consists only of upper and lower case english letters. The length of the string does not exceed 20 symbols. Message is a nonempty string, that consists only of upper and lower case english letters, digits and spaces. Message is surrounded with quote marks. Quote marks shouldn't be printed. The length of the string does not exceed 20 symbols.\n\nLength of any line in the input file does not exceed 50 symbols.\n\nOutput Specification:\nPrint the message the screen will show after the given program is executed.\n\nDemo Input:\n['8\\ntry\\n    try\\n        throw ( AE ) \\n    catch ( BE, \"BE in line 3\")\\n\\n    try\\n    catch(AE, \"AE in line 5\") \\ncatch(AE,\"AE somewhere\")\\n', '8\\ntry\\n    try\\n        throw ( AE ) \\n    catch ( AE, \"AE in line 3\")\\n\\n    try\\n    catch(BE, \"BE in line 5\") \\ncatch(AE,\"AE somewhere\")\\n', '8\\ntry\\n    try\\n        throw ( CE ) \\n    catch ( BE, \"BE in line 3\")\\n\\n    try\\n    catch(AE, \"AE in line 5\") \\ncatch(AE,\"AE somewhere\")\\n']\n\nDemo Output:\n['AE somewhere\\n', 'AE in line 3\\n', 'Unhandled Exception\\n']\n\nNote:\nIn the first sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(BE,\"BE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so the second block will be activated, because operator catch(AE,\"AE somewhere\") has exception type AE as parameter and operator catch(BE,\"BE in line 3\") has exception type BE.\n\nIn the second sample there are 2 try-catch-blocks such that try operator is described earlier than throw operator and catch operator is described later than throw operator: try-catch(AE,\"AE in line 3\") and try-catch(AE,\"AE somewhere\"). Exception type is AE, so both blocks can be activated, but only the first one will be activated, because operator catch(AE,\"AE in line 3\") is described earlier than catch(AE,\"AE somewhere\")\n\nIn the third sample there is no blocks that can be activated by an exception of type CE.",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the error, I need to remove the unused `regex` import. Let me also carefully review the parsing logic to ensure it handles all edge cases correctly.\n\n# Overview\nThis problem simulates a try-catch exception handling system. We need to:\n1. Parse the program to identify try, catch, and throw operators\n2. Match each try with its corresponding catch to form try-catch blocks using a stack\n3. When a throw occurs, find all valid try-catch blocks (where try comes before throw and catch comes after throw, with matching exception type)\n4. Select the block whose catch appears earliest\n5. Output the message from that catch, or \"Unhandled Exception\" if no match\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n lines of the program\n// 2. Parse each line to identify the operator type (try, catch, or throw)\n// 3. For catch: extract exception_type and message (handle spaces carefully)\n// 4. For throw: extract exception_type (handle spaces carefully)\n// 5. Match try operators with their corresponding catch operators using a stack\n//    - When we see a try, push its line number onto the stack\n//    - When we see a catch, pop from stack and create a try-catch block\n// 6. Find the throw operator's line number and exception type\n// 7. For each try-catch block, check if:\n//    - try line < throw line < catch line\n//    - catch exception type matches throw exception type\n// 8. Among valid blocks, select the one with the earliest catch line\n// 9. Output the message or \"Unhandled Exception\"\n\nimport ballerina/io;\n\ntype Operator record {\n    string opType; // \"try\", \"catch\", \"throw\"\n    int lineNum;\n    string exceptionType?;\n    string message?;\n};\n\ntype TryCatchBlock record {\n    int tryLine;\n    int catchLine;\n    string exceptionType;\n    string message;\n};\n\n// Helper function to find character in string\nfunction findChar(string s, string ch) returns int {\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Helper function to find last occurrence of character\nfunction findLastChar(string s, string ch) returns int {\n    int lastIdx = -1;\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            lastIdx = i;\n        }\n    }\n    return lastIdx;\n}\n\nfunction parseOperator(string line, int lineNum) returns Operator? {\n    string trimmed = line.trim();\n    \n    if trimmed == \"\" {\n        return ();\n    }\n    \n    if trimmed == \"try\" {\n        return {opType: \"try\", lineNum: lineNum};\n    }\n    \n    if trimmed.startsWith(\"catch\") {\n        // Parse catch(exception_type, \"message\")\n        // Find the opening and closing parentheses\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        \n        // Find the comma that separates exception type and message\n        // We need to be careful: the comma should be outside quotes\n        int commaPos = -1;\n        boolean inQuotes = false;\n        foreach int i in 0 ..< content.length() {\n            if content[i] == \"\\\"\" {\n                inQuotes = !inQuotes;\n            } else if content[i] == \",\" && !inQuotes {\n                commaPos = i;\n                break;\n            }\n        }\n        \n        if commaPos == -1 {\n            return ();\n        }\n        \n        string excType = content.substring(0, commaPos).trim();\n        string msgPart = content.substring(commaPos + 1).trim();\n        \n        // Extract message from quotes\n        int firstQuote = findChar(msgPart, \"\\\"\");\n        int lastQuote = findLastChar(msgPart, \"\\\"\");\n        \n        string msg = \"\";\n        if firstQuote != -1 && lastQuote != -1 && lastQuote > firstQuote {\n            msg = msgPart.substring(firstQuote + 1, lastQuote);\n        }\n        \n        return {opType: \"catch\", lineNum: lineNum, exceptionType: excType, message: msg};\n    }\n    \n    if trimmed.startsWith(\"throw\") {\n        // Parse throw(exception_type)\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        return {opType: \"throw\", lineNum: lineNum, exceptionType: content};\n    }\n    \n    return ();\n}\n\nfunction solve(int n, string[] lines) returns string {\n    Operator[] operators = [];\n    \n    // Parse all operators\n    foreach int i in 0 ..< n {\n        Operator? op = parseOperator(lines[i], i);\n        if op is Operator {\n            operators.push(op);\n        }\n    }\n    \n    // Match try with catch to form blocks\n    TryCatchBlock[] blocks = [];\n    int[] tryStack = []; // Stack of try line numbers\n    \n    foreach Operator op in operators {\n        if op.opType == \"try\" {\n            tryStack.push(op.lineNum);\n        } else if op.opType == \"catch\" {\n            if tryStack.length() > 0 {\n                int tryLine = tryStack.pop();\n                blocks.push({\n                    tryLine: tryLine,\n                    catchLine: op.lineNum,\n                    exceptionType: op.exceptionType ?: \"\",\n                    message: op.message ?: \"\"\n                });\n            }\n        }\n    }\n    \n    // Find throw operator\n    int throwLine = -1;\n    string throwException = \"\";\n    foreach Operator op in operators {\n        if op.opType == \"throw\" {\n            throwLine = op.lineNum;\n            throwException = op.exceptionType ?: \"\";\n            break;\n        }\n    }\n    \n    // Find valid blocks\n    TryCatchBlock[] validBlocks = [];\n    foreach TryCatchBlock block in blocks {\n        if block.tryLine < throwLine && throwLine < block.catchLine && \n            block.exceptionType == throwException {\n            validBlocks.push(block);\n        }\n    }\n    \n    // Select the block with earliest catch\n    if validBlocks.length() == 0 {\n        return \"Unhandled Exception\";\n    }\n    \n    TryCatchBlock selectedBlock = validBlocks[0];\n    foreach TryCatchBlock block in validBlocks {\n        if block.catchLine < selectedBlock.catchLine {\n            selectedBlock = block;\n        }\n    }\n    \n    return selectedBlock.message;\n}\n\npublic function main() returns error? {\n    string? input = io:readln();\n    if input is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(input.trim());\n    if n is error {\n        io:println(\"Invalid input\");\n        return;\n    }\n    \n    string[] lines = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is string {\n            lines.push(line);\n        } else {\n            lines.push(\"\");\n        }\n    }\n    \n    string result = solve(n, lines);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testFirstExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( AE ) \",\n        \"    catch ( BE, \\\"BE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(AE, \\\"AE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"AE somewhere\");\n}\n\n@test:Config {}\nfunction testSecondExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( AE ) \",\n        \"    catch ( AE, \\\"AE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(BE, \\\"BE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"AE in line 3\");\n}\n\n@test:Config {}\nfunction testThirdExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( CE ) \",\n        \"    catch ( BE, \\\"BE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(AE, \\\"AE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"Unhandled Exception\");\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    string[] lines = [\n        \"try\",\n        \"throw(EX)\",\n        \"catch(EX, \\\"Caught it\\\")\"\n    ];\n    string result = solve(3, lines);\n    test:assertEquals(result, \"Caught it\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Read n lines of the program\n// 2. Parse each line to identify the operator type (try, catch, or throw)\n// 3. For catch: extract exception_type and message (handle spaces carefully)\n// 4. For throw: extract exception_type (handle spaces carefully)\n// 5. Match try operators with their corresponding catch operators using a stack\n//    - When we see a try, push its line number onto the stack\n//    - When we see a catch, pop from stack and create a try-catch block\n// 6. Find the throw operator's line number and exception type\n// 7. For each try-catch block, check if:\n//    - try line < throw line < catch line\n//    - catch exception type matches throw exception type\n// 8. Among valid blocks, select the one with the earliest catch line\n// 9. Output the message or \"Unhandled Exception\"\n\nimport ballerina/io;\n\ntype Operator record {\n    string opType; // \"try\", \"catch\", \"throw\"\n    int lineNum;\n    string exceptionType?;\n    string message?;\n};\n\ntype TryCatchBlock record {\n    int tryLine;\n    int catchLine;\n    string exceptionType;\n    string message;\n};\n\n// Helper function to find character in string\nfunction findChar(string s, string ch) returns int {\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Helper function to find last occurrence of character\nfunction findLastChar(string s, string ch) returns int {\n    int lastIdx = -1;\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            lastIdx = i;\n        }\n    }\n    return lastIdx;\n}\n\nfunction parseOperator(string line, int lineNum) returns Operator? {\n    string trimmed = line.trim();\n    \n    if trimmed == \"\" {\n        return ();\n    }\n    \n    if trimmed == \"try\" {\n        return {opType: \"try\", lineNum: lineNum};\n    }\n    \n    if trimmed.startsWith(\"catch\") {\n        // Parse catch(exception_type, \"message\")\n        // Find the opening and closing parentheses\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        \n        // Find the comma that separates exception type and message\n        // We need to be careful: the comma should be outside quotes\n        int commaPos = -1;\n        boolean inQuotes = false;\n        foreach int i in 0 ..< content.length() {\n            if content[i] == \"\\\"\" {\n                inQuotes = !inQuotes;\n            } else if content[i] == \",\" && !inQuotes {\n                commaPos = i;\n                break;\n            }\n        }\n        \n        if commaPos == -1 {\n            return ();\n        }\n        \n        string excType = content.substring(0, commaPos).trim();\n        string msgPart = content.substring(commaPos + 1).trim();\n        \n        // Extract message from quotes\n        int firstQuote = findChar(msgPart, \"\\\"\");\n        int lastQuote = findLastChar(msgPart, \"\\\"\");\n        \n        string msg = \"\";\n        if firstQuote != -1 && lastQuote != -1 && lastQuote > firstQuote {\n            msg = msgPart.substring(firstQuote + 1, lastQuote);\n        }\n        \n        return {opType: \"catch\", lineNum: lineNum, exceptionType: excType, message: msg};\n    }\n    \n    if trimmed.startsWith(\"throw\") {\n        // Parse throw(exception_type)\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        return {opType: \"throw\", lineNum: lineNum, exceptionType: content};\n    }\n    \n    return ();\n}\n\nfunction solve(int n, string[] lines) returns string {\n    Operator[] operators = [];\n    \n    // Parse all operators\n    foreach int i in 0 ..< n {\n        Operator? op = parseOperator(lines[i], i);\n        if op is Operator {\n            operators.push(op);\n        }\n    }\n    \n    // Match try with catch to form blocks\n    TryCatchBlock[] blocks = [];\n    int[] tryStack = []; // Stack of try line numbers\n    \n    foreach Operator op in operators {\n        if op.opType == \"try\" {\n            tryStack.push(op.lineNum);\n        } else if op.opType == \"catch\" {\n            if tryStack.length() > 0 {\n                int tryLine = tryStack.pop();\n                blocks.push({\n                    tryLine: tryLine,\n                    catchLine: op.lineNum,\n                    exceptionType: op.exceptionType ?: \"\",\n                    message: op.message ?: \"\"\n                });\n            }\n        }\n    }\n    \n    // Find throw operator\n    int throwLine = -1;\n    string throwException = \"\";\n    foreach Operator op in operators {\n        if op.opType == \"throw\" {\n            throwLine = op.lineNum;\n            throwException = op.exceptionType ?: \"\";\n            break;\n        }\n    }\n    \n    // Find valid blocks\n    TryCatchBlock[] validBlocks = [];\n    foreach TryCatchBlock block in blocks {\n        if block.tryLine < throwLine && throwLine < block.catchLine && \n            block.exceptionType == throwException {\n            validBlocks.push(block);\n        }\n    }\n    \n    // Select the block with earliest catch\n    if validBlocks.length() == 0 {\n        return \"Unhandled Exception\";\n    }\n    \n    TryCatchBlock selectedBlock = validBlocks[0];\n    foreach TryCatchBlock block in validBlocks {\n        if block.catchLine < selectedBlock.catchLine {\n            selectedBlock = block;\n        }\n    }\n    \n    return selectedBlock.message;\n}\n\npublic function main() returns error? {\n    string? input = io:readln();\n    if input is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(input.trim());\n    if n is error {\n        io:println(\"Invalid input\");\n        return;\n    }\n    \n    string[] lines = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is string {\n            lines.push(line);\n        } else {\n            lines.push(\"\");\n        }\n    }\n    \n    string result = solve(n, lines);\n    io:println(result);\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:09:08.755200",
      "status": "failed",
      "completion": "# Overview\nThis problem simulates a try-catch exception handling system. We need to:\n1. Parse the program to identify try, catch, and throw operators\n2. Match each try with its corresponding catch to form try-catch blocks\n3. When a throw occurs, find all valid try-catch blocks (where try comes before throw and catch comes after throw, with matching exception type)\n4. Select the block whose catch appears earliest\n5. Output the message from that catch, or \"Unhandled Exception\" if no match\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n lines of the program\n// 2. Parse each line to identify the operator type (try, catch, or throw)\n// 3. For catch: extract exception_type and message\n// 4. For throw: extract exception_type\n// 5. Match try operators with their corresponding catch operators using a stack\n// 6. Find the throw operator's line number\n// 7. For each try-catch block, check if:\n//    - try line < throw line < catch line\n//    - catch exception type matches throw exception type\n// 8. Among valid blocks, select the one with the earliest catch line\n// 9. Output the message or \"Unhandled Exception\"\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Operator record {\n    string opType; // \"try\", \"catch\", \"throw\"\n    int lineNum;\n    string exceptionType?;\n    string message?;\n};\n\ntype TryCatchBlock record {\n    int tryLine;\n    int catchLine;\n    string exceptionType;\n    string message;\n};\n\nfunction parseOperator(string line, int lineNum) returns Operator? {\n    string trimmed = line.trim();\n    \n    if trimmed == \"\" {\n        return ();\n    }\n    \n    if trimmed == \"try\" {\n        return {opType: \"try\", lineNum: lineNum};\n    }\n    \n    if trimmed.startsWith(\"catch\") {\n        // Parse catch(exception_type, \"message\")\n        string content = trimmed.substring(5).trim(); // Remove \"catch\"\n        if content.startsWith(\"(\") {\n            content = content.substring(1);\n        }\n        if content.endsWith(\")\") {\n            content = content.substring(0, content.length() - 1);\n        }\n        \n        // Find the comma that separates exception type and message\n        int? commaPos = content.indexOf(\",\");\n        if commaPos is int {\n            string excType = content.substring(0, commaPos).trim();\n            string msgPart = content.substring(commaPos + 1).trim();\n            \n            // Extract message from quotes\n            int firstQuote = -1;\n            int lastQuote = -1;\n            foreach int i in 0 ..< msgPart.length() {\n                if msgPart[i] == \"\\\"\" {\n                    if firstQuote == -1 {\n                        firstQuote = i;\n                    }\n                    lastQuote = i;\n                }\n            }\n            \n            string msg = \"\";\n            if firstQuote != -1 && lastQuote != -1 && lastQuote > firstQuote {\n                msg = msgPart.substring(firstQuote + 1, lastQuote);\n            }\n            \n            return {opType: \"catch\", lineNum: lineNum, exceptionType: excType, message: msg};\n        }\n    }\n    \n    if trimmed.startsWith(\"throw\") {\n        // Parse throw(exception_type)\n        string content = trimmed.substring(5).trim(); // Remove \"throw\"\n        if content.startsWith(\"(\") {\n            content = content.substring(1);\n        }\n        if content.endsWith(\")\") {\n            content = content.substring(0, content.length() - 1);\n        }\n        string excType = content.trim();\n        return {opType: \"throw\", lineNum: lineNum, exceptionType: excType};\n    }\n    \n    return ();\n}\n\nfunction solve(int n, string[] lines) returns string {\n    Operator[] operators = [];\n    \n    // Parse all operators\n    foreach int i in 0 ..< n {\n        Operator? op = parseOperator(lines[i], i);\n        if op is Operator {\n            operators.push(op);\n        }\n    }\n    \n    // Match try with catch to form blocks\n    TryCatchBlock[] blocks = [];\n    int[] tryStack = []; // Stack of try line numbers\n    \n    foreach Operator op in operators {\n        if op.opType == \"try\" {\n            tryStack.push(op.lineNum);\n        } else if op.opType == \"catch\" {\n            if tryStack.length() > 0 {\n                int tryLine = tryStack.pop();\n                blocks.push({\n                    tryLine: tryLine,\n                    catchLine: op.lineNum,\n                    exceptionType: op.exceptionType ?: \"\",\n                    message: op.message ?: \"\"\n                });\n            }\n        }\n    }\n    \n    // Find throw operator\n    int throwLine = -1;\n    string throwException = \"\";\n    foreach Operator op in operators {\n        if op.opType == \"throw\" {\n            throwLine = op.lineNum;\n            throwException = op.exceptionType ?: \"\";\n            break;\n        }\n    }\n    \n    // Find valid blocks\n    TryCatchBlock[] validBlocks = [];\n    foreach TryCatchBlock block in blocks {\n        if block.tryLine < throwLine && throwLine < block.catchLine && \n            block.exceptionType == throwException {\n            validBlocks.push(block);\n        }\n    }\n    \n    // Select the block with earliest catch\n    if validBlocks.length() == 0 {\n        return \"Unhandled Exception\";\n    }\n    \n    TryCatchBlock selectedBlock = validBlocks[0];\n    foreach TryCatchBlock block in validBlocks {\n        if block.catchLine < selectedBlock.catchLine {\n            selectedBlock = block;\n        }\n    }\n    \n    return selectedBlock.message;\n}\n\npublic function main() returns error? {\n    string? input = io:readln();\n    if input is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(input.trim());\n    if n is error {\n        io:println(\"Invalid input\");\n        return;\n    }\n    \n    string[] lines = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is string {\n            lines.push(line);\n        } else {\n            lines.push(\"\");\n        }\n    }\n    \n    string result = solve(n, lines);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testFirstExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( AE ) \",\n        \"    catch ( BE, \\\"BE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(AE, \\\"AE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"AE somewhere\");\n}\n\n@test:Config {}\nfunction testSecondExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( AE ) \",\n        \"    catch ( AE, \\\"AE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(BE, \\\"BE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"AE in line 3\");\n}\n\n@test:Config {}\nfunction testThirdExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( CE ) \",\n        \"    catch ( BE, \\\"BE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(AE, \\\"AE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"Unhandled Exception\");\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    string[] lines = [\n        \"try\",\n        \"throw(EX)\",\n        \"catch(EX, \\\"Caught it\\\")\"\n    ];\n    string result = solve(3, lines);\n    test:assertEquals(result, \"Caught it\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n lines of the program\n// 2. Parse each line to identify the operator type (try, catch, or throw)\n// 3. For catch: extract exception_type and message\n// 4. For throw: extract exception_type\n// 5. Match try operators with their corresponding catch operators using a stack\n// 6. Find the throw operator's line number\n// 7. For each try-catch block, check if:\n//    - try line < throw line < catch line\n//    - catch exception type matches throw exception type\n// 8. Among valid blocks, select the one with the earliest catch line\n// 9. Output the message or \"Unhandled Exception\"\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Operator record {\n    string opType; // \"try\", \"catch\", \"throw\"\n    int lineNum;\n    string exceptionType?;\n    string message?;\n};\n\ntype TryCatchBlock record {\n    int tryLine;\n    int catchLine;\n    string exceptionType;\n    string message;\n};\n\nfunction parseOperator(string line, int lineNum) returns Operator? {\n    string trimmed = line.trim();\n    \n    if trimmed == \"\" {\n        return ();\n    }\n    \n    if trimmed == \"try\" {\n        return {opType: \"try\", lineNum: lineNum};\n    }\n    \n    if trimmed.startsWith(\"catch\") {\n        // Parse catch(exception_type, \"message\")\n        string content = trimmed.substring(5).trim(); // Remove \"catch\"\n        if content.startsWith(\"(\") {\n            content = content.substring(1);\n        }\n        if content.endsWith(\")\") {\n            content = content.substring(0, content.length() - 1);\n        }\n        \n        // Find the comma that separates exception type and message\n        int? commaPos = content.indexOf(\",\");\n        if commaPos is int {\n            string excType = content.substring(0, commaPos).trim();\n            string msgPart = content.substring(commaPos + 1).trim();\n            \n            // Extract message from quotes\n            int firstQuote = -1;\n            int lastQuote = -1;\n            foreach int i in 0 ..< msgPart.length() {\n                if msgPart[i] == \"\\\"\" {\n                    if firstQuote == -1 {\n                        firstQuote = i;\n                    }\n                    lastQuote = i;\n                }\n            }\n            \n            string msg = \"\";\n            if firstQuote != -1 && lastQuote != -1 && lastQuote > firstQuote {\n                msg = msgPart.substring(firstQuote + 1, lastQuote);\n            }\n            \n            return {opType: \"catch\", lineNum: lineNum, exceptionType: excType, message: msg};\n        }\n    }\n    \n    if trimmed.startsWith(\"throw\") {\n        // Parse throw(exception_type)\n        string content = trimmed.substring(5).trim(); // Remove \"throw\"\n        if content.startsWith(\"(\") {\n            content = content.substring(1);\n        }\n        if content.endsWith(\")\") {\n            content = content.substring(0, content.length() - 1);\n        }\n        string excType = content.trim();\n        return {opType: \"throw\", lineNum: lineNum, exceptionType: excType};\n    }\n    \n    return ();\n}\n\nfunction solve(int n, string[] lines) returns string {\n    Operator[] operators = [];\n    \n    // Parse all operators\n    foreach int i in 0 ..< n {\n        Operator? op = parseOperator(lines[i], i);\n        if op is Operator {\n            operators.push(op);\n        }\n    }\n    \n    // Match try with catch to form blocks\n    TryCatchBlock[] blocks = [];\n    int[] tryStack = []; // Stack of try line numbers\n    \n    foreach Operator op in operators {\n        if op.opType == \"try\" {\n            tryStack.push(op.lineNum);\n        } else if op.opType == \"catch\" {\n            if tryStack.length() > 0 {\n                int tryLine = tryStack.pop();\n                blocks.push({\n                    tryLine: tryLine,\n                    catchLine: op.lineNum,\n                    exceptionType: op.exceptionType ?: \"\",\n                    message: op.message ?: \"\"\n                });\n            }\n        }\n    }\n    \n    // Find throw operator\n    int throwLine = -1;\n    string throwException = \"\";\n    foreach Operator op in operators {\n        if op.opType == \"throw\" {\n            throwLine = op.lineNum;\n            throwException = op.exceptionType ?: \"\";\n            break;\n        }\n    }\n    \n    // Find valid blocks\n    TryCatchBlock[] validBlocks = [];\n    foreach TryCatchBlock block in blocks {\n        if block.tryLine < throwLine && throwLine < block.catchLine && \n            block.exceptionType == throwException {\n            validBlocks.push(block);\n        }\n    }\n    \n    // Select the block with earliest catch\n    if validBlocks.length() == 0 {\n        return \"Unhandled Exception\";\n    }\n    \n    TryCatchBlock selectedBlock = validBlocks[0];\n    foreach TryCatchBlock block in validBlocks {\n        if block.catchLine < selectedBlock.catchLine {\n            selectedBlock = block;\n        }\n    }\n    \n    return selectedBlock.message;\n}\n\npublic function main() returns error? {\n    string? input = io:readln();\n    if input is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(input.trim());\n    if n is error {\n        io:println(\"Invalid input\");\n        return;\n    }\n    \n    string[] lines = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is string {\n            lines.push(line);\n        } else {\n            lines.push(\"\");\n        }\n    }\n    \n    string result = solve(n, lines);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(15:18,15:23)] unused module prefix 'regex'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(15:18,15:23)] unused module prefix 'regex'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(15:18,15:23)] unused module prefix 'regex'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:09:41.276980",
      "status": "success",
      "completion": "Looking at the error, I need to remove the unused `regex` import. Let me also carefully review the parsing logic to ensure it handles all edge cases correctly.\n\n# Overview\nThis problem simulates a try-catch exception handling system. We need to:\n1. Parse the program to identify try, catch, and throw operators\n2. Match each try with its corresponding catch to form try-catch blocks using a stack\n3. When a throw occurs, find all valid try-catch blocks (where try comes before throw and catch comes after throw, with matching exception type)\n4. Select the block whose catch appears earliest\n5. Output the message from that catch, or \"Unhandled Exception\" if no match\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n lines of the program\n// 2. Parse each line to identify the operator type (try, catch, or throw)\n// 3. For catch: extract exception_type and message (handle spaces carefully)\n// 4. For throw: extract exception_type (handle spaces carefully)\n// 5. Match try operators with their corresponding catch operators using a stack\n//    - When we see a try, push its line number onto the stack\n//    - When we see a catch, pop from stack and create a try-catch block\n// 6. Find the throw operator's line number and exception type\n// 7. For each try-catch block, check if:\n//    - try line < throw line < catch line\n//    - catch exception type matches throw exception type\n// 8. Among valid blocks, select the one with the earliest catch line\n// 9. Output the message or \"Unhandled Exception\"\n\nimport ballerina/io;\n\ntype Operator record {\n    string opType; // \"try\", \"catch\", \"throw\"\n    int lineNum;\n    string exceptionType?;\n    string message?;\n};\n\ntype TryCatchBlock record {\n    int tryLine;\n    int catchLine;\n    string exceptionType;\n    string message;\n};\n\n// Helper function to find character in string\nfunction findChar(string s, string ch) returns int {\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Helper function to find last occurrence of character\nfunction findLastChar(string s, string ch) returns int {\n    int lastIdx = -1;\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            lastIdx = i;\n        }\n    }\n    return lastIdx;\n}\n\nfunction parseOperator(string line, int lineNum) returns Operator? {\n    string trimmed = line.trim();\n    \n    if trimmed == \"\" {\n        return ();\n    }\n    \n    if trimmed == \"try\" {\n        return {opType: \"try\", lineNum: lineNum};\n    }\n    \n    if trimmed.startsWith(\"catch\") {\n        // Parse catch(exception_type, \"message\")\n        // Find the opening and closing parentheses\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        \n        // Find the comma that separates exception type and message\n        // We need to be careful: the comma should be outside quotes\n        int commaPos = -1;\n        boolean inQuotes = false;\n        foreach int i in 0 ..< content.length() {\n            if content[i] == \"\\\"\" {\n                inQuotes = !inQuotes;\n            } else if content[i] == \",\" && !inQuotes {\n                commaPos = i;\n                break;\n            }\n        }\n        \n        if commaPos == -1 {\n            return ();\n        }\n        \n        string excType = content.substring(0, commaPos).trim();\n        string msgPart = content.substring(commaPos + 1).trim();\n        \n        // Extract message from quotes\n        int firstQuote = findChar(msgPart, \"\\\"\");\n        int lastQuote = findLastChar(msgPart, \"\\\"\");\n        \n        string msg = \"\";\n        if firstQuote != -1 && lastQuote != -1 && lastQuote > firstQuote {\n            msg = msgPart.substring(firstQuote + 1, lastQuote);\n        }\n        \n        return {opType: \"catch\", lineNum: lineNum, exceptionType: excType, message: msg};\n    }\n    \n    if trimmed.startsWith(\"throw\") {\n        // Parse throw(exception_type)\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        return {opType: \"throw\", lineNum: lineNum, exceptionType: content};\n    }\n    \n    return ();\n}\n\nfunction solve(int n, string[] lines) returns string {\n    Operator[] operators = [];\n    \n    // Parse all operators\n    foreach int i in 0 ..< n {\n        Operator? op = parseOperator(lines[i], i);\n        if op is Operator {\n            operators.push(op);\n        }\n    }\n    \n    // Match try with catch to form blocks\n    TryCatchBlock[] blocks = [];\n    int[] tryStack = []; // Stack of try line numbers\n    \n    foreach Operator op in operators {\n        if op.opType == \"try\" {\n            tryStack.push(op.lineNum);\n        } else if op.opType == \"catch\" {\n            if tryStack.length() > 0 {\n                int tryLine = tryStack.pop();\n                blocks.push({\n                    tryLine: tryLine,\n                    catchLine: op.lineNum,\n                    exceptionType: op.exceptionType ?: \"\",\n                    message: op.message ?: \"\"\n                });\n            }\n        }\n    }\n    \n    // Find throw operator\n    int throwLine = -1;\n    string throwException = \"\";\n    foreach Operator op in operators {\n        if op.opType == \"throw\" {\n            throwLine = op.lineNum;\n            throwException = op.exceptionType ?: \"\";\n            break;\n        }\n    }\n    \n    // Find valid blocks\n    TryCatchBlock[] validBlocks = [];\n    foreach TryCatchBlock block in blocks {\n        if block.tryLine < throwLine && throwLine < block.catchLine && \n            block.exceptionType == throwException {\n            validBlocks.push(block);\n        }\n    }\n    \n    // Select the block with earliest catch\n    if validBlocks.length() == 0 {\n        return \"Unhandled Exception\";\n    }\n    \n    TryCatchBlock selectedBlock = validBlocks[0];\n    foreach TryCatchBlock block in validBlocks {\n        if block.catchLine < selectedBlock.catchLine {\n            selectedBlock = block;\n        }\n    }\n    \n    return selectedBlock.message;\n}\n\npublic function main() returns error? {\n    string? input = io:readln();\n    if input is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(input.trim());\n    if n is error {\n        io:println(\"Invalid input\");\n        return;\n    }\n    \n    string[] lines = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is string {\n            lines.push(line);\n        } else {\n            lines.push(\"\");\n        }\n    }\n    \n    string result = solve(n, lines);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testFirstExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( AE ) \",\n        \"    catch ( BE, \\\"BE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(AE, \\\"AE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"AE somewhere\");\n}\n\n@test:Config {}\nfunction testSecondExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( AE ) \",\n        \"    catch ( AE, \\\"AE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(BE, \\\"BE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"AE in line 3\");\n}\n\n@test:Config {}\nfunction testThirdExample() {\n    string[] lines = [\n        \"try\",\n        \"    try\",\n        \"        throw ( CE ) \",\n        \"    catch ( BE, \\\"BE in line 3\\\")\",\n        \"\",\n        \"    try\",\n        \"    catch(AE, \\\"AE in line 5\\\") \",\n        \"catch(AE,\\\"AE somewhere\\\")\"\n    ];\n    string result = solve(8, lines);\n    test:assertEquals(result, \"Unhandled Exception\");\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    string[] lines = [\n        \"try\",\n        \"throw(EX)\",\n        \"catch(EX, \\\"Caught it\\\")\"\n    ];\n    string result = solve(3, lines);\n    test:assertEquals(result, \"Caught it\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n lines of the program\n// 2. Parse each line to identify the operator type (try, catch, or throw)\n// 3. For catch: extract exception_type and message (handle spaces carefully)\n// 4. For throw: extract exception_type (handle spaces carefully)\n// 5. Match try operators with their corresponding catch operators using a stack\n//    - When we see a try, push its line number onto the stack\n//    - When we see a catch, pop from stack and create a try-catch block\n// 6. Find the throw operator's line number and exception type\n// 7. For each try-catch block, check if:\n//    - try line < throw line < catch line\n//    - catch exception type matches throw exception type\n// 8. Among valid blocks, select the one with the earliest catch line\n// 9. Output the message or \"Unhandled Exception\"\n\nimport ballerina/io;\n\ntype Operator record {\n    string opType; // \"try\", \"catch\", \"throw\"\n    int lineNum;\n    string exceptionType?;\n    string message?;\n};\n\ntype TryCatchBlock record {\n    int tryLine;\n    int catchLine;\n    string exceptionType;\n    string message;\n};\n\n// Helper function to find character in string\nfunction findChar(string s, string ch) returns int {\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Helper function to find last occurrence of character\nfunction findLastChar(string s, string ch) returns int {\n    int lastIdx = -1;\n    foreach int i in 0 ..< s.length() {\n        if s[i] == ch {\n            lastIdx = i;\n        }\n    }\n    return lastIdx;\n}\n\nfunction parseOperator(string line, int lineNum) returns Operator? {\n    string trimmed = line.trim();\n    \n    if trimmed == \"\" {\n        return ();\n    }\n    \n    if trimmed == \"try\" {\n        return {opType: \"try\", lineNum: lineNum};\n    }\n    \n    if trimmed.startsWith(\"catch\") {\n        // Parse catch(exception_type, \"message\")\n        // Find the opening and closing parentheses\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        \n        // Find the comma that separates exception type and message\n        // We need to be careful: the comma should be outside quotes\n        int commaPos = -1;\n        boolean inQuotes = false;\n        foreach int i in 0 ..< content.length() {\n            if content[i] == \"\\\"\" {\n                inQuotes = !inQuotes;\n            } else if content[i] == \",\" && !inQuotes {\n                commaPos = i;\n                break;\n            }\n        }\n        \n        if commaPos == -1 {\n            return ();\n        }\n        \n        string excType = content.substring(0, commaPos).trim();\n        string msgPart = content.substring(commaPos + 1).trim();\n        \n        // Extract message from quotes\n        int firstQuote = findChar(msgPart, \"\\\"\");\n        int lastQuote = findLastChar(msgPart, \"\\\"\");\n        \n        string msg = \"\";\n        if firstQuote != -1 && lastQuote != -1 && lastQuote > firstQuote {\n            msg = msgPart.substring(firstQuote + 1, lastQuote);\n        }\n        \n        return {opType: \"catch\", lineNum: lineNum, exceptionType: excType, message: msg};\n    }\n    \n    if trimmed.startsWith(\"throw\") {\n        // Parse throw(exception_type)\n        int openParen = findChar(trimmed, \"(\");\n        int closeParen = findLastChar(trimmed, \")\");\n        \n        if openParen == -1 || closeParen == -1 {\n            return ();\n        }\n        \n        string content = trimmed.substring(openParen + 1, closeParen).trim();\n        return {opType: \"throw\", lineNum: lineNum, exceptionType: content};\n    }\n    \n    return ();\n}\n\nfunction solve(int n, string[] lines) returns string {\n    Operator[] operators = [];\n    \n    // Parse all operators\n    foreach int i in 0 ..< n {\n        Operator? op = parseOperator(lines[i], i);\n        if op is Operator {\n            operators.push(op);\n        }\n    }\n    \n    // Match try with catch to form blocks\n    TryCatchBlock[] blocks = [];\n    int[] tryStack = []; // Stack of try line numbers\n    \n    foreach Operator op in operators {\n        if op.opType == \"try\" {\n            tryStack.push(op.lineNum);\n        } else if op.opType == \"catch\" {\n            if tryStack.length() > 0 {\n                int tryLine = tryStack.pop();\n                blocks.push({\n                    tryLine: tryLine,\n                    catchLine: op.lineNum,\n                    exceptionType: op.exceptionType ?: \"\",\n                    message: op.message ?: \"\"\n                });\n            }\n        }\n    }\n    \n    // Find throw operator\n    int throwLine = -1;\n    string throwException = \"\";\n    foreach Operator op in operators {\n        if op.opType == \"throw\" {\n            throwLine = op.lineNum;\n            throwException = op.exceptionType ?: \"\";\n            break;\n        }\n    }\n    \n    // Find valid blocks\n    TryCatchBlock[] validBlocks = [];\n    foreach TryCatchBlock block in blocks {\n        if block.tryLine < throwLine && throwLine < block.catchLine && \n            block.exceptionType == throwException {\n            validBlocks.push(block);\n        }\n    }\n    \n    // Select the block with earliest catch\n    if validBlocks.length() == 0 {\n        return \"Unhandled Exception\";\n    }\n    \n    TryCatchBlock selectedBlock = validBlocks[0];\n    foreach TryCatchBlock block in validBlocks {\n        if block.catchLine < selectedBlock.catchLine {\n            selectedBlock = block;\n        }\n    }\n    \n    return selectedBlock.message;\n}\n\npublic function main() returns error? {\n    string? input = io:readln();\n    if input is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(input.trim());\n    if n is error {\n        io:println(\"Invalid input\");\n        return;\n    }\n    \n    string[] lines = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is string {\n            lines.push(line);\n        } else {\n            lines.push(\"\");\n        }\n    }\n    \n    string result = solve(n, lines);\n    io:println(result);\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T02:10:20.115958"
}