{
  "entry_id": "problem_0149",
  "problem_index": 149,
  "prompt": "Title: Maze\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nPavel loves grid mazes. A grid maze is an *n*<=×<=*m* rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.\n\nPavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly *k* empty cells into walls so that all the remaining cells still formed a connected area. Help him.\n\nInput Specification:\nThe first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=500, 0<=≤<=*k*<=&lt;<=*s*), where *n* and *m* are the maze's height and width, correspondingly, *k* is the number of walls Pavel wants to add and letter *s* represents the number of empty cells in the original maze.\n\nEach of the next *n* lines contains *m* characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall.\n\nOutput Specification:\nPrint *n* lines containing *m* characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\").\n\nIt is guaranteed that a solution exists. If there are multiple solutions you can output any of them.\n\nDemo Input:\n['3 4 2\\n#..#\\n..#.\\n#...\\n', '5 4 5\\n#...\\n#.#.\\n.#..\\n...#\\n.#.#\\n']\n\nDemo Output:\n['#.X#\\nX.#.\\n#...\\n', '#XXX\\n#X#.\\nX#..\\n...#\\n.#.#\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:36:22.813302",
      "status": "failed",
      "completion": "# Overview\nThis problem requires us to convert exactly k empty cells ('.') into walls ('X') in a maze such that all remaining empty cells still form a connected area. The strategy is to:\n1. Parse the maze and find all empty cells\n2. Use DFS/BFS to traverse the connected empty cells\n3. Mark the last k visited cells as walls (since we visit them last in the traversal, removing them won't disconnect earlier cells)\n4. Output the modified maze\n\nThe key insight is that if we do a DFS/BFS traversal and mark cells as visited, the last k cells we visit can be safely converted to walls without disconnecting the maze (as long as we don't revisit them).\n\n<CODE>\n```ballerina\n// Strategy:\n// 1. Read the maze dimensions and k\n// 2. Read the maze grid\n// 3. Find any empty cell to start DFS\n// 4. Perform DFS to visit all empty cells, keeping track of visit order\n// 5. Convert the last k visited cells to 'X'\n// 6. Print the modified maze\n//\n// The key insight: If we do DFS traversal of all connected empty cells,\n// the cells we visit last can be removed without disconnecting the rest,\n// because they are \"leaf\" nodes in our DFS tree.\n\nimport ballerina/io;\n\ntype Cell record {\n    int row;\n    int col;\n};\n\nfunction solveMaze(int n, int m, int k, string[][] maze) returns string[][] {\n    string[][] result = maze.clone();\n    Cell[] visitOrder = [];\n    boolean[][] visited = [];\n    \n    // Initialize visited array\n    int i = 0;\n    while i < n {\n        boolean[] row = [];\n        int j = 0;\n        while j < m {\n            row.push(false);\n            j += 1;\n        }\n        visited.push(row);\n        i += 1;\n    }\n    \n    // Find first empty cell to start DFS\n    int startRow = -1;\n    int startCol = -1;\n    i = 0;\n    while i < n && startRow == -1 {\n        int j = 0;\n        while j < m {\n            if maze[i][j] == \".\" {\n                startRow = i;\n                startCol = j;\n                break;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Perform DFS\n    if startRow != -1 {\n        dfs(startRow, startCol, n, m, maze, visited, visitOrder);\n    }\n    \n    // Convert last k cells to walls\n    int totalVisited = visitOrder.length();\n    int startIdx = totalVisited - k;\n    i = startIdx;\n    while i < totalVisited {\n        Cell cell = visitOrder[i];\n        result[cell.row][cell.col] = \"X\";\n        i += 1;\n    }\n    \n    return result;\n}\n\nfunction dfs(int row, int col, int n, int m, string[][] maze, \n             boolean[][] visited, Cell[] visitOrder) {\n    // Check bounds\n    if row < 0 || row >= n || col < 0 || col >= m {\n        return;\n    }\n    \n    // Check if wall or already visited\n    if maze[row][col] == \"#\" || visited[row][col] {\n        return;\n    }\n    \n    // Mark as visited\n    visited[row][col] = true;\n    Cell cell = {row: row, col: col};\n    visitOrder.push(cell);\n    \n    // Explore all 4 directions\n    dfs(row - 1, col, n, m, maze, visited, visitOrder); // up\n    dfs(row + 1, col, n, m, maze, visited, visitOrder); // down\n    dfs(row, col - 1, n, m, maze, visited, visitOrder); // left\n    dfs(row, col + 1, n, m, maze, visited, visitOrder); // right\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string? line = io:readln();\n    if line is () {\n        return error(\"No input provided\");\n    }\n    \n    string[] parts = line.trim().split(\" \");\n    if parts.length() < 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read maze\n    string[][] maze = [];\n    int i = 0;\n    while i < n {\n        string? mazeLine = io:readln();\n        if mazeLine is () {\n            return error(\"Incomplete maze input\");\n        }\n        \n        string[] row = [];\n        int j = 0;\n        while j < m {\n            if j < mazeLine.length() {\n                row.push(mazeLine.substring(j, j + 1));\n            } else {\n                row.push(\".\");\n            }\n            j += 1;\n        }\n        maze.push(row);\n        i += 1;\n    }\n    \n    // Solve the maze\n    string[][] result = solveMaze(n, m, k, maze);\n    \n    // Print result\n    i = 0;\n    while i < n {\n        string rowStr = \"\";\n        int j = 0;\n        while j < m {\n            rowStr += result[i][j];\n            j += 1;\n        }\n        io:println(rowStr);\n        i += 1;\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSimpleMaze() {\n    string[][] maze = [\n        [\"#\", \".\", \".\", \"#\"],\n        [\".\", \".\", \"#\", \".\"],\n        [\"#\", \".\", \".\", \".\"]\n    ];\n    \n    string[][] result = solveMaze(3, 4, 2, maze);\n    \n    // Count X's in result\n    int xCount = 0;\n    int i = 0;\n    while i < 3 {\n        int j = 0;\n        while j < 4 {\n            if result[i][j] == \"X\" {\n                xCount += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    test:assertEquals(xCount, 2, \"Should have exactly 2 X's\");\n}\n\n@test:Config {}\nfunction testNoWallsToAdd() {\n    string[][] maze = [\n        [\".\", \".\", \".\"],\n        [\".\", \"#\", \".\"],\n        [\".\", \".\", \".\"]\n    ];\n    \n    string[][] result = solveMaze(3, 3, 0, maze);\n    \n    // Count X's - should be 0\n    int xCount = 0;\n    int i = 0;\n    while i < 3 {\n        int j = 0;\n        while j < 3 {\n            if result[i][j] == \"X\" {\n                xCount += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    test:assertEquals(xCount, 0, \"Should have no X's when k=0\");\n}\n\n@test:Config {}\nfunction testSingleRow() {\n    string[][] maze = [\n        [\".\", \".\", \".\", \".\"]\n    ];\n    \n    string[][] result = solveMaze(1, 4, 1, maze);\n    \n    int xCount = 0;\n    int j = 0;\n    while j < 4 {\n        if result[0][j] == \"X\" {\n            xCount += 1;\n        }\n        j += 1;\n    }\n    \n    test:assertEquals(xCount, 1, \"Should have exactly 1 X\");\n}\n\n@test:Config {}\nfunction testLargerMaze() {\n    string[][] maze = [\n        [\"#\", \".\", \".\", \".\"],\n        [\"#\", \".\", \"#\", \".\"],\n        [\".\", \"#\", \".\", \".\"],\n        [\".\", \".\", \".\", \"#\"],\n        [\".\", \"#\", \".\", \"#\"]\n    ];\n    \n    string[][] result = solveMaze(5, 4, 5, maze);\n    \n    int xCount = 0;\n    int i = 0;\n    while i < 5 {\n        int j = 0;\n        while j < 4 {\n            if result[i][j] == \"X\" {\n                xCount += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    test:assertEquals(xCount, 5, \"Should have exactly 5 X's\");\n}\n```\n</TESTS>",
      "code": "// Strategy:\n// 1. Read the maze dimensions and k\n// 2. Read the maze grid\n// 3. Find any empty cell to start DFS\n// 4. Perform DFS to visit all empty cells, keeping track of visit order\n// 5. Convert the last k visited cells to 'X'\n// 6. Print the modified maze\n//\n// The key insight: If we do DFS traversal of all connected empty cells,\n// the cells we visit last can be removed without disconnecting the rest,\n// because they are \"leaf\" nodes in our DFS tree.\n\nimport ballerina/io;\n\ntype Cell record {\n    int row;\n    int col;\n};\n\nfunction solveMaze(int n, int m, int k, string[][] maze) returns string[][] {\n    string[][] result = maze.clone();\n    Cell[] visitOrder = [];\n    boolean[][] visited = [];\n    \n    // Initialize visited array\n    int i = 0;\n    while i < n {\n        boolean[] row = [];\n        int j = 0;\n        while j < m {\n            row.push(false);\n            j += 1;\n        }\n        visited.push(row);\n        i += 1;\n    }\n    \n    // Find first empty cell to start DFS\n    int startRow = -1;\n    int startCol = -1;\n    i = 0;\n    while i < n && startRow == -1 {\n        int j = 0;\n        while j < m {\n            if maze[i][j] == \".\" {\n                startRow = i;\n                startCol = j;\n                break;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Perform DFS\n    if startRow != -1 {\n        dfs(startRow, startCol, n, m, maze, visited, visitOrder);\n    }\n    \n    // Convert last k cells to walls\n    int totalVisited = visitOrder.length();\n    int startIdx = totalVisited - k;\n    i = startIdx;\n    while i < totalVisited {\n        Cell cell = visitOrder[i];\n        result[cell.row][cell.col] = \"X\";\n        i += 1;\n    }\n    \n    return result;\n}\n\nfunction dfs(int row, int col, int n, int m, string[][] maze, \n             boolean[][] visited, Cell[] visitOrder) {\n    // Check bounds\n    if row < 0 || row >= n || col < 0 || col >= m {\n        return;\n    }\n    \n    // Check if wall or already visited\n    if maze[row][col] == \"#\" || visited[row][col] {\n        return;\n    }\n    \n    // Mark as visited\n    visited[row][col] = true;\n    Cell cell = {row: row, col: col};\n    visitOrder.push(cell);\n    \n    // Explore all 4 directions\n    dfs(row - 1, col, n, m, maze, visited, visitOrder); // up\n    dfs(row + 1, col, n, m, maze, visited, visitOrder); // down\n    dfs(row, col - 1, n, m, maze, visited, visitOrder); // left\n    dfs(row, col + 1, n, m, maze, visited, visitOrder); // right\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string? line = io:readln();\n    if line is () {\n        return error(\"No input provided\");\n    }\n    \n    string[] parts = line.trim().split(\" \");\n    if parts.length() < 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read maze\n    string[][] maze = [];\n    int i = 0;\n    while i < n {\n        string? mazeLine = io:readln();\n        if mazeLine is () {\n            return error(\"Incomplete maze input\");\n        }\n        \n        string[] row = [];\n        int j = 0;\n        while j < m {\n            if j < mazeLine.length() {\n                row.push(mazeLine.substring(j, j + 1));\n            } else {\n                row.push(\".\");\n            }\n            j += 1;\n        }\n        maze.push(row);\n        i += 1;\n    }\n    \n    // Solve the maze\n    string[][] result = solveMaze(n, m, k, maze);\n    \n    // Print result\n    i = 0;\n    while i < n {\n        string rowStr = \"\";\n        int j = 0;\n        while j < m {\n            rowStr += result[i][j];\n            j += 1;\n        }\n        io:println(rowStr);\n        i += 1;\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(104:34,104:39)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(104:34,104:39)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(104:34,104:39)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:36:54.741654",
      "status": "failed",
      "completion": "I need to fix the compilation error. The issue is that in Ballerina, the string split function is accessed via `regex:split()` from the `ballerina/regex` module, not as a method on string. Let me rewrite the solution with proper string handling.\n\n# Overview\nThis problem requires converting exactly k empty cells ('.') into walls ('X') while maintaining connectivity of remaining empty cells. The approach:\n1. Parse the maze input character by character\n2. Find a starting empty cell and perform DFS traversal\n3. Track visit order during DFS - cells visited last are \"leaves\" in the DFS tree\n4. Convert the last k visited cells to 'X' (they can be removed without breaking connectivity)\n5. Output the modified maze\n\nThe key insight: In DFS traversal, the last k cells visited are safe to remove as they are furthest from the starting point in the DFS tree, so removing them won't disconnect earlier visited cells.\n\n<CODE>\n```ballerina\n// Strategy:\n// 1. Parse input: n (rows), m (cols), k (walls to add)\n// 2. Read the maze grid character by character\n// 3. Perform DFS starting from any empty cell to visit all connected empty cells\n// 4. Track the order of visited cells\n// 5. Convert the last k visited cells to 'X' (these are safe to remove)\n// 6. Output the modified maze\n//\n// Key insight: DFS naturally creates a spanning tree. The cells visited last\n// in DFS are \"leaf\" cells that can be removed without disconnecting the maze.\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Cell record {\n    int row;\n    int col;\n};\n\nfunction solveMaze(int n, int m, int k, string[][] maze) returns string[][] {\n    string[][] result = [];\n    \n    // Deep clone the maze\n    int i = 0;\n    while i < n {\n        string[] row = [];\n        int j = 0;\n        while j < m {\n            row.push(maze[i][j]);\n            j += 1;\n        }\n        result.push(row);\n        i += 1;\n    }\n    \n    Cell[] visitOrder = [];\n    boolean[][] visited = [];\n    \n    // Initialize visited array\n    i = 0;\n    while i < n {\n        boolean[] row = [];\n        int j = 0;\n        while j < m {\n            row.push(false);\n            j += 1;\n        }\n        visited.push(row);\n        i += 1;\n    }\n    \n    // Find first empty cell to start DFS\n    int startRow = -1;\n    int startCol = -1;\n    i = 0;\n    while i < n && startRow == -1 {\n        int j = 0;\n        while j < m {\n            if maze[i][j] == \".\" {\n                startRow = i;\n                startCol = j;\n                break;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Perform DFS\n    if startRow != -1 {\n        dfs(startRow, startCol, n, m, maze, visited, visitOrder);\n    }\n    \n    // Convert last k cells to walls\n    int totalVisited = visitOrder.length();\n    int startIdx = totalVisited - k;\n    i = startIdx;\n    while i < totalVisited {\n        Cell cell = visitOrder[i];\n        result[cell.row][cell.col] = \"X\";\n        i += 1;\n    }\n    \n    return result;\n}\n\nfunction dfs(int row, int col, int n, int m, string[][] maze, \n             boolean[][] visited, Cell[] visitOrder) {\n    // Check bounds\n    if row < 0 || row >= n || col < 0 || col >= m {\n        return;\n    }\n    \n    // Check if wall or already visited\n    if maze[row][col] == \"#\" || visited[row][col] {\n        return;\n    }\n    \n    // Mark as visited\n    visited[row][col] = true;\n    Cell cell = {row: row, col: col};\n    visitOrder.push(cell);\n    \n    // Explore all 4 directions (order matters for consistent results)\n    dfs(row - 1, col, n, m, maze, visited, visitOrder); // up\n    dfs(row + 1, col, n, m, maze, visited, visitOrder); // down\n    dfs(row, col - 1, n, m, maze, visited, visitOrder); // left\n    dfs(row, col + 1, n, m, maze, visited, visitOrder); // right\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string line = io:readln();\n    \n    // Parse the first line using regex:split\n    string[] parts = regex:split(line.trim(), \" \");\n    if parts.length() < 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read maze\n    string[][] maze = [];\n    int i = 0;\n    while i < n {\n        string mazeLine = io:readln();\n        \n        string[] row = [];\n        int j = 0;\n        while j < m {\n            if j < mazeLine.length() {\n                row.push(mazeLine.substring(j, j + 1));\n            } else {\n                row.push(\".\");\n            }\n            j += 1;\n        }\n        maze.push(row);\n        i += 1;\n    }\n    \n    // Solve the maze\n    string[][] result = solveMaze(n, m, k, maze);\n    \n    // Print result\n    i = 0;\n    while i < n {\n        string rowStr = \"\";\n        int j = 0;\n        while j < m {\n            rowStr += result[i][j];\n            j += 1;\n        }\n        io:println(rowStr);\n        i += 1;\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSimpleMaze() {\n    string[][] maze = [\n        [\"#\", \".\", \".\", \"#\"],\n        [\".\", \".\", \"#\", \".\"],\n        [\"#\", \".\", \".\", \".\"]\n    ];\n    \n    string[][] result = solveMaze(3, 4, 2, maze);\n    \n    // Count X's in result\n    int xCount = 0;\n    int i = 0;\n    while i < 3 {\n        int j = 0;\n        while j < 4 {\n            if result[i][j] == \"X\" {\n                xCount += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    test:assertEquals(xCount, 2, \"Should have exactly 2 X's\");\n}\n\n@test:Config {}\nfunction testNoWallsToAdd() {\n    string[][] maze = [\n        [\".\", \".\", \".\"],\n        [\".\", \"#\", \".\"],\n        [\".\", \".\", \".\"]\n    ];\n    \n    string[][] result = solveMaze(3, 3, 0, maze);\n    \n    // Count X's - should be 0\n    int xCount = 0;\n    int i = 0;\n    while i < 3 {\n        int j = 0;\n        while j < 3 {\n            if result[i][j] == \"X\" {\n                xCount += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    test:assertEquals(xCount, 0, \"Should have no X's when k=0\");\n}\n\n@test:Config {}\nfunction testSingleRow() {\n    string[][] maze = [\n        [\".\", \".\", \".\", \".\"]\n    ];\n    \n    string[][] result = solveMaze(1, 4, 1, maze);\n    \n    int xCount = 0;\n    int j = 0;\n    while j < 4 {\n        if result[0][j] == \"X\" {\n            xCount += 1;\n        }\n        j += 1;\n    }\n    \n    test:assertEquals(xCount, 1, \"Should have exactly 1 X\");\n}\n\n@test:Config {}\nfunction testLargerMaze() {\n    string[][] maze = [\n        [\"#\", \".\", \".\", \".\"],\n        [\"#\", \".\", \"#\", \".\"],\n        [\".\", \"#\", \".\", \".\"],\n        [\".\", \".\", \".\", \"#\"],\n        [\".\", \"#\", \".\", \"#\"]\n    ];\n    \n    string[][] result = solveMaze(5, 4, 5, maze);\n    \n    int xCount = 0;\n    int i = 0;\n    while i < 5 {\n        int j = 0;\n        while j < 4 {\n            if result[i][j] == \"X\" {\n                xCount += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    test:assertEquals(xCount, 5, \"Should have exactly 5 X's\");\n}\n```\n</TESTS>",
      "code": "// Strategy:\n// 1. Parse input: n (rows), m (cols), k (walls to add)\n// 2. Read the maze grid character by character\n// 3. Perform DFS starting from any empty cell to visit all connected empty cells\n// 4. Track the order of visited cells\n// 5. Convert the last k visited cells to 'X' (these are safe to remove)\n// 6. Output the modified maze\n//\n// Key insight: DFS naturally creates a spanning tree. The cells visited last\n// in DFS are \"leaf\" cells that can be removed without disconnecting the maze.\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Cell record {\n    int row;\n    int col;\n};\n\nfunction solveMaze(int n, int m, int k, string[][] maze) returns string[][] {\n    string[][] result = [];\n    \n    // Deep clone the maze\n    int i = 0;\n    while i < n {\n        string[] row = [];\n        int j = 0;\n        while j < m {\n            row.push(maze[i][j]);\n            j += 1;\n        }\n        result.push(row);\n        i += 1;\n    }\n    \n    Cell[] visitOrder = [];\n    boolean[][] visited = [];\n    \n    // Initialize visited array\n    i = 0;\n    while i < n {\n        boolean[] row = [];\n        int j = 0;\n        while j < m {\n            row.push(false);\n            j += 1;\n        }\n        visited.push(row);\n        i += 1;\n    }\n    \n    // Find first empty cell to start DFS\n    int startRow = -1;\n    int startCol = -1;\n    i = 0;\n    while i < n && startRow == -1 {\n        int j = 0;\n        while j < m {\n            if maze[i][j] == \".\" {\n                startRow = i;\n                startCol = j;\n                break;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    // Perform DFS\n    if startRow != -1 {\n        dfs(startRow, startCol, n, m, maze, visited, visitOrder);\n    }\n    \n    // Convert last k cells to walls\n    int totalVisited = visitOrder.length();\n    int startIdx = totalVisited - k;\n    i = startIdx;\n    while i < totalVisited {\n        Cell cell = visitOrder[i];\n        result[cell.row][cell.col] = \"X\";\n        i += 1;\n    }\n    \n    return result;\n}\n\nfunction dfs(int row, int col, int n, int m, string[][] maze, \n             boolean[][] visited, Cell[] visitOrder) {\n    // Check bounds\n    if row < 0 || row >= n || col < 0 || col >= m {\n        return;\n    }\n    \n    // Check if wall or already visited\n    if maze[row][col] == \"#\" || visited[row][col] {\n        return;\n    }\n    \n    // Mark as visited\n    visited[row][col] = true;\n    Cell cell = {row: row, col: col};\n    visitOrder.push(cell);\n    \n    // Explore all 4 directions (order matters for consistent results)\n    dfs(row - 1, col, n, m, maze, visited, visitOrder); // up\n    dfs(row + 1, col, n, m, maze, visited, visitOrder); // down\n    dfs(row, col - 1, n, m, maze, visited, visitOrder); // left\n    dfs(row, col + 1, n, m, maze, visited, visitOrder); // right\n}\n\npublic function main() returns error? {\n    // Read first line: n m k\n    string line = io:readln();\n    \n    // Parse the first line using regex:split\n    string[] parts = regex:split(line.trim(), \" \");\n    if parts.length() < 3 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read maze\n    string[][] maze = [];\n    int i = 0;\n    while i < n {\n        string mazeLine = io:readln();\n        \n        string[] row = [];\n        int j = 0;\n        while j < m {\n            if j < mazeLine.length() {\n                row.push(mazeLine.substring(j, j + 1));\n            } else {\n                row.push(\".\");\n            }\n            j += 1;\n        }\n        maze.push(row);\n        i += 1;\n    }\n    \n    // Solve the maze\n    string[][] result = solveMaze(n, m, k, maze);\n    \n    // Print result\n    i = 0;\n    while i < n {\n        string rowStr = \"\";\n        int j = 0;\n        while j < m {\n            rowStr += result[i][j];\n            j += 1;\n        }\n        io:println(rowStr);\n        i += 1;\n    }\n    \n    return;\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n",
          "expected_output": "#XXX\n#X#.\nX#..\n...#\n.#.#\n",
          "actual_output": "#...\n#.#.\nX#..\nXX.#\nX#X#\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T02:37:31.839637"
}