{
  "entry_id": "problem_0227",
  "problem_index": 227,
  "prompt": "Title: Lucky Numbers\n\nTime Limit: 2 seconds\n\nMemory Limit: 256 megabytes\n\nProblem Description:\nPetya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nLucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.\n\nOne day Petya came across a positive integer *n*. Help him to find the least super lucky number which is not less than *n*.\n\nInput Specification:\nThe only line contains a positive integer *n* (1<=≤<=*n*<=≤<=10100000). This number doesn't have leading zeroes.\n\nOutput Specification:\nOutput the least super lucky number that is more than or equal to *n*.\n\nDemo Input:\n['4500\\n', '47\\n']\n\nDemo Output:\n['4747\\n', '47\\n']\n\nNote:\nnone",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem requires finding the smallest \"super lucky\" number (containing only digits 4 and 7, with equal counts of each) that is greater than or equal to a given number n. The approach is to:\n1. Generate super lucky numbers of increasing even lengths (since we need equal 4s and 7s)\n2. For a given length, try to construct the smallest super lucky number >= n\n3. Use a strategy of trying to match prefixes of n while maintaining the super lucky property\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Super lucky numbers must have even length (equal 4s and 7s)\n// 2. Start with the length of n (rounded up to next even number)\n// 3. Try to build the smallest super lucky number >= n by:\n//    - Attempting to match n's prefix while keeping 4/7 balance\n//    - If we can't match, try the next valid configuration\n// 4. If no valid number exists for current length, try next even length\n// 5. Use recursive backtracking to generate candidates\n\nimport ballerina/io;\n\n// Check if a string contains only 4s and 7s with equal counts\nfunction isSuperLucky(string num) returns boolean {\n    int count4 = 0;\n    int count7 = 0;\n    \n    foreach int i in 0 ..< num.length() {\n        string:Char ch = num[i];\n        if ch == \"4\" {\n            count4 += 1;\n        } else if ch == \"7\" {\n            count7 += 1;\n        } else {\n            return false;\n        }\n    }\n    \n    return count4 == count7 && count4 > 0;\n}\n\n// Compare two numeric strings\nfunction compareNumericStrings(string a, string b) returns int {\n    if a.length() != b.length() {\n        return a.length() < b.length() ? -1 : 1;\n    }\n    \n    foreach int i in 0 ..< a.length() {\n        if a[i] < b[i] {\n            return -1;\n        } else if a[i] > b[i] {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n// Build smallest super lucky number of given length >= target\nfunction buildSuperLucky(string target, int length, string current, int count4, int count7) returns string? {\n    int maxCount = length / 2;\n    \n    // Base case: built complete number\n    if current.length() == length {\n        if count4 == maxCount && count7 == maxCount {\n            if compareNumericStrings(current, target) >= 0 {\n                return current;\n            }\n        }\n        return ();\n    }\n    \n    // Pruning: if we can't possibly balance, return\n    int remaining = length - current.length();\n    if count4 > maxCount || count7 > maxCount {\n        return ();\n    }\n    if remaining < (maxCount - count4) || remaining < (maxCount - count7) {\n        return ();\n    }\n    \n    // Try adding '4' first, then '7'\n    if count4 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"4\", count4 + 1, count7);\n        if result is string {\n            return result;\n        }\n    }\n    \n    if count7 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"7\", count4, count7 + 1);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return ();\n}\n\nfunction findLeastSuperLucky(string n) returns string|error {\n    int startLen = n.length();\n    \n    // Super lucky numbers must have even length\n    if startLen % 2 == 1 {\n        startLen += 1;\n    }\n    \n    // Try increasing even lengths\n    foreach int len in startLen ... startLen + 10 {\n        if len % 2 == 1 {\n            continue;\n        }\n        \n        string? result = buildSuperLucky(n, len, \"\", 0, 0);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return error(\"Could not find super lucky number\");\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string n = input_line.trim();\n        \n        // Validate input contains only digits\n        foreach int i in 0 ..< n.length() {\n            string:Char ch = n[i];\n            if ch < \"0\" || ch > \"9\" {\n                io:println(\"Invalid input: must be a positive integer\");\n                return;\n            }\n        }\n        \n        if n.length() == 0 || n == \"0\" {\n            io:println(\"Invalid input: must be a positive integer\");\n            return;\n        }\n        \n        string|error result = findLeastSuperLucky(n);\n        \n        if result is string {\n            io:println(result);\n        } else {\n            io:println(\"Error: \" + result.message());\n        }\n    } else {\n        io:println(\"No input provided\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSuperLucky47() {\n    string|error result = findLeastSuperLucky(\"47\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"47\");\n    }\n}\n\n@test:Config {}\nfunction testSuperLucky4500() {\n    string|error result = findLeastSuperLucky(\"4500\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"4747\");\n    }\n}\n\n@test:Config {}\nfunction testSuperLucky1() {\n    string|error result = findLeastSuperLucky(\"1\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"47\");\n    }\n}\n\n@test:Config {}\nfunction testSuperLucky4() {\n    string|error result = findLeastSuperLucky(\"4\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"47\");\n    }\n}\n\n@test:Config {}\nfunction testIsSuperLuckyValid() {\n    test:assertTrue(isSuperLucky(\"47\"));\n    test:assertTrue(isSuperLucky(\"7744\"));\n    test:assertTrue(isSuperLucky(\"474477\"));\n}\n\n@test:Config {}\nfunction testIsSuperLuckyInvalid() {\n    test:assertFalse(isSuperLucky(\"4\"));\n    test:assertFalse(isSuperLucky(\"744\"));\n    test:assertFalse(isSuperLucky(\"467\"));\n}\n\n@test:Config {}\nfunction testCompareNumericStrings() {\n    test:assertEquals(compareNumericStrings(\"47\", \"47\"), 0);\n    test:assertEquals(compareNumericStrings(\"47\", \"48\"), -1);\n    test:assertEquals(compareNumericStrings(\"48\", \"47\"), 1);\n    test:assertEquals(compareNumericStrings(\"100\", \"99\"), 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Super lucky numbers must have even length (equal 4s and 7s)\n// 2. Start with the length of n (rounded up to next even number)\n// 3. Try to build the smallest super lucky number >= n by:\n//    - Attempting to match n's prefix while keeping 4/7 balance\n//    - If we can't match, try the next valid configuration\n// 4. If no valid number exists for current length, try next even length\n// 5. Use recursive backtracking to generate candidates\n\nimport ballerina/io;\n\n// Check if a string contains only 4s and 7s with equal counts\nfunction isSuperLucky(string num) returns boolean {\n    int count4 = 0;\n    int count7 = 0;\n    \n    foreach int i in 0 ..< num.length() {\n        string:Char ch = num[i];\n        if ch == \"4\" {\n            count4 += 1;\n        } else if ch == \"7\" {\n            count7 += 1;\n        } else {\n            return false;\n        }\n    }\n    \n    return count4 == count7 && count4 > 0;\n}\n\n// Compare two numeric strings\nfunction compareNumericStrings(string a, string b) returns int {\n    if a.length() != b.length() {\n        return a.length() < b.length() ? -1 : 1;\n    }\n    \n    foreach int i in 0 ..< a.length() {\n        if a[i] < b[i] {\n            return -1;\n        } else if a[i] > b[i] {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n// Build smallest super lucky number of given length >= target\nfunction buildSuperLucky(string target, int length, string current, int count4, int count7) returns string? {\n    int maxCount = length / 2;\n    \n    // Base case: built complete number\n    if current.length() == length {\n        if count4 == maxCount && count7 == maxCount {\n            if compareNumericStrings(current, target) >= 0 {\n                return current;\n            }\n        }\n        return ();\n    }\n    \n    // Pruning: if we can't possibly balance, return\n    int remaining = length - current.length();\n    if count4 > maxCount || count7 > maxCount {\n        return ();\n    }\n    if remaining < (maxCount - count4) || remaining < (maxCount - count7) {\n        return ();\n    }\n    \n    // Try adding '4' first, then '7'\n    if count4 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"4\", count4 + 1, count7);\n        if result is string {\n            return result;\n        }\n    }\n    \n    if count7 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"7\", count4, count7 + 1);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return ();\n}\n\nfunction findLeastSuperLucky(string n) returns string|error {\n    int startLen = n.length();\n    \n    // Super lucky numbers must have even length\n    if startLen % 2 == 1 {\n        startLen += 1;\n    }\n    \n    // Try increasing even lengths\n    foreach int len in startLen ... startLen + 10 {\n        if len % 2 == 1 {\n            continue;\n        }\n        \n        string? result = buildSuperLucky(n, len, \"\", 0, 0);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return error(\"Could not find super lucky number\");\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string n = input_line.trim();\n        \n        // Validate input contains only digits\n        foreach int i in 0 ..< n.length() {\n            string:Char ch = n[i];\n            if ch < \"0\" || ch > \"9\" {\n                io:println(\"Invalid input: must be a positive integer\");\n                return;\n            }\n        }\n        \n        if n.length() == 0 || n == \"0\" {\n            io:println(\"Invalid input: must be a positive integer\");\n            return;\n        }\n        \n        string|error result = findLeastSuperLucky(n);\n        \n        if result is string {\n            io:println(result);\n        } else {\n            io:println(\"Error: \" + result.message());\n        }\n    } else {\n        io:println(\"No input provided\");\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:11:02.256669",
      "status": "success",
      "completion": "# Overview\nThis problem requires finding the smallest \"super lucky\" number (containing only digits 4 and 7, with equal counts of each) that is greater than or equal to a given number n. The approach is to:\n1. Generate super lucky numbers of increasing even lengths (since we need equal 4s and 7s)\n2. For a given length, try to construct the smallest super lucky number >= n\n3. Use a strategy of trying to match prefixes of n while maintaining the super lucky property\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Super lucky numbers must have even length (equal 4s and 7s)\n// 2. Start with the length of n (rounded up to next even number)\n// 3. Try to build the smallest super lucky number >= n by:\n//    - Attempting to match n's prefix while keeping 4/7 balance\n//    - If we can't match, try the next valid configuration\n// 4. If no valid number exists for current length, try next even length\n// 5. Use recursive backtracking to generate candidates\n\nimport ballerina/io;\n\n// Check if a string contains only 4s and 7s with equal counts\nfunction isSuperLucky(string num) returns boolean {\n    int count4 = 0;\n    int count7 = 0;\n    \n    foreach int i in 0 ..< num.length() {\n        string:Char ch = num[i];\n        if ch == \"4\" {\n            count4 += 1;\n        } else if ch == \"7\" {\n            count7 += 1;\n        } else {\n            return false;\n        }\n    }\n    \n    return count4 == count7 && count4 > 0;\n}\n\n// Compare two numeric strings\nfunction compareNumericStrings(string a, string b) returns int {\n    if a.length() != b.length() {\n        return a.length() < b.length() ? -1 : 1;\n    }\n    \n    foreach int i in 0 ..< a.length() {\n        if a[i] < b[i] {\n            return -1;\n        } else if a[i] > b[i] {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n// Build smallest super lucky number of given length >= target\nfunction buildSuperLucky(string target, int length, string current, int count4, int count7) returns string? {\n    int maxCount = length / 2;\n    \n    // Base case: built complete number\n    if current.length() == length {\n        if count4 == maxCount && count7 == maxCount {\n            if compareNumericStrings(current, target) >= 0 {\n                return current;\n            }\n        }\n        return ();\n    }\n    \n    // Pruning: if we can't possibly balance, return\n    int remaining = length - current.length();\n    if count4 > maxCount || count7 > maxCount {\n        return ();\n    }\n    if remaining < (maxCount - count4) || remaining < (maxCount - count7) {\n        return ();\n    }\n    \n    // Try adding '4' first, then '7'\n    if count4 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"4\", count4 + 1, count7);\n        if result is string {\n            return result;\n        }\n    }\n    \n    if count7 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"7\", count4, count7 + 1);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return ();\n}\n\nfunction findLeastSuperLucky(string n) returns string|error {\n    int startLen = n.length();\n    \n    // Super lucky numbers must have even length\n    if startLen % 2 == 1 {\n        startLen += 1;\n    }\n    \n    // Try increasing even lengths\n    foreach int len in startLen ... startLen + 10 {\n        if len % 2 == 1 {\n            continue;\n        }\n        \n        string? result = buildSuperLucky(n, len, \"\", 0, 0);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return error(\"Could not find super lucky number\");\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string n = input_line.trim();\n        \n        // Validate input contains only digits\n        foreach int i in 0 ..< n.length() {\n            string:Char ch = n[i];\n            if ch < \"0\" || ch > \"9\" {\n                io:println(\"Invalid input: must be a positive integer\");\n                return;\n            }\n        }\n        \n        if n.length() == 0 || n == \"0\" {\n            io:println(\"Invalid input: must be a positive integer\");\n            return;\n        }\n        \n        string|error result = findLeastSuperLucky(n);\n        \n        if result is string {\n            io:println(result);\n        } else {\n            io:println(\"Error: \" + result.message());\n        }\n    } else {\n        io:println(\"No input provided\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSuperLucky47() {\n    string|error result = findLeastSuperLucky(\"47\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"47\");\n    }\n}\n\n@test:Config {}\nfunction testSuperLucky4500() {\n    string|error result = findLeastSuperLucky(\"4500\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"4747\");\n    }\n}\n\n@test:Config {}\nfunction testSuperLucky1() {\n    string|error result = findLeastSuperLucky(\"1\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"47\");\n    }\n}\n\n@test:Config {}\nfunction testSuperLucky4() {\n    string|error result = findLeastSuperLucky(\"4\");\n    test:assertTrue(result is string);\n    if result is string {\n        test:assertEquals(result, \"47\");\n    }\n}\n\n@test:Config {}\nfunction testIsSuperLuckyValid() {\n    test:assertTrue(isSuperLucky(\"47\"));\n    test:assertTrue(isSuperLucky(\"7744\"));\n    test:assertTrue(isSuperLucky(\"474477\"));\n}\n\n@test:Config {}\nfunction testIsSuperLuckyInvalid() {\n    test:assertFalse(isSuperLucky(\"4\"));\n    test:assertFalse(isSuperLucky(\"744\"));\n    test:assertFalse(isSuperLucky(\"467\"));\n}\n\n@test:Config {}\nfunction testCompareNumericStrings() {\n    test:assertEquals(compareNumericStrings(\"47\", \"47\"), 0);\n    test:assertEquals(compareNumericStrings(\"47\", \"48\"), -1);\n    test:assertEquals(compareNumericStrings(\"48\", \"47\"), 1);\n    test:assertEquals(compareNumericStrings(\"100\", \"99\"), 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Super lucky numbers must have even length (equal 4s and 7s)\n// 2. Start with the length of n (rounded up to next even number)\n// 3. Try to build the smallest super lucky number >= n by:\n//    - Attempting to match n's prefix while keeping 4/7 balance\n//    - If we can't match, try the next valid configuration\n// 4. If no valid number exists for current length, try next even length\n// 5. Use recursive backtracking to generate candidates\n\nimport ballerina/io;\n\n// Check if a string contains only 4s and 7s with equal counts\nfunction isSuperLucky(string num) returns boolean {\n    int count4 = 0;\n    int count7 = 0;\n    \n    foreach int i in 0 ..< num.length() {\n        string:Char ch = num[i];\n        if ch == \"4\" {\n            count4 += 1;\n        } else if ch == \"7\" {\n            count7 += 1;\n        } else {\n            return false;\n        }\n    }\n    \n    return count4 == count7 && count4 > 0;\n}\n\n// Compare two numeric strings\nfunction compareNumericStrings(string a, string b) returns int {\n    if a.length() != b.length() {\n        return a.length() < b.length() ? -1 : 1;\n    }\n    \n    foreach int i in 0 ..< a.length() {\n        if a[i] < b[i] {\n            return -1;\n        } else if a[i] > b[i] {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\n// Build smallest super lucky number of given length >= target\nfunction buildSuperLucky(string target, int length, string current, int count4, int count7) returns string? {\n    int maxCount = length / 2;\n    \n    // Base case: built complete number\n    if current.length() == length {\n        if count4 == maxCount && count7 == maxCount {\n            if compareNumericStrings(current, target) >= 0 {\n                return current;\n            }\n        }\n        return ();\n    }\n    \n    // Pruning: if we can't possibly balance, return\n    int remaining = length - current.length();\n    if count4 > maxCount || count7 > maxCount {\n        return ();\n    }\n    if remaining < (maxCount - count4) || remaining < (maxCount - count7) {\n        return ();\n    }\n    \n    // Try adding '4' first, then '7'\n    if count4 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"4\", count4 + 1, count7);\n        if result is string {\n            return result;\n        }\n    }\n    \n    if count7 < maxCount {\n        string? result = buildSuperLucky(target, length, current + \"7\", count4, count7 + 1);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return ();\n}\n\nfunction findLeastSuperLucky(string n) returns string|error {\n    int startLen = n.length();\n    \n    // Super lucky numbers must have even length\n    if startLen % 2 == 1 {\n        startLen += 1;\n    }\n    \n    // Try increasing even lengths\n    foreach int len in startLen ... startLen + 10 {\n        if len % 2 == 1 {\n            continue;\n        }\n        \n        string? result = buildSuperLucky(n, len, \"\", 0, 0);\n        if result is string {\n            return result;\n        }\n    }\n    \n    return error(\"Could not find super lucky number\");\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string n = input_line.trim();\n        \n        // Validate input contains only digits\n        foreach int i in 0 ..< n.length() {\n            string:Char ch = n[i];\n            if ch < \"0\" || ch > \"9\" {\n                io:println(\"Invalid input: must be a positive integer\");\n                return;\n            }\n        }\n        \n        if n.length() == 0 || n == \"0\" {\n            io:println(\"Invalid input: must be a positive integer\");\n            return;\n        }\n        \n        string|error result = findLeastSuperLucky(n);\n        \n        if result is string {\n            io:println(result);\n        } else {\n            io:println(\"Error: \" + result.message());\n        }\n    } else {\n        io:println(\"No input provided\");\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T04:11:39.792068"
}