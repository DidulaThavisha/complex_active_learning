{
  "entry_id": "problem_0153",
  "problem_index": 153,
  "prompt": "Title: Inversions problem\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou are given a permutation of *n* numbers *p*1,<=*p*2,<=...,<=*p**n*. We perform *k* operations of the following type: choose uniformly at random two indices *l* and *r* (*l*<=≤<=*r*) and reverse the order of the elements *p**l*,<=*p**l*<=+<=1,<=...,<=*p**r*. Your task is to find the expected value of the number of inversions in the resulting permutation.\n\nInput Specification:\nThe first line of input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=109). The next line contains *n* integers *p*1,<=*p*2,<=...,<=*p**n* — the given permutation. All *p**i* are different and in range from 1 to *n*.\n\nThe problem consists of three subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.\n -  In subproblem G1 (3 points), the constraints 1<=≤<=*n*<=≤<=6, 1<=≤<=*k*<=≤<=4 will hold. -  In subproblem G2 (5 points), the constraints 1<=≤<=*n*<=≤<=30, 1<=≤<=*k*<=≤<=200 will hold. -  In subproblem G3 (16 points), the constraints 1<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=109 will hold.\n\nOutput Specification:\nOutput the answer with absolute or relative error no more than 1*e*<=-<=9.\n\nDemo Input:\n['3 1\\n1 2 3\\n', '3 4\\n1 3 2\\n']\n\nDemo Output:\n['0.833333333333333\\n', '1.458333333333334\\n']\n\nNote:\nConsider the first sample test. We will randomly pick an interval of the permutation (1, 2, 3) (which has no inversions) and reverse the order of its elements. With probability <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/eb946338365d9781f7d2e9ec692c26702d0ae3a7.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/>, the interval will consist of a single element and the permutation will not be altered. With probability <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/a063853bdfd761520e06382373fe270b6078994b.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> we will inverse the first two elements' order and obtain the permutation (2, 1, 3) which has one inversion. With the same probability we might pick the interval consisting of the last two elements which will lead to the permutation (1, 3, 2) with one inversion. Finally, with probability <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/a063853bdfd761520e06382373fe270b6078994b.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> the randomly picked interval will contain all elements, leading to the permutation (3, 2, 1) with 3 inversions. Hence, the expected number of inversions is equal to <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/cc9273ddc69be58e22251bdf070c83670617a9a2.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/>.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:39:51.869858",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to find the expected number of inversions after performing k random reverse operations on a permutation. The key insight is that after many operations, the distribution converges to a steady state. We need to calculate the probability that each pair (i,j) where i<j forms an inversion after k operations.\n\nThe approach:\n1. For each pair of positions (i,j) where i<j, calculate the probability that element at position i is greater than element at position j after k operations\n2. A reverse operation affects a pair (i,j) only if both i and j are within the selected range [l,r]\n3. The probability a specific range [l,r] is chosen = 1 / (n*(n+1)/2)\n4. For large k, the system converges to a steady state where each pair has probability close to 0.5 of being inverted\n5. We can use matrix exponentiation or iterative simulation to track probabilities\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to track the probability that each pair of positions forms an inversion\n// 2. For each pair (i,j) where i<j, we track P(arr[i] > arr[j])\n// 3. A reverse operation on range [l,r] flips the inversion status of pairs within that range\n// 4. We need to compute the expected inversions after k operations\n// \n// Key observation: For a pair at positions (i,j) where i<j:\n// - If a reversal includes both i and j, their relative order flips\n// - Probability of selecting a range that includes both i and j = number of valid (l,r) / total ranges\n// - Total ranges = n*(n+1)/2\n// - Valid ranges for (i,j): l <= i and r >= j, so (i+1) * (n-j+1) ranges\n//\n// After one operation, P_new(inversion) = P_old * (1 - p_flip) + (1 - P_old) * p_flip\n// Where p_flip is probability that the pair gets flipped\n\nimport ballerina/io;\n\n// Calculate number of inversions in current permutation\nfunction countInversions(int[] arr) returns int {\n    int count = 0;\n    int n = arr.length();\n    foreach int i in 0 ..< n {\n        foreach int j in i + 1 ..< n {\n            if arr[i] > arr[j] {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n\n// Calculate expected inversions after k operations\nfunction expectedInversions(int n, int k, int[] perm) returns float {\n    // Total number of possible ranges\n    float totalRanges = <float>(n * (n + 1) / 2);\n    \n    // Initialize probability matrix - prob[i][j] = probability that position i has larger value than position j\n    float[][] prob = [];\n    foreach int i in 0 ..< n {\n        float[] row = [];\n        foreach int j in 0 ..< n {\n            if i < j {\n                // Check initial inversion status\n                if perm[i] > perm[j] {\n                    row.push(1.0);\n                } else {\n                    row.push(0.0);\n                }\n            } else {\n                row.push(0.0);\n            }\n        }\n        prob.push(row);\n    }\n    \n    // Perform k iterations\n    foreach int _ in 0 ..< k {\n        float[][] newProb = [];\n        \n        foreach int i in 0 ..< n {\n            float[] row = [];\n            foreach int j in 0 ..< n {\n                if i < j {\n                    // Calculate probability that range includes both i and j\n                    // l must be <= i (0 to i), r must be >= j (j to n-1)\n                    // Number of valid (l,r) pairs = (i+1) * (n-j)\n                    float validRanges = <float>((i + 1) * (n - j));\n                    float flipProb = validRanges / totalRanges;\n                    \n                    // Update probability: if flipped, inversion status changes\n                    float oldProb = prob[i][j];\n                    float updated = oldProb * (1.0 - flipProb) + (1.0 - oldProb) * flipProb;\n                    row.push(updated);\n                } else {\n                    row.push(0.0);\n                }\n            }\n            newProb.push(row);\n        }\n        \n        prob = newProb;\n    }\n    \n    // Sum up all probabilities\n    float expected = 0.0;\n    foreach int i in 0 ..< n {\n        foreach int j in i + 1 ..< n {\n            expected += prob[i][j];\n        }\n    }\n    \n    return expected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: permutation\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid permutation length\");\n    }\n    \n    int[] perm = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        perm.push(val);\n    }\n    \n    float result = expectedInversions(n, k, perm);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] perm = [1, 2, 3];\n    float result = expectedInversions(3, 1, perm);\n    test:assertTrue((result - 0.833333333333333).abs() < 1e-6, \"Expected ~0.8333 for example 1\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] perm = [1, 3, 2];\n    float result = expectedInversions(3, 4, perm);\n    test:assertTrue((result - 1.458333333333334).abs() < 1e-6, \"Expected ~1.4583 for example 2\");\n}\n\n@test:Config {}\nfunction testNoOperations() {\n    int[] perm = [2, 1, 3];\n    float result = expectedInversions(3, 0, perm);\n    test:assertEquals(result, 1.0, \"No operations should keep initial inversions\");\n}\n\n@test:Config {}\nfunction testSortedArray() {\n    int[] perm = [1, 2, 3, 4];\n    float result = expectedInversions(4, 0, perm);\n    test:assertEquals(result, 0.0, \"Sorted array should have 0 inversions\");\n}\n\n@test:Config {}\nfunction testReversedArray() {\n    int[] perm = [3, 2, 1];\n    float result = expectedInversions(3, 0, perm);\n    test:assertEquals(result, 3.0, \"Reversed array should have n*(n-1)/2 inversions\");\n}\n\n@test:Config {}\nfunction testSingleElement() {\n    int[] perm = [1];\n    float result = expectedInversions(1, 5, perm);\n    test:assertEquals(result, 0.0, \"Single element has no inversions\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need to track the probability that each pair of positions forms an inversion\n// 2. For each pair (i,j) where i<j, we track P(arr[i] > arr[j])\n// 3. A reverse operation on range [l,r] flips the inversion status of pairs within that range\n// 4. We need to compute the expected inversions after k operations\n// \n// Key observation: For a pair at positions (i,j) where i<j:\n// - If a reversal includes both i and j, their relative order flips\n// - Probability of selecting a range that includes both i and j = number of valid (l,r) / total ranges\n// - Total ranges = n*(n+1)/2\n// - Valid ranges for (i,j): l <= i and r >= j, so (i+1) * (n-j+1) ranges\n//\n// After one operation, P_new(inversion) = P_old * (1 - p_flip) + (1 - P_old) * p_flip\n// Where p_flip is probability that the pair gets flipped\n\nimport ballerina/io;\n\n// Calculate number of inversions in current permutation\nfunction countInversions(int[] arr) returns int {\n    int count = 0;\n    int n = arr.length();\n    foreach int i in 0 ..< n {\n        foreach int j in i + 1 ..< n {\n            if arr[i] > arr[j] {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n\n// Calculate expected inversions after k operations\nfunction expectedInversions(int n, int k, int[] perm) returns float {\n    // Total number of possible ranges\n    float totalRanges = <float>(n * (n + 1) / 2);\n    \n    // Initialize probability matrix - prob[i][j] = probability that position i has larger value than position j\n    float[][] prob = [];\n    foreach int i in 0 ..< n {\n        float[] row = [];\n        foreach int j in 0 ..< n {\n            if i < j {\n                // Check initial inversion status\n                if perm[i] > perm[j] {\n                    row.push(1.0);\n                } else {\n                    row.push(0.0);\n                }\n            } else {\n                row.push(0.0);\n            }\n        }\n        prob.push(row);\n    }\n    \n    // Perform k iterations\n    foreach int _ in 0 ..< k {\n        float[][] newProb = [];\n        \n        foreach int i in 0 ..< n {\n            float[] row = [];\n            foreach int j in 0 ..< n {\n                if i < j {\n                    // Calculate probability that range includes both i and j\n                    // l must be <= i (0 to i), r must be >= j (j to n-1)\n                    // Number of valid (l,r) pairs = (i+1) * (n-j)\n                    float validRanges = <float>((i + 1) * (n - j));\n                    float flipProb = validRanges / totalRanges;\n                    \n                    // Update probability: if flipped, inversion status changes\n                    float oldProb = prob[i][j];\n                    float updated = oldProb * (1.0 - flipProb) + (1.0 - oldProb) * flipProb;\n                    row.push(updated);\n                } else {\n                    row.push(0.0);\n                }\n            }\n            newProb.push(row);\n        }\n        \n        prob = newProb;\n    }\n    \n    // Sum up all probabilities\n    float expected = 0.0;\n    foreach int i in 0 ..< n {\n        foreach int j in i + 1 ..< n {\n            expected += prob[i][j];\n        }\n    }\n    \n    return expected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: permutation\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid permutation length\");\n    }\n    \n    int[] perm = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        perm.push(val);\n    }\n    \n    float result = expectedInversions(n, k, perm);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(102:36,102:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(116:36,116:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(102:36,102:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(116:36,116:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(102:36,102:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(116:36,116:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:40:25.984844",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to find the expected number of inversions after performing k random reverse operations on a permutation. The key insight is that we track the probability that each pair of positions forms an inversion after k operations.\n\nThe approach:\n1. For each pair of positions (i,j) where i<j, we track the probability that the element at position i is greater than the element at position j\n2. A reverse operation on range [l,r] flips the relative order of elements within that range\n3. For positions i and j where i<j, they get flipped if we choose a range [l,r] where l≤i and r≥j\n4. Number of such ranges = (i+1) × (n-j)\n5. Total possible ranges = n×(n+1)/2\n6. After each operation, we update probabilities based on flip probability\n7. Sum all probabilities to get expected inversions\n\nThe main fix needed is to use `regex:split()` from ballerina/regex module instead of the non-existent `split()` method on strings.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Track probability P[i][j] that position i has a larger value than position j (for i < j)\n// 2. Initially, P[i][j] = 1 if perm[i] > perm[j], else 0\n// 3. For each operation, calculate the probability that pair (i,j) gets flipped\n// 4. Flip probability = (number of ranges containing both i and j) / (total ranges)\n// 5. For i < j: ranges [l,r] where l ≤ i and r ≥ j count = (i+1) × (n-j)\n// 6. Total ranges = n × (n+1) / 2\n// 7. Update: P_new[i][j] = P_old[i][j] × (1 - flip_prob) + (1 - P_old[i][j]) × flip_prob\n// 8. After k operations, sum all P[i][j] to get expected inversions\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate expected inversions after k operations\nfunction expectedInversions(int n, int k, int[] perm) returns float {\n    // Total number of possible ranges [l,r]: for each l, r can be from l to n-1\n    // Total = n + (n-1) + ... + 1 = n*(n+1)/2\n    float totalRanges = <float>(n * (n + 1) / 2);\n    \n    // Initialize probability matrix\n    // prob[i][j] = probability that value at position i > value at position j (for i < j)\n    float[][] prob = [];\n    foreach int i in 0 ..< n {\n        float[] row = [];\n        foreach int j in 0 ..< n {\n            if i < j {\n                // Check initial inversion status\n                if perm[i] > perm[j] {\n                    row.push(1.0);\n                } else {\n                    row.push(0.0);\n                }\n            } else {\n                row.push(0.0);\n            }\n        }\n        prob.push(row);\n    }\n    \n    // Perform k iterations to update probabilities\n    foreach int _ in 0 ..< k {\n        float[][] newProb = [];\n        \n        foreach int i in 0 ..< n {\n            float[] row = [];\n            foreach int j in 0 ..< n {\n                if i < j {\n                    // Calculate number of ranges [l,r] that include both positions i and j\n                    // l can be 0 to i (i+1 choices)\n                    // r can be j to n-1 (n-j choices)\n                    float validRanges = <float>((i + 1) * (n - j));\n                    float flipProb = validRanges / totalRanges;\n                    \n                    // Update probability\n                    // If the pair gets flipped, inversion status changes\n                    float oldProb = prob[i][j];\n                    float updated = oldProb * (1.0 - flipProb) + (1.0 - oldProb) * flipProb;\n                    row.push(updated);\n                } else {\n                    row.push(0.0);\n                }\n            }\n            newProb.push(row);\n        }\n        \n        prob = newProb;\n    }\n    \n    // Sum up all probabilities to get expected number of inversions\n    float expected = 0.0;\n    foreach int i in 0 ..< n {\n        foreach int j in i + 1 ..< n {\n            expected += prob[i][j];\n        }\n    }\n    \n    return expected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Validate input\n    if n < 1 || n > 100 {\n        return error(\"n must be between 1 and 100\");\n    }\n    if k < 1 {\n        return error(\"k must be at least 1\");\n    }\n    \n    // Read second line: permutation\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Invalid permutation length\");\n    }\n    \n    int[] perm = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        if val < 1 || val > n {\n            return error(\"Permutation values must be between 1 and n\");\n        }\n        perm.push(val);\n    }\n    \n    float result = expectedInversions(n, k, perm);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] perm = [1, 2, 3];\n    float result = expectedInversions(3, 1, perm);\n    test:assertTrue((result - 0.833333333333333).abs() < 1e-6, \"Expected ~0.8333 for example 1\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] perm = [1, 3, 2];\n    float result = expectedInversions(3, 4, perm);\n    test:assertTrue((result - 1.458333333333334).abs() < 1e-6, \"Expected ~1.4583 for example 2\");\n}\n\n@test:Config {}\nfunction testNoOperations() {\n    int[] perm = [2, 1, 3];\n    float result = expectedInversions(3, 0, perm);\n    test:assertEquals(result, 1.0, \"No operations should keep initial inversions\");\n}\n\n@test:Config {}\nfunction testSortedArray() {\n    int[] perm = [1, 2, 3, 4];\n    float result = expectedInversions(4, 0, perm);\n    test:assertEquals(result, 0.0, \"Sorted array should have 0 inversions\");\n}\n\n@test:Config {}\nfunction testReversedArray() {\n    int[] perm = [3, 2, 1];\n    float result = expectedInversions(3, 0, perm);\n    test:assertEquals(result, 3.0, \"Reversed array should have n*(n-1)/2 inversions\");\n}\n\n@test:Config {}\nfunction testSingleElement() {\n    int[] perm = [1];\n    float result = expectedInversions(1, 5, perm);\n    test:assertEquals(result, 0.0, \"Single element has no inversions\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Track probability P[i][j] that position i has a larger value than position j (for i < j)\n// 2. Initially, P[i][j] = 1 if perm[i] > perm[j], else 0\n// 3. For each operation, calculate the probability that pair (i,j) gets flipped\n// 4. Flip probability = (number of ranges containing both i and j) / (total ranges)\n// 5. For i < j: ranges [l,r] where l ≤ i and r ≥ j count = (i+1) × (n-j)\n// 6. Total ranges = n × (n+1) / 2\n// 7. Update: P_new[i][j] = P_old[i][j] × (1 - flip_prob) + (1 - P_old[i][j]) × flip_prob\n// 8. After k operations, sum all P[i][j] to get expected inversions\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate expected inversions after k operations\nfunction expectedInversions(int n, int k, int[] perm) returns float {\n    // Total number of possible ranges [l,r]: for each l, r can be from l to n-1\n    // Total = n + (n-1) + ... + 1 = n*(n+1)/2\n    float totalRanges = <float>(n * (n + 1) / 2);\n    \n    // Initialize probability matrix\n    // prob[i][j] = probability that value at position i > value at position j (for i < j)\n    float[][] prob = [];\n    foreach int i in 0 ..< n {\n        float[] row = [];\n        foreach int j in 0 ..< n {\n            if i < j {\n                // Check initial inversion status\n                if perm[i] > perm[j] {\n                    row.push(1.0);\n                } else {\n                    row.push(0.0);\n                }\n            } else {\n                row.push(0.0);\n            }\n        }\n        prob.push(row);\n    }\n    \n    // Perform k iterations to update probabilities\n    foreach int _ in 0 ..< k {\n        float[][] newProb = [];\n        \n        foreach int i in 0 ..< n {\n            float[] row = [];\n            foreach int j in 0 ..< n {\n                if i < j {\n                    // Calculate number of ranges [l,r] that include both positions i and j\n                    // l can be 0 to i (i+1 choices)\n                    // r can be j to n-1 (n-j choices)\n                    float validRanges = <float>((i + 1) * (n - j));\n                    float flipProb = validRanges / totalRanges;\n                    \n                    // Update probability\n                    // If the pair gets flipped, inversion status changes\n                    float oldProb = prob[i][j];\n                    float updated = oldProb * (1.0 - flipProb) + (1.0 - oldProb) * flipProb;\n                    row.push(updated);\n                } else {\n                    row.push(0.0);\n                }\n            }\n            newProb.push(row);\n        }\n        \n        prob = newProb;\n    }\n    \n    // Sum up all probabilities to get expected number of inversions\n    float expected = 0.0;\n    foreach int i in 0 ..< n {\n        foreach int j in i + 1 ..< n {\n            expected += prob[i][j];\n        }\n    }\n    \n    return expected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Validate input\n    if n < 1 || n > 100 {\n        return error(\"n must be between 1 and 100\");\n    }\n    if k < 1 {\n        return error(\"k must be at least 1\");\n    }\n    \n    // Read second line: permutation\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Invalid permutation length\");\n    }\n    \n    int[] perm = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        if val < 1 || val > n {\n            return error(\"Permutation values must be between 1 and n\");\n        }\n        perm.push(val);\n    }\n    \n    float result = expectedInversions(n, k, perm);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "3 1\n1 2 3\n",
          "expected_output": "0.833333333333333\n",
          "actual_output": "0.8333333333333333\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T02:41:00.744261"
}