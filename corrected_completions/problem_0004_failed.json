{
  "entry_id": "problem_0004",
  "problem_index": 4,
  "prompt": "Title: Constellation\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nCat Noku has obtained a map of the night sky. On this map, he found a constellation with *n* stars numbered from 1 to *n*. For each *i*, the *i*-th star is located at coordinates (*x**i*,<=*y**i*). No two stars are located at the same position.\n\nIn the evening Noku is going to take a look at the night sky. He would like to find three distinct stars and form a triangle. The triangle must have positive area. In addition, all other stars must lie strictly outside of this triangle. He is having trouble finding the answer and would like your help. Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions. \n\nIt is guaranteed that there is no line such that all stars lie on that line. It can be proven that if the previous condition is satisfied, there exists a solution to this problem.\n\nInput Specification:\nThe first line of the input contains a single integer *n* (3<=≤<=*n*<=≤<=100<=000).\n\nEach of the next *n* lines contains two integers *x**i* and *y**i* (<=-<=109<=≤<=*x**i*,<=*y**i*<=≤<=109).\n\nIt is guaranteed that no two stars lie at the same point, and there does not exist a line such that all stars lie on that line.\n\nOutput Specification:\nPrint three distinct integers on a single line — the indices of the three points that form a triangle that satisfies the conditions stated in the problem.\n\nIf there are multiple possible answers, you may print any of them.\n\nDemo Input:\n['3\\n0 1\\n1 0\\n1 1\\n', '5\\n0 0\\n0 2\\n2 0\\n2 2\\n1 1\\n']\n\nDemo Output:\n['1 2 3\\n', '1 3 5\\n']\n\nNote:\nIn the first sample, we can print the three indices in any order.\n\nIn the second sample, we have the following picture. \n\nNote that the triangle formed by starts 1, 4 and 3 doesn't satisfy the conditions stated in the problem, as point 5 is not strictly outside of this triangle (it lies on it's border).",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-04T23:58:46.331917",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find three distinct stars that form a triangle with positive area, where all other stars lie strictly outside the triangle. The key insight is that we can use a greedy approach: sort the points by some criteria (like x-coordinate, then y-coordinate) and check small subsets of consecutive points. Since we're guaranteed a solution exists and not all points are collinear, we can try the first three non-collinear points and check if all other points lie outside. If that doesn't work, we can try other combinations from the sorted list.\n\nA simpler approach: Since we're guaranteed a solution exists, we can sort points and try combinations starting from the first few points. For most cases, taking three consecutive points from a sorted order will give us a small triangle that likely doesn't contain other points.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n and n points from input\n// 2. Sort points by x-coordinate first, then y-coordinate\n// 3. Try combinations of 3 points starting from the beginning\n// 4. For each combination, check if it forms a valid triangle (positive area)\n// 5. Check if all other points lie strictly outside this triangle\n// 6. A point is strictly outside if it's not inside and not on the boundary\n// 7. Use cross product to check triangle area and point orientation\n// 8. Return the first valid combination found\n\nimport ballerina/io;\n\ntype Point record {|\n    int x;\n    int y;\n    int index; // 1-based index\n|};\n\n// Calculate twice the signed area of triangle (to avoid floating point)\n// If result is 0, points are collinear\n// If positive, counter-clockwise orientation\n// If negative, clockwise orientation\nfunction crossProduct(Point p1, Point p2, Point p3) returns int {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n// Check if point p is strictly inside triangle formed by a, b, c\nfunction isStrictlyInside(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    // All same sign and non-zero means strictly inside\n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    boolean hasZero = (d1 == 0) || (d2 == 0) || (d3 == 0);\n    \n    // Strictly inside means all same sign and no zeros\n    return !(hasNeg && hasPos) && !hasZero && (hasNeg || hasPos);\n}\n\n// Check if point is on boundary or inside\nfunction isInsideOrOnBoundary(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    \n    return !(hasNeg && hasPos);\n}\n\nfunction findTriangle(Point[] points) returns [int, int, int]|error {\n    int n = points.length();\n    \n    // Try different combinations, starting with first few points\n    foreach int i in 0 ..< n {\n        foreach int j in (i + 1) ..< n {\n            foreach int k in (j + 1) ..< n {\n                Point p1 = points[i];\n                Point p2 = points[j];\n                Point p3 = points[k];\n                \n                // Check if triangle has positive area (not collinear)\n                int area = crossProduct(p1, p2, p3);\n                if area == 0 {\n                    continue; // Collinear points\n                }\n                \n                // Check if all other points are strictly outside\n                boolean valid = true;\n                foreach int m in 0 ..< n {\n                    if m == i || m == j || m == k {\n                        continue;\n                    }\n                    \n                    if isInsideOrOnBoundary(points[m], p1, p2, p3) {\n                        valid = false;\n                        break;\n                    }\n                }\n                \n                if valid {\n                    return [p1.index, p2.index, p3.index];\n                }\n            }\n        }\n    }\n    \n    return error(\"No valid triangle found\");\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line.trim());\n    \n    if n < 3 {\n        return error(\"Need at least 3 points\");\n    }\n    \n    // Read n points\n    Point[] points = [];\n    foreach int i in 0 ..< n {\n        string? pointLine = io:readln();\n        if pointLine is () {\n            return error(\"Failed to read point\");\n        }\n        \n        string[] parts = pointLine.trim().split(\" \");\n        if parts.length() < 2 {\n            return error(\"Invalid point format\");\n        }\n        \n        int x = check 'int:fromString(parts[0].trim());\n        int y = check 'int:fromString(parts[1].trim());\n        \n        points.push({x: x, y: y, index: i + 1});\n    }\n    \n    // Find valid triangle\n    [int, int, int] result = check findTriangle(points);\n    \n    io:println(result[0].toString() + \" \" + result[1].toString() + \" \" + result[2].toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCrossProduct() {\n    Point p1 = {x: 0, y: 0, index: 1};\n    Point p2 = {x: 1, y: 0, index: 2};\n    Point p3 = {x: 0, y: 1, index: 3};\n    \n    int area = crossProduct(p1, p2, p3);\n    test:assertTrue(area != 0, \"Triangle should have non-zero area\");\n    \n    // Collinear points\n    Point p4 = {x: 2, y: 0, index: 4};\n    int area2 = crossProduct(p1, p2, p4);\n    test:assertEquals(area2, 0, \"Collinear points should have zero area\");\n}\n\n@test:Config {}\nfunction testIsStrictlyInside() {\n    Point a = {x: 0, y: 0, index: 1};\n    Point b = {x: 4, y: 0, index: 2};\n    Point c = {x: 0, y: 4, index: 3};\n    \n    Point inside = {x: 1, y: 1, index: 4};\n    test:assertTrue(isStrictlyInside(inside, a, b, c), \"Point should be strictly inside\");\n    \n    Point outside = {x: 5, y: 5, index: 5};\n    test:assertFalse(isStrictlyInside(outside, a, b, c), \"Point should be outside\");\n}\n\n@test:Config {}\nfunction testFindTriangleSimple() returns error? {\n    Point[] points = [\n        {x: 0, y: 1, index: 1},\n        {x: 1, y: 0, index: 2},\n        {x: 1, y: 1, index: 3}\n    ];\n    \n    [int, int, int] result = check findTriangle(points);\n    test:assertTrue(result[0] >= 1 && result[0] <= 3, \"Result should contain valid indices\");\n    test:assertTrue(result[1] >= 1 && result[1] <= 3, \"Result should contain valid indices\");\n    test:assertTrue(result[2] >= 1 && result[2] <= 3, \"Result should contain valid indices\");\n}\n\n@test:Config {}\nfunction testFindTriangleWithExtraPoint() returns error? {\n    Point[] points = [\n        {x: 0, y: 0, index: 1},\n        {x: 0, y: 2, index: 2},\n        {x: 2, y: 0, index: 3},\n        {x: 2, y: 2, index: 4},\n        {x: 1, y: 1, index: 5}\n    ];\n    \n    [int, int, int] result = check findTriangle(points);\n    // The result should be a valid combination where point 5 is outside\n    test:assertTrue(result[0] != result[1] && result[1] != result[2] && result[0] != result[2], \n                    \"Indices should be distinct\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n and n points from input\n// 2. Sort points by x-coordinate first, then y-coordinate\n// 3. Try combinations of 3 points starting from the beginning\n// 4. For each combination, check if it forms a valid triangle (positive area)\n// 5. Check if all other points lie strictly outside this triangle\n// 6. A point is strictly outside if it's not inside and not on the boundary\n// 7. Use cross product to check triangle area and point orientation\n// 8. Return the first valid combination found\n\nimport ballerina/io;\n\ntype Point record {|\n    int x;\n    int y;\n    int index; // 1-based index\n|};\n\n// Calculate twice the signed area of triangle (to avoid floating point)\n// If result is 0, points are collinear\n// If positive, counter-clockwise orientation\n// If negative, clockwise orientation\nfunction crossProduct(Point p1, Point p2, Point p3) returns int {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n// Check if point p is strictly inside triangle formed by a, b, c\nfunction isStrictlyInside(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    // All same sign and non-zero means strictly inside\n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    boolean hasZero = (d1 == 0) || (d2 == 0) || (d3 == 0);\n    \n    // Strictly inside means all same sign and no zeros\n    return !(hasNeg && hasPos) && !hasZero && (hasNeg || hasPos);\n}\n\n// Check if point is on boundary or inside\nfunction isInsideOrOnBoundary(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    \n    return !(hasNeg && hasPos);\n}\n\nfunction findTriangle(Point[] points) returns [int, int, int]|error {\n    int n = points.length();\n    \n    // Try different combinations, starting with first few points\n    foreach int i in 0 ..< n {\n        foreach int j in (i + 1) ..< n {\n            foreach int k in (j + 1) ..< n {\n                Point p1 = points[i];\n                Point p2 = points[j];\n                Point p3 = points[k];\n                \n                // Check if triangle has positive area (not collinear)\n                int area = crossProduct(p1, p2, p3);\n                if area == 0 {\n                    continue; // Collinear points\n                }\n                \n                // Check if all other points are strictly outside\n                boolean valid = true;\n                foreach int m in 0 ..< n {\n                    if m == i || m == j || m == k {\n                        continue;\n                    }\n                    \n                    if isInsideOrOnBoundary(points[m], p1, p2, p3) {\n                        valid = false;\n                        break;\n                    }\n                }\n                \n                if valid {\n                    return [p1.index, p2.index, p3.index];\n                }\n            }\n        }\n    }\n    \n    return error(\"No valid triangle found\");\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line.trim());\n    \n    if n < 3 {\n        return error(\"Need at least 3 points\");\n    }\n    \n    // Read n points\n    Point[] points = [];\n    foreach int i in 0 ..< n {\n        string? pointLine = io:readln();\n        if pointLine is () {\n            return error(\"Failed to read point\");\n        }\n        \n        string[] parts = pointLine.trim().split(\" \");\n        if parts.length() < 2 {\n            return error(\"Invalid point format\");\n        }\n        \n        int x = check 'int:fromString(parts[0].trim());\n        int y = check 'int:fromString(parts[1].trim());\n        \n        points.push({x: x, y: y, index: i + 1});\n    }\n    \n    // Find valid triangle\n    [int, int, int] result = check findTriangle(points);\n    \n    io:println(result[0].toString() + \" \" + result[1].toString() + \" \" + result[2].toString());\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(115:43,115:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(115:43,115:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(115:43,115:48)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-04T23:59:22.388465",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find three distinct stars that form a triangle with positive area, where all other stars lie strictly outside the triangle. The key insight is that if we sort the points and try small combinations, we're likely to find a triangle that doesn't contain other points. Since a solution is guaranteed to exist, we can try combinations systematically.\n\nThe main fix needed is to use `regex:split()` from the `ballerina/regex` module instead of the non-existent `split()` method on strings. We also need to properly handle string splitting with the correct Ballerina syntax.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n and n points from input\n// 2. Try combinations of 3 points to find a valid triangle\n// 3. For each combination, check if it forms a valid triangle (positive area using cross product)\n// 4. Check if all other points lie strictly outside this triangle\n// 5. A point is strictly outside if it's not inside and not on the boundary\n// 6. Use cross product for orientation tests\n// 7. Return the first valid combination found\n// \n// Key fix: Use regex:split() for string splitting instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Point record {|\n    int x;\n    int y;\n    int index; // 1-based index\n|};\n\n// Calculate twice the signed area of triangle using cross product\n// If result is 0, points are collinear\nfunction crossProduct(Point p1, Point p2, Point p3) returns int {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n// Check if point p is strictly inside triangle formed by a, b, c\nfunction isStrictlyInside(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    // All same sign and non-zero means strictly inside\n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    boolean hasZero = (d1 == 0) || (d2 == 0) || (d3 == 0);\n    \n    // Strictly inside means all same sign and no zeros (not on boundary)\n    return !(hasNeg && hasPos) && !hasZero && (hasNeg || hasPos);\n}\n\n// Check if point is on boundary or inside the triangle\nfunction isInsideOrOnBoundary(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    // If all have same sign (or zero), point is inside or on boundary\n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    \n    return !(hasNeg && hasPos);\n}\n\nfunction findTriangle(Point[] points) returns [int, int, int]|error {\n    int n = points.length();\n    \n    // Try different combinations, starting with first few points\n    // This greedy approach works because a solution is guaranteed to exist\n    foreach int i in 0 ..< n {\n        foreach int j in (i + 1) ..< n {\n            foreach int k in (j + 1) ..< n {\n                Point p1 = points[i];\n                Point p2 = points[j];\n                Point p3 = points[k];\n                \n                // Check if triangle has positive area (not collinear)\n                int area = crossProduct(p1, p2, p3);\n                if area == 0 {\n                    continue; // Collinear points, skip\n                }\n                \n                // Check if all other points are strictly outside\n                boolean valid = true;\n                foreach int m in 0 ..< n {\n                    if m == i || m == j || m == k {\n                        continue;\n                    }\n                    \n                    if isInsideOrOnBoundary(points[m], p1, p2, p3) {\n                        valid = false;\n                        break;\n                    }\n                }\n                \n                if valid {\n                    return [p1.index, p2.index, p3.index];\n                }\n            }\n        }\n    }\n    \n    return error(\"No valid triangle found\");\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line.trim());\n    \n    if n < 3 {\n        return error(\"Need at least 3 points\");\n    }\n    \n    // Read n points\n    Point[] points = [];\n    foreach int i in 0 ..< n {\n        string? pointLine = io:readln();\n        if pointLine is () {\n            return error(\"Failed to read point\");\n        }\n        \n        // Use regex:split instead of string.split()\n        string[] parts = regex:split(pointLine.trim(), \" +\");\n        if parts.length() < 2 {\n            return error(\"Invalid point format\");\n        }\n        \n        int x = check 'int:fromString(parts[0].trim());\n        int y = check 'int:fromString(parts[1].trim());\n        \n        points.push({x: x, y: y, index: i + 1});\n    }\n    \n    // Find valid triangle\n    [int, int, int] result = check findTriangle(points);\n    \n    io:println(result[0].toString() + \" \" + result[1].toString() + \" \" + result[2].toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCrossProduct() {\n    Point p1 = {x: 0, y: 0, index: 1};\n    Point p2 = {x: 1, y: 0, index: 2};\n    Point p3 = {x: 0, y: 1, index: 3};\n    \n    int area = crossProduct(p1, p2, p3);\n    test:assertTrue(area != 0, \"Triangle should have non-zero area\");\n    \n    // Collinear points\n    Point p4 = {x: 2, y: 0, index: 4};\n    int area2 = crossProduct(p1, p2, p4);\n    test:assertEquals(area2, 0, \"Collinear points should have zero area\");\n    \n    // Another non-collinear test\n    Point p5 = {x: 1, y: 1, index: 5};\n    int area3 = crossProduct(p1, p2, p5);\n    test:assertTrue(area3 != 0, \"Non-collinear points should have non-zero area\");\n    \n    // Test with negative coordinates\n    Point p6 = {x: -1, y: 0, index: 6};\n    Point p7 = {x: 0, y: -1, index: 7};\n    int area4 = crossProduct(p1, p6, p7);\n    test:assertTrue(area4 != 0, \"Triangle with negative coords should work\");\n}\n\n@test:Config {}\nfunction testIsStrictlyInside() {\n    Point a = {x: 0, y: 0, index: 1};\n    Point b = {x: 4, y: 0, index: 2};\n    Point c = {x: 0, y: 4, index: 3};\n    \n    Point inside = {x: 1, y: 1, index: 4};\n    test:assertTrue(isStrictlyInside(inside, a, b, c), \"Point (1,1) should be strictly inside\");\n    \n    Point outside = {x: 5, y: 5, index: 5};\n    test:assertFalse(isStrictlyInside(outside, a, b, c), \"Point (5,5) should be outside\");\n    \n    // Point on boundary should not be strictly inside\n    Point onBoundary = {x: 2, y: 0, index: 6};\n    test:assertFalse(isStrictlyInside(onBoundary, a, b, c), \"Point on boundary should not be strictly inside\");\n    \n    Point inside2 = {x: 1, y: 2, index: 7};\n    test:assertTrue(isStrictlyInside(inside2, a, b, c), \"Point (1,2) should be strictly inside\");\n}\n\n@test:Config {}\nfunction testFindTriangleSimple() returns error? {\n    Point[] points = [\n        {x: 0, y: 1, index: 1},\n        {x: 1, y: 0, index: 2},\n        {x: 1, y: 1, index: 3}\n    ];\n    \n    [int, int, int] result = check findTriangle(points);\n    test:assertTrue(result[0] >= 1 && result[0] <= 3, \"Result should contain valid indices\");\n    test:assertTrue(result[1] >= 1 && result[1] <= 3, \"Result should contain valid indices\");\n    test:assertTrue(result[2] >= 1 && result[2] <= 3, \"Result should contain valid indices\");\n    test:assertTrue(result[0] != result[1] && result[1] != result[2] && result[0] != result[2], \n                    \"Indices should be distinct\");\n}\n\n@test:Config {}\nfunction testFindTriangleWithExtraPoint() returns error? {\n    Point[] points = [\n        {x: 0, y: 0, index: 1},\n        {x: 0, y: 2, index: 2},\n        {x: 2, y: 0, index: 3},\n        {x: 2, y: 2, index: 4},\n        {x: 1, y: 1, index: 5}\n    ];\n    \n    [int, int, int] result = check findTriangle(points);\n    // The result should be a valid combination where point 5 is outside\n    test:assertTrue(result[0] != result[1] && result[1] != result[2] && result[0] != result[2], \n                    \"Indices should be distinct\");\n    test:assertTrue(result[0] >= 1 && result[0] <= 5, \"Index should be in valid range\");\n    test:assertTrue(result[1] >= 1 && result[1] <= 5, \"Index should be in valid range\");\n    test:assertTrue(result[2] >= 1 && result[2] <= 5, \"Index should be in valid range\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n and n points from input\n// 2. Try combinations of 3 points to find a valid triangle\n// 3. For each combination, check if it forms a valid triangle (positive area using cross product)\n// 4. Check if all other points lie strictly outside this triangle\n// 5. A point is strictly outside if it's not inside and not on the boundary\n// 6. Use cross product for orientation tests\n// 7. Return the first valid combination found\n// \n// Key fix: Use regex:split() for string splitting instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Point record {|\n    int x;\n    int y;\n    int index; // 1-based index\n|};\n\n// Calculate twice the signed area of triangle using cross product\n// If result is 0, points are collinear\nfunction crossProduct(Point p1, Point p2, Point p3) returns int {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\n// Check if point p is strictly inside triangle formed by a, b, c\nfunction isStrictlyInside(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    // All same sign and non-zero means strictly inside\n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    boolean hasZero = (d1 == 0) || (d2 == 0) || (d3 == 0);\n    \n    // Strictly inside means all same sign and no zeros (not on boundary)\n    return !(hasNeg && hasPos) && !hasZero && (hasNeg || hasPos);\n}\n\n// Check if point is on boundary or inside the triangle\nfunction isInsideOrOnBoundary(Point p, Point a, Point b, Point c) returns boolean {\n    int d1 = crossProduct(a, b, p);\n    int d2 = crossProduct(b, c, p);\n    int d3 = crossProduct(c, a, p);\n    \n    // If all have same sign (or zero), point is inside or on boundary\n    boolean hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    boolean hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n    \n    return !(hasNeg && hasPos);\n}\n\nfunction findTriangle(Point[] points) returns [int, int, int]|error {\n    int n = points.length();\n    \n    // Try different combinations, starting with first few points\n    // This greedy approach works because a solution is guaranteed to exist\n    foreach int i in 0 ..< n {\n        foreach int j in (i + 1) ..< n {\n            foreach int k in (j + 1) ..< n {\n                Point p1 = points[i];\n                Point p2 = points[j];\n                Point p3 = points[k];\n                \n                // Check if triangle has positive area (not collinear)\n                int area = crossProduct(p1, p2, p3);\n                if area == 0 {\n                    continue; // Collinear points, skip\n                }\n                \n                // Check if all other points are strictly outside\n                boolean valid = true;\n                foreach int m in 0 ..< n {\n                    if m == i || m == j || m == k {\n                        continue;\n                    }\n                    \n                    if isInsideOrOnBoundary(points[m], p1, p2, p3) {\n                        valid = false;\n                        break;\n                    }\n                }\n                \n                if valid {\n                    return [p1.index, p2.index, p3.index];\n                }\n            }\n        }\n    }\n    \n    return error(\"No valid triangle found\");\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(line.trim());\n    \n    if n < 3 {\n        return error(\"Need at least 3 points\");\n    }\n    \n    // Read n points\n    Point[] points = [];\n    foreach int i in 0 ..< n {\n        string? pointLine = io:readln();\n        if pointLine is () {\n            return error(\"Failed to read point\");\n        }\n        \n        // Use regex:split instead of string.split()\n        string[] parts = regex:split(pointLine.trim(), \" +\");\n        if parts.length() < 2 {\n            return error(\"Invalid point format\");\n        }\n        \n        int x = check 'int:fromString(parts[0].trim());\n        int y = check 'int:fromString(parts[1].trim());\n        \n        points.push({x: x, y: y, index: i + 1});\n    }\n    \n    // Find valid triangle\n    [int, int, int] result = check findTriangle(points);\n    \n    io:println(result[0].toString() + \" \" + result[1].toString() + \" \" + result[2].toString());\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5\n0 0\n0 2\n2 0\n2 2\n1 1\n",
          "expected_output": "1 3 5\n",
          "actual_output": "1 2 5\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T00:00:02.393452"
}