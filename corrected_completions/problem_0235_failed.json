{
  "entry_id": "problem_0235",
  "problem_index": 235,
  "prompt": "Title: Balls and Boxes\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nLittle Vasya had *n* boxes with balls in the room. The boxes stood in a row and were numbered with numbers from 1 to *n* from left to right.\n\nOnce Vasya chose one of the boxes, let's assume that its number is *i*, took all balls out from it (it is guaranteed that this box originally had at least one ball), and began putting balls (one at a time) to the boxes with numbers *i*<=+<=1, *i*<=+<=2, *i*<=+<=3 and so on. If Vasya puts a ball into the box number *n*, then the next ball goes to box 1, the next one goes to box 2 and so on. He did it until he had no balls left in his hands. It is possible that Vasya puts multiple balls to the same box, and it is also possible that one or more balls will go to the box number *i*. If *i*<==<=*n*, Vasya puts the first ball into the box number 1, then the next ball goes to box 2 and so on. \n\nFor example, let's suppose that initially Vasya had four boxes, and the first box had 3 balls, the second one had 2, the third one had 5 and the fourth one had 4 balls. Then, if *i*<==<=3, then Vasya will take all five balls out of the third box and put them in the boxes with numbers: 4,<=1,<=2,<=3,<=4. After all Vasya's actions the balls will lie in the boxes as follows: in the first box there are 4 balls, 3 in the second one, 1 in the third one and 6 in the fourth one.\n\nAt this point Vasya has completely forgotten the original arrangement of the balls in the boxes, but he knows how they are arranged now, and the number *x* — the number of the box, where he put the last of the taken out balls.\n\nHe asks you to help to find the initial arrangement of the balls in the boxes.\n\nInput Specification:\nThe first line of the input contains two integers *n* and *x* (2<=≤<=*n*<=≤<=105, 1<=≤<=*x*<=≤<=*n*), that represent the number of the boxes and the index of the box that got the last ball from Vasya, correspondingly. The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n*, where integer *a**i* (0<=≤<=*a**i*<=≤<=109, *a**x*<=≠<=0) represents the number of balls in the box with index *i* after Vasya completes all the actions. \n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutput Specification:\nPrint *n* integers, where the *i*-th one represents the number of balls in the box number *i* before Vasya starts acting. Separate the numbers in the output by spaces. If there are multiple correct solutions, you are allowed to print any of them.\n\nDemo Input:\n['4 4\\n4 3 1 6\\n', '5 2\\n3 2 0 2 7\\n', '3 3\\n2 3 1\\n']\n\nDemo Output:\n['3 2 5 4 ', '2 1 4 1 6 ', '1 2 3 ']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:19:03.594438",
      "status": "failed",
      "completion": "# Overview\n\nThis problem involves reversing a ball distribution operation. Given the final state of balls in boxes and knowing which box received the last ball, we need to find the initial state.\n\n**Key observations:**\n1. Vasya picked box `i`, took all balls from it, and distributed them starting from box `i+1` (or box 1 if `i == n`)\n2. The last ball landed in box `x`, so we can calculate how many balls were distributed\n3. Box `i` had 0 balls after taking them out, but might have received balls during distribution\n4. We need to reverse the distribution: subtract 1 from each box that received a ball, and find which box was the source\n\n**Algorithm:**\n1. Find the source box `i`: Since the last ball went to box `x`, and we know the distribution wraps around, we work backwards\n2. Count how many balls were distributed by checking which boxes received balls\n3. The source box `i` is at position `(x - balls_distributed + 1) % n` (with adjustments)\n4. Reverse the distribution by subtracting 1 from boxes that received balls\n5. Add all distributed balls back to the source box\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We know the final state and which box (x) got the last ball\n// 2. We need to find which box (i) was the source\n// 3. If box i had B balls initially, after distribution:\n//    - Box i will have 0 balls initially (all taken out)\n//    - Then B balls are distributed starting from box (i+1) or box 1 if i==n\n//    - Each of the next B boxes gets 1 ball added\n//    - Box x is the last box to receive a ball\n// 4. To reverse: find i, count balls distributed, subtract 1 from each box that got a ball,\n//    and add all distributed balls to box i\n\nimport ballerina/io;\n\nfunction solveBallsAndBoxes(int n, int x, int[] finalState) returns int[] {\n    int[] initial = finalState.clone();\n    \n    // We need to find which box was the source (i)\n    // The last ball went to box x\n    // We need to find the minimum number of balls that could have been distributed\n    \n    // Find the minimum value among all boxes to determine how many complete rounds happened\n    int minVal = finalState[0];\n    foreach int val in finalState {\n        if val < minVal {\n            minVal = val;\n        }\n    }\n    \n    // The source box i is right before the first box that received a ball\n    // Since last ball went to x (1-indexed), we need to work backwards\n    // The distribution started from some box i+1 and ended at x\n    \n    // Try to find which box was emptied\n    // The box that was emptied is the one right before the sequence of boxes that got balls\n    // Since x got the last ball, we can trace back\n    \n    int sourceBox = -1;\n    \n    // The key insight: after distribution, all boxes have at least minVal balls\n    // The boxes from (i+1) to x (wrapping around) each got one extra ball beyond minVal\n    // So we look for a box that has exactly minVal balls and is right after x (considering wrap)\n    \n    // Count how many balls were distributed: it's the box that comes after x that didn't get a ball\n    // We need to find where the sequence of \"+1\" boxes ends\n    \n    // Start from x and go backwards to find boxes with minVal (these didn't receive balls)\n    // The first box after x (going forward) with minVal is where distribution didn't reach\n    \n    int ballsDistributed = 0;\n    int idx = x % n; // Convert to 0-indexed, then check next position\n    \n    // Count consecutive boxes from position after x that have more than minVal\n    while (true) {\n        if (initial[idx] == minVal) {\n            break;\n        }\n        ballsDistributed += 1;\n        initial[idx] -= 1; // Remove the distributed ball\n        idx = (idx + n - 1) % n; // Go backwards\n        if (ballsDistributed > n) {\n            break; // Safety check\n        }\n    }\n    \n    // The source box is at idx (0-indexed)\n    sourceBox = idx;\n    \n    // Add all distributed balls back to source box\n    initial[sourceBox] += ballsDistributed;\n    \n    return initial;\n}\n\npublic function main() returns error? {\n    // Read first line: n and x\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x = check 'int:fromString(parts1[1]);\n    \n    // Read second line: final state of boxes\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of box values\");\n    }\n    \n    int[] finalState = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        finalState.push(val);\n    }\n    \n    // Convert x to 0-indexed\n    x = x - 1;\n    \n    int[] result = solveBallsAndBoxes(n, x, finalState);\n    \n    // Print result\n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        output += result[i].toString();\n        if i < result.length() - 1 {\n            output += \" \";\n        }\n    }\n    io:println(output + \" \");\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] finalState = [4, 3, 1, 6];\n    int[] result = solveBallsAndBoxes(4, 3, finalState); // x=4 in 1-indexed = 3 in 0-indexed\n    // Expected: [3, 2, 5, 4]\n    test:assertEquals(result[0], 3);\n    test:assertEquals(result[1], 2);\n    test:assertEquals(result[2], 5);\n    test:assertEquals(result[3], 4);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] finalState = [3, 2, 0, 2, 7];\n    int[] result = solveBallsAndBoxes(5, 1, finalState); // x=2 in 1-indexed = 1 in 0-indexed\n    // Expected: [2, 1, 4, 1, 6]\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 1);\n    test:assertEquals(result[2], 4);\n    test:assertEquals(result[3], 1);\n    test:assertEquals(result[4], 6);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] finalState = [2, 3, 1];\n    int[] result = solveBallsAndBoxes(3, 2, finalState); // x=3 in 1-indexed = 2 in 0-indexed\n    // Expected: [1, 2, 3]\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1], 2);\n    test:assertEquals(result[2], 3);\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    int[] finalState = [2, 1];\n    int[] result = solveBallsAndBoxes(2, 0, finalState); // x=1 in 1-indexed = 0 in 0-indexed\n    // If box 2 had 1 ball initially and was source, distributing to box 1\n    // Initial: [1, 1], After: [2, 0] - but x=1 means last ball went to box 1\n    test:assertEquals(result.length(), 2);\n    test:assertTrue(result[0] >= 0);\n    test:assertTrue(result[1] >= 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We know the final state and which box (x) got the last ball\n// 2. We need to find which box (i) was the source\n// 3. If box i had B balls initially, after distribution:\n//    - Box i will have 0 balls initially (all taken out)\n//    - Then B balls are distributed starting from box (i+1) or box 1 if i==n\n//    - Each of the next B boxes gets 1 ball added\n//    - Box x is the last box to receive a ball\n// 4. To reverse: find i, count balls distributed, subtract 1 from each box that got a ball,\n//    and add all distributed balls to box i\n\nimport ballerina/io;\n\nfunction solveBallsAndBoxes(int n, int x, int[] finalState) returns int[] {\n    int[] initial = finalState.clone();\n    \n    // We need to find which box was the source (i)\n    // The last ball went to box x\n    // We need to find the minimum number of balls that could have been distributed\n    \n    // Find the minimum value among all boxes to determine how many complete rounds happened\n    int minVal = finalState[0];\n    foreach int val in finalState {\n        if val < minVal {\n            minVal = val;\n        }\n    }\n    \n    // The source box i is right before the first box that received a ball\n    // Since last ball went to x (1-indexed), we need to work backwards\n    // The distribution started from some box i+1 and ended at x\n    \n    // Try to find which box was emptied\n    // The box that was emptied is the one right before the sequence of boxes that got balls\n    // Since x got the last ball, we can trace back\n    \n    int sourceBox = -1;\n    \n    // The key insight: after distribution, all boxes have at least minVal balls\n    // The boxes from (i+1) to x (wrapping around) each got one extra ball beyond minVal\n    // So we look for a box that has exactly minVal balls and is right after x (considering wrap)\n    \n    // Count how many balls were distributed: it's the box that comes after x that didn't get a ball\n    // We need to find where the sequence of \"+1\" boxes ends\n    \n    // Start from x and go backwards to find boxes with minVal (these didn't receive balls)\n    // The first box after x (going forward) with minVal is where distribution didn't reach\n    \n    int ballsDistributed = 0;\n    int idx = x % n; // Convert to 0-indexed, then check next position\n    \n    // Count consecutive boxes from position after x that have more than minVal\n    while (true) {\n        if (initial[idx] == minVal) {\n            break;\n        }\n        ballsDistributed += 1;\n        initial[idx] -= 1; // Remove the distributed ball\n        idx = (idx + n - 1) % n; // Go backwards\n        if (ballsDistributed > n) {\n            break; // Safety check\n        }\n    }\n    \n    // The source box is at idx (0-indexed)\n    sourceBox = idx;\n    \n    // Add all distributed balls back to source box\n    initial[sourceBox] += ballsDistributed;\n    \n    return initial;\n}\n\npublic function main() returns error? {\n    // Read first line: n and x\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x = check 'int:fromString(parts1[1]);\n    \n    // Read second line: final state of boxes\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of box values\");\n    }\n    \n    int[] finalState = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        finalState.push(val);\n    }\n    \n    // Convert x to 0-indexed\n    x = x - 1;\n    \n    int[] result = solveBallsAndBoxes(n, x, finalState);\n    \n    // Print result\n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        output += result[i].toString();\n        if i < result.length() - 1 {\n            output += \" \";\n        }\n    }\n    io:println(output + \" \");\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(81:36,81:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(95:36,95:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(81:36,81:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(95:36,95:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(81:36,81:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(95:36,95:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:19:43.445040",
      "status": "failed",
      "completion": "Looking at the compilation errors, the issue is that `split` is not a method on `string` in Ballerina. I need to use the `string:split` function from the standard library instead.\n\nLet me also reconsider the algorithm:\n- We have the final state and know box `x` received the last ball\n- We need to find which box `i` was the source\n- The source box is the one that comes RIGHT AFTER box `x` (wrapping around) that has the minimum value\n- Because balls were distributed from `i+1` to `x`, so the box at position `(x+1) % n` didn't receive any balls and should have the minimum count\n\nLet me trace through example 1:\n- Final: [4, 3, 1, 6], x=4 (1-indexed) = 3 (0-indexed)\n- Expected initial: [3, 2, 5, 4]\n- Box 3 (0-indexed) got the last ball\n- Box at position (3+1)%4 = 0 has value 4, box 1 has 3, box 2 has 1 (minimum)\n- So box 2 is the source! It had 5 balls initially\n- Distribution went: box 3 (+1), box 0 (+1), box 1 (+1), box 2 (+1), box 3 (+1) = 5 balls\n- Reverse: [4-1, 3-1, 1-1, 6-2] + add 5 to box 2 = [3, 2, 0, 4] + [0,0,5,0] = [3, 2, 5, 4] ✓\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Given final state after distribution and box x that got the last ball\n// 2. Need to find initial state before distribution\n// 3. Key insight: The source box i is right after box x (wrapping around) and has minimum balls\n//    because it was emptied and then got some balls back during distribution\n// 4. Algorithm:\n//    a. Find minimum value in final state\n//    b. Find source box: start from (x+1)%n and find first box with minimum value\n//    c. Count balls distributed: from source+1 to x (wrapping), count boxes > minimum\n//    d. Reverse distribution: subtract 1 from each box that received balls\n//    e. Add all distributed balls back to source box\n\nimport ballerina/io;\n\nfunction solveBallsAndBoxes(int n, int x, int[] finalState) returns int[] {\n    int[] initial = finalState.clone();\n    \n    // Find minimum value (the box that didn't receive balls during distribution)\n    int minVal = finalState[0];\n    foreach int val in finalState {\n        if val < minVal {\n            minVal = val;\n        }\n    }\n    \n    // Find source box: it's the first box with minVal starting from (x+1)%n\n    int sourceBox = (x + 1) % n;\n    while initial[sourceBox] != minVal {\n        sourceBox = (sourceBox + 1) % n;\n    }\n    \n    // Count balls distributed and reverse the distribution\n    // Balls were distributed from (sourceBox+1) to x (wrapping around)\n    int ballsDistributed = 0;\n    int idx = (sourceBox + 1) % n;\n    \n    while idx != ((x + 1) % n) {\n        if initial[idx] > minVal {\n            initial[idx] -= 1;\n            ballsDistributed += 1;\n        }\n        idx = (idx + 1) % n;\n    }\n    \n    // Add all distributed balls back to source box\n    initial[sourceBox] += ballsDistributed;\n    \n    return initial;\n}\n\npublic function main() returns error? {\n    // Read first line: n and x\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string:RegExp spaceSep = re ` `;\n    string[] parts1 = spaceSep.split(line1.trim());\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x = check 'int:fromString(parts1[1]);\n    \n    // Read second line: final state of boxes\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = spaceSep.split(line2.trim());\n    if parts2.length() != n {\n        return error(\"Invalid number of box values\");\n    }\n    \n    int[] finalState = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        finalState.push(val);\n    }\n    \n    // Convert x to 0-indexed\n    x = x - 1;\n    \n    int[] result = solveBallsAndBoxes(n, x, finalState);\n    \n    // Print result\n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        output += result[i].toString();\n        if i < result.length() - 1 {\n            output += \" \";\n        }\n    }\n    io:println(output + \" \");\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] finalState = [4, 3, 1, 6];\n    int[] result = solveBallsAndBoxes(4, 3, finalState); // x=4 in 1-indexed = 3 in 0-indexed\n    // Expected: [3, 2, 5, 4]\n    test:assertEquals(result[0], 3);\n    test:assertEquals(result[1], 2);\n    test:assertEquals(result[2], 5);\n    test:assertEquals(result[3], 4);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] finalState = [3, 2, 0, 2, 7];\n    int[] result = solveBallsAndBoxes(5, 1, finalState); // x=2 in 1-indexed = 1 in 0-indexed\n    // Expected: [2, 1, 4, 1, 6]\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 1);\n    test:assertEquals(result[2], 4);\n    test:assertEquals(result[3], 1);\n    test:assertEquals(result[4], 6);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] finalState = [2, 3, 1];\n    int[] result = solveBallsAndBoxes(3, 2, finalState); // x=3 in 1-indexed = 2 in 0-indexed\n    // Expected: [1, 2, 3]\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1], 2);\n    test:assertEquals(result[2], 3);\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    int[] finalState = [2, 1];\n    int[] result = solveBallsAndBoxes(2, 0, finalState); // x=1 in 1-indexed = 0 in 0-indexed\n    // Box at position 1 has minimum (1), so it's the source\n    // 1 ball was distributed from box 1 to box 0\n    // Initial should be [1, 1]\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Given final state after distribution and box x that got the last ball\n// 2. Need to find initial state before distribution\n// 3. Key insight: The source box i is right after box x (wrapping around) and has minimum balls\n//    because it was emptied and then got some balls back during distribution\n// 4. Algorithm:\n//    a. Find minimum value in final state\n//    b. Find source box: start from (x+1)%n and find first box with minimum value\n//    c. Count balls distributed: from source+1 to x (wrapping), count boxes > minimum\n//    d. Reverse distribution: subtract 1 from each box that received balls\n//    e. Add all distributed balls back to source box\n\nimport ballerina/io;\n\nfunction solveBallsAndBoxes(int n, int x, int[] finalState) returns int[] {\n    int[] initial = finalState.clone();\n    \n    // Find minimum value (the box that didn't receive balls during distribution)\n    int minVal = finalState[0];\n    foreach int val in finalState {\n        if val < minVal {\n            minVal = val;\n        }\n    }\n    \n    // Find source box: it's the first box with minVal starting from (x+1)%n\n    int sourceBox = (x + 1) % n;\n    while initial[sourceBox] != minVal {\n        sourceBox = (sourceBox + 1) % n;\n    }\n    \n    // Count balls distributed and reverse the distribution\n    // Balls were distributed from (sourceBox+1) to x (wrapping around)\n    int ballsDistributed = 0;\n    int idx = (sourceBox + 1) % n;\n    \n    while idx != ((x + 1) % n) {\n        if initial[idx] > minVal {\n            initial[idx] -= 1;\n            ballsDistributed += 1;\n        }\n        idx = (idx + 1) % n;\n    }\n    \n    // Add all distributed balls back to source box\n    initial[sourceBox] += ballsDistributed;\n    \n    return initial;\n}\n\npublic function main() returns error? {\n    // Read first line: n and x\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string:RegExp spaceSep = re ` `;\n    string[] parts1 = spaceSep.split(line1.trim());\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x = check 'int:fromString(parts1[1]);\n    \n    // Read second line: final state of boxes\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = spaceSep.split(line2.trim());\n    if parts2.length() != n {\n        return error(\"Invalid number of box values\");\n    }\n    \n    int[] finalState = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        finalState.push(val);\n    }\n    \n    // Convert x to 0-indexed\n    x = x - 1;\n    \n    int[] result = solveBallsAndBoxes(n, x, finalState);\n    \n    // Print result\n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        output += result[i].toString();\n        if i < result.length() - 1 {\n            output += \" \";\n        }\n    }\n    io:println(output + \" \");\n}",
      "tests_passed": 1,
      "tests_total": 3,
      "tests_pass_rate": 0.3333333333333333,
      "validation_msg": "Only passed 1/3 tests (33.3%), need 75%",
      "error": "Only passed 1/3 tests (33.3%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4 4\n4 3 1 6\n",
          "expected_output": "3 2 5 4 ",
          "actual_output": "4 3 2 5 \n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/3 tests (33.3%), need 75%",
  "timestamp": "2026-01-05T04:20:24.618601"
}