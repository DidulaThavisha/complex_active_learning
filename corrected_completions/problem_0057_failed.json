{
  "entry_id": "problem_0057",
  "problem_index": 57,
  "prompt": "Title: Laboratory Work\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAnya and Kirill are doing a physics laboratory work. In one of the tasks they have to measure some value *n* times, and then compute the average value to lower the error.\n\nKirill has already made his measurements, and has got the following integer values: *x*1, *x*2, ..., *x**n*. It is important that the values are close to each other, namely, the difference between the maximum value and the minimum value is at most 2.\n\nAnya does not want to make the measurements, however, she can't just copy the values from Kirill's work, because the error of each measurement is a random value, and this coincidence will be noted by the teacher. Anya wants to write such integer values *y*1, *y*2, ..., *y**n* in her work, that the following conditions are met:\n -  the average value of *x*1,<=*x*2,<=...,<=*x**n* is equal to the average value of *y*1,<=*y*2,<=...,<=*y**n*;-  all Anya's measurements are in the same bounds as all Kirill's measurements, that is, the maximum value among Anya's values is not greater than the maximum value among Kirill's values, and the minimum value among Anya's values is not less than the minimum value among Kirill's values;-  the number of equal measurements in Anya's work and Kirill's work is as small as possible among options with the previous conditions met. Formally, the teacher goes through all Anya's values one by one, if there is equal value in Kirill's work and it is not strike off yet, he strikes off this Anya's value and one of equal values in Kirill's work. The number of equal measurements is then the total number of strike off values in Anya's work. \nHelp Anya to write such a set of measurements that the conditions above are met.\n\nInput Specification:\nThe first line contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the numeber of measurements made by Kirill.\n\nThe second line contains a sequence of integers *x*1,<=*x*2,<=...,<=*x**n* (<=-<=100<=000<=≤<=*x**i*<=≤<=100<=000) — the measurements made by Kirill. It is guaranteed that the difference between the maximum and minimum values among values *x*1,<=*x*2,<=...,<=*x**n* does not exceed 2.\n\nOutput Specification:\nIn the first line print the minimum possible number of equal measurements.\n\nIn the second line print *n* integers *y*1,<=*y*2,<=...,<=*y**n* — the values Anya should write. You can print the integers in arbitrary order. Keep in mind that the minimum value among Anya's values should be not less that the minimum among Kirill's values, and the maximum among Anya's values should be not greater than the maximum among Kirill's values.\n\nIf there are multiple answers, print any of them.\n\nDemo Input:\n['6\\n-1 1 1 0 0 -1\\n', '3\\n100 100 101\\n', '7\\n-10 -9 -10 -8 -10 -9 -9\\n']\n\nDemo Output:\n['2\\n0 0 0 0 0 0 \\n', '3\\n101 100 100 \\n', '5\\n-10 -10 -9 -9 -9 -9 -9 \\n']\n\nNote:\nIn the first example Anya can write zeros as here measurements results. The average value is then equal to the average value of Kirill's values, and there are only two equal measurements.\n\nIn the second example Anya should write two values 100 and one value 101 (in any order), because it is the only possibility to make the average be the equal to the average of Kirill's values. Thus, all three measurements are equal.\n\nIn the third example the number of equal measurements is 5.",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:55:54.783742",
      "status": "failed",
      "completion": "# Overview\nThis problem requires finding a set of measurements for Anya that:\n1. Has the same average as Kirill's measurements\n2. Stays within the same min/max bounds as Kirill's measurements\n3. Minimizes the number of equal values between the two sets\n\nThe key insight is that since the range is at most 2, we have at most 3 distinct values. To minimize matches, we should try to distribute values differently while maintaining the same sum (to preserve the average).\n\nStrategy:\n- Find min, max, and sum of Kirill's measurements\n- Count occurrences of each value in Kirill's set\n- Try to construct Anya's set using the same min/max bounds but different distribution\n- The optimal approach is to use a pattern that minimizes overlap with Kirill's distribution\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n and the array of measurements\n// 2. Find min, max, and sum of Kirill's measurements\n// 3. Count occurrences of each value in Kirill's array\n// 4. To minimize equal measurements, we should try to balance the distribution differently\n// 5. Strategy: Use alternating pattern starting from min or max to create different distribution\n// 6. Calculate how many of each value we need to maintain the same sum\n// 7. Count equal measurements by comparing sorted arrays\n\nimport ballerina/io;\n\nfunction solveLabWork(int[] kirill) returns [int, int[]] {\n    int n = kirill.length();\n    \n    // Find min, max, and sum\n    int minVal = kirill[0];\n    int maxVal = kirill[0];\n    int sum = 0;\n    \n    foreach int val in kirill {\n        if val < minVal {\n            minVal = val;\n        }\n        if val > maxVal {\n            maxVal = val;\n        }\n        sum += val;\n    }\n    \n    // Count occurrences in Kirill's array\n    map<int> kirillCount = {};\n    foreach int val in kirill {\n        string key = val.toString();\n        if kirillCount.hasKey(key) {\n            kirillCount[key] = kirillCount.get(key) + 1;\n        } else {\n            kirillCount[key] = 1;\n        }\n    }\n    \n    // Build Anya's array to minimize matches\n    // Strategy: distribute values to minimize overlap with Kirill's distribution\n    int[] anya = [];\n    \n    // Try to use extreme values (min and max) as much as possible\n    // This often gives a different distribution than the original\n    int remainingSum = sum;\n    int remainingCount = n;\n    \n    // Fill with min values first, then adjust with max values\n    foreach int i in 0 ..< n {\n        anya.push(minVal);\n    }\n    \n    // Now adjust to get the correct sum\n    int currentSum = minVal * n;\n    int diff = remainingSum - currentSum;\n    \n    // We need to increase sum by diff\n    // Each replacement of minVal with maxVal increases sum by (maxVal - minVal)\n    int valueRange = maxVal - minVal;\n    \n    if valueRange > 0 {\n        int numMax = diff / valueRange;\n        int remainder = diff % valueRange;\n        \n        // Place maxVal values\n        foreach int i in 0 ..< numMax {\n            anya[i] = maxVal;\n        }\n        \n        // Place middle value if needed (when range is 2)\n        if remainder > 0 {\n            anya[numMax] = minVal + remainder;\n        }\n    }\n    \n    // Count equal measurements\n    map<int> anyaCount = {};\n    foreach int val in anya {\n        string key = val.toString();\n        if anyaCount.hasKey(key) {\n            anyaCount[key] = anyaCount.get(key) + 1;\n        } else {\n            anyaCount[key] = 1;\n        }\n    }\n    \n    int equalCount = 0;\n    foreach var [key, count] in anyaCount.entries() {\n        if kirillCount.hasKey(key) {\n            int kirillCnt = kirillCount.get(key);\n            int anyaCnt = count;\n            equalCount += (kirillCnt < anyaCnt) ? kirillCnt : anyaCnt;\n        }\n    }\n    \n    return [equalCount, anya];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read measurements\n    string? measurementsLine = io:readln();\n    if measurementsLine is () {\n        return error(\"Failed to read measurements\");\n    }\n    \n    string[] parts = measurementsLine.trim().split(\" \");\n    int[] kirill = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int val = check 'int:fromString(part.trim());\n            kirill.push(val);\n        }\n    }\n    \n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    io:println(equalCount);\n    \n    string output = \"\";\n    foreach int i in 0 ..< anya.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += anya[i].toString();\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] kirill = [-1, 1, 1, 0, 0, -1];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // Check that the sum is equal\n    int kirillSum = 0;\n    foreach int val in kirill {\n        kirillSum += val;\n    }\n    int anyaSum = 0;\n    foreach int val in anya {\n        anyaSum += val;\n    }\n    test:assertEquals(kirillSum, anyaSum);\n    \n    // Check that array length is same\n    test:assertEquals(anya.length(), kirill.length());\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] kirill = [100, 100, 101];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // Check sum equality\n    int kirillSum = 301;\n    int anyaSum = 0;\n    foreach int val in anya {\n        anyaSum += val;\n    }\n    test:assertEquals(kirillSum, anyaSum);\n    \n    // Check bounds\n    int minAnya = anya[0];\n    int maxAnya = anya[0];\n    foreach int val in anya {\n        if val < minAnya {\n            minAnya = val;\n        }\n        if val > maxAnya {\n            maxAnya = val;\n        }\n    }\n    test:assertTrue(minAnya >= 100 && maxAnya <= 101);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] kirill = [-10, -9, -10, -8, -10, -9, -9];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // Check sum equality\n    int kirillSum = 0;\n    foreach int val in kirill {\n        kirillSum += val;\n    }\n    int anyaSum = 0;\n    foreach int val in anya {\n        anyaSum += val;\n    }\n    test:assertEquals(kirillSum, anyaSum);\n    \n    // Check length\n    test:assertEquals(anya.length(), 7);\n}\n\n@test:Config {}\nfunction testSingleElement() {\n    int[] kirill = [5];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // With single element, must be equal\n    test:assertEquals(anya[0], 5);\n    test:assertEquals(equalCount, 1);\n    test:assertEquals(anya.length(), 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n and the array of measurements\n// 2. Find min, max, and sum of Kirill's measurements\n// 3. Count occurrences of each value in Kirill's array\n// 4. To minimize equal measurements, we should try to balance the distribution differently\n// 5. Strategy: Use alternating pattern starting from min or max to create different distribution\n// 6. Calculate how many of each value we need to maintain the same sum\n// 7. Count equal measurements by comparing sorted arrays\n\nimport ballerina/io;\n\nfunction solveLabWork(int[] kirill) returns [int, int[]] {\n    int n = kirill.length();\n    \n    // Find min, max, and sum\n    int minVal = kirill[0];\n    int maxVal = kirill[0];\n    int sum = 0;\n    \n    foreach int val in kirill {\n        if val < minVal {\n            minVal = val;\n        }\n        if val > maxVal {\n            maxVal = val;\n        }\n        sum += val;\n    }\n    \n    // Count occurrences in Kirill's array\n    map<int> kirillCount = {};\n    foreach int val in kirill {\n        string key = val.toString();\n        if kirillCount.hasKey(key) {\n            kirillCount[key] = kirillCount.get(key) + 1;\n        } else {\n            kirillCount[key] = 1;\n        }\n    }\n    \n    // Build Anya's array to minimize matches\n    // Strategy: distribute values to minimize overlap with Kirill's distribution\n    int[] anya = [];\n    \n    // Try to use extreme values (min and max) as much as possible\n    // This often gives a different distribution than the original\n    int remainingSum = sum;\n    int remainingCount = n;\n    \n    // Fill with min values first, then adjust with max values\n    foreach int i in 0 ..< n {\n        anya.push(minVal);\n    }\n    \n    // Now adjust to get the correct sum\n    int currentSum = minVal * n;\n    int diff = remainingSum - currentSum;\n    \n    // We need to increase sum by diff\n    // Each replacement of minVal with maxVal increases sum by (maxVal - minVal)\n    int valueRange = maxVal - minVal;\n    \n    if valueRange > 0 {\n        int numMax = diff / valueRange;\n        int remainder = diff % valueRange;\n        \n        // Place maxVal values\n        foreach int i in 0 ..< numMax {\n            anya[i] = maxVal;\n        }\n        \n        // Place middle value if needed (when range is 2)\n        if remainder > 0 {\n            anya[numMax] = minVal + remainder;\n        }\n    }\n    \n    // Count equal measurements\n    map<int> anyaCount = {};\n    foreach int val in anya {\n        string key = val.toString();\n        if anyaCount.hasKey(key) {\n            anyaCount[key] = anyaCount.get(key) + 1;\n        } else {\n            anyaCount[key] = 1;\n        }\n    }\n    \n    int equalCount = 0;\n    foreach var [key, count] in anyaCount.entries() {\n        if kirillCount.hasKey(key) {\n            int kirillCnt = kirillCount.get(key);\n            int anyaCnt = count;\n            equalCount += (kirillCnt < anyaCnt) ? kirillCnt : anyaCnt;\n        }\n    }\n    \n    return [equalCount, anya];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read measurements\n    string? measurementsLine = io:readln();\n    if measurementsLine is () {\n        return error(\"Failed to read measurements\");\n    }\n    \n    string[] parts = measurementsLine.trim().split(\" \");\n    int[] kirill = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int val = check 'int:fromString(part.trim());\n            kirill.push(val);\n        }\n    }\n    \n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    io:println(equalCount);\n    \n    string output = \"\";\n    foreach int i in 0 ..< anya.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += anya[i].toString();\n    }\n    io:println(output);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(115:46,115:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(115:46,115:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(115:46,115:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:56:28.944195",
      "status": "failed",
      "completion": "Looking at the error, the issue is that Ballerina's string type doesn't have a `split` method directly. I need to use the `regex` module from the standard library for splitting strings.\n\nLet me analyze the problem more carefully:\n1. Kirill has measurements where max - min ≤ 2\n2. Anya needs measurements with same average, within same bounds, but minimizing overlapping values\n3. The strategy is to redistribute values differently while maintaining the sum\n\nThe key insight: To minimize matches, we should create a distribution that's as different as possible from Kirill's. If we can use only min and max values (avoiding middle values), we create the most different distribution.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Since max - min ≤ 2, we have at most 3 distinct values\n// 2. To minimize equal measurements, we want a different distribution than Kirill's\n// 3. Best strategy: use only min and max values in Anya's array if possible\n// 4. Calculate how many min and max values needed to achieve same sum\n// 5. If exact distribution with only min/max isn't possible, use the middle value\n// 6. Count matches by tracking occurrences of each value in both arrays\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveLabWork(int[] kirill) returns [int, int[]] {\n    int n = kirill.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Find min, max, and sum\n    int minVal = kirill[0];\n    int maxVal = kirill[0];\n    int sum = 0;\n    \n    foreach int val in kirill {\n        if val < minVal {\n            minVal = val;\n        }\n        if val > maxVal {\n            maxVal = val;\n        }\n        sum += val;\n    }\n    \n    // Count occurrences in Kirill's array\n    map<int> kirillCount = {};\n    foreach int val in kirill {\n        string key = val.toString();\n        if kirillCount.hasKey(key) {\n            kirillCount[key] = kirillCount.get(key) + 1;\n        } else {\n            kirillCount[key] = 1;\n        }\n    }\n    \n    // Build Anya's array to minimize matches\n    int[] anya = [];\n    \n    // Strategy: Try to use only min and max values\n    // If minVal == maxVal, we must use same values\n    if minVal == maxVal {\n        foreach int i in 0 ..< n {\n            anya.push(minVal);\n        }\n    } else {\n        // We want: numMin * minVal + numMax * maxVal = sum\n        // And: numMin + numMax = n\n        // Solving: numMin = (n * maxVal - sum) / (maxVal - minVal)\n        \n        int numerator = n * maxVal - sum;\n        int denominator = maxVal - minVal;\n        \n        int numMin = numerator / denominator;\n        int remainder = numerator % denominator;\n        \n        // If remainder is 0, we can use only min and max\n        if remainder == 0 {\n            int numMax = n - numMin;\n            foreach int i in 0 ..< numMax {\n                anya.push(maxVal);\n            }\n            foreach int i in 0 ..< numMin {\n                anya.push(minVal);\n            }\n        } else {\n            // We need to use middle value\n            // Middle value is minVal + remainder (when denominator is 2)\n            // Or we need to recalculate\n            int midVal = minVal + remainder;\n            \n            // Use greedy approach: maximize use of extreme values\n            int numMax = numerator / denominator;\n            int numMid = 1;\n            int numMin = n - numMax - numMid;\n            \n            foreach int i in 0 ..< numMax {\n                anya.push(maxVal);\n            }\n            foreach int i in 0 ..< numMid {\n                anya.push(midVal);\n            }\n            foreach int i in 0 ..< numMin {\n                anya.push(minVal);\n            }\n        }\n    }\n    \n    // Count equal measurements\n    map<int> anyaCount = {};\n    foreach int val in anya {\n        string key = val.toString();\n        if anyaCount.hasKey(key) {\n            anyaCount[key] = anyaCount.get(key) + 1;\n        } else {\n            anyaCount[key] = 1;\n        }\n    }\n    \n    int equalCount = 0;\n    foreach var [key, count] in anyaCount.entries() {\n        if kirillCount.hasKey(key) {\n            int kirillCnt = kirillCount.get(key);\n            int anyaCnt = count;\n            equalCount += (kirillCnt < anyaCnt) ? kirillCnt : anyaCnt;\n        }\n    }\n    \n    return [equalCount, anya];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read measurements\n    string? measurementsLine = io:readln();\n    if measurementsLine is () {\n        return error(\"Failed to read measurements\");\n    }\n    \n    string[] parts = regex:split(measurementsLine.trim(), \" \");\n    int[] kirill = [];\n    \n    foreach string part in parts {\n        string trimmed = part.trim();\n        if trimmed.length() > 0 {\n            int val = check 'int:fromString(trimmed);\n            kirill.push(val);\n        }\n    }\n    \n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    io:println(equalCount);\n    \n    string output = \"\";\n    foreach int i in 0 ..< anya.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += anya[i].toString();\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] kirill = [-1, 1, 1, 0, 0, -1];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // Check that the sum is equal\n    int kirillSum = 0;\n    foreach int val in kirill {\n        kirillSum += val;\n    }\n    int anyaSum = 0;\n    foreach int val in anya {\n        anyaSum += val;\n    }\n    test:assertEquals(kirillSum, anyaSum, \"Sums must be equal\");\n    \n    // Check that array length is same\n    test:assertEquals(anya.length(), kirill.length(), \"Lengths must be equal\");\n    \n    // Check bounds are respected\n    test:assertTrue(equalCount <= 6, \"Equal count should be reasonable\");\n    \n    // Verify min/max bounds\n    int minAnya = anya[0];\n    int maxAnya = anya[0];\n    foreach int val in anya {\n        if val < minAnya { minAnya = val; }\n        if val > maxAnya { maxAnya = val; }\n    }\n    test:assertTrue(minAnya >= -1 && maxAnya <= 1, \"Bounds must be respected\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] kirill = [100, 100, 101];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // Check sum equality\n    int kirillSum = 301;\n    int anyaSum = 0;\n    foreach int val in anya {\n        anyaSum += val;\n    }\n    test:assertEquals(kirillSum, anyaSum, \"Sums must be equal\");\n    \n    // Check bounds\n    int minAnya = anya[0];\n    int maxAnya = anya[0];\n    foreach int val in anya {\n        if val < minAnya { minAnya = val; }\n        if val > maxAnya { maxAnya = val; }\n    }\n    test:assertTrue(minAnya >= 100 && maxAnya <= 101, \"Bounds must be respected\");\n    \n    // Check length\n    test:assertEquals(anya.length(), 3, \"Length must be 3\");\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] kirill = [-10, -9, -10, -8, -10, -9, -9];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // Check sum equality\n    int kirillSum = 0;\n    foreach int val in kirill {\n        kirillSum += val;\n    }\n    int anyaSum = 0;\n    foreach int val in anya {\n        anyaSum += val;\n    }\n    test:assertEquals(kirillSum, anyaSum, \"Sums must be equal\");\n    \n    // Check length\n    test:assertEquals(anya.length(), 7, \"Length must be 7\");\n    \n    // Check bounds\n    int minAnya = anya[0];\n    int maxAnya = anya[0];\n    foreach int val in anya {\n        if val < minAnya { minAnya = val; }\n        if val > maxAnya { maxAnya = val; }\n    }\n    test:assertTrue(minAnya >= -10 && maxAnya <= -8, \"Bounds must be respected\");\n}\n\n@test:Config {}\nfunction testSingleElement() {\n    int[] kirill = [5];\n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    // With single element, must be equal\n    test:assertEquals(anya[0], 5, \"Single element must match\");\n    test:assertEquals(equalCount, 1, \"Equal count must be 1\");\n    test:assertEquals(anya.length(), 1, \"Length must be 1\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Since max - min ≤ 2, we have at most 3 distinct values\n// 2. To minimize equal measurements, we want a different distribution than Kirill's\n// 3. Best strategy: use only min and max values in Anya's array if possible\n// 4. Calculate how many min and max values needed to achieve same sum\n// 5. If exact distribution with only min/max isn't possible, use the middle value\n// 6. Count matches by tracking occurrences of each value in both arrays\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveLabWork(int[] kirill) returns [int, int[]] {\n    int n = kirill.length();\n    \n    if n == 0 {\n        return [0, []];\n    }\n    \n    // Find min, max, and sum\n    int minVal = kirill[0];\n    int maxVal = kirill[0];\n    int sum = 0;\n    \n    foreach int val in kirill {\n        if val < minVal {\n            minVal = val;\n        }\n        if val > maxVal {\n            maxVal = val;\n        }\n        sum += val;\n    }\n    \n    // Count occurrences in Kirill's array\n    map<int> kirillCount = {};\n    foreach int val in kirill {\n        string key = val.toString();\n        if kirillCount.hasKey(key) {\n            kirillCount[key] = kirillCount.get(key) + 1;\n        } else {\n            kirillCount[key] = 1;\n        }\n    }\n    \n    // Build Anya's array to minimize matches\n    int[] anya = [];\n    \n    // Strategy: Try to use only min and max values\n    // If minVal == maxVal, we must use same values\n    if minVal == maxVal {\n        foreach int i in 0 ..< n {\n            anya.push(minVal);\n        }\n    } else {\n        // We want: numMin * minVal + numMax * maxVal = sum\n        // And: numMin + numMax = n\n        // Solving: numMin = (n * maxVal - sum) / (maxVal - minVal)\n        \n        int numerator = n * maxVal - sum;\n        int denominator = maxVal - minVal;\n        \n        int numMin = numerator / denominator;\n        int remainder = numerator % denominator;\n        \n        // If remainder is 0, we can use only min and max\n        if remainder == 0 {\n            int numMax = n - numMin;\n            foreach int i in 0 ..< numMax {\n                anya.push(maxVal);\n            }\n            foreach int i in 0 ..< numMin {\n                anya.push(minVal);\n            }\n        } else {\n            // We need to use middle value\n            // Middle value is minVal + remainder (when denominator is 2)\n            // Or we need to recalculate\n            int midVal = minVal + remainder;\n            \n            // Use greedy approach: maximize use of extreme values\n            int numMax = numerator / denominator;\n            int numMid = 1;\n            int numMin = n - numMax - numMid;\n            \n            foreach int i in 0 ..< numMax {\n                anya.push(maxVal);\n            }\n            foreach int i in 0 ..< numMid {\n                anya.push(midVal);\n            }\n            foreach int i in 0 ..< numMin {\n                anya.push(minVal);\n            }\n        }\n    }\n    \n    // Count equal measurements\n    map<int> anyaCount = {};\n    foreach int val in anya {\n        string key = val.toString();\n        if anyaCount.hasKey(key) {\n            anyaCount[key] = anyaCount.get(key) + 1;\n        } else {\n            anyaCount[key] = 1;\n        }\n    }\n    \n    int equalCount = 0;\n    foreach var [key, count] in anyaCount.entries() {\n        if kirillCount.hasKey(key) {\n            int kirillCnt = kirillCount.get(key);\n            int anyaCnt = count;\n            equalCount += (kirillCnt < anyaCnt) ? kirillCnt : anyaCnt;\n        }\n    }\n    \n    return [equalCount, anya];\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read measurements\n    string? measurementsLine = io:readln();\n    if measurementsLine is () {\n        return error(\"Failed to read measurements\");\n    }\n    \n    string[] parts = regex:split(measurementsLine.trim(), \" \");\n    int[] kirill = [];\n    \n    foreach string part in parts {\n        string trimmed = part.trim();\n        if trimmed.length() > 0 {\n            int val = check 'int:fromString(trimmed);\n            kirill.push(val);\n        }\n    }\n    \n    [int, int[]] result = solveLabWork(kirill);\n    int equalCount = result[0];\n    int[] anya = result[1];\n    \n    io:println(equalCount);\n    \n    string output = \"\";\n    foreach int i in 0 ..< anya.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += anya[i].toString();\n    }\n    io:println(output);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(83:17,83:23)] redeclared symbol 'numMin'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(83:17,83:23)] redeclared symbol 'numMin'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(83:17,83:23)] redeclared symbol 'numMin'\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(83:17,83:23)] redeclared symbol 'numMin'\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T00:57:02.816067"
}