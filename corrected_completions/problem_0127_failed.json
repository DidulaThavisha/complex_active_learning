{
  "entry_id": "problem_0127",
  "problem_index": 127,
  "prompt": "Title: Fractal\n\nTime Limit: 2 seconds\n\nMemory Limit: 64 megabytes\n\nProblem Description:\nEver since Kalevitch, a famous Berland abstractionist, heard of fractals, he made them the main topic of his canvases. Every morning the artist takes a piece of graph paper and starts with making a model of his future canvas. He takes a square as big as *n*<=×<=*n* squares and paints some of them black. Then he takes a clean square piece of paper and paints the fractal using the following algorithm: \n\nStep 1. The paper is divided into *n*2 identical squares and some of them are painted black according to the model.\n\nStep 2. Every square that remains white is divided into *n*2 smaller squares and some of them are painted black according to the model.\n\nEvery following step repeats step 2.\n\nUnfortunately, this tiresome work demands too much time from the painting genius. Kalevitch has been dreaming of making the process automatic to move to making 3D or even 4D fractals.\n\nInput Specification:\nThe first line contains integers *n* and *k* (2<=≤<=*n*<=≤<=3, 1<=≤<=*k*<=≤<=5), where *k* is the amount of steps of the algorithm. Each of the following *n* lines contains *n* symbols that determine the model. Symbol «.» stands for a white square, whereas «*» stands for a black one. It is guaranteed that the model has at least one white square.\n\nOutput Specification:\nOutput a matrix *n**k*<=×<=*n**k* which is what a picture should look like after *k* steps of the algorithm.\n\nDemo Input:\n['2 3\\n.*\\n..\\n', '3 2\\n.*.\\n***\\n.*.\\n']\n\nDemo Output:\n['.*******\\n..******\\n.*.*****\\n....****\\n.***.***\\n..**..**\\n.*.*.*.*\\n........\\n', '.*.***.*.\\n*********\\n.*.***.*.\\n*********\\n*********\\n*********\\n.*.***.*.\\n*********\\n.*.***.*.\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:14:52.851469",
      "status": "failed",
      "completion": "# Overview\nThis problem requires building a fractal pattern recursively. We start with an n×n model pattern where some cells are black (*) and others are white (.). At each step k, we replace every white cell with a scaled-down copy of the entire pattern, while black cells remain black. After k iterations, we output the final n^k × n^k matrix.\n\nThe approach:\n1. Parse input to get n, k, and the model pattern\n2. Build the fractal recursively: at each level, if a cell in the model is black, fill the corresponding region with black; if white, recurse with the pattern at the next level\n3. For efficiency, we can think of it as: at step k, the size is n^k × n^k, and we check each position by examining the model at each recursive level\n\n<CODE>\n```ballerina\n// Reasoning:\n// - At step 0, we would have just a 1x1 white square (conceptually)\n// - At step 1, we have the model itself (n x n)\n// - At step 2, each white square in the model is replaced by the model itself (n^2 x n^2)\n// - At step k, the final size is n^k x n^k\n//\n// To determine if position (row, col) is black in the final fractal:\n// - We recursively check at each level from k down to 1\n// - At each level i, we divide the position by n^(i-1) to find which cell of the model it belongs to\n// - If that model cell is black, the position is black\n// - If that model cell is white, we continue to the next level\n// - We check the position modulo n^(i-1) for the next iteration\n\nimport ballerina/io;\n\n// Function to determine if a position in the fractal is black\nfunction isBlack(int row, int col, int n, int k, string[] model) returns boolean {\n    int currentLevel = k;\n    int currentRow = row;\n    int currentCol = col;\n    \n    while currentLevel > 0 {\n        int size = pow(n, currentLevel - 1); // size of sub-fractal at this level\n        int modelRow = currentRow / size;\n        int modelCol = currentCol / size;\n        \n        // Check the model at this position\n        if modelRow < n && modelCol < n {\n            string rowStr = model[modelRow];\n            if rowStr[modelCol] == \"*\" {\n                return true; // Black cell in model means entire region is black\n            }\n            // White cell means we need to check deeper\n            currentRow = currentRow % size;\n            currentCol = currentCol % size;\n            currentLevel = currentLevel - 1;\n        } else {\n            return false;\n        }\n    }\n    \n    return false; // Base case (shouldn't reach here normally)\n}\n\n// Helper function to calculate power\nfunction pow(int base, int exp) returns int {\n    if exp == 0 {\n        return 1;\n    }\n    int result = 1;\n    int i = 0;\n    while i < exp {\n        result = result * base;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Main fractal generation function\nfunction generateFractal(int n, int k, string[] model) returns string[] {\n    int size = pow(n, k);\n    string[] result = [];\n    \n    int row = 0;\n    while row < size {\n        string line = \"\";\n        int col = 0;\n        while col < size {\n            if isBlack(row, col, n, k, model) {\n                line = line + \"*\";\n            } else {\n                line = line + \".\";\n            }\n            col = col + 1;\n        }\n        result.push(line);\n        row = row + 1;\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = firstLine.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int k = check 'int:fromString(parts[1]);\n    \n    // Read the model (n lines)\n    string[] model = [];\n    int i = 0;\n    while i < n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read model line\");\n        }\n        model.push(line.trim());\n        i = i + 1;\n    }\n    \n    // Generate and output the fractal\n    string[] fractal = generateFractal(n, k, model);\n    foreach string line in fractal {\n        io:println(line);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testPowFunction() {\n    test:assertEquals(pow(2, 0), 1);\n    test:assertEquals(pow(2, 3), 8);\n    test:assertEquals(pow(3, 2), 9);\n    test:assertEquals(pow(5, 1), 5);\n}\n\n@test:Config {}\nfunction testIsBlackSimple() {\n    string[] model = [\".*\", \"..\"];\n    // At k=1, position (0,0) should be white, (0,1) should be black\n    test:assertEquals(isBlack(0, 0, 2, 1, model), false);\n    test:assertEquals(isBlack(0, 1, 2, 1, model), true);\n    test:assertEquals(isBlack(1, 0, 2, 1, model), false);\n    test:assertEquals(isBlack(1, 1, 2, 1, model), false);\n}\n\n@test:Config {}\nfunction testGenerateFractalK1() {\n    string[] model = [\".*\", \"..\"];\n    string[] result = generateFractal(2, 1, model);\n    test:assertEquals(result.length(), 2);\n    test:assertEquals(result[0], \".*\");\n    test:assertEquals(result[1], \"..\");\n}\n\n@test:Config {}\nfunction testGenerateFractalK2() {\n    string[] model = [\".*\", \"..\"];\n    string[] result = generateFractal(2, 2, model);\n    test:assertEquals(result.length(), 4);\n    test:assertEquals(result[0], \".***\");\n    test:assertEquals(result[1], \"..**\");\n    test:assertEquals(result[2], \".*.*\");\n    test:assertEquals(result[3], \"....\");\n}\n\n@test:Config {}\nfunction testGenerateFractalN3K1() {\n    string[] model = [\".*.\", \"***\", \".*.\"];\n    string[] result = generateFractal(3, 1, model);\n    test:assertEquals(result.length(), 3);\n    test:assertEquals(result[0], \".*.\");\n    test:assertEquals(result[1], \"***\");\n    test:assertEquals(result[2], \".*.\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - At step 0, we would have just a 1x1 white square (conceptually)\n// - At step 1, we have the model itself (n x n)\n// - At step 2, each white square in the model is replaced by the model itself (n^2 x n^2)\n// - At step k, the final size is n^k x n^k\n//\n// To determine if position (row, col) is black in the final fractal:\n// - We recursively check at each level from k down to 1\n// - At each level i, we divide the position by n^(i-1) to find which cell of the model it belongs to\n// - If that model cell is black, the position is black\n// - If that model cell is white, we continue to the next level\n// - We check the position modulo n^(i-1) for the next iteration\n\nimport ballerina/io;\n\n// Function to determine if a position in the fractal is black\nfunction isBlack(int row, int col, int n, int k, string[] model) returns boolean {\n    int currentLevel = k;\n    int currentRow = row;\n    int currentCol = col;\n    \n    while currentLevel > 0 {\n        int size = pow(n, currentLevel - 1); // size of sub-fractal at this level\n        int modelRow = currentRow / size;\n        int modelCol = currentCol / size;\n        \n        // Check the model at this position\n        if modelRow < n && modelCol < n {\n            string rowStr = model[modelRow];\n            if rowStr[modelCol] == \"*\" {\n                return true; // Black cell in model means entire region is black\n            }\n            // White cell means we need to check deeper\n            currentRow = currentRow % size;\n            currentCol = currentCol % size;\n            currentLevel = currentLevel - 1;\n        } else {\n            return false;\n        }\n    }\n    \n    return false; // Base case (shouldn't reach here normally)\n}\n\n// Helper function to calculate power\nfunction pow(int base, int exp) returns int {\n    if exp == 0 {\n        return 1;\n    }\n    int result = 1;\n    int i = 0;\n    while i < exp {\n        result = result * base;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Main fractal generation function\nfunction generateFractal(int n, int k, string[] model) returns string[] {\n    int size = pow(n, k);\n    string[] result = [];\n    \n    int row = 0;\n    while row < size {\n        string line = \"\";\n        int col = 0;\n        while col < size {\n            if isBlack(row, col, n, k, model) {\n                line = line + \"*\";\n            } else {\n                line = line + \".\";\n            }\n            col = col + 1;\n        }\n        result.push(line);\n        row = row + 1;\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = firstLine.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int k = check 'int:fromString(parts[1]);\n    \n    // Read the model (n lines)\n    string[] model = [];\n    int i = 0;\n    while i < n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read model line\");\n        }\n        model.push(line.trim());\n        i = i + 1;\n    }\n    \n    // Generate and output the fractal\n    string[] fractal = generateFractal(n, k, model);\n    foreach string line in fractal {\n        io:println(line);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(90:39,90:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(90:39,90:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(90:39,90:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:15:25.695660",
      "status": "failed",
      "completion": "# Overview\nThis problem requires building a fractal pattern recursively. We start with an n×n model pattern where some cells are black (*) and others are white (.). At each step k, we replace every white cell with a scaled-down copy of the entire pattern, while black cells remain black. After k iterations, we output the final n^k × n^k matrix.\n\nThe key insight: To determine if position (row, col) is black at level k, we recursively check each level. At each level, we find which model cell the position maps to. If that model cell is black, the position is black. If white, we recurse into the sub-fractal.\n\nThe main fix needed: Use `regex:split()` from ballerina/regex instead of the non-existent `split()` method on string, or use alternative string parsing methods.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - At step k, the final size is n^k x n^k\n// - To determine if position (row, col) is black:\n//   * At each level from k down to 1, divide position by n^(level-1) to find which model cell\n//   * If model cell is black (*), position is black\n//   * If model cell is white (.), recurse into that cell with position % n^(level-1)\n// - We need to parse input carefully without using non-existent string.split()\n// - Use string:indexOf and substring operations for parsing\n\nimport ballerina/io;\n\n// Helper function to calculate power\nfunction pow(int base, int exp) returns int {\n    if exp == 0 {\n        return 1;\n    }\n    int result = 1;\n    int i = 0;\n    while i < exp {\n        result = result * base;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Function to determine if a position in the fractal is black\nfunction isBlack(int row, int col, int n, int k, string[] model) returns boolean {\n    int currentLevel = k;\n    int currentRow = row;\n    int currentCol = col;\n    \n    while currentLevel > 0 {\n        int size = pow(n, currentLevel - 1);\n        int modelRow = currentRow / size;\n        int modelCol = currentCol / size;\n        \n        // Get character from model\n        if modelRow >= 0 && modelRow < n && modelCol >= 0 && modelCol < n {\n            string rowStr = model[modelRow];\n            if modelCol < rowStr.length() {\n                string:Char ch = rowStr[modelCol];\n                if ch == \"*\" {\n                    return true;\n                }\n                // White cell, recurse deeper\n                currentRow = currentRow % size;\n                currentCol = currentCol % size;\n                currentLevel = currentLevel - 1;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n// Main fractal generation function\nfunction generateFractal(int n, int k, string[] model) returns string[] {\n    int size = pow(n, k);\n    string[] result = [];\n    \n    int row = 0;\n    while row < size {\n        string line = \"\";\n        int col = 0;\n        while col < size {\n            if isBlack(row, col, n, k, model) {\n                line = line + \"*\";\n            } else {\n                line = line + \".\";\n            }\n            col = col + 1;\n        }\n        result.push(line);\n        row = row + 1;\n    }\n    \n    return result;\n}\n\n// Helper function to parse two integers from a line\nfunction parseTwoInts(string line) returns [int, int]|error {\n    string trimmed = line.trim();\n    int spaceIndex = trimmed.indexOf(\" \");\n    \n    if spaceIndex < 0 {\n        return error(\"No space found in input\");\n    }\n    \n    string firstPart = trimmed.substring(0, spaceIndex);\n    string secondPart = trimmed.substring(spaceIndex + 1);\n    \n    int first = check 'int:fromString(firstPart.trim());\n    int second = check 'int:fromString(secondPart.trim());\n    \n    return [first, second];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    [int, int]|error parsed = parseTwoInts(firstLine);\n    if parsed is error {\n        return error(\"Invalid input format: \" + parsed.message());\n    }\n    \n    int n = parsed[0];\n    int k = parsed[1];\n    \n    // Read the model (n lines)\n    string[] model = [];\n    int i = 0;\n    while i < n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read model line\");\n        }\n        model.push(line.trim());\n        i = i + 1;\n    }\n    \n    // Generate and output the fractal\n    string[] fractal = generateFractal(n, k, model);\n    foreach string line in fractal {\n        io:println(line);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testPowFunction() {\n    test:assertEquals(pow(2, 0), 1);\n    test:assertEquals(pow(2, 3), 8);\n    test:assertEquals(pow(3, 2), 9);\n    test:assertEquals(pow(5, 1), 5);\n}\n\n@test:Config {}\nfunction testIsBlackSimple() {\n    string[] model = [\".*\", \"..\"];\n    // At k=1, position (0,0) should be white, (0,1) should be black\n    test:assertEquals(isBlack(0, 0, 2, 1, model), false);\n    test:assertEquals(isBlack(0, 1, 2, 1, model), true);\n    test:assertEquals(isBlack(1, 0, 2, 1, model), false);\n    test:assertEquals(isBlack(1, 1, 2, 1, model), false);\n}\n\n@test:Config {}\nfunction testGenerateFractalK1() {\n    string[] model = [\".*\", \"..\"];\n    string[] result = generateFractal(2, 1, model);\n    test:assertEquals(result.length(), 2);\n    test:assertEquals(result[0], \".*\");\n    test:assertEquals(result[1], \"..\");\n}\n\n@test:Config {}\nfunction testGenerateFractalK2() {\n    string[] model = [\".*\", \"..\"];\n    string[] result = generateFractal(2, 2, model);\n    test:assertEquals(result.length(), 4);\n    test:assertEquals(result[0], \".***\");\n    test:assertEquals(result[1], \"..**\");\n    test:assertEquals(result[2], \".*.*\");\n    test:assertEquals(result[3], \"....\");\n}\n\n@test:Config {}\nfunction testGenerateFractalN3K1() {\n    string[] model = [\".*.\", \"***\", \".*.\"];\n    string[] result = generateFractal(3, 1, model);\n    test:assertEquals(result.length(), 3);\n    test:assertEquals(result[0], \".*.\");\n    test:assertEquals(result[1], \"***\");\n    test:assertEquals(result[2], \".*.\");\n}\n\n@test:Config {}\nfunction testParseTwoInts() {\n    [int, int]|error result = parseTwoInts(\"2 3\");\n    test:assertTrue(result is [int, int]);\n    if result is [int, int] {\n        test:assertEquals(result[0], 2);\n        test:assertEquals(result[1], 3);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - At step k, the final size is n^k x n^k\n// - To determine if position (row, col) is black:\n//   * At each level from k down to 1, divide position by n^(level-1) to find which model cell\n//   * If model cell is black (*), position is black\n//   * If model cell is white (.), recurse into that cell with position % n^(level-1)\n// - We need to parse input carefully without using non-existent string.split()\n// - Use string:indexOf and substring operations for parsing\n\nimport ballerina/io;\n\n// Helper function to calculate power\nfunction pow(int base, int exp) returns int {\n    if exp == 0 {\n        return 1;\n    }\n    int result = 1;\n    int i = 0;\n    while i < exp {\n        result = result * base;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Function to determine if a position in the fractal is black\nfunction isBlack(int row, int col, int n, int k, string[] model) returns boolean {\n    int currentLevel = k;\n    int currentRow = row;\n    int currentCol = col;\n    \n    while currentLevel > 0 {\n        int size = pow(n, currentLevel - 1);\n        int modelRow = currentRow / size;\n        int modelCol = currentCol / size;\n        \n        // Get character from model\n        if modelRow >= 0 && modelRow < n && modelCol >= 0 && modelCol < n {\n            string rowStr = model[modelRow];\n            if modelCol < rowStr.length() {\n                string:Char ch = rowStr[modelCol];\n                if ch == \"*\" {\n                    return true;\n                }\n                // White cell, recurse deeper\n                currentRow = currentRow % size;\n                currentCol = currentCol % size;\n                currentLevel = currentLevel - 1;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n// Main fractal generation function\nfunction generateFractal(int n, int k, string[] model) returns string[] {\n    int size = pow(n, k);\n    string[] result = [];\n    \n    int row = 0;\n    while row < size {\n        string line = \"\";\n        int col = 0;\n        while col < size {\n            if isBlack(row, col, n, k, model) {\n                line = line + \"*\";\n            } else {\n                line = line + \".\";\n            }\n            col = col + 1;\n        }\n        result.push(line);\n        row = row + 1;\n    }\n    \n    return result;\n}\n\n// Helper function to parse two integers from a line\nfunction parseTwoInts(string line) returns [int, int]|error {\n    string trimmed = line.trim();\n    int spaceIndex = trimmed.indexOf(\" \");\n    \n    if spaceIndex < 0 {\n        return error(\"No space found in input\");\n    }\n    \n    string firstPart = trimmed.substring(0, spaceIndex);\n    string secondPart = trimmed.substring(spaceIndex + 1);\n    \n    int first = check 'int:fromString(firstPart.trim());\n    int second = check 'int:fromString(secondPart.trim());\n    \n    return [first, second];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    [int, int]|error parsed = parseTwoInts(firstLine);\n    if parsed is error {\n        return error(\"Invalid input format: \" + parsed.message());\n    }\n    \n    int n = parsed[0];\n    int k = parsed[1];\n    \n    // Read the model (n lines)\n    string[] model = [];\n    int i = 0;\n    while i < n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read model line\");\n        }\n        model.push(line.trim());\n        i = i + 1;\n    }\n    \n    // Generate and output the fractal\n    string[] fractal = generateFractal(n, k, model);\n    foreach string line in fractal {\n        io:println(line);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(87:22,87:42)] incompatible types: expected 'int', found 'int?'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(87:22,87:42)] incompatible types: expected 'int', found 'int?'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(87:22,87:42)] incompatible types: expected 'int', found 'int?'\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(87:22,87:42)] incompatible types: expected 'int', found 'int?'\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T02:15:52.918966"
}