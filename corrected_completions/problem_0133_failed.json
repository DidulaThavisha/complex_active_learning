{
  "entry_id": "problem_0133",
  "problem_index": 133,
  "prompt": "Title: Too Easy Problems\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou are preparing for an exam on scheduling theory. The exam will last for exactly *T* milliseconds and will consist of *n* problems. You can either solve problem *i* in exactly *t**i* milliseconds or ignore it and spend no time. You don't need time to rest after solving a problem, either.\n\nUnfortunately, your teacher considers some of the problems too easy for you. Thus, he assigned an integer *a**i* to every problem *i* meaning that the problem *i* can bring you a point to the final score only in case you have solved no more than *a**i* problems overall (including problem *i*).\n\nFormally, suppose you solve problems *p*1,<=*p*2,<=...,<=*p**k* during the exam. Then, your final score *s* will be equal to the number of values of *j* between 1 and *k* such that *k*<=≤<=*a**p**j*.\n\nYou have guessed that the real first problem of the exam is already in front of you. Therefore, you want to choose a set of problems to solve during the exam maximizing your final score in advance. Don't forget that the exam is limited in time, and you must have enough time to solve all chosen problems. If there exist different sets of problems leading to the maximum final score, any of them will do.\n\nInput Specification:\nThe first line contains two integers *n* and *T* (1<=≤<=*n*<=≤<=2·105; 1<=≤<=*T*<=≤<=109) — the number of problems in the exam and the length of the exam in milliseconds, respectively.\n\nEach of the next *n* lines contains two integers *a**i* and *t**i* (1<=≤<=*a**i*<=≤<=*n*; 1<=≤<=*t**i*<=≤<=104). The problems are numbered from 1 to *n*.\n\nOutput Specification:\nIn the first line, output a single integer *s* — your maximum possible final score.\n\nIn the second line, output a single integer *k* (0<=≤<=*k*<=≤<=*n*) — the number of problems you should solve.\n\nIn the third line, output *k* distinct integers *p*1,<=*p*2,<=...,<=*p**k* (1<=≤<=*p**i*<=≤<=*n*) — the indexes of problems you should solve, in any order.\n\nIf there are several optimal sets of problems, you may output any of them.\n\nDemo Input:\n['5 300\\n3 100\\n4 150\\n4 80\\n2 90\\n2 300\\n', '2 100\\n1 787\\n2 788\\n', '2 100\\n2 42\\n2 58\\n']\n\nDemo Output:\n['2\\n3\\n3 1 4\\n', '0\\n0\\n\\n', '2\\n2\\n1 2\\n']\n\nNote:\nIn the first example, you should solve problems 3, 1, and 4. In this case you'll spend 80 + 100 + 90 = 270 milliseconds, falling within the length of the exam, 300 milliseconds (and even leaving yourself 30 milliseconds to have a rest). Problems 3 and 1 will bring you a point each, while problem 4 won't. You'll score two points.\n\nIn the second example, the length of the exam is catastrophically not enough to solve even a single problem.\n\nIn the third example, you have just enough time to solve both problems in 42 + 58 = 100 milliseconds and hand your solutions to the teacher with a smile.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:20:31.192287",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to select a subset of problems to solve during an exam to maximize the score. Each problem has a time cost and a constraint: problem i only gives a point if we solve at most `a[i]` problems total. The strategy is to sort problems by their constraint value `a[i]` in ascending order, then greedily select problems that fit within the time limit while maximizing score.\n\nThe key insight: if we solve k problems, only those with `a[i] >= k` will contribute to the score. So we try different values of k and for each k, we select the k problems with `a[i] >= k` that have the smallest time costs.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. For a given number of problems k to solve, only problems with a[i] >= k will score\n// 2. We should try all possible values of k (0 to n) and find which gives max score\n// 3. For each k, select the k problems with a[i] >= k that have minimum time costs\n// 4. Check if total time <= T, and count how many actually score (those with a[i] >= k)\n// 5. Track the best configuration\n\nimport ballerina/io;\n\ntype Problem record {\n    int index;\n    int a;\n    int t;\n};\n\nfunction solveTooEasyProblems(int n, int T, Problem[] problems) returns [int, int[]] {\n    int maxScore = 0;\n    int[] bestSolution = [];\n    \n    // Try solving k problems (k from 0 to n)\n    foreach int k in 0...n {\n        if k == 0 {\n            continue;\n        }\n        \n        // Filter problems where a[i] >= k (these can potentially score)\n        Problem[] candidates = [];\n        foreach Problem p in problems {\n            if p.a >= k {\n                candidates.push(p);\n            }\n        }\n        \n        // If we don't have k candidates, skip\n        if candidates.length() < k {\n            continue;\n        }\n        \n        // Sort candidates by time (ascending) to pick k cheapest ones\n        Problem[] sortedCandidates = candidates.clone();\n        // Simple bubble sort for time\n        int len = sortedCandidates.length();\n        foreach int i in 0..<len {\n            foreach int j in 0..<(len - i - 1) {\n                if sortedCandidates[j].t > sortedCandidates[j + 1].t {\n                    Problem temp = sortedCandidates[j];\n                    sortedCandidates[j] = sortedCandidates[j + 1];\n                    sortedCandidates[j + 1] = temp;\n                }\n            }\n        }\n        \n        // Take first k problems (cheapest)\n        int totalTime = 0;\n        int[] selectedIndices = [];\n        foreach int i in 0..<k {\n            totalTime += sortedCandidates[i].t;\n            selectedIndices.push(sortedCandidates[i].index);\n        }\n        \n        // Check if time constraint is satisfied\n        if totalTime <= T {\n            // Score is the number of problems where a[i] >= k (which is k for all selected)\n            int score = k;\n            if score > maxScore {\n                maxScore = score;\n                bestSolution = selectedIndices;\n            }\n        }\n    }\n    \n    return [maxScore, bestSolution];\n}\n\npublic function main() returns error? {\n    // Read first line: n and T\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int T = check 'int:fromString(parts1[1]);\n    \n    // Read n problems\n    Problem[] problems = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read problem line\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid problem line format\");\n        }\n        \n        int a = check 'int:fromString(parts[0]);\n        int t = check 'int:fromString(parts[1]);\n        \n        problems.push({index: i + 1, a: a, t: t});\n    }\n    \n    // Solve the problem\n    [int score, int[] solution] = solveTooEasyProblems(n, T, problems);\n    \n    // Output results\n    io:println(score);\n    io:println(solution.length());\n    if solution.length() > 0 {\n        string output = \"\";\n        foreach int i in 0..<solution.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += solution[i].toString();\n        }\n        io:println(output);\n    } else {\n        io:println(\"\");\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Problem[] problems = [\n        {index: 1, a: 3, t: 100},\n        {index: 2, a: 4, t: 150},\n        {index: 3, a: 4, t: 80},\n        {index: 4, a: 2, t: 90},\n        {index: 5, a: 2, t: 300}\n    ];\n    \n    [int score, int[] solution] = solveTooEasyProblems(5, 300, problems);\n    test:assertEquals(score, 2);\n    test:assertEquals(solution.length(), 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    Problem[] problems = [\n        {index: 1, a: 1, t: 787},\n        {index: 2, a: 2, t: 788}\n    ];\n    \n    [int score, int[] solution] = solveTooEasyProblems(2, 100, problems);\n    test:assertEquals(score, 0);\n    test:assertEquals(solution.length(), 0);\n}\n\n@test:Config {}\nfunction testExample3() {\n    Problem[] problems = [\n        {index: 1, a: 2, t: 42},\n        {index: 2, a: 2, t: 58}\n    ];\n    \n    [int score, int[] solution] = solveTooEasyProblems(2, 100, problems);\n    test:assertEquals(score, 2);\n    test:assertEquals(solution.length(), 2);\n}\n\n@test:Config {}\nfunction testSingleProblem() {\n    Problem[] problems = [\n        {index: 1, a: 1, t: 50}\n    ];\n    \n    [int score, int[] solution] = solveTooEasyProblems(1, 100, problems);\n    test:assertEquals(score, 1);\n    test:assertEquals(solution.length(), 1);\n    test:assertEquals(solution[0], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. For a given number of problems k to solve, only problems with a[i] >= k will score\n// 2. We should try all possible values of k (0 to n) and find which gives max score\n// 3. For each k, select the k problems with a[i] >= k that have minimum time costs\n// 4. Check if total time <= T, and count how many actually score (those with a[i] >= k)\n// 5. Track the best configuration\n\nimport ballerina/io;\n\ntype Problem record {\n    int index;\n    int a;\n    int t;\n};\n\nfunction solveTooEasyProblems(int n, int T, Problem[] problems) returns [int, int[]] {\n    int maxScore = 0;\n    int[] bestSolution = [];\n    \n    // Try solving k problems (k from 0 to n)\n    foreach int k in 0...n {\n        if k == 0 {\n            continue;\n        }\n        \n        // Filter problems where a[i] >= k (these can potentially score)\n        Problem[] candidates = [];\n        foreach Problem p in problems {\n            if p.a >= k {\n                candidates.push(p);\n            }\n        }\n        \n        // If we don't have k candidates, skip\n        if candidates.length() < k {\n            continue;\n        }\n        \n        // Sort candidates by time (ascending) to pick k cheapest ones\n        Problem[] sortedCandidates = candidates.clone();\n        // Simple bubble sort for time\n        int len = sortedCandidates.length();\n        foreach int i in 0..<len {\n            foreach int j in 0..<(len - i - 1) {\n                if sortedCandidates[j].t > sortedCandidates[j + 1].t {\n                    Problem temp = sortedCandidates[j];\n                    sortedCandidates[j] = sortedCandidates[j + 1];\n                    sortedCandidates[j + 1] = temp;\n                }\n            }\n        }\n        \n        // Take first k problems (cheapest)\n        int totalTime = 0;\n        int[] selectedIndices = [];\n        foreach int i in 0..<k {\n            totalTime += sortedCandidates[i].t;\n            selectedIndices.push(sortedCandidates[i].index);\n        }\n        \n        // Check if time constraint is satisfied\n        if totalTime <= T {\n            // Score is the number of problems where a[i] >= k (which is k for all selected)\n            int score = k;\n            if score > maxScore {\n                maxScore = score;\n                bestSolution = selectedIndices;\n            }\n        }\n    }\n    \n    return [maxScore, bestSolution];\n}\n\npublic function main() returns error? {\n    // Read first line: n and T\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int T = check 'int:fromString(parts1[1]);\n    \n    // Read n problems\n    Problem[] problems = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read problem line\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid problem line format\");\n        }\n        \n        int a = check 'int:fromString(parts[0]);\n        int t = check 'int:fromString(parts[1]);\n        \n        problems.push({index: i + 1, a: a, t: t});\n    }\n    \n    // Solve the problem\n    [int score, int[] solution] = solveTooEasyProblems(n, T, problems);\n    \n    // Output results\n    io:println(score);\n    io:println(solution.length());\n    if solution.length() > 0 {\n        string output = \"\";\n        foreach int i in 0..<solution.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += solution[i].toString();\n        }\n        io:println(output);\n    } else {\n        io:println(\"\");\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(82:36,82:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(98:38,98:43)] undefined function 'split' in type 'string'\nERROR [main.bal:(110:10,110:10)] missing comma token\nERROR [main.bal:(110:10,110:15)] unknown type 'score'\nERROR [main.bal:(110:23,110:23)] missing comma token\nERROR [main.bal:(110:23,110:31)] unknown type 'solution'\nERROR [main.bal:(110:33,110:33)] missing identifier\nERROR [main.bal:(110:35,110:71)] incompatible types: expected '[int,other,int[],o",
      "error": "Compilation error: ERROR [main.bal:(82:36,82:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(98:38,98:43)] undefined function 'split' in type 'string'\nERROR [main.bal:(110:10,110:10)] missing comma token\nERROR [main.bal:(110:10,110:15)] unknown type 'score'\nERROR [main.bal:(110:23,110:23)] missing comma token\nERROR [main.bal:(110:23,110:31)] unknown type 'solution'\nERROR [main.bal:(110:33,110:33)] missing identifier\nERROR [main.bal:(110:35,110:71)] incompatible types: expected '[int,other,int[],o",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(82:36,82:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(98:38,98:43)] undefined function 'split' in type 'string'\nERROR [main.bal:(110:10,110:10)] missing comma token\nERROR [main.bal:(110:10,110:15)] unknown type 'score'\nERROR [main.bal:(110:23,110:23)] missing comma token\nERROR [main.bal:(110:23,110:31)] unknown type 'solution'\nERROR [main.bal:(110:33,110:33)] missing identifier\nERROR [main.bal:(110:35,110:71)] incompatible types: expected '[int,other,int[],other]', found '[int,int[]]'\nERROR [main.bal:(113:16,113:21)] undefined symbol 'score'\nERROR [main.bal:(114:16,114:24)] undefined symbol 'solution'\nERROR [main.bal:(115:8,115:16)] undefined symbol 'solution'\nERROR [main.bal:(117:30,117:38)] undefined symbol 'solution'\nERROR [main.bal:(121:23,121:31)] undefined symbol 'solution'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:20:59.645623",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to select a subset of problems to solve during an exam to maximize the score. Each problem has a time cost and a constraint: problem i only gives a point if we solve at most `a[i]` problems total. The strategy is to sort problems by their constraint value `a[i]` in ascending order, then greedily select problems that fit within the time limit while maximizing score.\n\nThe key insight: if we solve k problems, only those with `a[i] >= k` will contribute to the score. So we try different values of k and for each k, we select the k problems with `a[i] >= k` that have the smallest time costs.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. For a given number of problems k to solve, only problems with a[i] >= k will score\n// 2. We should try all possible values of k (0 to n) and find which gives max score\n// 3. For each k, select the k problems with a[i] >= k that have minimum time costs\n// 4. Check if total time <= T, and count how many actually score (those with a[i] >= k)\n// 5. Track the best configuration\n// 6. Need to import ballerina/lang.string for split, use regex:split instead\n\nimport ballerina/io;\nimport ballerina/lang.'int;\n\ntype Problem record {\n    int index;\n    int a;\n    int t;\n};\n\nfunction solveTooEasyProblems(int n, int T, Problem[] problems) returns [int, int[]] {\n    int maxScore = 0;\n    int[] bestSolution = [];\n    \n    // Try solving k problems (k from 0 to n)\n    foreach int k in 0...n {\n        if k == 0 {\n            continue;\n        }\n        \n        // Filter problems where a[i] >= k (these can potentially score)\n        Problem[] candidates = [];\n        foreach Problem p in problems {\n            if p.a >= k {\n                candidates.push(p);\n            }\n        }\n        \n        // If we don't have k candidates, skip\n        if candidates.length() < k {\n            continue;\n        }\n        \n        // Sort candidates by time (ascending) to pick k cheapest ones\n        Problem[] sortedCandidates = candidates.clone();\n        // Simple bubble sort for time\n        int len = sortedCandidates.length();\n        foreach int i in 0..<len {\n            foreach int j in 0..<(len - i - 1) {\n                if sortedCandidates[j].t > sortedCandidates[j + 1].t {\n                    Problem temp = sortedCandidates[j];\n                    sortedCandidates[j] = sortedCandidates[j + 1];\n                    sortedCandidates[j + 1] = temp;\n                }\n            }\n        }\n        \n        // Take first k problems (cheapest)\n        int totalTime = 0;\n        int[] selectedIndices = [];\n        foreach int i in 0..<k {\n            totalTime += sortedCandidates[i].t;\n            selectedIndices.push(sortedCandidates[i].index);\n        }\n        \n        // Check if time constraint is satisfied\n        if totalTime <= T {\n            // Score is the number of problems where a[i] >= k (which is k for all selected)\n            int score = k;\n            if score > maxScore {\n                maxScore = score;\n                bestSolution = selectedIndices;\n            }\n        }\n    }\n    \n    return [maxScore, bestSolution];\n}\n\nfunction splitString(string input, string delimiter) returns string[] {\n    string[] result = [];\n    string current = \"\";\n    int i = 0;\n    while i < input.length() {\n        string char = input.substring(i, i + 1);\n        if char == delimiter {\n            if current.length() > 0 {\n                result.push(current);\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i = i + 1;\n    }\n    if current.length() > 0 {\n        result.push(current);\n    }\n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n and T\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = splitString(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int T = check 'int:fromString(parts1[1]);\n    \n    // Read n problems\n    Problem[] problems = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read problem line\");\n        }\n        \n        string[] parts = splitString(line.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid problem line format\");\n        }\n        \n        int a = check 'int:fromString(parts[0]);\n        int t = check 'int:fromString(parts[1]);\n        \n        problems.push({index: i + 1, a: a, t: t});\n    }\n    \n    // Solve the problem\n    int score;\n    int[] solution;\n    [score, solution] = solveTooEasyProblems(n, T, problems);\n    \n    // Output results\n    io:println(score);\n    io:println(solution.length());\n    if solution.length() > 0 {\n        string output = \"\";\n        foreach int i in 0..<solution.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += solution[i].toString();\n        }\n        io:println(output);\n    } else {\n        io:println(\"\");\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    Problem[] problems = [\n        {index: 1, a: 3, t: 100},\n        {index: 2, a: 4, t: 150},\n        {index: 3, a: 4, t: 80},\n        {index: 4, a: 2, t: 90},\n        {index: 5, a: 2, t: 300}\n    ];\n    \n    int score;\n    int[] solution;\n    [score, solution] = solveTooEasyProblems(5, 300, problems);\n    test:assertEquals(score, 2);\n    test:assertEquals(solution.length(), 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    Problem[] problems = [\n        {index: 1, a: 1, t: 787},\n        {index: 2, a: 2, t: 788}\n    ];\n    \n    int score;\n    int[] solution;\n    [score, solution] = solveTooEasyProblems(2, 100, problems);\n    test:assertEquals(score, 0);\n    test:assertEquals(solution.length(), 0);\n}\n\n@test:Config {}\nfunction testExample3() {\n    Problem[] problems = [\n        {index: 1, a: 2, t: 42},\n        {index: 2, a: 2, t: 58}\n    ];\n    \n    int score;\n    int[] solution;\n    [score, solution] = solveTooEasyProblems(2, 100, problems);\n    test:assertEquals(score, 2);\n    test:assertEquals(solution.length(), 2);\n}\n\n@test:Config {}\nfunction testSingleProblem() {\n    Problem[] problems = [\n        {index: 1, a: 1, t: 50}\n    ];\n    \n    int score;\n    int[] solution;\n    [score, solution] = solveTooEasyProblems(1, 100, problems);\n    test:assertEquals(score, 1);\n    test:assertEquals(solution.length(), 1);\n    test:assertEquals(solution[0], 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. For a given number of problems k to solve, only problems with a[i] >= k will score\n// 2. We should try all possible values of k (0 to n) and find which gives max score\n// 3. For each k, select the k problems with a[i] >= k that have minimum time costs\n// 4. Check if total time <= T, and count how many actually score (those with a[i] >= k)\n// 5. Track the best configuration\n// 6. Need to import ballerina/lang.string for split, use regex:split instead\n\nimport ballerina/io;\nimport ballerina/lang.'int;\n\ntype Problem record {\n    int index;\n    int a;\n    int t;\n};\n\nfunction solveTooEasyProblems(int n, int T, Problem[] problems) returns [int, int[]] {\n    int maxScore = 0;\n    int[] bestSolution = [];\n    \n    // Try solving k problems (k from 0 to n)\n    foreach int k in 0...n {\n        if k == 0 {\n            continue;\n        }\n        \n        // Filter problems where a[i] >= k (these can potentially score)\n        Problem[] candidates = [];\n        foreach Problem p in problems {\n            if p.a >= k {\n                candidates.push(p);\n            }\n        }\n        \n        // If we don't have k candidates, skip\n        if candidates.length() < k {\n            continue;\n        }\n        \n        // Sort candidates by time (ascending) to pick k cheapest ones\n        Problem[] sortedCandidates = candidates.clone();\n        // Simple bubble sort for time\n        int len = sortedCandidates.length();\n        foreach int i in 0..<len {\n            foreach int j in 0..<(len - i - 1) {\n                if sortedCandidates[j].t > sortedCandidates[j + 1].t {\n                    Problem temp = sortedCandidates[j];\n                    sortedCandidates[j] = sortedCandidates[j + 1];\n                    sortedCandidates[j + 1] = temp;\n                }\n            }\n        }\n        \n        // Take first k problems (cheapest)\n        int totalTime = 0;\n        int[] selectedIndices = [];\n        foreach int i in 0..<k {\n            totalTime += sortedCandidates[i].t;\n            selectedIndices.push(sortedCandidates[i].index);\n        }\n        \n        // Check if time constraint is satisfied\n        if totalTime <= T {\n            // Score is the number of problems where a[i] >= k (which is k for all selected)\n            int score = k;\n            if score > maxScore {\n                maxScore = score;\n                bestSolution = selectedIndices;\n            }\n        }\n    }\n    \n    return [maxScore, bestSolution];\n}\n\nfunction splitString(string input, string delimiter) returns string[] {\n    string[] result = [];\n    string current = \"\";\n    int i = 0;\n    while i < input.length() {\n        string char = input.substring(i, i + 1);\n        if char == delimiter {\n            if current.length() > 0 {\n                result.push(current);\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i = i + 1;\n    }\n    if current.length() > 0 {\n        result.push(current);\n    }\n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n and T\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = splitString(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid first line format\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int T = check 'int:fromString(parts1[1]);\n    \n    // Read n problems\n    Problem[] problems = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read problem line\");\n        }\n        \n        string[] parts = splitString(line.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid problem line format\");\n        }\n        \n        int a = check 'int:fromString(parts[0]);\n        int t = check 'int:fromString(parts[1]);\n        \n        problems.push({index: i + 1, a: a, t: t});\n    }\n    \n    // Solve the problem\n    int score;\n    int[] solution;\n    [score, solution] = solveTooEasyProblems(n, T, problems);\n    \n    // Output results\n    io:println(score);\n    io:println(solution.length());\n    if solution.length() > 0 {\n        string output = \"\";\n        foreach int i in 0..<solution.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += solution[i].toString();\n        }\n        io:println(output);\n    } else {\n        io:println(\"\");\n    }\n    \n    return;\n}",
      "tests_passed": 2,
      "tests_total": 3,
      "tests_pass_rate": 0.6666666666666666,
      "validation_msg": "Only passed 2/3 tests (66.7%), need 75%",
      "error": "Only passed 2/3 tests (66.7%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5 300\n3 100\n4 150\n4 80\n2 90\n2 300\n",
          "expected_output": "2\n3\n3 1 4\n",
          "actual_output": "2\n2\n3 4\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 2/3 tests (66.7%), need 75%",
  "timestamp": "2026-01-05T02:21:34.839256"
}