{
  "entry_id": "problem_0140",
  "problem_index": 140,
  "prompt": "Title: Shockers\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nValentin participates in a show called \"Shockers\". The rules are quite easy: jury selects one letter which Valentin doesn't know. He should make a small speech, but every time he pronounces a word that contains the selected letter, he receives an electric shock. He can make guesses which letter is selected, but for each incorrect guess he receives an electric shock too. The show ends when Valentin guesses the selected letter correctly.\n\nValentin can't keep in mind everything, so he could guess the selected letter much later than it can be uniquely determined and get excessive electric shocks. Excessive electric shocks are those which Valentin got after the moment the selected letter can be uniquely determined. You should find out the number of excessive electric shocks.\n\nInput Specification:\nThe first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of actions Valentin did.\n\nThe next *n* lines contain descriptions of his actions, each line contains description of one action. Each action can be of one of three types: \n 1.  Valentin pronounced some word and didn't get an electric shock. This action is described by the string \". w\" (without quotes), in which \".\" is a dot (ASCII-code 46), and *w* is the word that Valentin said. 1.  Valentin pronounced some word and got an electric shock. This action is described by the string \"! w\" (without quotes), in which \"!\" is an exclamation mark (ASCII-code 33), and *w* is the word that Valentin said. 1.  Valentin made a guess about the selected letter. This action is described by the string \"? s\" (without quotes), in which \"?\" is a question mark (ASCII-code 63), and *s* is the guess — a lowercase English letter. \nAll words consist only of lowercase English letters. The total length of all words does not exceed 105.\n\nIt is guaranteed that last action is a guess about the selected letter. Also, it is guaranteed that Valentin didn't make correct guesses about the selected letter before the last action. Moreover, it's guaranteed that if Valentin got an electric shock after pronouncing some word, then it contains the selected letter; and also if Valentin didn't get an electric shock after pronouncing some word, then it does not contain the selected letter.\n\nOutput Specification:\nOutput a single integer — the number of electric shocks that Valentin could have avoided if he had told the selected letter just after it became uniquely determined.\n\nDemo Input:\n['5\\n! abc\\n. ad\\n. b\\n! cd\\n? c\\n', '8\\n! hello\\n! codeforces\\n? c\\n. o\\n? d\\n? h\\n. l\\n? e\\n', '7\\n! ababahalamaha\\n? a\\n? b\\n? a\\n? b\\n? a\\n? h\\n']\n\nDemo Output:\n['1\\n', '2\\n', '0\\n']\n\nNote:\nIn the first test case after the first action it becomes clear that the selected letter is one of the following: *a*, *b*, *c*. After the second action we can note that the selected letter is not *a*. Valentin tells word \"b\" and doesn't get a shock. After that it is clear that the selected letter is *c*, but Valentin pronounces the word *cd* and gets an excessive electric shock. \n\nIn the second test case after the first two electric shocks we understand that the selected letter is *e* or *o*. Valentin tries some words consisting of these letters and after the second word it's clear that the selected letter is *e*, but Valentin makes 3 more actions before he makes a correct hypothesis.\n\nIn the third example the selected letter can be uniquely determined only when Valentin guesses it, so he didn't get excessive electric shocks.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the error, the issue is that I'm trying to remove keys from the map that may not exist. When processing \". ad\", the letter 'd' might not be in the candidates map anymore (or never was added properly).\n\nLet me analyze the problem more carefully:\n\n1. We start with all 26 letters as candidates\n2. For \". word\" - remove all letters IN the word from candidates (only if they exist)\n3. For \"! word\" - keep ONLY letters that are in BOTH candidates AND the word\n4. For \"? letter\" - remove that letter from candidates (only if it exists)\n5. Track when we have exactly 1 candidate left\n6. Count shocks AFTER that determination point\n\nThe bug is in the remove operation - I need to check if the key exists before removing, or simply not error if it doesn't exist.\n\n# Overview\nThis problem tracks when a secret letter becomes uniquely determined by eliminating possibilities through observations. We maintain a set of candidate letters, process each action to narrow down candidates, detect when only one letter remains, and count electric shocks received after that point.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Maintain a set of candidate letters (initially all 26 lowercase letters)\n// 2. Process each action to update candidates:\n//    - \". word\": word has NO selected letter -> remove all letters in word from candidates\n//    - \"! word\": word HAS the selected letter -> intersect candidates with letters in word\n//    - \"? letter\": incorrect guess -> remove this letter from candidates\n// 3. Detect when candidates.length() becomes 1 (uniquely determined)\n// 4. Count shocks (! and ?) that occur AFTER unique determination\n// 5. The last action is always the correct guess, so we don't count it\n\nimport ballerina/io;\n\nfunction countExcessiveShocks(int n, string[] actions) returns int|error {\n    // Initialize candidates with all lowercase letters a-z\n    map<boolean> candidates = {};\n    foreach int i in 0...25 {\n        string letter = check string:fromCodePointInt(97 + i); // ASCII 'a' = 97\n        candidates[letter] = true;\n    }\n    \n    int determinedAt = -1; // Action index when letter becomes uniquely determined\n    int excessiveShocks = 0;\n    \n    foreach int i in 0..<n {\n        string action = actions[i];\n        \n        if action.length() < 3 {\n            return error(\"Invalid action format\");\n        }\n        \n        string actionType = action.substring(0, 1);\n        string content = action.substring(2);\n        \n        if actionType == \".\" {\n            // Word without shock - remove all its letters from candidates\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                if candidates.hasKey(char) {\n                    _ = candidates.remove(char);\n                }\n            }\n        } else if actionType == \"!\" {\n            // Word with shock - intersect candidates with letters in this word\n            // First, build set of unique letters in the word\n            map<boolean> wordLetters = {};\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                wordLetters[char] = true;\n            }\n            \n            // Keep only letters that are in BOTH candidates and wordLetters\n            map<boolean> newCandidates = {};\n            foreach string letter in candidates.keys() {\n                if wordLetters.hasKey(letter) {\n                    newCandidates[letter] = true;\n                }\n            }\n            candidates = newCandidates;\n            \n            // If already determined, this shock is excessive\n            if determinedAt >= 0 && determinedAt < i {\n                excessiveShocks += 1;\n            }\n        } else if actionType == \"?\" {\n            // Incorrect guess - remove this letter from candidates\n            if candidates.hasKey(content) {\n                _ = candidates.remove(content);\n            }\n            \n            // If already determined and NOT the last action, this shock is excessive\n            // Last action is the correct guess, so we don't count it\n            if determinedAt >= 0 && determinedAt < i && i < n - 1 {\n                excessiveShocks += 1;\n            }\n        }\n        \n        // Check if letter is now uniquely determined (after processing this action)\n        if determinedAt < 0 && candidates.length() == 1 {\n            determinedAt = i;\n        }\n    }\n    \n    return excessiveShocks;\n}\n\npublic function main() returns error? {\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"No input provided\");\n    }\n    \n    int n = check int:fromString(firstLine.trim());\n    \n    string[] actions = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Insufficient input lines\");\n        }\n        actions.push(line.trim());\n    }\n    \n    int result = check countExcessiveShocks(n, actions);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() returns error? {\n    string[] actions = [\n        \"! abc\",\n        \". ad\",\n        \". b\",\n        \"! cd\",\n        \"? c\"\n    ];\n    int result = check countExcessiveShocks(5, actions);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample2() returns error? {\n    string[] actions = [\n        \"! hello\",\n        \"! codeforces\",\n        \"? c\",\n        \". o\",\n        \"? d\",\n        \"? h\",\n        \". l\",\n        \"? e\"\n    ];\n    int result = check countExcessiveShocks(8, actions);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample3() returns error? {\n    string[] actions = [\n        \"! ababahalamaha\",\n        \"? a\",\n        \"? b\",\n        \"? a\",\n        \"? b\",\n        \"? a\",\n        \"? h\"\n    ];\n    int result = check countExcessiveShocks(7, actions);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testSimpleCase() returns error? {\n    string[] actions = [\n        \"! abc\",\n        \". a\",\n        \". b\",\n        \"? c\"\n    ];\n    int result = check countExcessiveShocks(4, actions);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Maintain a set of candidate letters (initially all 26 lowercase letters)\n// 2. Process each action to update candidates:\n//    - \". word\": word has NO selected letter -> remove all letters in word from candidates\n//    - \"! word\": word HAS the selected letter -> intersect candidates with letters in word\n//    - \"? letter\": incorrect guess -> remove this letter from candidates\n// 3. Detect when candidates.length() becomes 1 (uniquely determined)\n// 4. Count shocks (! and ?) that occur AFTER unique determination\n// 5. The last action is always the correct guess, so we don't count it\n\nimport ballerina/io;\n\nfunction countExcessiveShocks(int n, string[] actions) returns int|error {\n    // Initialize candidates with all lowercase letters a-z\n    map<boolean> candidates = {};\n    foreach int i in 0...25 {\n        string letter = check string:fromCodePointInt(97 + i); // ASCII 'a' = 97\n        candidates[letter] = true;\n    }\n    \n    int determinedAt = -1; // Action index when letter becomes uniquely determined\n    int excessiveShocks = 0;\n    \n    foreach int i in 0..<n {\n        string action = actions[i];\n        \n        if action.length() < 3 {\n            return error(\"Invalid action format\");\n        }\n        \n        string actionType = action.substring(0, 1);\n        string content = action.substring(2);\n        \n        if actionType == \".\" {\n            // Word without shock - remove all its letters from candidates\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                if candidates.hasKey(char) {\n                    _ = candidates.remove(char);\n                }\n            }\n        } else if actionType == \"!\" {\n            // Word with shock - intersect candidates with letters in this word\n            // First, build set of unique letters in the word\n            map<boolean> wordLetters = {};\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                wordLetters[char] = true;\n            }\n            \n            // Keep only letters that are in BOTH candidates and wordLetters\n            map<boolean> newCandidates = {};\n            foreach string letter in candidates.keys() {\n                if wordLetters.hasKey(letter) {\n                    newCandidates[letter] = true;\n                }\n            }\n            candidates = newCandidates;\n            \n            // If already determined, this shock is excessive\n            if determinedAt >= 0 && determinedAt < i {\n                excessiveShocks += 1;\n            }\n        } else if actionType == \"?\" {\n            // Incorrect guess - remove this letter from candidates\n            if candidates.hasKey(content) {\n                _ = candidates.remove(content);\n            }\n            \n            // If already determined and NOT the last action, this shock is excessive\n            // Last action is the correct guess, so we don't count it\n            if determinedAt >= 0 && determinedAt < i && i < n - 1 {\n                excessiveShocks += 1;\n            }\n        }\n        \n        // Check if letter is now uniquely determined (after processing this action)\n        if determinedAt < 0 && candidates.length() == 1 {\n            determinedAt = i;\n        }\n    }\n    \n    return excessiveShocks;\n}\n\npublic function main() returns error? {\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"No input provided\");\n    }\n    \n    int n = check int:fromString(firstLine.trim());\n    \n    string[] actions = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Insufficient input lines\");\n        }\n        actions.push(line.trim());\n    }\n    \n    int result = check countExcessiveShocks(n, actions);\n    io:println(result);\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:28:06.327887",
      "status": "failed",
      "completion": "# Overview\nThis problem requires us to determine when the selected letter becomes uniquely determined, and count how many electric shocks Valentin received after that point. We need to:\n1. Track possible letters (start with all 26 letters)\n2. For words without shock (.), eliminate all letters in that word from possibilities\n3. For words with shock (!), keep only letters that appear in that word\n4. For incorrect guesses (?), eliminate that letter from possibilities\n5. Find when only 1 letter remains and count shocks after that point\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Start with a set of all 26 lowercase letters as possible candidates\n// 2. Process each action:\n//    - \". word\" -> remove all letters in word from candidates (word doesn't contain selected letter)\n//    - \"! word\" -> keep only letters that are both in candidates AND in word (word contains selected letter)\n//    - \"? letter\" -> remove that letter from candidates (incorrect guess)\n// 3. Track when candidates becomes a singleton (uniquely determined)\n// 4. Count shocks after that point (! actions and ? actions both cause shocks)\n\nimport ballerina/io;\n\nfunction countExcessiveShocks(int n, string[] actions) returns int|error {\n    // Initialize set of possible letters (a-z)\n    map<boolean> candidates = {};\n    foreach int i in 0...25 {\n        string letter = check string:fromCodePointInt(97 + i); // 'a' = 97\n        candidates[letter] = true;\n    }\n    \n    int determinedAt = -1; // Index when letter becomes uniquely determined\n    int excessiveShocks = 0;\n    \n    foreach int i in 0..<n {\n        string action = actions[i];\n        \n        if action.length() < 3 {\n            return error(\"Invalid action format\");\n        }\n        \n        string actionType = action.substring(0, 1);\n        string content = action.substring(2);\n        \n        // Check if already determined before processing\n        boolean wasAlreadyDetermined = determinedAt >= 0;\n        \n        if actionType == \".\" {\n            // Word without shock - remove all its letters from candidates\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                _ = candidates.remove(char);\n            }\n        } else if actionType == \"!\" {\n            // Word with shock - keep only letters present in this word\n            map<boolean> wordLetters = {};\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                wordLetters[char] = true;\n            }\n            \n            // Intersect candidates with wordLetters\n            map<boolean> newCandidates = {};\n            foreach string letter in candidates.keys() {\n                if wordLetters.hasKey(letter) {\n                    newCandidates[letter] = true;\n                }\n            }\n            candidates = newCandidates;\n            \n            // Count shock if already determined\n            if wasAlreadyDetermined {\n                excessiveShocks += 1;\n            }\n        } else if actionType == \"?\" {\n            // Incorrect guess - remove this letter\n            _ = candidates.remove(content);\n            \n            // Count shock if already determined and not the last action\n            if wasAlreadyDetermined && i < n - 1 {\n                excessiveShocks += 1;\n            }\n        }\n        \n        // Check if letter is now uniquely determined\n        if determinedAt < 0 && candidates.length() == 1 {\n            determinedAt = i;\n        }\n    }\n    \n    return excessiveShocks;\n}\n\npublic function main() returns error? {\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"No input provided\");\n    }\n    \n    int n = check int:fromString(firstLine.trim());\n    \n    string[] actions = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Insufficient input lines\");\n        }\n        actions.push(line.trim());\n    }\n    \n    int result = check countExcessiveShocks(n, actions);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() returns error? {\n    string[] actions = [\n        \"! abc\",\n        \". ad\",\n        \". b\",\n        \"! cd\",\n        \"? c\"\n    ];\n    int result = check countExcessiveShocks(5, actions);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample2() returns error? {\n    string[] actions = [\n        \"! hello\",\n        \"! codeforces\",\n        \"? c\",\n        \". o\",\n        \"? d\",\n        \"? h\",\n        \". l\",\n        \"? e\"\n    ];\n    int result = check countExcessiveShocks(8, actions);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample3() returns error? {\n    string[] actions = [\n        \"! ababahalamaha\",\n        \"? a\",\n        \"? b\",\n        \"? a\",\n        \"? b\",\n        \"? a\",\n        \"? h\"\n    ];\n    int result = check countExcessiveShocks(7, actions);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testSimpleCase() returns error? {\n    string[] actions = [\n        \"! abc\",\n        \". a\",\n        \". b\",\n        \"? c\"\n    ];\n    int result = check countExcessiveShocks(4, actions);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Start with a set of all 26 lowercase letters as possible candidates\n// 2. Process each action:\n//    - \". word\" -> remove all letters in word from candidates (word doesn't contain selected letter)\n//    - \"! word\" -> keep only letters that are both in candidates AND in word (word contains selected letter)\n//    - \"? letter\" -> remove that letter from candidates (incorrect guess)\n// 3. Track when candidates becomes a singleton (uniquely determined)\n// 4. Count shocks after that point (! actions and ? actions both cause shocks)\n\nimport ballerina/io;\n\nfunction countExcessiveShocks(int n, string[] actions) returns int|error {\n    // Initialize set of possible letters (a-z)\n    map<boolean> candidates = {};\n    foreach int i in 0...25 {\n        string letter = check string:fromCodePointInt(97 + i); // 'a' = 97\n        candidates[letter] = true;\n    }\n    \n    int determinedAt = -1; // Index when letter becomes uniquely determined\n    int excessiveShocks = 0;\n    \n    foreach int i in 0..<n {\n        string action = actions[i];\n        \n        if action.length() < 3 {\n            return error(\"Invalid action format\");\n        }\n        \n        string actionType = action.substring(0, 1);\n        string content = action.substring(2);\n        \n        // Check if already determined before processing\n        boolean wasAlreadyDetermined = determinedAt >= 0;\n        \n        if actionType == \".\" {\n            // Word without shock - remove all its letters from candidates\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                _ = candidates.remove(char);\n            }\n        } else if actionType == \"!\" {\n            // Word with shock - keep only letters present in this word\n            map<boolean> wordLetters = {};\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                wordLetters[char] = true;\n            }\n            \n            // Intersect candidates with wordLetters\n            map<boolean> newCandidates = {};\n            foreach string letter in candidates.keys() {\n                if wordLetters.hasKey(letter) {\n                    newCandidates[letter] = true;\n                }\n            }\n            candidates = newCandidates;\n            \n            // Count shock if already determined\n            if wasAlreadyDetermined {\n                excessiveShocks += 1;\n            }\n        } else if actionType == \"?\" {\n            // Incorrect guess - remove this letter\n            _ = candidates.remove(content);\n            \n            // Count shock if already determined and not the last action\n            if wasAlreadyDetermined && i < n - 1 {\n                excessiveShocks += 1;\n            }\n        }\n        \n        // Check if letter is now uniquely determined\n        if determinedAt < 0 && candidates.length() == 1 {\n            determinedAt = i;\n        }\n    }\n    \n    return excessiveShocks;\n}\n\npublic function main() returns error? {\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"No input provided\");\n    }\n    \n    int n = check int:fromString(firstLine.trim());\n    \n    string[] actions = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Insufficient input lines\");\n        }\n        actions.push(line.trim());\n    }\n    \n    int result = check countExcessiveShocks(n, actions);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/3 tests (0.0%), need 75%",
      "error": "Only passed 0/3 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5\n! abc\n. ad\n. b\n! cd\n? c\n",
          "expected_output": "1\n",
          "actual_output": "Compiling source\n\tmain.bal\n\nRunning executable\n\nerror: {ballerina/lang.map}KeyNotFound {\"message\":\"cannot find key 'd'\"}\n\tat ballerina.lang.map.0:remove(map.bal:192)\n\t   main:countExcessiveShocks(main.bal:40)\n\t   main:main(main.bal:99)\n",
          "error": "Runtime error (exit code 1)"
        }
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:28:43.756371",
      "status": "success",
      "completion": "Looking at the error, the issue is that I'm trying to remove keys from the map that may not exist. When processing \". ad\", the letter 'd' might not be in the candidates map anymore (or never was added properly).\n\nLet me analyze the problem more carefully:\n\n1. We start with all 26 letters as candidates\n2. For \". word\" - remove all letters IN the word from candidates (only if they exist)\n3. For \"! word\" - keep ONLY letters that are in BOTH candidates AND the word\n4. For \"? letter\" - remove that letter from candidates (only if it exists)\n5. Track when we have exactly 1 candidate left\n6. Count shocks AFTER that determination point\n\nThe bug is in the remove operation - I need to check if the key exists before removing, or simply not error if it doesn't exist.\n\n# Overview\nThis problem tracks when a secret letter becomes uniquely determined by eliminating possibilities through observations. We maintain a set of candidate letters, process each action to narrow down candidates, detect when only one letter remains, and count electric shocks received after that point.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Maintain a set of candidate letters (initially all 26 lowercase letters)\n// 2. Process each action to update candidates:\n//    - \". word\": word has NO selected letter -> remove all letters in word from candidates\n//    - \"! word\": word HAS the selected letter -> intersect candidates with letters in word\n//    - \"? letter\": incorrect guess -> remove this letter from candidates\n// 3. Detect when candidates.length() becomes 1 (uniquely determined)\n// 4. Count shocks (! and ?) that occur AFTER unique determination\n// 5. The last action is always the correct guess, so we don't count it\n\nimport ballerina/io;\n\nfunction countExcessiveShocks(int n, string[] actions) returns int|error {\n    // Initialize candidates with all lowercase letters a-z\n    map<boolean> candidates = {};\n    foreach int i in 0...25 {\n        string letter = check string:fromCodePointInt(97 + i); // ASCII 'a' = 97\n        candidates[letter] = true;\n    }\n    \n    int determinedAt = -1; // Action index when letter becomes uniquely determined\n    int excessiveShocks = 0;\n    \n    foreach int i in 0..<n {\n        string action = actions[i];\n        \n        if action.length() < 3 {\n            return error(\"Invalid action format\");\n        }\n        \n        string actionType = action.substring(0, 1);\n        string content = action.substring(2);\n        \n        if actionType == \".\" {\n            // Word without shock - remove all its letters from candidates\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                if candidates.hasKey(char) {\n                    _ = candidates.remove(char);\n                }\n            }\n        } else if actionType == \"!\" {\n            // Word with shock - intersect candidates with letters in this word\n            // First, build set of unique letters in the word\n            map<boolean> wordLetters = {};\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                wordLetters[char] = true;\n            }\n            \n            // Keep only letters that are in BOTH candidates and wordLetters\n            map<boolean> newCandidates = {};\n            foreach string letter in candidates.keys() {\n                if wordLetters.hasKey(letter) {\n                    newCandidates[letter] = true;\n                }\n            }\n            candidates = newCandidates;\n            \n            // If already determined, this shock is excessive\n            if determinedAt >= 0 && determinedAt < i {\n                excessiveShocks += 1;\n            }\n        } else if actionType == \"?\" {\n            // Incorrect guess - remove this letter from candidates\n            if candidates.hasKey(content) {\n                _ = candidates.remove(content);\n            }\n            \n            // If already determined and NOT the last action, this shock is excessive\n            // Last action is the correct guess, so we don't count it\n            if determinedAt >= 0 && determinedAt < i && i < n - 1 {\n                excessiveShocks += 1;\n            }\n        }\n        \n        // Check if letter is now uniquely determined (after processing this action)\n        if determinedAt < 0 && candidates.length() == 1 {\n            determinedAt = i;\n        }\n    }\n    \n    return excessiveShocks;\n}\n\npublic function main() returns error? {\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"No input provided\");\n    }\n    \n    int n = check int:fromString(firstLine.trim());\n    \n    string[] actions = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Insufficient input lines\");\n        }\n        actions.push(line.trim());\n    }\n    \n    int result = check countExcessiveShocks(n, actions);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() returns error? {\n    string[] actions = [\n        \"! abc\",\n        \". ad\",\n        \". b\",\n        \"! cd\",\n        \"? c\"\n    ];\n    int result = check countExcessiveShocks(5, actions);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testExample2() returns error? {\n    string[] actions = [\n        \"! hello\",\n        \"! codeforces\",\n        \"? c\",\n        \". o\",\n        \"? d\",\n        \"? h\",\n        \". l\",\n        \"? e\"\n    ];\n    int result = check countExcessiveShocks(8, actions);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testExample3() returns error? {\n    string[] actions = [\n        \"! ababahalamaha\",\n        \"? a\",\n        \"? b\",\n        \"? a\",\n        \"? b\",\n        \"? a\",\n        \"? h\"\n    ];\n    int result = check countExcessiveShocks(7, actions);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testSimpleCase() returns error? {\n    string[] actions = [\n        \"! abc\",\n        \". a\",\n        \". b\",\n        \"? c\"\n    ];\n    int result = check countExcessiveShocks(4, actions);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Maintain a set of candidate letters (initially all 26 lowercase letters)\n// 2. Process each action to update candidates:\n//    - \". word\": word has NO selected letter -> remove all letters in word from candidates\n//    - \"! word\": word HAS the selected letter -> intersect candidates with letters in word\n//    - \"? letter\": incorrect guess -> remove this letter from candidates\n// 3. Detect when candidates.length() becomes 1 (uniquely determined)\n// 4. Count shocks (! and ?) that occur AFTER unique determination\n// 5. The last action is always the correct guess, so we don't count it\n\nimport ballerina/io;\n\nfunction countExcessiveShocks(int n, string[] actions) returns int|error {\n    // Initialize candidates with all lowercase letters a-z\n    map<boolean> candidates = {};\n    foreach int i in 0...25 {\n        string letter = check string:fromCodePointInt(97 + i); // ASCII 'a' = 97\n        candidates[letter] = true;\n    }\n    \n    int determinedAt = -1; // Action index when letter becomes uniquely determined\n    int excessiveShocks = 0;\n    \n    foreach int i in 0..<n {\n        string action = actions[i];\n        \n        if action.length() < 3 {\n            return error(\"Invalid action format\");\n        }\n        \n        string actionType = action.substring(0, 1);\n        string content = action.substring(2);\n        \n        if actionType == \".\" {\n            // Word without shock - remove all its letters from candidates\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                if candidates.hasKey(char) {\n                    _ = candidates.remove(char);\n                }\n            }\n        } else if actionType == \"!\" {\n            // Word with shock - intersect candidates with letters in this word\n            // First, build set of unique letters in the word\n            map<boolean> wordLetters = {};\n            foreach int j in 0..<content.length() {\n                string char = content.substring(j, j + 1);\n                wordLetters[char] = true;\n            }\n            \n            // Keep only letters that are in BOTH candidates and wordLetters\n            map<boolean> newCandidates = {};\n            foreach string letter in candidates.keys() {\n                if wordLetters.hasKey(letter) {\n                    newCandidates[letter] = true;\n                }\n            }\n            candidates = newCandidates;\n            \n            // If already determined, this shock is excessive\n            if determinedAt >= 0 && determinedAt < i {\n                excessiveShocks += 1;\n            }\n        } else if actionType == \"?\" {\n            // Incorrect guess - remove this letter from candidates\n            if candidates.hasKey(content) {\n                _ = candidates.remove(content);\n            }\n            \n            // If already determined and NOT the last action, this shock is excessive\n            // Last action is the correct guess, so we don't count it\n            if determinedAt >= 0 && determinedAt < i && i < n - 1 {\n                excessiveShocks += 1;\n            }\n        }\n        \n        // Check if letter is now uniquely determined (after processing this action)\n        if determinedAt < 0 && candidates.length() == 1 {\n            determinedAt = i;\n        }\n    }\n    \n    return excessiveShocks;\n}\n\npublic function main() returns error? {\n    string? firstLine = io:readln();\n    if firstLine is () {\n        return error(\"No input provided\");\n    }\n    \n    int n = check int:fromString(firstLine.trim());\n    \n    string[] actions = [];\n    foreach int i in 0..<n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Insufficient input lines\");\n        }\n        actions.push(line.trim());\n    }\n    \n    int result = check countExcessiveShocks(n, actions);\n    io:println(result);\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T02:29:20.688700"
}