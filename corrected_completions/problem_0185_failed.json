{
  "entry_id": "problem_0185",
  "problem_index": 185,
  "prompt": "Title: Cinema\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nOverall there are *m* actors in Berland. Each actor has a personal identifier — an integer from 1 to *m* (distinct actors have distinct identifiers). Vasya likes to watch Berland movies with Berland actors, and he has *k* favorite actors. He watched the movie trailers for the next month and wrote the following information for every movie: the movie title, the number of actors who starred in it, and the identifiers of these actors. Besides, he managed to copy the movie titles and how many actors starred there, but he didn't manage to write down the identifiers of some actors. Vasya looks at his records and wonders which movies may be his favourite, and which ones may not be. Once Vasya learns the exact cast of all movies, his favorite movies will be determined as follows: a movie becomes favorite movie, if no other movie from Vasya's list has more favorite actors.\n\nHelp the boy to determine the following for each movie:\n-  whether it surely will be his favourite movie;-  whether it surely won't be his favourite movie; -  can either be favourite or not.\n\nInput Specification:\nThe first line of the input contains two integers *m* and *k* (1<=≤<=*m*<=≤<=100,<=1<=≤<=*k*<=≤<=*m*) — the number of actors in Berland and the number of Vasya's favourite actors. \n\nThe second line contains *k* distinct integers *a**i* (1<=≤<=*a**i*<=≤<=*m*) — the identifiers of Vasya's favourite actors.\n\nThe third line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of movies in Vasya's list.\n\nThen follow *n* blocks of lines, each block contains a movie's description. The *i*-th movie's description contains three lines: \n -  the first line contains string *s**i* (*s**i* consists of lowercase English letters and can have the length of from 1 to 10 characters, inclusive) — the movie's title, -  the second line contains a non-negative integer *d**i* (1<=≤<=*d**i*<=≤<=*m*) — the number of actors who starred in this movie,-  the third line has *d**i* integers *b**i*,<=*j* (0<=≤<=*b**i*,<=*j*<=≤<=*m*) — the identifiers of the actors who star in this movie. If *b**i*,<=*j*<==<=0, than Vasya doesn't remember the identifier of the *j*-th actor. It is guaranteed that the list of actors for a movie doesn't contain the same actors. \nAll movies have distinct names. The numbers on the lines are separated by single spaces.\n\nOutput Specification:\nPrint *n* lines in the output. In the *i*-th line print: \n -  0, if the *i*-th movie will surely be the favourite; -  1, if the *i*-th movie won't surely be the favourite; -  2, if the *i*-th movie can either be favourite, or not favourite.\n\nDemo Input:\n['5 3\\n1 2 3\\n6\\nfirstfilm\\n3\\n0 0 0\\nsecondfilm\\n4\\n0 0 4 5\\nthirdfilm\\n1\\n2\\nfourthfilm\\n1\\n5\\nfifthfilm\\n1\\n4\\nsixthfilm\\n2\\n1 0\\n', '5 3\\n1 3 5\\n4\\njumanji\\n3\\n0 0 0\\ntheeagle\\n5\\n1 2 3 4 0\\nmatrix\\n3\\n2 4 0\\nsourcecode\\n2\\n2 4\\n']\n\nDemo Output:\n['2\\n2\\n1\\n1\\n1\\n2\\n', '2\\n0\\n1\\n1\\n']\n\nNote:\nNote to the second sample: \n -  Movie jumanji can theoretically have from 1 to 3 Vasya's favourite actors. -  Movie theeagle has all three favourite actors, as the actor Vasya failed to remember, can only have identifier 5. -  Movie matrix can have exactly one favourite actor. -  Movie sourcecode doesn't have any favourite actors. \nThus, movie theeagle will surely be favourite, movies matrix and sourcecode won't surely be favourite, and movie jumanji can be either favourite (if it has all three favourite actors), or not favourite.",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:24:11.851039",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to determine for each movie whether it will surely be a favorite, surely won't be a favorite, or could be either. A movie is favorite if no other movie has more favorite actors. We need to calculate the minimum and maximum possible favorite actors for each movie (considering unknown actors as 0), then determine the outcome based on comparing these ranges across all movies.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get m (total actors), k (favorite count), favorite actor IDs, and movie details\n// 2. For each movie, calculate:\n//    - min_fav: count of known favorite actors in the cast\n//    - max_fav: min_fav + count of unknown actors (0s), capped by remaining favorites\n// 3. To determine if a movie is surely/possibly/never favorite:\n//    - Find the maximum possible favorite count any OTHER movie can have (global_max_other)\n//    - If movie's min_fav >= global_max_other: surely favorite (0)\n//    - If movie's max_fav < global_max that ANY movie can achieve: surely not favorite (1)\n//    - Otherwise: could be either (2)\n\nimport ballerina/io;\n\ntype MovieInfo record {\n    string title;\n    int minFav;\n    int maxFav;\n};\n\nfunction solveCinema(int m, int k, int[] favorites, MovieInfo[] movies) returns int[] {\n    int n = movies.length();\n    int[] results = [];\n    \n    // Find the global maximum favorite count any movie can achieve\n    int globalMax = 0;\n    foreach var movie in movies {\n        if movie.maxFav > globalMax {\n            globalMax = movie.maxFav;\n        }\n    }\n    \n    // For each movie, determine its status\n    foreach int i in 0 ..< n {\n        MovieInfo currentMovie = movies[i];\n        \n        // Find the maximum that OTHER movies can achieve\n        int maxOthersCanAchieve = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                if movies[j].maxFav > maxOthersCanAchieve {\n                    maxOthersCanAchieve = movies[j].maxFav;\n                }\n            }\n        }\n        \n        // Determine status\n        if currentMovie.minFav >= maxOthersCanAchieve {\n            // This movie will surely be favorite\n            results.push(0);\n        } else if currentMovie.maxFav < globalMax {\n            // This movie surely won't be favorite (another movie can achieve more)\n            results.push(1);\n        } else {\n            // Could be either\n            results.push(2);\n        }\n    }\n    \n    return results;\n}\n\nfunction calculateFavorites(int[] actors, int[] favorites, int k) returns [int, int] {\n    int minFav = 0;\n    int unknownCount = 0;\n    boolean[] usedFavorites = [];\n    \n    // Initialize used favorites tracker\n    foreach int i in 0 ..< k {\n        usedFavorites.push(false);\n    }\n    \n    // Count known favorite actors and unknowns\n    foreach var actor in actors {\n        if actor == 0 {\n            unknownCount += 1;\n        } else {\n            // Check if this actor is in favorites\n            foreach int i in 0 ..< favorites.length() {\n                if favorites[i] == actor {\n                    minFav += 1;\n                    usedFavorites[i] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Count how many favorites are still available for unknowns\n    int availableFavorites = 0;\n    foreach var used in usedFavorites {\n        if !used {\n            availableFavorites += 1;\n        }\n    }\n    \n    // maxFav = minFav + min(unknownCount, availableFavorites)\n    int maxFav = minFav + (unknownCount < availableFavorites ? unknownCount : availableFavorites);\n    \n    return [minFav, maxFav];\n}\n\npublic function main() returns error? {\n    // Read m and k\n    string? line1 = io:readln();\n    if line1 !is string {\n        return error(\"Failed to read first line\");\n    }\n    string[] parts1 = line1.trim().split(\" \");\n    int m = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read favorite actors\n    string? line2 = io:readln();\n    if line2 !is string {\n        return error(\"Failed to read favorite actors\");\n    }\n    string[] favParts = line2.trim().split(\" \");\n    int[] favorites = [];\n    foreach var favStr in favParts {\n        favorites.push(check 'int:fromString(favStr));\n    }\n    \n    // Read number of movies\n    string? line3 = io:readln();\n    if line3 !is string {\n        return error(\"Failed to read number of movies\");\n    }\n    int n = check 'int:fromString(line3.trim());\n    \n    // Read each movie\n    MovieInfo[] movies = [];\n    foreach int i in 0 ..< n {\n        // Read title\n        string? titleLine = io:readln();\n        if titleLine !is string {\n            return error(\"Failed to read movie title\");\n        }\n        string title = titleLine.trim();\n        \n        // Read number of actors\n        string? dLine = io:readln();\n        if dLine !is string {\n            return error(\"Failed to read actor count\");\n        }\n        int d = check 'int:fromString(dLine.trim());\n        \n        // Read actor IDs\n        string? actorsLine = io:readln();\n        if actorsLine !is string {\n            return error(\"Failed to read actors\");\n        }\n        string[] actorParts = actorsLine.trim().split(\" \");\n        int[] actors = [];\n        foreach var actorStr in actorParts {\n            actors.push(check 'int:fromString(actorStr));\n        }\n        \n        // Calculate min and max favorites\n        [int, int] favCounts = calculateFavorites(actors, favorites, k);\n        \n        movies.push({\n            title: title,\n            minFav: favCounts[0],\n            maxFav: favCounts[1]\n        });\n    }\n    \n    // Solve and output\n    int[] results = solveCinema(m, k, favorites, movies);\n    foreach var result in results {\n        io:println(result);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCalculateFavorites() {\n    // Test 1: All known actors, 2 are favorites\n    int[] actors1 = [1, 2, 4];\n    int[] favorites1 = [1, 3, 5];\n    [int, int] result1 = calculateFavorites(actors1, favorites1, 3);\n    test:assertEquals(result1[0], 1); // minFav\n    test:assertEquals(result1[1], 1); // maxFav\n\n    // Test 2: All unknown actors\n    int[] actors2 = [0, 0, 0];\n    int[] favorites2 = [1, 2, 3];\n    [int, int] result2 = calculateFavorites(actors2, favorites2, 3);\n    test:assertEquals(result2[0], 0); // minFav\n    test:assertEquals(result2[1], 3); // maxFav (can use all 3 favorites)\n\n    // Test 3: Mix of known and unknown\n    int[] actors3 = [1, 0, 4];\n    int[] favorites3 = [1, 3, 5];\n    [int, int] result3 = calculateFavorites(actors3, favorites3, 3);\n    test:assertEquals(result3[0], 1); // minFav (actor 1 is favorite)\n    test:assertEquals(result3[1], 2); // maxFav (1 known + 1 unknown can be favorite)\n\n    // Test 4: No favorites in cast\n    int[] actors4 = [2, 4];\n    int[] favorites4 = [1, 3, 5];\n    [int, int] result4 = calculateFavorites(actors4, favorites4, 3);\n    test:assertEquals(result4[0], 0); // minFav\n    test:assertEquals(result4[1], 0); // maxFav\n}\n\n@test:Config {}\nfunction testSolveCinema() {\n    // Test case from sample 2\n    MovieInfo[] movies = [\n        {title: \"jumanji\", minFav: 0, maxFav: 3},\n        {title: \"theeagle\", minFav: 3, maxFav: 3},\n        {title: \"matrix\", minFav: 0, maxFav: 1},\n        {title: \"sourcecode\", minFav: 0, maxFav: 0}\n    ];\n    \n    int[] results = solveCinema(5, 3, [1, 3, 5], movies);\n    test:assertEquals(results[0], 2); // jumanji - could be either\n    test:assertEquals(results[1], 0); // theeagle - surely favorite\n    test:assertEquals(results[2], 1); // matrix - surely not favorite\n    test:assertEquals(results[3], 1); // sourcecode - surely not favorite\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get m (total actors), k (favorite count), favorite actor IDs, and movie details\n// 2. For each movie, calculate:\n//    - min_fav: count of known favorite actors in the cast\n//    - max_fav: min_fav + count of unknown actors (0s), capped by remaining favorites\n// 3. To determine if a movie is surely/possibly/never favorite:\n//    - Find the maximum possible favorite count any OTHER movie can have (global_max_other)\n//    - If movie's min_fav >= global_max_other: surely favorite (0)\n//    - If movie's max_fav < global_max that ANY movie can achieve: surely not favorite (1)\n//    - Otherwise: could be either (2)\n\nimport ballerina/io;\n\ntype MovieInfo record {\n    string title;\n    int minFav;\n    int maxFav;\n};\n\nfunction solveCinema(int m, int k, int[] favorites, MovieInfo[] movies) returns int[] {\n    int n = movies.length();\n    int[] results = [];\n    \n    // Find the global maximum favorite count any movie can achieve\n    int globalMax = 0;\n    foreach var movie in movies {\n        if movie.maxFav > globalMax {\n            globalMax = movie.maxFav;\n        }\n    }\n    \n    // For each movie, determine its status\n    foreach int i in 0 ..< n {\n        MovieInfo currentMovie = movies[i];\n        \n        // Find the maximum that OTHER movies can achieve\n        int maxOthersCanAchieve = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                if movies[j].maxFav > maxOthersCanAchieve {\n                    maxOthersCanAchieve = movies[j].maxFav;\n                }\n            }\n        }\n        \n        // Determine status\n        if currentMovie.minFav >= maxOthersCanAchieve {\n            // This movie will surely be favorite\n            results.push(0);\n        } else if currentMovie.maxFav < globalMax {\n            // This movie surely won't be favorite (another movie can achieve more)\n            results.push(1);\n        } else {\n            // Could be either\n            results.push(2);\n        }\n    }\n    \n    return results;\n}\n\nfunction calculateFavorites(int[] actors, int[] favorites, int k) returns [int, int] {\n    int minFav = 0;\n    int unknownCount = 0;\n    boolean[] usedFavorites = [];\n    \n    // Initialize used favorites tracker\n    foreach int i in 0 ..< k {\n        usedFavorites.push(false);\n    }\n    \n    // Count known favorite actors and unknowns\n    foreach var actor in actors {\n        if actor == 0 {\n            unknownCount += 1;\n        } else {\n            // Check if this actor is in favorites\n            foreach int i in 0 ..< favorites.length() {\n                if favorites[i] == actor {\n                    minFav += 1;\n                    usedFavorites[i] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Count how many favorites are still available for unknowns\n    int availableFavorites = 0;\n    foreach var used in usedFavorites {\n        if !used {\n            availableFavorites += 1;\n        }\n    }\n    \n    // maxFav = minFav + min(unknownCount, availableFavorites)\n    int maxFav = minFav + (unknownCount < availableFavorites ? unknownCount : availableFavorites);\n    \n    return [minFav, maxFav];\n}\n\npublic function main() returns error? {\n    // Read m and k\n    string? line1 = io:readln();\n    if line1 !is string {\n        return error(\"Failed to read first line\");\n    }\n    string[] parts1 = line1.trim().split(\" \");\n    int m = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read favorite actors\n    string? line2 = io:readln();\n    if line2 !is string {\n        return error(\"Failed to read favorite actors\");\n    }\n    string[] favParts = line2.trim().split(\" \");\n    int[] favorites = [];\n    foreach var favStr in favParts {\n        favorites.push(check 'int:fromString(favStr));\n    }\n    \n    // Read number of movies\n    string? line3 = io:readln();\n    if line3 !is string {\n        return error(\"Failed to read number of movies\");\n    }\n    int n = check 'int:fromString(line3.trim());\n    \n    // Read each movie\n    MovieInfo[] movies = [];\n    foreach int i in 0 ..< n {\n        // Read title\n        string? titleLine = io:readln();\n        if titleLine !is string {\n            return error(\"Failed to read movie title\");\n        }\n        string title = titleLine.trim();\n        \n        // Read number of actors\n        string? dLine = io:readln();\n        if dLine !is string {\n            return error(\"Failed to read actor count\");\n        }\n        int d = check 'int:fromString(dLine.trim());\n        \n        // Read actor IDs\n        string? actorsLine = io:readln();\n        if actorsLine !is string {\n            return error(\"Failed to read actors\");\n        }\n        string[] actorParts = actorsLine.trim().split(\" \");\n        int[] actors = [];\n        foreach var actorStr in actorParts {\n            actors.push(check 'int:fromString(actorStr));\n        }\n        \n        // Calculate min and max favorites\n        [int, int] favCounts = calculateFavorites(actors, favorites, k);\n        \n        movies.push({\n            title: title,\n            minFav: favCounts[0],\n            maxFav: favCounts[1]\n        });\n    }\n    \n    // Solve and output\n    int[] results = solveCinema(m, k, favorites, movies);\n    foreach var result in results {\n        io:println(result);\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(108:36,108:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:38,117:43)] undefined function 'split' in type 'string'\nERROR [main.bal:(152:49,152:54)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(108:36,108:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:38,117:43)] undefined function 'split' in type 'string'\nERROR [main.bal:(152:49,152:54)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(108:36,108:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:38,117:43)] undefined function 'split' in type 'string'\nERROR [main.bal:(152:49,152:54)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:24:49.385865",
      "status": "failed",
      "completion": "Looking at the compilation errors, the issue is that `split` is not a method on `string` in Ballerina. I need to use the `regex` module from the standard library to split strings.\n\nLet me analyze the problem:\n1. We need to determine if each movie will surely be favorite (0), surely not be favorite (1), or maybe (2)\n2. A movie is favorite if NO OTHER movie has MORE favorite actors\n3. For each movie, calculate min/max possible favorite actors (unknowns can be any actor)\n4. Compare against what other movies can achieve\n\nThe key insight: \n- If a movie's minimum favorites >= maximum any other movie can achieve → surely favorite (0)\n- If a movie's maximum favorites < maximum some other movie can achieve → surely not favorite (1)  \n- Otherwise → maybe (2)\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get m (total actors), k (favorite count), favorite actor IDs, and movie details\n// 2. For each movie, calculate:\n//    - min_fav: count of known favorite actors in the cast\n//    - max_fav: min_fav + count of unknown actors (0s), capped by remaining favorites\n// 3. To determine if a movie is surely/possibly/never favorite:\n//    - A movie is favorite if no other movie has MORE favorite actors\n//    - If movie's min_fav >= max any OTHER movie can achieve: surely favorite (0)\n//    - If movie's max_fav < max some OTHER movie can achieve: surely not favorite (1)\n//    - Otherwise: could be either (2)\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype MovieInfo record {\n    string title;\n    int minFav;\n    int maxFav;\n};\n\nfunction solveCinema(int m, int k, int[] favorites, MovieInfo[] movies) returns int[] {\n    int n = movies.length();\n    int[] results = [];\n    \n    // For each movie, determine its status\n    foreach int i in 0 ..< n {\n        MovieInfo currentMovie = movies[i];\n        \n        // Find the maximum that OTHER movies can achieve\n        int maxOthersCanAchieve = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                if movies[j].maxFav > maxOthersCanAchieve {\n                    maxOthersCanAchieve = movies[j].maxFav;\n                }\n            }\n        }\n        \n        // Determine status\n        // Surely favorite: this movie's minimum >= what others can maximally achieve\n        if currentMovie.minFav >= maxOthersCanAchieve {\n            results.push(0);\n        } \n        // Surely not favorite: this movie's maximum < what some other can achieve\n        else if currentMovie.maxFav < maxOthersCanAchieve {\n            results.push(1);\n        } \n        // Maybe: this movie could potentially tie or beat others\n        else {\n            results.push(2);\n        }\n    }\n    \n    return results;\n}\n\nfunction calculateFavorites(int[] actors, int[] favorites, int k) returns [int, int] {\n    int minFav = 0;\n    int unknownCount = 0;\n    boolean[] usedFavorites = [];\n    \n    // Initialize used favorites tracker\n    foreach int i in 0 ..< k {\n        usedFavorites.push(false);\n    }\n    \n    // Count known favorite actors and unknowns\n    foreach var actor in actors {\n        if actor == 0 {\n            unknownCount += 1;\n        } else {\n            // Check if this actor is in favorites\n            foreach int i in 0 ..< favorites.length() {\n                if favorites[i] == actor {\n                    minFav += 1;\n                    usedFavorites[i] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Count how many favorites are still available for unknowns\n    int availableFavorites = 0;\n    foreach var used in usedFavorites {\n        if !used {\n            availableFavorites += 1;\n        }\n    }\n    \n    // maxFav = minFav + min(unknownCount, availableFavorites)\n    int maxFav = minFav + (unknownCount < availableFavorites ? unknownCount : availableFavorites);\n    \n    return [minFav, maxFav];\n}\n\npublic function main() returns error? {\n    // Read m and k\n    string line1 = check io:readln();\n    string[] parts1 = regex:split(line1.trim(), \" \");\n    int m = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read favorite actors\n    string line2 = check io:readln();\n    string[] favParts = regex:split(line2.trim(), \" \");\n    int[] favorites = [];\n    foreach var favStr in favParts {\n        favorites.push(check 'int:fromString(favStr));\n    }\n    \n    // Read number of movies\n    string line3 = check io:readln();\n    int n = check 'int:fromString(line3.trim());\n    \n    // Read each movie\n    MovieInfo[] movies = [];\n    foreach int i in 0 ..< n {\n        // Read title\n        string title = check io:readln();\n        title = title.trim();\n        \n        // Read number of actors\n        string dLine = check io:readln();\n        int d = check 'int:fromString(dLine.trim());\n        \n        // Read actor IDs\n        string actorsLine = check io:readln();\n        string[] actorParts = regex:split(actorsLine.trim(), \" \");\n        int[] actors = [];\n        foreach var actorStr in actorParts {\n            actors.push(check 'int:fromString(actorStr));\n        }\n        \n        // Calculate min and max favorites\n        [int, int] favCounts = calculateFavorites(actors, favorites, k);\n        \n        movies.push({\n            title: title,\n            minFav: favCounts[0],\n            maxFav: favCounts[1]\n        });\n    }\n    \n    // Solve and output\n    int[] results = solveCinema(m, k, favorites, movies);\n    foreach var result in results {\n        io:println(result);\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCalculateFavorites() {\n    // Test 1: All known actors, 2 are favorites\n    int[] actors1 = [1, 2, 4];\n    int[] favorites1 = [1, 3, 5];\n    [int, int] result1 = calculateFavorites(actors1, favorites1, 3);\n    test:assertEquals(result1[0], 1); // minFav\n    test:assertEquals(result1[1], 1); // maxFav\n\n    // Test 2: All unknown actors\n    int[] actors2 = [0, 0, 0];\n    int[] favorites2 = [1, 2, 3];\n    [int, int] result2 = calculateFavorites(actors2, favorites2, 3);\n    test:assertEquals(result2[0], 0); // minFav\n    test:assertEquals(result2[1], 3); // maxFav (can use all 3 favorites)\n\n    // Test 3: Mix of known and unknown\n    int[] actors3 = [1, 0, 4];\n    int[] favorites3 = [1, 3, 5];\n    [int, int] result3 = calculateFavorites(actors3, favorites3, 3);\n    test:assertEquals(result3[0], 1); // minFav (actor 1 is favorite)\n    test:assertEquals(result3[1], 2); // maxFav (1 known + 1 unknown can be favorite)\n\n    // Test 4: No favorites in cast\n    int[] actors4 = [2, 4];\n    int[] favorites4 = [1, 3, 5];\n    [int, int] result4 = calculateFavorites(actors4, favorites4, 3);\n    test:assertEquals(result4[0], 0); // minFav\n    test:assertEquals(result4[1], 0); // maxFav\n}\n\n@test:Config {}\nfunction testSolveCinema() {\n    // Test case from sample 2\n    MovieInfo[] movies = [\n        {title: \"jumanji\", minFav: 0, maxFav: 3},\n        {title: \"theeagle\", minFav: 3, maxFav: 3},\n        {title: \"matrix\", minFav: 0, maxFav: 1},\n        {title: \"sourcecode\", minFav: 0, maxFav: 0}\n    ];\n    \n    int[] results = solveCinema(5, 3, [1, 3, 5], movies);\n    test:assertEquals(results[0], 2); // jumanji - could be either\n    test:assertEquals(results[1], 0); // theeagle - surely favorite\n    test:assertEquals(results[2], 1); // matrix - surely not favorite\n    test:assertEquals(results[3], 1); // sourcecode - surely not favorite\n}\n\n@test:Config {}\nfunction testSolveCinemaEdgeCases() {\n    // Test: Single movie - always favorite\n    MovieInfo[] movies1 = [\n        {title: \"single\", minFav: 1, maxFav: 2}\n    ];\n    int[] results1 = solveCinema(5, 3, [1, 2, 3], movies1);\n    test:assertEquals(results1[0], 0); // surely favorite (no other movies)\n    \n    // Test: Two movies with same range\n    MovieInfo[] movies2 = [\n        {title: \"first\", minFav: 1, maxFav: 2},\n        {title: \"second\", minFav: 1, maxFav: 2}\n    ];\n    int[] results2 = solveCinema(5, 3, [1, 2, 3], movies2);\n    test:assertEquals(results2[0], 2); // maybe\n    test:assertEquals(results2[1], 2); // maybe\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get m (total actors), k (favorite count), favorite actor IDs, and movie details\n// 2. For each movie, calculate:\n//    - min_fav: count of known favorite actors in the cast\n//    - max_fav: min_fav + count of unknown actors (0s), capped by remaining favorites\n// 3. To determine if a movie is surely/possibly/never favorite:\n//    - A movie is favorite if no other movie has MORE favorite actors\n//    - If movie's min_fav >= max any OTHER movie can achieve: surely favorite (0)\n//    - If movie's max_fav < max some OTHER movie can achieve: surely not favorite (1)\n//    - Otherwise: could be either (2)\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype MovieInfo record {\n    string title;\n    int minFav;\n    int maxFav;\n};\n\nfunction solveCinema(int m, int k, int[] favorites, MovieInfo[] movies) returns int[] {\n    int n = movies.length();\n    int[] results = [];\n    \n    // For each movie, determine its status\n    foreach int i in 0 ..< n {\n        MovieInfo currentMovie = movies[i];\n        \n        // Find the maximum that OTHER movies can achieve\n        int maxOthersCanAchieve = 0;\n        foreach int j in 0 ..< n {\n            if i != j {\n                if movies[j].maxFav > maxOthersCanAchieve {\n                    maxOthersCanAchieve = movies[j].maxFav;\n                }\n            }\n        }\n        \n        // Determine status\n        // Surely favorite: this movie's minimum >= what others can maximally achieve\n        if currentMovie.minFav >= maxOthersCanAchieve {\n            results.push(0);\n        } \n        // Surely not favorite: this movie's maximum < what some other can achieve\n        else if currentMovie.maxFav < maxOthersCanAchieve {\n            results.push(1);\n        } \n        // Maybe: this movie could potentially tie or beat others\n        else {\n            results.push(2);\n        }\n    }\n    \n    return results;\n}\n\nfunction calculateFavorites(int[] actors, int[] favorites, int k) returns [int, int] {\n    int minFav = 0;\n    int unknownCount = 0;\n    boolean[] usedFavorites = [];\n    \n    // Initialize used favorites tracker\n    foreach int i in 0 ..< k {\n        usedFavorites.push(false);\n    }\n    \n    // Count known favorite actors and unknowns\n    foreach var actor in actors {\n        if actor == 0 {\n            unknownCount += 1;\n        } else {\n            // Check if this actor is in favorites\n            foreach int i in 0 ..< favorites.length() {\n                if favorites[i] == actor {\n                    minFav += 1;\n                    usedFavorites[i] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Count how many favorites are still available for unknowns\n    int availableFavorites = 0;\n    foreach var used in usedFavorites {\n        if !used {\n            availableFavorites += 1;\n        }\n    }\n    \n    // maxFav = minFav + min(unknownCount, availableFavorites)\n    int maxFav = minFav + (unknownCount < availableFavorites ? unknownCount : availableFavorites);\n    \n    return [minFav, maxFav];\n}\n\npublic function main() returns error? {\n    // Read m and k\n    string line1 = check io:readln();\n    string[] parts1 = regex:split(line1.trim(), \" \");\n    int m = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read favorite actors\n    string line2 = check io:readln();\n    string[] favParts = regex:split(line2.trim(), \" \");\n    int[] favorites = [];\n    foreach var favStr in favParts {\n        favorites.push(check 'int:fromString(favStr));\n    }\n    \n    // Read number of movies\n    string line3 = check io:readln();\n    int n = check 'int:fromString(line3.trim());\n    \n    // Read each movie\n    MovieInfo[] movies = [];\n    foreach int i in 0 ..< n {\n        // Read title\n        string title = check io:readln();\n        title = title.trim();\n        \n        // Read number of actors\n        string dLine = check io:readln();\n        int d = check 'int:fromString(dLine.trim());\n        \n        // Read actor IDs\n        string actorsLine = check io:readln();\n        string[] actorParts = regex:split(actorsLine.trim(), \" \");\n        int[] actors = [];\n        foreach var actorStr in actorParts {\n            actors.push(check 'int:fromString(actorStr));\n        }\n        \n        // Calculate min and max favorites\n        [int, int] favCounts = calculateFavorites(actors, favorites, k);\n        \n        movies.push({\n            title: title,\n            minFav: favCounts[0],\n            maxFav: favCounts[1]\n        });\n    }\n    \n    // Solve and output\n    int[] results = solveCinema(m, k, favorites, movies);\n    foreach var result in results {\n        io:println(result);\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "5 3\n1 2 3\n6\nfirstfilm\n3\n0 0 0\nsecondfilm\n4\n0 0 4 5\nthirdfilm\n1\n2\nfourthfilm\n1\n5\nfifthfilm\n1\n4\nsixthfilm\n2\n1 0\n",
          "expected_output": "2\n2\n1\n1\n1\n2\n",
          "actual_output": "2\n1\n1\n1\n1\n1\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T03:25:29.641409"
}