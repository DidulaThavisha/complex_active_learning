{
  "entry_id": "problem_0104",
  "problem_index": 104,
  "prompt": "Title: Zebra Tower\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nLittle Janet likes playing with cubes. Actually, she likes to play with anything whatsoever, cubes or tesseracts, as long as they are multicolored. Each cube is described by two parameters — color *c**i* and size *s**i*. A Zebra Tower is a tower that consists of cubes of exactly two colors. Besides, the colors of the cubes in the tower must alternate (colors of adjacent cubes must differ). The Zebra Tower should have at least two cubes. There are no other limitations. The figure below shows an example of a Zebra Tower.\n\nA Zebra Tower's height is the sum of sizes of all cubes that form the tower. Help little Janet build the Zebra Tower of the maximum possible height, using the available cubes.\n\nInput Specification:\nThe first line contains an integer *n* (2<=≤<=*n*<=≤<=105) — the number of cubes. Next *n* lines contain the descriptions of the cubes, one description per line. A cube description consists of two space-separated integers *c**i* and *s**i* (1<=≤<=*c**i*,<=*s**i*<=≤<=109) — the *i*-th cube's color and size, correspondingly. It is guaranteed that there are at least two cubes of different colors.\n\nOutput Specification:\nPrint the description of the Zebra Tower of the maximum height in the following form. In the first line print the tower's height, in the second line print the number of cubes that form the tower, and in the third line print the space-separated indices of cubes in the order in which they follow in the tower from the bottom to the top. Assume that the cubes are numbered from 1 to *n* in the order in which they were given in the input.\n\nIf there are several existing Zebra Towers with maximum heights, it is allowed to print any of them. \n\nPlease do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.\n\nDemo Input:\n['4\\n1 2\\n1 3\\n2 4\\n3 3\\n', '2\\n1 1\\n2 1\\n']\n\nDemo Output:\n['9\\n3\\n2 3 1 \\n', '2\\n2\\n2 1 \\n']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:48:26.372795",
      "status": "failed",
      "completion": "# Overview\n\nThe problem asks us to build a \"Zebra Tower\" with maximum height from given cubes. A Zebra Tower must have:\n1. Exactly two colors\n2. Colors alternating (adjacent cubes have different colors)\n3. At least two cubes\n\nThe strategy is:\n1. Group cubes by color\n2. Try all pairs of colors\n3. For each pair, greedily alternate between the two colors, always picking the largest available cube\n4. Track the maximum height configuration\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get cube information (color, size, index)\n// 2. Group cubes by color\n// 3. Try all pairs of colors to build zebra towers\n// 4. For each color pair, use greedy approach: alternate colors and pick largest cube each time\n// 5. Track the configuration with maximum height\n// 6. Output the best configuration\n\nimport ballerina/io;\n\ntype Cube record {\n    int color;\n    int size;\n    int index;\n};\n\ntype TowerResult record {\n    int height;\n    int[] indices;\n};\n\nfunction buildZebraTower(Cube[] cubes) returns TowerResult {\n    // Group cubes by color\n    map<Cube[]> colorGroups = {};\n    \n    foreach Cube cube in cubes {\n        string colorKey = cube.color.toString();\n        if colorGroups.hasKey(colorKey) {\n            Cube[]? existing = colorGroups[colorKey];\n            if existing is Cube[] {\n                existing.push(cube);\n            }\n        } else {\n            colorGroups[colorKey] = [cube];\n        }\n    }\n    \n    // Get all unique colors\n    string[] colors = colorGroups.keys();\n    \n    int maxHeight = 0;\n    int[] bestIndices = [];\n    \n    // Try all pairs of colors\n    foreach int i in 0 ..< colors.length() {\n        foreach int j in i + 1 ..< colors.length() {\n            string color1 = colors[i];\n            string color2 = colors[j];\n            \n            Cube[]? group1 = colorGroups[color1];\n            Cube[]? group2 = colorGroups[color2];\n            \n            if group1 is Cube[] && group2 is Cube[] {\n                // Sort each group by size in descending order\n                Cube[] sorted1 = sortCubesBySize(group1);\n                Cube[] sorted2 = sortCubesBySize(group2);\n                \n                // Build tower by alternating, always picking largest\n                TowerResult result = buildAlternatingTower(sorted1, sorted2);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n                \n                // Try starting with color2 instead of color1\n                result = buildAlternatingTower(sorted2, sorted1);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n            }\n        }\n    }\n    \n    return {height: maxHeight, indices: bestIndices};\n}\n\nfunction sortCubesBySize(Cube[] cubes) returns Cube[] {\n    Cube[] sorted = cubes.clone();\n    // Simple bubble sort (sufficient for constraints)\n    int n = sorted.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sorted[j].size < sorted[j + 1].size {\n                Cube temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n    return sorted;\n}\n\nfunction buildAlternatingTower(Cube[] group1, Cube[] group2) returns TowerResult {\n    int[] indices = [];\n    int totalHeight = 0;\n    int idx1 = 0;\n    int idx2 = 0;\n    boolean useGroup1 = true;\n    \n    // Alternate between groups, picking largest available\n    while idx1 < group1.length() || idx2 < group2.length() {\n        if useGroup1 {\n            if idx1 < group1.length() {\n                indices.push(group1[idx1].index);\n                totalHeight += group1[idx1].size;\n                idx1 += 1;\n                useGroup1 = false;\n            } else {\n                break;\n            }\n        } else {\n            if idx2 < group2.length() {\n                indices.push(group2[idx2].index);\n                totalHeight += group2[idx2].size;\n                idx2 += 1;\n                useGroup1 = true;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return {height: totalHeight, indices: indices};\n}\n\npublic function main() returns error? {\n    // Read number of cubes\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(line.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    Cube[] cubes = [];\n    \n    // Read cube descriptions\n    foreach int i in 1 ... n {\n        string? cubeLine = io:readln();\n        if cubeLine is () {\n            return error(\"Failed to read cube input\");\n        }\n        \n        string[] parts = cubeLine.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid cube format\");\n        }\n        \n        int|error color = 'int:fromString(parts[0]);\n        int|error size = 'int:fromString(parts[1]);\n        \n        if color is error || size is error {\n            return error(\"Invalid cube values\");\n        }\n        \n        cubes.push({color: color, size: size, index: i});\n    }\n    \n    TowerResult result = buildZebraTower(cubes);\n    \n    io:println(result.height);\n    io:println(result.indices.length());\n    \n    string indicesStr = \"\";\n    foreach int idx in result.indices {\n        indicesStr += idx.toString() + \" \";\n    }\n    io:println(indicesStr);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBasicZebraTower() {\n    Cube[] cubes = [\n        {color: 1, size: 2, index: 1},\n        {color: 1, size: 3, index: 2},\n        {color: 2, size: 4, index: 3},\n        {color: 3, size: 3, index: 4}\n    ];\n    \n    TowerResult result = buildZebraTower(cubes);\n    test:assertEquals(result.height, 9);\n    test:assertEquals(result.indices.length(), 3);\n}\n\n@test:Config {}\nfunction testTwoColorsTwoBlocks() {\n    Cube[] cubes = [\n        {color: 1, size: 1, index: 1},\n        {color: 2, size: 1, index: 2}\n    ];\n    \n    TowerResult result = buildZebraTower(cubes);\n    test:assertEquals(result.height, 2);\n    test:assertEquals(result.indices.length(), 2);\n}\n\n@test:Config {}\nfunction testMultipleCubesSameColor() {\n    Cube[] cubes = [\n        {color: 1, size: 5, index: 1},\n        {color: 1, size: 3, index: 2},\n        {color: 2, size: 4, index: 3},\n        {color: 2, size: 2, index: 4}\n    ];\n    \n    TowerResult result = buildZebraTower(cubes);\n    test:assertEquals(result.height, 14);\n    test:assertEquals(result.indices.length(), 4);\n}\n\n@test:Config {}\nfunction testSortCubesBySize() {\n    Cube[] cubes = [\n        {color: 1, size: 2, index: 1},\n        {color: 1, size: 5, index: 2},\n        {color: 1, size: 3, index: 3}\n    ];\n    \n    Cube[] sorted = sortCubesBySize(cubes);\n    test:assertEquals(sorted[0].size, 5);\n    test:assertEquals(sorted[1].size, 3);\n    test:assertEquals(sorted[2].size, 2);\n    test:assertEquals(sorted.length(), 3);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get cube information (color, size, index)\n// 2. Group cubes by color\n// 3. Try all pairs of colors to build zebra towers\n// 4. For each color pair, use greedy approach: alternate colors and pick largest cube each time\n// 5. Track the configuration with maximum height\n// 6. Output the best configuration\n\nimport ballerina/io;\n\ntype Cube record {\n    int color;\n    int size;\n    int index;\n};\n\ntype TowerResult record {\n    int height;\n    int[] indices;\n};\n\nfunction buildZebraTower(Cube[] cubes) returns TowerResult {\n    // Group cubes by color\n    map<Cube[]> colorGroups = {};\n    \n    foreach Cube cube in cubes {\n        string colorKey = cube.color.toString();\n        if colorGroups.hasKey(colorKey) {\n            Cube[]? existing = colorGroups[colorKey];\n            if existing is Cube[] {\n                existing.push(cube);\n            }\n        } else {\n            colorGroups[colorKey] = [cube];\n        }\n    }\n    \n    // Get all unique colors\n    string[] colors = colorGroups.keys();\n    \n    int maxHeight = 0;\n    int[] bestIndices = [];\n    \n    // Try all pairs of colors\n    foreach int i in 0 ..< colors.length() {\n        foreach int j in i + 1 ..< colors.length() {\n            string color1 = colors[i];\n            string color2 = colors[j];\n            \n            Cube[]? group1 = colorGroups[color1];\n            Cube[]? group2 = colorGroups[color2];\n            \n            if group1 is Cube[] && group2 is Cube[] {\n                // Sort each group by size in descending order\n                Cube[] sorted1 = sortCubesBySize(group1);\n                Cube[] sorted2 = sortCubesBySize(group2);\n                \n                // Build tower by alternating, always picking largest\n                TowerResult result = buildAlternatingTower(sorted1, sorted2);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n                \n                // Try starting with color2 instead of color1\n                result = buildAlternatingTower(sorted2, sorted1);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n            }\n        }\n    }\n    \n    return {height: maxHeight, indices: bestIndices};\n}\n\nfunction sortCubesBySize(Cube[] cubes) returns Cube[] {\n    Cube[] sorted = cubes.clone();\n    // Simple bubble sort (sufficient for constraints)\n    int n = sorted.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sorted[j].size < sorted[j + 1].size {\n                Cube temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n    return sorted;\n}\n\nfunction buildAlternatingTower(Cube[] group1, Cube[] group2) returns TowerResult {\n    int[] indices = [];\n    int totalHeight = 0;\n    int idx1 = 0;\n    int idx2 = 0;\n    boolean useGroup1 = true;\n    \n    // Alternate between groups, picking largest available\n    while idx1 < group1.length() || idx2 < group2.length() {\n        if useGroup1 {\n            if idx1 < group1.length() {\n                indices.push(group1[idx1].index);\n                totalHeight += group1[idx1].size;\n                idx1 += 1;\n                useGroup1 = false;\n            } else {\n                break;\n            }\n        } else {\n            if idx2 < group2.length() {\n                indices.push(group2[idx2].index);\n                totalHeight += group2[idx2].size;\n                idx2 += 1;\n                useGroup1 = true;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return {height: totalHeight, indices: indices};\n}\n\npublic function main() returns error? {\n    // Read number of cubes\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = 'int:fromString(line.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    Cube[] cubes = [];\n    \n    // Read cube descriptions\n    foreach int i in 1 ... n {\n        string? cubeLine = io:readln();\n        if cubeLine is () {\n            return error(\"Failed to read cube input\");\n        }\n        \n        string[] parts = cubeLine.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid cube format\");\n        }\n        \n        int|error color = 'int:fromString(parts[0]);\n        int|error size = 'int:fromString(parts[1]);\n        \n        if color is error || size is error {\n            return error(\"Invalid cube values\");\n        }\n        \n        cubes.push({color: color, size: size, index: i});\n    }\n    \n    TowerResult result = buildZebraTower(cubes);\n    \n    io:println(result.height);\n    io:println(result.indices.length());\n    \n    string indicesStr = \"\";\n    foreach int idx in result.indices {\n        indicesStr += idx.toString() + \" \";\n    }\n    io:println(indicesStr);\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(150:42,150:47)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(150:42,150:47)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(150:42,150:47)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:48:57.889855",
      "status": "failed",
      "completion": "Looking at the compilation error, the issue is that `split` is not a method on `string` in Ballerina. I need to use the `regex` module's `split` function instead, or use the `string:split` function from the standard library.\n\nLet me analyze the problem again and fix the compilation issues:\n\n1. Use `regex:split` or iterate through string to parse manually\n2. Ensure all string operations are valid in Ballerina\n3. The greedy alternating approach is correct for maximizing height\n\n# Overview\n\nThe problem asks us to build a \"Zebra Tower\" with maximum height from given cubes. A Zebra Tower must have:\n1. Exactly two colors\n2. Colors alternating (adjacent cubes have different colors)\n3. At least two cubes\n\nThe strategy is:\n1. Parse input to get cube information (color, size, index)\n2. Group cubes by color\n3. Try all pairs of colors\n4. For each pair, greedily alternate between the two colors, always picking the largest available cube\n5. Track the maximum height configuration\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get cube information (color, size, index)\n// 2. Group cubes by color\n// 3. Try all pairs of colors to build zebra towers\n// 4. For each color pair, use greedy approach: alternate colors and pick largest cube each time\n// 5. Track the configuration with maximum height\n// 6. Output the best configuration\n//\n// Fix: Use regex:split for string splitting instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Cube record {\n    int color;\n    int size;\n    int index;\n};\n\ntype TowerResult record {\n    int height;\n    int[] indices;\n};\n\nfunction buildZebraTower(Cube[] cubes) returns TowerResult {\n    // Group cubes by color\n    map<Cube[]> colorGroups = {};\n    \n    foreach Cube cube in cubes {\n        string colorKey = cube.color.toString();\n        if colorGroups.hasKey(colorKey) {\n            Cube[]? existing = colorGroups[colorKey];\n            if existing is Cube[] {\n                existing.push(cube);\n            }\n        } else {\n            colorGroups[colorKey] = [cube];\n        }\n    }\n    \n    // Get all unique colors\n    string[] colors = colorGroups.keys();\n    \n    int maxHeight = 0;\n    int[] bestIndices = [];\n    \n    // Try all pairs of colors\n    foreach int i in 0 ..< colors.length() {\n        foreach int j in i + 1 ..< colors.length() {\n            string color1 = colors[i];\n            string color2 = colors[j];\n            \n            Cube[]? group1 = colorGroups[color1];\n            Cube[]? group2 = colorGroups[color2];\n            \n            if group1 is Cube[] && group2 is Cube[] {\n                // Sort each group by size in descending order\n                Cube[] sorted1 = sortCubesBySize(group1);\n                Cube[] sorted2 = sortCubesBySize(group2);\n                \n                // Build tower by alternating, always picking largest\n                TowerResult result = buildAlternatingTower(sorted1, sorted2);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n                \n                // Try starting with color2 instead of color1\n                result = buildAlternatingTower(sorted2, sorted1);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n            }\n        }\n    }\n    \n    return {height: maxHeight, indices: bestIndices};\n}\n\nfunction sortCubesBySize(Cube[] cubes) returns Cube[] {\n    Cube[] sorted = cubes.clone();\n    // Simple bubble sort (sufficient for constraints)\n    int n = sorted.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sorted[j].size < sorted[j + 1].size {\n                Cube temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n    return sorted;\n}\n\nfunction buildAlternatingTower(Cube[] group1, Cube[] group2) returns TowerResult {\n    int[] indices = [];\n    int totalHeight = 0;\n    int idx1 = 0;\n    int idx2 = 0;\n    boolean useGroup1 = true;\n    \n    // Alternate between groups, picking largest available\n    while idx1 < group1.length() || idx2 < group2.length() {\n        if useGroup1 {\n            if idx1 < group1.length() {\n                indices.push(group1[idx1].index);\n                totalHeight += group1[idx1].size;\n                idx1 += 1;\n                useGroup1 = false;\n            } else {\n                break;\n            }\n        } else {\n            if idx2 < group2.length() {\n                indices.push(group2[idx2].index);\n                totalHeight += group2[idx2].size;\n                idx2 += 1;\n                useGroup1 = true;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return {height: totalHeight, indices: indices};\n}\n\npublic function main() returns error? {\n    // Read number of cubes\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = int:fromString(line.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    Cube[] cubes = [];\n    \n    // Read cube descriptions\n    foreach int i in 1 ... n {\n        string? cubeLine = io:readln();\n        if cubeLine is () {\n            return error(\"Failed to read cube input\");\n        }\n        \n        string[] parts = regex:split(cubeLine.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid cube format\");\n        }\n        \n        int|error color = int:fromString(parts[0]);\n        int|error size = int:fromString(parts[1]);\n        \n        if color is error || size is error {\n            return error(\"Invalid cube values\");\n        }\n        \n        cubes.push({color: color, size: size, index: i});\n    }\n    \n    TowerResult result = buildZebraTower(cubes);\n    \n    io:println(result.height);\n    io:println(result.indices.length());\n    \n    string indicesStr = \"\";\n    foreach int idx in result.indices {\n        indicesStr += idx.toString() + \" \";\n    }\n    io:println(indicesStr);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBasicZebraTower() {\n    Cube[] cubes = [\n        {color: 1, size: 2, index: 1},\n        {color: 1, size: 3, index: 2},\n        {color: 2, size: 4, index: 3},\n        {color: 3, size: 3, index: 4}\n    ];\n    \n    TowerResult result = buildZebraTower(cubes);\n    test:assertEquals(result.height, 9);\n    test:assertEquals(result.indices.length(), 3);\n}\n\n@test:Config {}\nfunction testTwoColorsTwoBlocks() {\n    Cube[] cubes = [\n        {color: 1, size: 1, index: 1},\n        {color: 2, size: 1, index: 2}\n    ];\n    \n    TowerResult result = buildZebraTower(cubes);\n    test:assertEquals(result.height, 2);\n    test:assertEquals(result.indices.length(), 2);\n}\n\n@test:Config {}\nfunction testMultipleCubesSameColor() {\n    Cube[] cubes = [\n        {color: 1, size: 5, index: 1},\n        {color: 1, size: 3, index: 2},\n        {color: 2, size: 4, index: 3},\n        {color: 2, size: 2, index: 4}\n    ];\n    \n    TowerResult result = buildZebraTower(cubes);\n    test:assertEquals(result.height, 14);\n    test:assertEquals(result.indices.length(), 4);\n}\n\n@test:Config {}\nfunction testSortCubesBySize() {\n    Cube[] cubes = [\n        {color: 1, size: 2, index: 1},\n        {color: 1, size: 5, index: 2},\n        {color: 1, size: 3, index: 3}\n    ];\n    \n    Cube[] sorted = sortCubesBySize(cubes);\n    test:assertEquals(sorted[0].size, 5);\n    test:assertEquals(sorted[1].size, 3);\n    test:assertEquals(sorted[2].size, 2);\n    test:assertEquals(sorted.length(), 3);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get cube information (color, size, index)\n// 2. Group cubes by color\n// 3. Try all pairs of colors to build zebra towers\n// 4. For each color pair, use greedy approach: alternate colors and pick largest cube each time\n// 5. Track the configuration with maximum height\n// 6. Output the best configuration\n//\n// Fix: Use regex:split for string splitting instead of string.split()\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Cube record {\n    int color;\n    int size;\n    int index;\n};\n\ntype TowerResult record {\n    int height;\n    int[] indices;\n};\n\nfunction buildZebraTower(Cube[] cubes) returns TowerResult {\n    // Group cubes by color\n    map<Cube[]> colorGroups = {};\n    \n    foreach Cube cube in cubes {\n        string colorKey = cube.color.toString();\n        if colorGroups.hasKey(colorKey) {\n            Cube[]? existing = colorGroups[colorKey];\n            if existing is Cube[] {\n                existing.push(cube);\n            }\n        } else {\n            colorGroups[colorKey] = [cube];\n        }\n    }\n    \n    // Get all unique colors\n    string[] colors = colorGroups.keys();\n    \n    int maxHeight = 0;\n    int[] bestIndices = [];\n    \n    // Try all pairs of colors\n    foreach int i in 0 ..< colors.length() {\n        foreach int j in i + 1 ..< colors.length() {\n            string color1 = colors[i];\n            string color2 = colors[j];\n            \n            Cube[]? group1 = colorGroups[color1];\n            Cube[]? group2 = colorGroups[color2];\n            \n            if group1 is Cube[] && group2 is Cube[] {\n                // Sort each group by size in descending order\n                Cube[] sorted1 = sortCubesBySize(group1);\n                Cube[] sorted2 = sortCubesBySize(group2);\n                \n                // Build tower by alternating, always picking largest\n                TowerResult result = buildAlternatingTower(sorted1, sorted2);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n                \n                // Try starting with color2 instead of color1\n                result = buildAlternatingTower(sorted2, sorted1);\n                \n                if result.height > maxHeight {\n                    maxHeight = result.height;\n                    bestIndices = result.indices;\n                }\n            }\n        }\n    }\n    \n    return {height: maxHeight, indices: bestIndices};\n}\n\nfunction sortCubesBySize(Cube[] cubes) returns Cube[] {\n    Cube[] sorted = cubes.clone();\n    // Simple bubble sort (sufficient for constraints)\n    int n = sorted.length();\n    foreach int i in 0 ..< n {\n        foreach int j in 0 ..< n - i - 1 {\n            if sorted[j].size < sorted[j + 1].size {\n                Cube temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n    return sorted;\n}\n\nfunction buildAlternatingTower(Cube[] group1, Cube[] group2) returns TowerResult {\n    int[] indices = [];\n    int totalHeight = 0;\n    int idx1 = 0;\n    int idx2 = 0;\n    boolean useGroup1 = true;\n    \n    // Alternate between groups, picking largest available\n    while idx1 < group1.length() || idx2 < group2.length() {\n        if useGroup1 {\n            if idx1 < group1.length() {\n                indices.push(group1[idx1].index);\n                totalHeight += group1[idx1].size;\n                idx1 += 1;\n                useGroup1 = false;\n            } else {\n                break;\n            }\n        } else {\n            if idx2 < group2.length() {\n                indices.push(group2[idx2].index);\n                totalHeight += group2[idx2].size;\n                idx2 += 1;\n                useGroup1 = true;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return {height: totalHeight, indices: indices};\n}\n\npublic function main() returns error? {\n    // Read number of cubes\n    string? line = io:readln();\n    if line is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int|error n = int:fromString(line.trim());\n    if n is error {\n        return error(\"Invalid number format\");\n    }\n    \n    Cube[] cubes = [];\n    \n    // Read cube descriptions\n    foreach int i in 1 ... n {\n        string? cubeLine = io:readln();\n        if cubeLine is () {\n            return error(\"Failed to read cube input\");\n        }\n        \n        string[] parts = regex:split(cubeLine.trim(), \" \");\n        if parts.length() != 2 {\n            return error(\"Invalid cube format\");\n        }\n        \n        int|error color = int:fromString(parts[0]);\n        int|error size = int:fromString(parts[1]);\n        \n        if color is error || size is error {\n            return error(\"Invalid cube values\");\n        }\n        \n        cubes.push({color: color, size: size, index: i});\n    }\n    \n    TowerResult result = buildZebraTower(cubes);\n    \n    io:println(result.height);\n    io:println(result.indices.length());\n    \n    string indicesStr = \"\";\n    foreach int idx in result.indices {\n        indicesStr += idx.toString() + \" \";\n    }\n    io:println(indicesStr);\n    \n    return;\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "2\n1 1\n2 1\n",
          "expected_output": "2\n2\n2 1 \n",
          "actual_output": "2\n2\n1 2 \n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T01:49:31.730853"
}