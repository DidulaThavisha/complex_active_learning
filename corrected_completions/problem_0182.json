{
  "entry_id": "problem_0182",
  "problem_index": 182,
  "prompt": "Title: k-Interesting Pairs Of Integers\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nVasya has the sequence consisting of *n* integers. Vasya consider the pair of integers *x* and *y* k-interesting, if their binary representation differs from each other exactly in *k* bits. For example, if *k*<==<=2, the pair of integers *x*<==<=5 and *y*<==<=3 is k-interesting, because their binary representation *x*=101 and *y*=011 differs exactly in two bits.\n\nVasya wants to know how many pairs of indexes (*i*, *j*) are in his sequence so that *i*<=&lt;<=*j* and the pair of integers *a**i* and *a**j* is k-interesting. Your task is to help Vasya and determine this number.\n\nInput Specification:\nThe first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=14) — the number of integers in Vasya's sequence and the number of bits in which integers in k-interesting pair should differ.\n\nThe second line contains the sequence *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=104), which Vasya has.\n\nOutput Specification:\nPrint the number of pairs (*i*, *j*) so that *i*<=&lt;<=*j* and the pair of integers *a**i* and *a**j* is k-interesting.\n\nDemo Input:\n['4 1\\n0 3 2 1\\n', '6 0\\n200 100 100 100 200 200\\n']\n\nDemo Output:\n['4\\n', '6\\n']\n\nNote:\nIn the first test there are 4 k-interesting pairs:\n -  (1, 3), -  (1, 4), -  (2, 3), -  (2, 4). \nIn the second test *k* = 0. Consequently, integers in any k-interesting pair should be equal to themselves. Thus, for the second test there are 6 k-interesting pairs:\n -  (1, 5), -  (1, 6), -  (2, 3), -  (2, 4), -  (3, 4), -  (5, 6).",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis solution finds the count of k-interesting pairs in a sequence. Two numbers form a k-interesting pair if their binary representations differ in exactly k bits. We need to count all pairs (i, j) where i < j and the integers at positions i and j differ in exactly k bits.\n\nThe approach:\n1. Read n and k from input\n2. Read the sequence of n integers\n3. For each pair (i, j) where i < j, count the number of differing bits using XOR\n4. If the bit difference count equals k, increment the result counter\n\nThe key fix: Use `regex:split()` from ballerina/regex library or use string:split() from ballerina/lang.string module instead of the non-existent split method on string type.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - To find if two numbers differ in exactly k bits, we can XOR them\n// - XOR gives 1 where bits differ and 0 where they match\n// - Count the number of 1s in the XOR result\n// - If count equals k, it's a k-interesting pair\n// - We need to check all pairs (i, j) where i < j\n// - Fix: Use regex:split from ballerina/regex to split strings\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to count the number of set bits (1s) in the binary representation\nfunction countSetBits(int num) returns int {\n    int count = 0;\n    int n = num;\n    while n > 0 {\n        count += n & 1;\n        n = n >> 1;\n    }\n    return count;\n}\n\n// Function to find k-interesting pairs\n// Two numbers are k-interesting if their binary representations differ in exactly k bits\nfunction countKInterestingPairs(int[] sequence, int k) returns int {\n    int count = 0;\n    int n = sequence.length();\n    \n    // Check all pairs (i, j) where i < j\n    int i = 0;\n    while i < n {\n        int j = i + 1;\n        while j < n {\n            // XOR gives us bits that differ\n            int xorResult = sequence[i] ^ sequence[j];\n            // Count how many bits are different\n            int bitDiff = countSetBits(xorResult);\n            \n            // If exactly k bits differ, it's a k-interesting pair\n            if bitDiff == k {\n                count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: sequence of integers\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read sequence\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Sequence length doesn't match n\");\n    }\n    \n    int[] sequence = [];\n    foreach string part in parts2 {\n        int num = check 'int:fromString(part);\n        sequence.push(num);\n    }\n    \n    // Calculate and print result\n    int result = countKInterestingPairs(sequence, k);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCountSetBits() {\n    // Test counting set bits\n    test:assertEquals(countSetBits(5), 2); // 101 has 2 ones\n    test:assertEquals(countSetBits(7), 3); // 111 has 3 ones\n    test:assertEquals(countSetBits(0), 0); // 0 has 0 ones\n    test:assertEquals(countSetBits(8), 1); // 1000 has 1 one\n}\n\n@test:Config {}\nfunction testKInterestingPairsExample1() {\n    // Test case 1: k=1, sequence=[0, 3, 2, 1]\n    // Expected: 4 pairs\n    int[] sequence = [0, 3, 2, 1];\n    int result = countKInterestingPairs(sequence, 1);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testKInterestingPairsExample2() {\n    // Test case 2: k=0, sequence=[200, 100, 100, 100, 200, 200]\n    // Expected: 6 pairs (pairs of equal numbers)\n    int[] sequence = [200, 100, 100, 100, 200, 200];\n    int result = countKInterestingPairs(sequence, 0);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testKInterestingPairsAllSame() {\n    // All same numbers with k=0 should give n*(n-1)/2 pairs\n    int[] sequence = [5, 5, 5, 5];\n    int result = countKInterestingPairs(sequence, 0);\n    test:assertEquals(result, 6); // 4*3/2 = 6\n}\n\n@test:Config {}\nfunction testKInterestingPairsNoPairs() {\n    // No pairs should match when k=5 and numbers are too close\n    int[] sequence = [0, 1, 2, 3];\n    int result = countKInterestingPairs(sequence, 5);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testKInterestingPairsTwoBits() {\n    // Test with k=2: 5 (101) and 3 (011) differ in 2 bits\n    int[] sequence = [5, 3];\n    int result = countKInterestingPairs(sequence, 2);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testKInterestingPairsMinimalSequence() {\n    // Minimal case: 2 elements that differ in exactly 1 bit\n    int[] sequence = [0, 1];\n    int result = countKInterestingPairs(sequence, 1);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - To find if two numbers differ in exactly k bits, we can XOR them\n// - XOR gives 1 where bits differ and 0 where they match\n// - Count the number of 1s in the XOR result\n// - If count equals k, it's a k-interesting pair\n// - We need to check all pairs (i, j) where i < j\n// - Fix: Use regex:split from ballerina/regex to split strings\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to count the number of set bits (1s) in the binary representation\nfunction countSetBits(int num) returns int {\n    int count = 0;\n    int n = num;\n    while n > 0 {\n        count += n & 1;\n        n = n >> 1;\n    }\n    return count;\n}\n\n// Function to find k-interesting pairs\n// Two numbers are k-interesting if their binary representations differ in exactly k bits\nfunction countKInterestingPairs(int[] sequence, int k) returns int {\n    int count = 0;\n    int n = sequence.length();\n    \n    // Check all pairs (i, j) where i < j\n    int i = 0;\n    while i < n {\n        int j = i + 1;\n        while j < n {\n            // XOR gives us bits that differ\n            int xorResult = sequence[i] ^ sequence[j];\n            // Count how many bits are different\n            int bitDiff = countSetBits(xorResult);\n            \n            // If exactly k bits differ, it's a k-interesting pair\n            if bitDiff == k {\n                count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: sequence of integers\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read sequence\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Sequence length doesn't match n\");\n    }\n    \n    int[] sequence = [];\n    foreach string part in parts2 {\n        int num = check 'int:fromString(part);\n        sequence.push(num);\n    }\n    \n    // Calculate and print result\n    int result = countKInterestingPairs(sequence, k);\n    io:println(result);\n    \n    return;\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:19:59.445829",
      "status": "failed",
      "completion": "# Overview\nThis solution finds the count of k-interesting pairs in a sequence. Two numbers form a k-interesting pair if their binary representations differ in exactly k bits. We need to count all pairs (i, j) where i < j and the integers at positions i and j differ in exactly k bits.\n\nThe approach:\n1. Read n and k from input\n2. Read the sequence of n integers\n3. For each pair (i, j) where i < j, count the number of differing bits using XOR\n4. If the bit difference count equals k, increment the result counter\n\n<CODE>\n```ballerina\n// Reasoning:\n// - To find if two numbers differ in exactly k bits, we can XOR them\n// - XOR gives 1 where bits differ and 0 where they match\n// - Count the number of 1s in the XOR result\n// - If count equals k, it's a k-interesting pair\n// - We need to check all pairs (i, j) where i < j\n\nimport ballerina/io;\n\n// Function to count the number of set bits (1s) in the binary representation\nfunction countSetBits(int num) returns int {\n    int count = 0;\n    int n = num;\n    while n > 0 {\n        count += n & 1;\n        n = n >> 1;\n    }\n    return count;\n}\n\n// Function to find k-interesting pairs\n// Two numbers are k-interesting if their binary representations differ in exactly k bits\nfunction countKInterestingPairs(int[] sequence, int k) returns int {\n    int count = 0;\n    int n = sequence.length();\n    \n    // Check all pairs (i, j) where i < j\n    int i = 0;\n    while i < n {\n        int j = i + 1;\n        while j < n {\n            // XOR gives us bits that differ\n            int xorResult = sequence[i] ^ sequence[j];\n            // Count how many bits are different\n            int bitDiff = countSetBits(xorResult);\n            \n            // If exactly k bits differ, it's a k-interesting pair\n            if bitDiff == k {\n                count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: sequence of integers\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read sequence\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Sequence length doesn't match n\");\n    }\n    \n    int[] sequence = [];\n    foreach string part in parts2 {\n        int num = check 'int:fromString(part);\n        sequence.push(num);\n    }\n    \n    // Calculate and print result\n    int result = countKInterestingPairs(sequence, k);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCountSetBits() {\n    // Test counting set bits\n    test:assertEquals(countSetBits(5), 2); // 101 has 2 ones\n    test:assertEquals(countSetBits(7), 3); // 111 has 3 ones\n    test:assertEquals(countSetBits(0), 0); // 0 has 0 ones\n    test:assertEquals(countSetBits(8), 1); // 1000 has 1 one\n}\n\n@test:Config {}\nfunction testKInterestingPairsExample1() {\n    // Test case 1: k=1, sequence=[0, 3, 2, 1]\n    // Expected: 4 pairs\n    int[] sequence = [0, 3, 2, 1];\n    int result = countKInterestingPairs(sequence, 1);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testKInterestingPairsExample2() {\n    // Test case 2: k=0, sequence=[200, 100, 100, 100, 200, 200]\n    // Expected: 6 pairs (pairs of equal numbers)\n    int[] sequence = [200, 100, 100, 100, 200, 200];\n    int result = countKInterestingPairs(sequence, 0);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testKInterestingPairsAllSame() {\n    // All same numbers with k=0 should give n*(n-1)/2 pairs\n    int[] sequence = [5, 5, 5, 5];\n    int result = countKInterestingPairs(sequence, 0);\n    test:assertEquals(result, 6); // 4*3/2 = 6\n}\n\n@test:Config {}\nfunction testKInterestingPairsNoPairs() {\n    // No pairs should match when k=5 and numbers are too close\n    int[] sequence = [0, 1, 2, 3];\n    int result = countKInterestingPairs(sequence, 5);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testKInterestingPairsTwoBits() {\n    // Test with k=2: 5 (101) and 3 (011) differ in 2 bits\n    int[] sequence = [5, 3];\n    int result = countKInterestingPairs(sequence, 2);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testKInterestingPairsMinimalSequence() {\n    // Minimal case: 2 elements that differ in exactly 1 bit\n    int[] sequence = [0, 1];\n    int result = countKInterestingPairs(sequence, 1);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - To find if two numbers differ in exactly k bits, we can XOR them\n// - XOR gives 1 where bits differ and 0 where they match\n// - Count the number of 1s in the XOR result\n// - If count equals k, it's a k-interesting pair\n// - We need to check all pairs (i, j) where i < j\n\nimport ballerina/io;\n\n// Function to count the number of set bits (1s) in the binary representation\nfunction countSetBits(int num) returns int {\n    int count = 0;\n    int n = num;\n    while n > 0 {\n        count += n & 1;\n        n = n >> 1;\n    }\n    return count;\n}\n\n// Function to find k-interesting pairs\n// Two numbers are k-interesting if their binary representations differ in exactly k bits\nfunction countKInterestingPairs(int[] sequence, int k) returns int {\n    int count = 0;\n    int n = sequence.length();\n    \n    // Check all pairs (i, j) where i < j\n    int i = 0;\n    while i < n {\n        int j = i + 1;\n        while j < n {\n            // XOR gives us bits that differ\n            int xorResult = sequence[i] ^ sequence[j];\n            // Count how many bits are different\n            int bitDiff = countSetBits(xorResult);\n            \n            // If exactly k bits differ, it's a k-interesting pair\n            if bitDiff == k {\n                count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: sequence of integers\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read sequence\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Sequence length doesn't match n\");\n    }\n    \n    int[] sequence = [];\n    foreach string part in parts2 {\n        int num = check 'int:fromString(part);\n        sequence.push(num);\n    }\n    \n    // Calculate and print result\n    int result = countKInterestingPairs(sequence, k);\n    io:println(result);\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(56:36,56:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(70:36,70:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(56:36,56:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(70:36,70:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(56:36,56:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(70:36,70:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:20:25.831820",
      "status": "success",
      "completion": "# Overview\nThis solution finds the count of k-interesting pairs in a sequence. Two numbers form a k-interesting pair if their binary representations differ in exactly k bits. We need to count all pairs (i, j) where i < j and the integers at positions i and j differ in exactly k bits.\n\nThe approach:\n1. Read n and k from input\n2. Read the sequence of n integers\n3. For each pair (i, j) where i < j, count the number of differing bits using XOR\n4. If the bit difference count equals k, increment the result counter\n\nThe key fix: Use `regex:split()` from ballerina/regex library or use string:split() from ballerina/lang.string module instead of the non-existent split method on string type.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - To find if two numbers differ in exactly k bits, we can XOR them\n// - XOR gives 1 where bits differ and 0 where they match\n// - Count the number of 1s in the XOR result\n// - If count equals k, it's a k-interesting pair\n// - We need to check all pairs (i, j) where i < j\n// - Fix: Use regex:split from ballerina/regex to split strings\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to count the number of set bits (1s) in the binary representation\nfunction countSetBits(int num) returns int {\n    int count = 0;\n    int n = num;\n    while n > 0 {\n        count += n & 1;\n        n = n >> 1;\n    }\n    return count;\n}\n\n// Function to find k-interesting pairs\n// Two numbers are k-interesting if their binary representations differ in exactly k bits\nfunction countKInterestingPairs(int[] sequence, int k) returns int {\n    int count = 0;\n    int n = sequence.length();\n    \n    // Check all pairs (i, j) where i < j\n    int i = 0;\n    while i < n {\n        int j = i + 1;\n        while j < n {\n            // XOR gives us bits that differ\n            int xorResult = sequence[i] ^ sequence[j];\n            // Count how many bits are different\n            int bitDiff = countSetBits(xorResult);\n            \n            // If exactly k bits differ, it's a k-interesting pair\n            if bitDiff == k {\n                count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: sequence of integers\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read sequence\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Sequence length doesn't match n\");\n    }\n    \n    int[] sequence = [];\n    foreach string part in parts2 {\n        int num = check 'int:fromString(part);\n        sequence.push(num);\n    }\n    \n    // Calculate and print result\n    int result = countKInterestingPairs(sequence, k);\n    io:println(result);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCountSetBits() {\n    // Test counting set bits\n    test:assertEquals(countSetBits(5), 2); // 101 has 2 ones\n    test:assertEquals(countSetBits(7), 3); // 111 has 3 ones\n    test:assertEquals(countSetBits(0), 0); // 0 has 0 ones\n    test:assertEquals(countSetBits(8), 1); // 1000 has 1 one\n}\n\n@test:Config {}\nfunction testKInterestingPairsExample1() {\n    // Test case 1: k=1, sequence=[0, 3, 2, 1]\n    // Expected: 4 pairs\n    int[] sequence = [0, 3, 2, 1];\n    int result = countKInterestingPairs(sequence, 1);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testKInterestingPairsExample2() {\n    // Test case 2: k=0, sequence=[200, 100, 100, 100, 200, 200]\n    // Expected: 6 pairs (pairs of equal numbers)\n    int[] sequence = [200, 100, 100, 100, 200, 200];\n    int result = countKInterestingPairs(sequence, 0);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testKInterestingPairsAllSame() {\n    // All same numbers with k=0 should give n*(n-1)/2 pairs\n    int[] sequence = [5, 5, 5, 5];\n    int result = countKInterestingPairs(sequence, 0);\n    test:assertEquals(result, 6); // 4*3/2 = 6\n}\n\n@test:Config {}\nfunction testKInterestingPairsNoPairs() {\n    // No pairs should match when k=5 and numbers are too close\n    int[] sequence = [0, 1, 2, 3];\n    int result = countKInterestingPairs(sequence, 5);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testKInterestingPairsTwoBits() {\n    // Test with k=2: 5 (101) and 3 (011) differ in 2 bits\n    int[] sequence = [5, 3];\n    int result = countKInterestingPairs(sequence, 2);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testKInterestingPairsMinimalSequence() {\n    // Minimal case: 2 elements that differ in exactly 1 bit\n    int[] sequence = [0, 1];\n    int result = countKInterestingPairs(sequence, 1);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - To find if two numbers differ in exactly k bits, we can XOR them\n// - XOR gives 1 where bits differ and 0 where they match\n// - Count the number of 1s in the XOR result\n// - If count equals k, it's a k-interesting pair\n// - We need to check all pairs (i, j) where i < j\n// - Fix: Use regex:split from ballerina/regex to split strings\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to count the number of set bits (1s) in the binary representation\nfunction countSetBits(int num) returns int {\n    int count = 0;\n    int n = num;\n    while n > 0 {\n        count += n & 1;\n        n = n >> 1;\n    }\n    return count;\n}\n\n// Function to find k-interesting pairs\n// Two numbers are k-interesting if their binary representations differ in exactly k bits\nfunction countKInterestingPairs(int[] sequence, int k) returns int {\n    int count = 0;\n    int n = sequence.length();\n    \n    // Check all pairs (i, j) where i < j\n    int i = 0;\n    while i < n {\n        int j = i + 1;\n        while j < n {\n            // XOR gives us bits that differ\n            int xorResult = sequence[i] ^ sequence[j];\n            // Count how many bits are different\n            int bitDiff = countSetBits(xorResult);\n            \n            // If exactly k bits differ, it's a k-interesting pair\n            if bitDiff == k {\n                count += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: sequence of integers\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read sequence\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Sequence length doesn't match n\");\n    }\n    \n    int[] sequence = [];\n    foreach string part in parts2 {\n        int num = check 'int:fromString(part);\n        sequence.push(num);\n    }\n    \n    // Calculate and print result\n    int result = countKInterestingPairs(sequence, k);\n    io:println(result);\n    \n    return;\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:20:56.815636"
}