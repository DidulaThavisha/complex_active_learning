{
  "entry_id": "problem_0115",
  "problem_index": 115,
  "prompt": "Title: The Tag Game\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAlice got tired of playing the tag game by the usual rules so she offered Bob a little modification to it. Now the game should be played on an undirected rooted tree of *n* vertices. Vertex 1 is the root of the tree.\n\nAlice starts at vertex 1 and Bob starts at vertex *x* (*x*<=≠<=1). The moves are made in turns, Bob goes first. In one move one can either stay at the current vertex or travel to the neighbouring one.\n\nThe game ends when Alice goes to the same vertex where Bob is standing. Alice wants to minimize the total number of moves and Bob wants to maximize it.\n\nYou should write a program which will determine how many moves will the game last.\n\nInput Specification:\nThe first line contains two integer numbers *n* and *x* (2<=≤<=*n*<=≤<=2·105, 2<=≤<=*x*<=≤<=*n*).\n\nEach of the next *n*<=-<=1 lines contains two integer numbers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=*n*) — edges of the tree. It is guaranteed that the edges form a valid tree.\n\nOutput Specification:\nPrint the total number of moves Alice and Bob will make.\n\nDemo Input:\n['4 3\\n1 2\\n2 3\\n2 4\\n', '5 2\\n1 2\\n2 3\\n3 4\\n2 5\\n']\n\nDemo Output:\n['4\\n', '6\\n']\n\nNote:\nIn the first example the tree looks like this:\n\nThe red vertex is Alice's starting position, the blue one is Bob's. Bob will make the game run the longest by standing at the vertex 3 during all the game. So here are the moves:\n\nB: stay at vertex 3\n\nA: go to vertex 2\n\nB: stay at vertex 3\n\nA: go to vertex 3\n\nIn the second example the tree looks like this:\n\nThe moves in the optimal strategy are:\n\nB: go to vertex 3\n\nA: go to vertex 2\n\nB: go to vertex 4\n\nA: go to vertex 3\n\nB: stay at vertex 4\n\nA: go to vertex 4",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:01:42.893096",
      "status": "failed",
      "completion": "# Overview\n\nThis problem is about a tag game on a tree where Alice starts at vertex 1 and Bob starts at vertex x. Bob moves first and wants to maximize the number of moves, while Alice wants to minimize them. The key insight is:\n\n1. Bob's optimal strategy is to move as far away from Alice as possible\n2. Bob can move towards the farthest point in his subtree (away from root)\n3. Alice will take the shortest path to Bob\n4. The game ends when they meet\n\nThe solution involves:\n- Finding the distance from root (vertex 1) to Bob's starting position (vertex x)\n- Finding the maximum distance Bob can reach from his position going away from root\n- Bob's strategy: move to maximize distance while Alice approaches\n- Result: max(0, 2 * maxDistanceFromBob - distanceFromRootToBob)\n\nThe game lasts: If Bob can reach a point farther from root than Alice can catch him, he maximizes moves. Otherwise, Alice catches him at distanceFromRootToBob moves.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Build an adjacency list representation of the tree\n// 2. Find distance from root (1) to Bob's position (x) using BFS/DFS\n// 3. Find the maximum distance Bob can go from x in the subtree away from root\n// 4. Bob's optimal strategy: go to the farthest leaf in his subtree (not towards root)\n// 5. Alice follows the shortest path to catch Bob\n// 6. Result formula: 2 * maxDistFromBob if it's > distFromRoot, otherwise distFromRoot\n// 7. The answer is: 2 * max_depth_from_bob (since both players move)\n\nimport ballerina/io;\n\ntype Graph map<int[]>;\n\n// Build adjacency list from edges\nfunction buildGraph(int[][] edges, int n) returns Graph {\n    Graph graph = {};\n    int i = 1;\n    while i <= n {\n        graph[i] = [];\n        i += 1;\n    }\n    \n    foreach int[] edge in edges {\n        int a = edge[0];\n        int b = edge[1];\n        int[]? aList = graph[a];\n        int[]? bList = graph[b];\n        \n        if aList is int[] {\n            aList.push(b);\n        }\n        if bList is int[] {\n            bList.push(a);\n        }\n    }\n    return graph;\n}\n\n// BFS to find distance from source to target\nfunction findDistance(Graph graph, int src, int target, int n) returns int {\n    int[] dist = [];\n    int i = 0;\n    while i <= n {\n        dist.push(-1);\n        i += 1;\n    }\n    \n    int[] queue = [src];\n    dist[src] = 0;\n    int front = 0;\n    \n    while front < queue.length() {\n        int curr = queue[front];\n        front += 1;\n        \n        int[]? neighbors = graph[curr];\n        if neighbors is int[] {\n            foreach int neighbor in neighbors {\n                if dist[neighbor] == -1 {\n                    dist[neighbor] = dist[curr] + 1;\n                    queue.push(neighbor);\n                    if neighbor == target {\n                        return dist[neighbor];\n                    }\n                }\n            }\n        }\n    }\n    return dist[target];\n}\n\n// Find maximum distance from a node avoiding parent (going into subtree)\nfunction findMaxDistanceInSubtree(Graph graph, int start, int parent) returns int {\n    int maxDist = 0;\n    \n    int[]? neighbors = graph[start];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if neighbor != parent {\n                int dist = 1 + findMaxDistanceInSubtree(graph, neighbor, start);\n                if dist > maxDist {\n                    maxDist = dist;\n                }\n            }\n        }\n    }\n    return maxDist;\n}\n\n// Main solution function\nfunction solveTagGame(int n, int x, int[][] edges) returns int {\n    Graph graph = buildGraph(edges, n);\n    \n    // Distance from Alice (at 1) to Bob (at x)\n    int distAliceToBob = findDistance(graph, 1, x, n);\n    \n    // Maximum distance Bob can reach from x (going away from root into his subtree)\n    int maxDistFromBob = findMaxDistanceInSubtree(graph, x, -1);\n    \n    // Bob's strategy: if he can reach a point farther than Alice can catch him early\n    // The game lasts: 2 * maxDistFromBob moves if Bob wins, else distAliceToBob * 2\n    // Actually: Bob moves first, optimal is to go to farthest point\n    // Alice needs distAliceToBob moves to reach where Bob started\n    // If maxDistFromBob > distAliceToBob, Bob wins by moving away\n    \n    if maxDistFromBob > distAliceToBob {\n        return 2 * maxDistFromBob;\n    } else {\n        return 2 * distAliceToBob;\n    }\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln();\n    if line1 is string {\n        string[] parts = line1.trim().split(\" \");\n        if parts.length() != 2 {\n            io:println(\"Invalid input format\");\n            return;\n        }\n        \n        int|error n = 'int:fromString(parts[0]);\n        int|error x = 'int:fromString(parts[1]);\n        \n        if n is error || x is error {\n            io:println(\"Invalid numbers\");\n            return;\n        }\n        \n        int[][] edges = [];\n        int i = 0;\n        while i < n - 1 {\n            string? edgeLine = io:readln();\n            if edgeLine is string {\n                string[] edgeParts = edgeLine.trim().split(\" \");\n                if edgeParts.length() == 2 {\n                    int|error a = 'int:fromString(edgeParts[0]);\n                    int|error b = 'int:fromString(edgeParts[1]);\n                    \n                    if a is int && b is int {\n                        edges.push([a, b]);\n                    }\n                }\n            }\n            i += 1;\n        }\n        \n        int result = solveTagGame(n, x, edges);\n        io:println(result);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] edges = [[1, 2], [2, 3], [2, 4]];\n    int result = solveTagGame(4, 3, edges);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] edges = [[1, 2], [2, 3], [3, 4], [2, 5]];\n    int result = solveTagGame(5, 2, edges);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    // Tree: 1-2, Bob at 2\n    int[][] edges = [[1, 2]];\n    int result = solveTagGame(2, 2, edges);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testLinearTree() {\n    // Tree: 1-2-3-4, Bob at 4\n    int[][] edges = [[1, 2], [2, 3], [3, 4]];\n    int result = solveTagGame(4, 4, edges);\n    test:assertEquals(result, 6);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Build an adjacency list representation of the tree\n// 2. Find distance from root (1) to Bob's position (x) using BFS/DFS\n// 3. Find the maximum distance Bob can go from x in the subtree away from root\n// 4. Bob's optimal strategy: go to the farthest leaf in his subtree (not towards root)\n// 5. Alice follows the shortest path to catch Bob\n// 6. Result formula: 2 * maxDistFromBob if it's > distFromRoot, otherwise distFromRoot\n// 7. The answer is: 2 * max_depth_from_bob (since both players move)\n\nimport ballerina/io;\n\ntype Graph map<int[]>;\n\n// Build adjacency list from edges\nfunction buildGraph(int[][] edges, int n) returns Graph {\n    Graph graph = {};\n    int i = 1;\n    while i <= n {\n        graph[i] = [];\n        i += 1;\n    }\n    \n    foreach int[] edge in edges {\n        int a = edge[0];\n        int b = edge[1];\n        int[]? aList = graph[a];\n        int[]? bList = graph[b];\n        \n        if aList is int[] {\n            aList.push(b);\n        }\n        if bList is int[] {\n            bList.push(a);\n        }\n    }\n    return graph;\n}\n\n// BFS to find distance from source to target\nfunction findDistance(Graph graph, int src, int target, int n) returns int {\n    int[] dist = [];\n    int i = 0;\n    while i <= n {\n        dist.push(-1);\n        i += 1;\n    }\n    \n    int[] queue = [src];\n    dist[src] = 0;\n    int front = 0;\n    \n    while front < queue.length() {\n        int curr = queue[front];\n        front += 1;\n        \n        int[]? neighbors = graph[curr];\n        if neighbors is int[] {\n            foreach int neighbor in neighbors {\n                if dist[neighbor] == -1 {\n                    dist[neighbor] = dist[curr] + 1;\n                    queue.push(neighbor);\n                    if neighbor == target {\n                        return dist[neighbor];\n                    }\n                }\n            }\n        }\n    }\n    return dist[target];\n}\n\n// Find maximum distance from a node avoiding parent (going into subtree)\nfunction findMaxDistanceInSubtree(Graph graph, int start, int parent) returns int {\n    int maxDist = 0;\n    \n    int[]? neighbors = graph[start];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if neighbor != parent {\n                int dist = 1 + findMaxDistanceInSubtree(graph, neighbor, start);\n                if dist > maxDist {\n                    maxDist = dist;\n                }\n            }\n        }\n    }\n    return maxDist;\n}\n\n// Main solution function\nfunction solveTagGame(int n, int x, int[][] edges) returns int {\n    Graph graph = buildGraph(edges, n);\n    \n    // Distance from Alice (at 1) to Bob (at x)\n    int distAliceToBob = findDistance(graph, 1, x, n);\n    \n    // Maximum distance Bob can reach from x (going away from root into his subtree)\n    int maxDistFromBob = findMaxDistanceInSubtree(graph, x, -1);\n    \n    // Bob's strategy: if he can reach a point farther than Alice can catch him early\n    // The game lasts: 2 * maxDistFromBob moves if Bob wins, else distAliceToBob * 2\n    // Actually: Bob moves first, optimal is to go to farthest point\n    // Alice needs distAliceToBob moves to reach where Bob started\n    // If maxDistFromBob > distAliceToBob, Bob wins by moving away\n    \n    if maxDistFromBob > distAliceToBob {\n        return 2 * maxDistFromBob;\n    } else {\n        return 2 * distAliceToBob;\n    }\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln();\n    if line1 is string {\n        string[] parts = line1.trim().split(\" \");\n        if parts.length() != 2 {\n            io:println(\"Invalid input format\");\n            return;\n        }\n        \n        int|error n = 'int:fromString(parts[0]);\n        int|error x = 'int:fromString(parts[1]);\n        \n        if n is error || x is error {\n            io:println(\"Invalid numbers\");\n            return;\n        }\n        \n        int[][] edges = [];\n        int i = 0;\n        while i < n - 1 {\n            string? edgeLine = io:readln();\n            if edgeLine is string {\n                string[] edgeParts = edgeLine.trim().split(\" \");\n                if edgeParts.length() == 2 {\n                    int|error a = 'int:fromString(edgeParts[0]);\n                    int|error b = 'int:fromString(edgeParts[1]);\n                    \n                    if a is int && b is int {\n                        edges.push([a, b]);\n                    }\n                }\n            }\n            i += 1;\n        }\n        \n        int result = solveTagGame(n, x, edges);\n        io:println(result);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(19:15,19:16)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(26:30,26:31)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(27:30,27:31)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(56:34,56:38)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(73:52,73:57)] invalid token 'start'\nERROR [main.bal:(73:57,73:57)] missing identifier\nERROR [main.bal:(76:30,76:35)] action invocation as an expression not",
      "error": "Compilation error: ERROR [main.bal:(19:15,19:16)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(26:30,26:31)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(27:30,27:31)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(56:34,56:38)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(73:52,73:57)] invalid token 'start'\nERROR [main.bal:(73:57,73:57)] missing identifier\nERROR [main.bal:(76:30,76:35)] action invocation as an expression not",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(19:15,19:16)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(26:30,26:31)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(27:30,27:31)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(56:34,56:38)] incompatible types: expected 'string', found 'int'\nERROR [main.bal:(73:52,73:57)] invalid token 'start'\nERROR [main.bal:(73:57,73:57)] missing identifier\nERROR [main.bal:(76:30,76:35)] action invocation as an expression not allowed here\nERROR [main.bal:(80:74,80:79)] action invocation as an expression not allowed here\nERROR [main.bal:(116:39,116:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(135:54,135:59)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:02:17.169504",
      "status": "failed",
      "completion": "# Overview\n\nThis problem is about a tag game on a tree where Alice starts at vertex 1 (root) and Bob starts at vertex x. Bob moves first and wants to maximize the number of moves, while Alice wants to minimize them.\n\nKey insights:\n1. Build the tree as an adjacency list\n2. Find the distance from root (vertex 1) to Bob's starting position (vertex x)\n3. Find the maximum distance Bob can reach from x going away from the root (into his subtree)\n4. Bob's optimal strategy: move to the farthest point he can reach that's away from Alice\n5. If Bob can reach farther from root than Alice's initial distance to him, Bob wins by going deep\n6. Formula: max(2 * maxDistFromBob, 2 * distFromRootToBob) - but we need to consider Bob moves away from root\n\nThe solution requires careful path finding and distance calculation on the tree.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Build adjacency list from edges\n// 2. Use BFS to find distance from Alice (vertex 1) to Bob (vertex x)\n// 3. Use DFS to find the maximum distance Bob can travel from x going away from root\n// 4. Bob wants to maximize: he goes to the farthest point in his subtree (not towards root)\n// 5. Alice follows shortest path to catch Bob\n// 6. Game length = 2 * max(maxDistFromBob, distFromRootToBob)\n// Note: Bob can go deeper if his subtree is deep enough, otherwise Alice catches quickly\n\nimport ballerina/io;\n\n// Build adjacency list representation of tree\nfunction buildGraph(int[][] edges, int n) returns map<int[]> {\n    map<int[]> graph = {};\n    int i = 1;\n    while i <= n {\n        graph[i.toString()] = [];\n        i += 1;\n    }\n    \n    foreach int[] edge in edges {\n        int a = edge[0];\n        int b = edge[1];\n        int[]? aList = graph[a.toString()];\n        int[]? bList = graph[b.toString()];\n        \n        if aList is int[] {\n            aList.push(b);\n        }\n        if bList is int[] {\n            bList.push(a);\n        }\n    }\n    return graph;\n}\n\n// BFS to find distance from source to target\nfunction findDistance(map<int[]> graph, int src, int target, int n) returns int {\n    int[] dist = [];\n    int i = 0;\n    while i <= n {\n        dist.push(-1);\n        i += 1;\n    }\n    \n    int[] queue = [src];\n    dist[src] = 0;\n    int front = 0;\n    \n    while front < queue.length() {\n        int curr = queue[front];\n        front += 1;\n        \n        int[]? neighbors = graph[curr.toString()];\n        if neighbors is int[] {\n            foreach int neighbor in neighbors {\n                if dist[neighbor] == -1 {\n                    dist[neighbor] = dist[curr] + 1;\n                    queue.push(neighbor);\n                    if neighbor == target {\n                        return dist[neighbor];\n                    }\n                }\n            }\n        }\n    }\n    return dist[target];\n}\n\n// DFS to find maximum distance from start node, avoiding going back to parent\nfunction findMaxDistanceInSubtree(map<int[]> graph, int current, int parent) returns int {\n    int maxDist = 0;\n    \n    int[]? neighbors = graph[current.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if neighbor != parent {\n                int dist = 1 + findMaxDistanceInSubtree(graph, neighbor, current);\n                if dist > maxDist {\n                    maxDist = dist;\n                }\n            }\n        }\n    }\n    return maxDist;\n}\n\n// Main solution function\nfunction solveTagGame(int n, int x, int[][] edges) returns int {\n    map<int[]> graph = buildGraph(edges, n);\n    \n    // Distance from Alice's start (vertex 1) to Bob's start (vertex x)\n    int distAliceToBob = findDistance(graph, 1, x, n);\n    \n    // Maximum distance Bob can reach from x going into his subtree (away from root)\n    int maxDistFromBob = findMaxDistanceInSubtree(graph, x, -1);\n    \n    // Bob's optimal strategy:\n    // - If maxDistFromBob > distAliceToBob, Bob can reach far enough that game lasts 2*maxDistFromBob\n    // - Otherwise, Alice catches Bob at or before he gets too far: 2*distAliceToBob\n    \n    if maxDistFromBob > distAliceToBob {\n        return 2 * maxDistFromBob;\n    } else {\n        return 2 * distAliceToBob;\n    }\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln(\"Enter n and x: \");\n    if line1 is string {\n        string:RegExp r1 = re ` `;\n        string[] parts = r1.split(line1.trim());\n        if parts.length() != 2 {\n            io:println(\"Invalid input format\");\n            return;\n        }\n        \n        int|error n = int:fromString(parts[0]);\n        int|error x = int:fromString(parts[1]);\n        \n        if n is error || x is error {\n            io:println(\"Invalid numbers\");\n            return;\n        }\n        \n        int[][] edges = [];\n        int i = 0;\n        while i < n - 1 {\n            string? edgeLine = io:readln(\"\");\n            if edgeLine is string {\n                string:RegExp r2 = re ` `;\n                string[] edgeParts = r2.split(edgeLine.trim());\n                if edgeParts.length() == 2 {\n                    int|error a = int:fromString(edgeParts[0]);\n                    int|error b = int:fromString(edgeParts[1]);\n                    \n                    if a is int && b is int {\n                        edges.push([a, b]);\n                    }\n                }\n            }\n            i += 1;\n        }\n        \n        int result = solveTagGame(n, x, edges);\n        io:println(result);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[][] edges = [[1, 2], [2, 3], [2, 4]];\n    int result = solveTagGame(4, 3, edges);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[][] edges = [[1, 2], [2, 3], [3, 4], [2, 5]];\n    int result = solveTagGame(5, 2, edges);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    // Tree: 1-2, Bob at 2\n    int[][] edges = [[1, 2]];\n    int result = solveTagGame(2, 2, edges);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testLinearTree() {\n    // Tree: 1-2-3-4, Bob at 4\n    int[][] edges = [[1, 2], [2, 3], [3, 4]];\n    int result = solveTagGame(4, 4, edges);\n    test:assertEquals(result, 6);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Build adjacency list from edges\n// 2. Use BFS to find distance from Alice (vertex 1) to Bob (vertex x)\n// 3. Use DFS to find the maximum distance Bob can travel from x going away from root\n// 4. Bob wants to maximize: he goes to the farthest point in his subtree (not towards root)\n// 5. Alice follows shortest path to catch Bob\n// 6. Game length = 2 * max(maxDistFromBob, distFromRootToBob)\n// Note: Bob can go deeper if his subtree is deep enough, otherwise Alice catches quickly\n\nimport ballerina/io;\n\n// Build adjacency list representation of tree\nfunction buildGraph(int[][] edges, int n) returns map<int[]> {\n    map<int[]> graph = {};\n    int i = 1;\n    while i <= n {\n        graph[i.toString()] = [];\n        i += 1;\n    }\n    \n    foreach int[] edge in edges {\n        int a = edge[0];\n        int b = edge[1];\n        int[]? aList = graph[a.toString()];\n        int[]? bList = graph[b.toString()];\n        \n        if aList is int[] {\n            aList.push(b);\n        }\n        if bList is int[] {\n            bList.push(a);\n        }\n    }\n    return graph;\n}\n\n// BFS to find distance from source to target\nfunction findDistance(map<int[]> graph, int src, int target, int n) returns int {\n    int[] dist = [];\n    int i = 0;\n    while i <= n {\n        dist.push(-1);\n        i += 1;\n    }\n    \n    int[] queue = [src];\n    dist[src] = 0;\n    int front = 0;\n    \n    while front < queue.length() {\n        int curr = queue[front];\n        front += 1;\n        \n        int[]? neighbors = graph[curr.toString()];\n        if neighbors is int[] {\n            foreach int neighbor in neighbors {\n                if dist[neighbor] == -1 {\n                    dist[neighbor] = dist[curr] + 1;\n                    queue.push(neighbor);\n                    if neighbor == target {\n                        return dist[neighbor];\n                    }\n                }\n            }\n        }\n    }\n    return dist[target];\n}\n\n// DFS to find maximum distance from start node, avoiding going back to parent\nfunction findMaxDistanceInSubtree(map<int[]> graph, int current, int parent) returns int {\n    int maxDist = 0;\n    \n    int[]? neighbors = graph[current.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if neighbor != parent {\n                int dist = 1 + findMaxDistanceInSubtree(graph, neighbor, current);\n                if dist > maxDist {\n                    maxDist = dist;\n                }\n            }\n        }\n    }\n    return maxDist;\n}\n\n// Main solution function\nfunction solveTagGame(int n, int x, int[][] edges) returns int {\n    map<int[]> graph = buildGraph(edges, n);\n    \n    // Distance from Alice's start (vertex 1) to Bob's start (vertex x)\n    int distAliceToBob = findDistance(graph, 1, x, n);\n    \n    // Maximum distance Bob can reach from x going into his subtree (away from root)\n    int maxDistFromBob = findMaxDistanceInSubtree(graph, x, -1);\n    \n    // Bob's optimal strategy:\n    // - If maxDistFromBob > distAliceToBob, Bob can reach far enough that game lasts 2*maxDistFromBob\n    // - Otherwise, Alice catches Bob at or before he gets too far: 2*distAliceToBob\n    \n    if maxDistFromBob > distAliceToBob {\n        return 2 * maxDistFromBob;\n    } else {\n        return 2 * distAliceToBob;\n    }\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln(\"Enter n and x: \");\n    if line1 is string {\n        string:RegExp r1 = re ` `;\n        string[] parts = r1.split(line1.trim());\n        if parts.length() != 2 {\n            io:println(\"Invalid input format\");\n            return;\n        }\n        \n        int|error n = int:fromString(parts[0]);\n        int|error x = int:fromString(parts[1]);\n        \n        if n is error || x is error {\n            io:println(\"Invalid numbers\");\n            return;\n        }\n        \n        int[][] edges = [];\n        int i = 0;\n        while i < n - 1 {\n            string? edgeLine = io:readln(\"\");\n            if edgeLine is string {\n                string:RegExp r2 = re ` `;\n                string[] edgeParts = r2.split(edgeLine.trim());\n                if edgeParts.length() == 2 {\n                    int|error a = int:fromString(edgeParts[0]);\n                    int|error b = int:fromString(edgeParts[1]);\n                    \n                    if a is int && b is int {\n                        edges.push([a, b]);\n                    }\n                }\n            }\n            i += 1;\n        }\n        \n        int result = solveTagGame(n, x, edges);\n        io:println(result);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4 3\n1 2\n2 3\n2 4\n",
          "expected_output": "4\n",
          "actual_output": "Enter n and x: 4\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T02:02:49.364842"
}