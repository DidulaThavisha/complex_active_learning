{
  "entry_id": "problem_0135",
  "problem_index": 135,
  "prompt": "Title: Substring\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou are given a graph with $n$ nodes and $m$ directed edges. One lowercase letter is assigned to each node. We define a path's value as the number of the most frequently occurring letter. For example, if letters on a path are \"abaca\", then the value of that path is $3$. Your task is find a path whose value is the largest.\n\nInput Specification:\nThe first line contains two positive integers $n, m$ ($1 \\leq n, m \\leq 300\\,000$), denoting that the graph has $n$ nodes and $m$ directed edges.\n\nThe second line contains a string $s$ with only lowercase English letters. The $i$-th character is the letter assigned to the $i$-th node.\n\nThen $m$ lines follow. Each line contains two integers $x, y$ ($1 \\leq x, y \\leq n$), describing a directed edge from $x$ to $y$. Note that $x$ can be equal to $y$ and there can be multiple edges between $x$ and $y$. Also the graph can be not connected.\n\nOutput Specification:\nOutput a single line with a single integer denoting the largest value. If the value can be arbitrarily large, output -1 instead.\n\nDemo Input:\n['5 4\\nabaca\\n1 2\\n1 3\\n3 4\\n4 5\\n', '6 6\\nxzyabc\\n1 2\\n3 1\\n2 3\\n5 4\\n4 3\\n6 4\\n', '10 14\\nxzyzyzyzqx\\n1 2\\n2 4\\n3 5\\n4 5\\n2 6\\n6 8\\n6 5\\n2 10\\n3 9\\n10 9\\n4 6\\n1 10\\n2 8\\n3 7\\n']\n\nDemo Output:\n['3\\n', '-1\\n', '4\\n']\n\nNote:\nIn the first sample, the path with largest value is $1 \\to 3 \\to 4 \\to 5$. The value is $3$ because the letter 'a' appears $3$ times.",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:22:40.407782",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires finding the maximum frequency of any letter along any path in a directed graph. The key insight is that if the graph contains a cycle, we can traverse it infinitely, making the answer -1. Otherwise, we need to find the path that maximizes the count of any single letter.\n\nThe approach:\n1. Detect if there's a cycle using DFS (if cycle exists, return -1)\n2. If no cycle, use dynamic programming with memoization to find the maximum count for each letter at each node\n3. For each node and each letter (a-z), track the maximum count of that letter ending at that node\n4. Use topological sort/DFS to process nodes in the correct order\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First check if graph has a cycle using DFS with three states: unvisited(0), visiting(1), visited(2)\n// 2. If cycle exists, return -1 (can traverse infinitely)\n// 3. If no cycle, use DP: dp[node][letter] = max count of 'letter' on any path ending at 'node'\n// 4. Process nodes using DFS with memoization\n// 5. For each node, calculate dp values based on incoming edges\n// 6. Return the maximum value across all nodes and all letters\n\nimport ballerina/io;\n\n// Check if graph has a cycle using DFS\nfunction hasCycle(map<int[]> graph, int n) returns boolean {\n    int[] state = []; // 0=unvisited, 1=visiting, 2=visited\n    int i = 0;\n    while i < n {\n        state.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i < n {\n        if state[i] == 0 {\n            if detectCycle(i, graph, state) {\n                return true;\n            }\n        }\n        i += 1;\n    }\n    return false;\n}\n\nfunction detectCycle(int node, map<int[]> graph, int[] state) returns boolean {\n    state[node] = 1; // visiting\n    \n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if state[neighbor] == 1 {\n                return true; // back edge found\n            }\n            if state[neighbor] == 0 {\n                if detectCycle(neighbor, graph, state) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    state[node] = 2; // visited\n    return false;\n}\n\n// DFS with memoization to calculate max count for each letter at each node\nfunction dfs(int node, map<int[]> graph, string letters, int[][] dp, boolean[] visited) {\n    if visited[node] {\n        return;\n    }\n    visited[node] = true;\n    \n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            dfs(neighbor, graph, letters, dp, visited);\n            \n            // Update dp[node] based on dp[neighbor]\n            int letterIdx = 0;\n            while letterIdx < 26 {\n                int currentCount = dp[neighbor][letterIdx];\n                if letters[node:codePointAt()] == (97 + letterIdx) {\n                    currentCount += 1;\n                }\n                if currentCount > dp[node][letterIdx] {\n                    dp[node][letterIdx] = currentCount;\n                }\n                letterIdx += 1;\n            }\n        }\n    }\n    \n    // Initialize with current node's letter\n    int currentLetterIdx = letters[node:codePointAt()] - 97;\n    if dp[node][currentLetterIdx] == 0 {\n        dp[node][currentLetterIdx] = 1;\n    }\n}\n\nfunction solve(int n, int m, string letters, int[][] edges) returns int {\n    // Build adjacency list\n    map<int[]> graph = {};\n    int i = 0;\n    while i < n {\n        graph[i.toString()] = [];\n        i += 1;\n    }\n    \n    i = 0;\n    while i < m {\n        int x = edges[i][0] - 1; // 0-indexed\n        int y = edges[i][1] - 1;\n        int[]? current = graph[x.toString()];\n        if current is int[] {\n            current.push(y);\n            graph[x.toString()] = current;\n        }\n        i += 1;\n    }\n    \n    // Check for cycle\n    if hasCycle(graph, n) {\n        return -1;\n    }\n    \n    // DP: dp[node][letter] = max count of letter on paths ending at node\n    int[][] dp = [];\n    i = 0;\n    while i < n {\n        int[] letterCounts = [];\n        int j = 0;\n        while j < 26 {\n            letterCounts.push(0);\n            j += 1;\n        }\n        dp.push(letterCounts);\n        i += 1;\n    }\n    \n    boolean[] visited = [];\n    i = 0;\n    while i < n {\n        visited.push(false);\n        i += 1;\n    }\n    \n    // Process all nodes\n    i = 0;\n    while i < n {\n        if !visited[i] {\n            dfs(i, graph, letters, dp, visited);\n        }\n        i += 1;\n    }\n    \n    // Find maximum value\n    int maxValue = 0;\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j < 26 {\n            if dp[i][j] > maxValue {\n                maxValue = dp[i][j];\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return maxValue;\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln();\n    if line1 is string {\n        string[] parts = line1.trim().split(\" \");\n        if parts.length() == 2 {\n            int|error n = 'int:fromString(parts[0]);\n            int|error m = 'int:fromString(parts[1]);\n            \n            if n is int && m is int {\n                string? line2 = io:readln();\n                if line2 is string {\n                    string letters = line2.trim();\n                    \n                    int[][] edges = [];\n                    int i = 0;\n                    while i < m {\n                        string? edgeLine = io:readln();\n                        if edgeLine is string {\n                            string[] edgeParts = edgeLine.trim().split(\" \");\n                            if edgeParts.length() == 2 {\n                                int|error x = 'int:fromString(edgeParts[0]);\n                                int|error y = 'int:fromString(edgeParts[1]);\n                                if x is int && y is int {\n                                    edges.push([x, y]);\n                                }\n                            }\n                        }\n                        i += 1;\n                    }\n                    \n                    int result = solve(n, m, letters, edges);\n                    io:println(result);\n                }\n            }\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int result = solve(5, 4, \"abaca\", [[1, 2], [1, 3], [3, 4], [4, 5]]);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int result = solve(6, 6, \"xzyabc\", [[1, 2], [3, 1], [2, 3], [5, 4], [4, 3], [6, 4]]);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int result = solve(10, 14, \"xzyzyzyzqx\", [[1, 2], [2, 4], [3, 5], [4, 5], [2, 6], [6, 8], [6, 5], [2, 10], [3, 9], [10, 9], [4, 6], [1, 10], [2, 8], [3, 7]]);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testSingleNode() {\n    int result = solve(1, 0, \"a\", []);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. First check if graph has a cycle using DFS with three states: unvisited(0), visiting(1), visited(2)\n// 2. If cycle exists, return -1 (can traverse infinitely)\n// 3. If no cycle, use DP: dp[node][letter] = max count of 'letter' on any path ending at 'node'\n// 4. Process nodes using DFS with memoization\n// 5. For each node, calculate dp values based on incoming edges\n// 6. Return the maximum value across all nodes and all letters\n\nimport ballerina/io;\n\n// Check if graph has a cycle using DFS\nfunction hasCycle(map<int[]> graph, int n) returns boolean {\n    int[] state = []; // 0=unvisited, 1=visiting, 2=visited\n    int i = 0;\n    while i < n {\n        state.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i < n {\n        if state[i] == 0 {\n            if detectCycle(i, graph, state) {\n                return true;\n            }\n        }\n        i += 1;\n    }\n    return false;\n}\n\nfunction detectCycle(int node, map<int[]> graph, int[] state) returns boolean {\n    state[node] = 1; // visiting\n    \n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if state[neighbor] == 1 {\n                return true; // back edge found\n            }\n            if state[neighbor] == 0 {\n                if detectCycle(neighbor, graph, state) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    state[node] = 2; // visited\n    return false;\n}\n\n// DFS with memoization to calculate max count for each letter at each node\nfunction dfs(int node, map<int[]> graph, string letters, int[][] dp, boolean[] visited) {\n    if visited[node] {\n        return;\n    }\n    visited[node] = true;\n    \n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            dfs(neighbor, graph, letters, dp, visited);\n            \n            // Update dp[node] based on dp[neighbor]\n            int letterIdx = 0;\n            while letterIdx < 26 {\n                int currentCount = dp[neighbor][letterIdx];\n                if letters[node:codePointAt()] == (97 + letterIdx) {\n                    currentCount += 1;\n                }\n                if currentCount > dp[node][letterIdx] {\n                    dp[node][letterIdx] = currentCount;\n                }\n                letterIdx += 1;\n            }\n        }\n    }\n    \n    // Initialize with current node's letter\n    int currentLetterIdx = letters[node:codePointAt()] - 97;\n    if dp[node][currentLetterIdx] == 0 {\n        dp[node][currentLetterIdx] = 1;\n    }\n}\n\nfunction solve(int n, int m, string letters, int[][] edges) returns int {\n    // Build adjacency list\n    map<int[]> graph = {};\n    int i = 0;\n    while i < n {\n        graph[i.toString()] = [];\n        i += 1;\n    }\n    \n    i = 0;\n    while i < m {\n        int x = edges[i][0] - 1; // 0-indexed\n        int y = edges[i][1] - 1;\n        int[]? current = graph[x.toString()];\n        if current is int[] {\n            current.push(y);\n            graph[x.toString()] = current;\n        }\n        i += 1;\n    }\n    \n    // Check for cycle\n    if hasCycle(graph, n) {\n        return -1;\n    }\n    \n    // DP: dp[node][letter] = max count of letter on paths ending at node\n    int[][] dp = [];\n    i = 0;\n    while i < n {\n        int[] letterCounts = [];\n        int j = 0;\n        while j < 26 {\n            letterCounts.push(0);\n            j += 1;\n        }\n        dp.push(letterCounts);\n        i += 1;\n    }\n    \n    boolean[] visited = [];\n    i = 0;\n    while i < n {\n        visited.push(false);\n        i += 1;\n    }\n    \n    // Process all nodes\n    i = 0;\n    while i < n {\n        if !visited[i] {\n            dfs(i, graph, letters, dp, visited);\n        }\n        i += 1;\n    }\n    \n    // Find maximum value\n    int maxValue = 0;\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j < 26 {\n            if dp[i][j] > maxValue {\n                maxValue = dp[i][j];\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return maxValue;\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln();\n    if line1 is string {\n        string[] parts = line1.trim().split(\" \");\n        if parts.length() == 2 {\n            int|error n = 'int:fromString(parts[0]);\n            int|error m = 'int:fromString(parts[1]);\n            \n            if n is int && m is int {\n                string? line2 = io:readln();\n                if line2 is string {\n                    string letters = line2.trim();\n                    \n                    int[][] edges = [];\n                    int i = 0;\n                    while i < m {\n                        string? edgeLine = io:readln();\n                        if edgeLine is string {\n                            string[] edgeParts = edgeLine.trim().split(\" \");\n                            if edgeParts.length() == 2 {\n                                int|error x = 'int:fromString(edgeParts[0]);\n                                int|error y = 'int:fromString(edgeParts[1]);\n                                if x is int && y is int {\n                                    edges.push([x, y]);\n                                }\n                            }\n                        }\n                        i += 1;\n                    }\n                    \n                    int result = solve(n, m, letters, edges);\n                    io:println(result);\n                }\n            }\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(69:28,69:46)] undefined function 'codePointAt'\nERROR [main.bal:(69:28,69:46)] undefined module 'node'\nERROR [main.bal:(81:36,81:54)] undefined function 'codePointAt'\nERROR [main.bal:(81:36,81:54)] undefined module 'node'\nERROR [main.bal:(163:39,163:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(178:66,178:71)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(69:28,69:46)] undefined function 'codePointAt'\nERROR [main.bal:(69:28,69:46)] undefined module 'node'\nERROR [main.bal:(81:36,81:54)] undefined function 'codePointAt'\nERROR [main.bal:(81:36,81:54)] undefined module 'node'\nERROR [main.bal:(163:39,163:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(178:66,178:71)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(69:28,69:46)] undefined function 'codePointAt'\nERROR [main.bal:(69:28,69:46)] undefined module 'node'\nERROR [main.bal:(81:36,81:54)] undefined function 'codePointAt'\nERROR [main.bal:(81:36,81:54)] undefined module 'node'\nERROR [main.bal:(163:39,163:44)] undefined function 'split' in type 'string'\nERROR [main.bal:(178:66,178:71)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:23:11.825990",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires finding the maximum frequency of any letter along any path in a directed graph. If the graph contains a cycle, we can traverse it infinitely, making the answer -1. Otherwise, we use dynamic programming to find the path that maximizes the count of any single letter.\n\nThe approach:\n1. Detect cycles using DFS with three states (unvisited, visiting, visited)\n2. If a cycle exists, return -1\n3. If no cycle, use DP where dp[node][letter] = max count of 'letter' on any path ending at 'node'\n4. Process nodes in reverse topological order using DFS\n5. Return the maximum value across all nodes and letters\n\nKey fixes from previous attempt:\n- Use `string:split()` instead of `string.split()`\n- Use `string:toCodePointInt()` to get character code\n- Fix the DP logic to process in correct order (reverse topological)\n- Handle string indexing properly using `substring()`\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input: n nodes, m edges, node labels, and edge list\n// 2. Build adjacency list representation of the graph\n// 3. Detect cycles using DFS (white-gray-black coloring)\n// 4. If cycle found, return -1 (infinite traversal possible)\n// 5. Otherwise, use DP with memoization:\n//    - dp[node][letter] = max occurrences of 'letter' on paths ending at node\n//    - Process nodes via DFS, computing DP values bottom-up\n//    - For each node, try extending paths from all neighbors\n// 6. Return maximum DP value across all nodes and letters\n\nimport ballerina/io;\n\n// Detect cycle using DFS with three states\n// 0 = white (unvisited), 1 = gray (visiting), 2 = black (visited)\nfunction hasCycle(map<int[]> graph, int n) returns boolean {\n    int[] color = [];\n    int i = 0;\n    while i < n {\n        color.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i < n {\n        if color[i] == 0 {\n            if detectCycleDFS(i, graph, color) {\n                return true;\n            }\n        }\n        i += 1;\n    }\n    return false;\n}\n\nfunction detectCycleDFS(int node, map<int[]> graph, int[] color) returns boolean {\n    color[node] = 1; // gray - currently visiting\n    \n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if color[neighbor] == 1 {\n                return true; // back edge - cycle detected\n            }\n            if color[neighbor] == 0 {\n                if detectCycleDFS(neighbor, graph, color) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    color[node] = 2; // black - done visiting\n    return false;\n}\n\n// DFS to compute DP values with memoization\nfunction computeDP(int node, map<int[]> graph, string letters, int[][] dp, boolean[] computed) {\n    if computed[node] {\n        return;\n    }\n    \n    // Initialize current node's letter count\n    string nodeChar = letters.substring(node, node + 1);\n    int|error charCode = string:toCodePointInt(nodeChar);\n    if charCode is int {\n        int letterIdx = charCode - 97; // 'a' = 97\n        dp[node][letterIdx] = 1;\n    }\n    \n    // Process all neighbors first (post-order DFS)\n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            computeDP(neighbor, graph, letters, dp, computed);\n            \n            // Extend paths from neighbor to current node\n            int letterIdx = 0;\n            while letterIdx < 26 {\n                int pathCount = dp[neighbor][letterIdx];\n                \n                // If current node has the same letter, increment count\n                string nodeChar2 = letters.substring(node, node + 1);\n                int|error charCode2 = string:toCodePointInt(nodeChar2);\n                if charCode2 is int {\n                    int currentLetterIdx = charCode2 - 97;\n                    if letterIdx == currentLetterIdx {\n                        pathCount += 1;\n                    }\n                }\n                \n                // Update maximum\n                if pathCount > dp[node][letterIdx] {\n                    dp[node][letterIdx] = pathCount;\n                }\n                \n                letterIdx += 1;\n            }\n        }\n    }\n    \n    computed[node] = true;\n}\n\nfunction solve(int n, int m, string letters, int[][] edges) returns int {\n    // Build adjacency list (directed graph)\n    map<int[]> graph = {};\n    int i = 0;\n    while i < n {\n        graph[i.toString()] = [];\n        i += 1;\n    }\n    \n    i = 0;\n    while i < m {\n        int x = edges[i][0] - 1; // convert to 0-indexed\n        int y = edges[i][1] - 1;\n        int[]? current = graph[x.toString()];\n        if current is int[] {\n            current.push(y);\n            graph[x.toString()] = current;\n        }\n        i += 1;\n    }\n    \n    // Check for cycles\n    if hasCycle(graph, n) {\n        return -1;\n    }\n    \n    // Initialize DP table\n    // dp[node][letter] = max count of letter on paths ending at node\n    int[][] dp = [];\n    i = 0;\n    while i < n {\n        int[] letterCounts = [];\n        int j = 0;\n        while j < 26 {\n            letterCounts.push(0);\n            j += 1;\n        }\n        dp.push(letterCounts);\n        i += 1;\n    }\n    \n    boolean[] computed = [];\n    i = 0;\n    while i < n {\n        computed.push(false);\n        i += 1;\n    }\n    \n    // Compute DP for all nodes\n    i = 0;\n    while i < n {\n        if !computed[i] {\n            computeDP(i, graph, letters, dp, computed);\n        }\n        i += 1;\n    }\n    \n    // Find maximum value\n    int maxValue = 0;\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j < 26 {\n            if dp[i][j] > maxValue {\n                maxValue = dp[i][j];\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return maxValue;\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln();\n    if line1 is string {\n        string[] parts = string:'split(line1.trim(), \" \");\n        if parts.length() == 2 {\n            int|error n = 'int:fromString(parts[0]);\n            int|error m = 'int:fromString(parts[1]);\n            \n            if n is int && m is int {\n                string? line2 = io:readln();\n                if line2 is string {\n                    string letters = line2.trim();\n                    \n                    int[][] edges = [];\n                    int i = 0;\n                    while i < m {\n                        string? edgeLine = io:readln();\n                        if edgeLine is string {\n                            string[] edgeParts = string:'split(edgeLine.trim(), \" \");\n                            if edgeParts.length() == 2 {\n                                int|error x = 'int:fromString(edgeParts[0]);\n                                int|error y = 'int:fromString(edgeParts[1]);\n                                if x is int && y is int {\n                                    edges.push([x, y]);\n                                }\n                            }\n                        }\n                        i += 1;\n                    }\n                    \n                    int result = solve(n, m, letters, edges);\n                    io:println(result);\n                }\n            }\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int result = solve(5, 4, \"abaca\", [[1, 2], [1, 3], [3, 4], [4, 5]]);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int result = solve(6, 6, \"xzyabc\", [[1, 2], [3, 1], [2, 3], [5, 4], [4, 3], [6, 4]]);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testExample3() {\n    int result = solve(10, 14, \"xzyzyzyzqx\", [[1, 2], [2, 4], [3, 5], [4, 5], [2, 6], [6, 8], [6, 5], [2, 10], [3, 9], [10, 9], [4, 6], [1, 10], [2, 8], [3, 7]]);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testSingleNode() {\n    int result = solve(1, 0, \"a\", []);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input: n nodes, m edges, node labels, and edge list\n// 2. Build adjacency list representation of the graph\n// 3. Detect cycles using DFS (white-gray-black coloring)\n// 4. If cycle found, return -1 (infinite traversal possible)\n// 5. Otherwise, use DP with memoization:\n//    - dp[node][letter] = max occurrences of 'letter' on paths ending at node\n//    - Process nodes via DFS, computing DP values bottom-up\n//    - For each node, try extending paths from all neighbors\n// 6. Return maximum DP value across all nodes and letters\n\nimport ballerina/io;\n\n// Detect cycle using DFS with three states\n// 0 = white (unvisited), 1 = gray (visiting), 2 = black (visited)\nfunction hasCycle(map<int[]> graph, int n) returns boolean {\n    int[] color = [];\n    int i = 0;\n    while i < n {\n        color.push(0);\n        i += 1;\n    }\n    \n    i = 0;\n    while i < n {\n        if color[i] == 0 {\n            if detectCycleDFS(i, graph, color) {\n                return true;\n            }\n        }\n        i += 1;\n    }\n    return false;\n}\n\nfunction detectCycleDFS(int node, map<int[]> graph, int[] color) returns boolean {\n    color[node] = 1; // gray - currently visiting\n    \n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            if color[neighbor] == 1 {\n                return true; // back edge - cycle detected\n            }\n            if color[neighbor] == 0 {\n                if detectCycleDFS(neighbor, graph, color) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    color[node] = 2; // black - done visiting\n    return false;\n}\n\n// DFS to compute DP values with memoization\nfunction computeDP(int node, map<int[]> graph, string letters, int[][] dp, boolean[] computed) {\n    if computed[node] {\n        return;\n    }\n    \n    // Initialize current node's letter count\n    string nodeChar = letters.substring(node, node + 1);\n    int|error charCode = string:toCodePointInt(nodeChar);\n    if charCode is int {\n        int letterIdx = charCode - 97; // 'a' = 97\n        dp[node][letterIdx] = 1;\n    }\n    \n    // Process all neighbors first (post-order DFS)\n    int[]? neighbors = graph[node.toString()];\n    if neighbors is int[] {\n        foreach int neighbor in neighbors {\n            computeDP(neighbor, graph, letters, dp, computed);\n            \n            // Extend paths from neighbor to current node\n            int letterIdx = 0;\n            while letterIdx < 26 {\n                int pathCount = dp[neighbor][letterIdx];\n                \n                // If current node has the same letter, increment count\n                string nodeChar2 = letters.substring(node, node + 1);\n                int|error charCode2 = string:toCodePointInt(nodeChar2);\n                if charCode2 is int {\n                    int currentLetterIdx = charCode2 - 97;\n                    if letterIdx == currentLetterIdx {\n                        pathCount += 1;\n                    }\n                }\n                \n                // Update maximum\n                if pathCount > dp[node][letterIdx] {\n                    dp[node][letterIdx] = pathCount;\n                }\n                \n                letterIdx += 1;\n            }\n        }\n    }\n    \n    computed[node] = true;\n}\n\nfunction solve(int n, int m, string letters, int[][] edges) returns int {\n    // Build adjacency list (directed graph)\n    map<int[]> graph = {};\n    int i = 0;\n    while i < n {\n        graph[i.toString()] = [];\n        i += 1;\n    }\n    \n    i = 0;\n    while i < m {\n        int x = edges[i][0] - 1; // convert to 0-indexed\n        int y = edges[i][1] - 1;\n        int[]? current = graph[x.toString()];\n        if current is int[] {\n            current.push(y);\n            graph[x.toString()] = current;\n        }\n        i += 1;\n    }\n    \n    // Check for cycles\n    if hasCycle(graph, n) {\n        return -1;\n    }\n    \n    // Initialize DP table\n    // dp[node][letter] = max count of letter on paths ending at node\n    int[][] dp = [];\n    i = 0;\n    while i < n {\n        int[] letterCounts = [];\n        int j = 0;\n        while j < 26 {\n            letterCounts.push(0);\n            j += 1;\n        }\n        dp.push(letterCounts);\n        i += 1;\n    }\n    \n    boolean[] computed = [];\n    i = 0;\n    while i < n {\n        computed.push(false);\n        i += 1;\n    }\n    \n    // Compute DP for all nodes\n    i = 0;\n    while i < n {\n        if !computed[i] {\n            computeDP(i, graph, letters, dp, computed);\n        }\n        i += 1;\n    }\n    \n    // Find maximum value\n    int maxValue = 0;\n    i = 0;\n    while i < n {\n        int j = 0;\n        while j < 26 {\n            if dp[i][j] > maxValue {\n                maxValue = dp[i][j];\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    return maxValue;\n}\n\npublic function main() returns error? {\n    string? line1 = io:readln();\n    if line1 is string {\n        string[] parts = string:'split(line1.trim(), \" \");\n        if parts.length() == 2 {\n            int|error n = 'int:fromString(parts[0]);\n            int|error m = 'int:fromString(parts[1]);\n            \n            if n is int && m is int {\n                string? line2 = io:readln();\n                if line2 is string {\n                    string letters = line2.trim();\n                    \n                    int[][] edges = [];\n                    int i = 0;\n                    while i < m {\n                        string? edgeLine = io:readln();\n                        if edgeLine is string {\n                            string[] edgeParts = string:'split(edgeLine.trim(), \" \");\n                            if edgeParts.length() == 2 {\n                                int|error x = 'int:fromString(edgeParts[0]);\n                                int|error y = 'int:fromString(edgeParts[1]);\n                                if x is int && y is int {\n                                    edges.push([x, y]);\n                                }\n                            }\n                        }\n                        i += 1;\n                    }\n                    \n                    int result = solve(n, m, letters, edges);\n                    io:println(result);\n                }\n            }\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(65:48,65:56)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(84:61,84:70)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(182:26,182:58)] undefined function 'split'\nERROR [main.bal:(197:50,197:85)] undefined function 'split'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(65:48,65:56)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(84:61,84:70)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(182:26,182:58)] undefined function 'split'\nERROR [main.bal:(197:50,197:85)] undefined function 'split'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(65:48,65:56)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(84:61,84:70)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(182:26,182:58)] undefined function 'split'\nERROR [main.bal:(197:50,197:85)] undefined function 'split'\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(65:48,65:56)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(84:61,84:70)] incompatible types: expected 'string:Char', found 'string'\nERROR [main.bal:(182:26,182:58)] undefined function 'split'\nERROR [main.bal:(197:50,197:85)] undefined function 'split'\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T02:23:42.337316"
}