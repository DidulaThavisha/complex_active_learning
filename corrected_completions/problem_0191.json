{
  "entry_id": "problem_0191",
  "problem_index": 191,
  "prompt": "Title: Shovel Sale\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nThere are *n* shovels in Polycarp's shop. The *i*-th shovel costs *i* burles, that is, the first shovel costs 1 burle, the second shovel costs 2 burles, the third shovel costs 3 burles, and so on. Polycarps wants to sell shovels in pairs.\n\nVisitors are more likely to buy a pair of shovels if their total cost ends with several 9s. Because of this, Polycarp wants to choose a pair of shovels to sell in such a way that the sum of their costs ends with maximum possible number of nines. For example, if he chooses shovels with costs 12345 and 37454, their total cost is 49799, it ends with two nines.\n\nYou are to compute the number of pairs of shovels such that their total cost ends with maximum possible number of nines. Two pairs are considered different if there is a shovel presented in one pair, but not in the other.\n\nInput Specification:\nThe first line contains a single integer *n* (2<=≤<=*n*<=≤<=109) — the number of shovels in Polycarp's shop.\n\nOutput Specification:\nPrint the number of pairs of shovels such that their total cost ends with maximum possible number of nines. \n\nNote that it is possible that the largest number of 9s at the end is 0, then you should count all such ways.\n\nIt is guaranteed that for every *n*<=≤<=109 the answer doesn't exceed 2·109.\n\nDemo Input:\n['7\\n', '14\\n', '50\\n']\n\nDemo Output:\n['3\\n', '9\\n', '1\\n']\n\nNote:\nIn the first example the maximum possible number of nines at the end is one. Polycarp cah choose the following pairs of shovels for that purpose:\n -  2 and 7; -  3 and 6; -  4 and 5. \nIn the second example the maximum number of nines at the end of total cost of two shovels is one. The following pairs of shovels suit Polycarp:\n -  1 and 8; -  2 and 7; -  3 and 6; -  4 and 5; -  5 and 14; -  6 and 13; -  7 and 12; -  8 and 11; -  9 and 10. \nIn the third example it is necessary to choose shovels 49 and 50, because the sum of their cost is 99, that means that the total number of nines is equal to two, which is maximum possible for *n* = 50.",
  "rating": 1800,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the issue, the main problem is that the code is prompting \"Enter n: \" which shouldn't be there for automated test cases. The input should be read directly from stdin without any prompt.\n\nLet me analyze the problem more carefully:\n\n1. We have n shovels with costs 1, 2, 3, ..., n\n2. We need pairs (i, j) where i < j\n3. Sum = i + j should end with maximum possible trailing 9s\n4. Count how many such pairs exist\n\nFor n=7:\n- Max sum = 7 + 6 = 13\n- Can we get sum ending in 9? Yes (2+7=9, 3+6=9, 4+5=9)\n- Can we get sum ending in 99? No (max sum is 13)\n- So maximum trailing 9s = 1, and count = 3\n\nFor n=14:\n- Max sum = 14 + 13 = 27\n- Sums ending in 9: 9, 19\n- Sum=9: (1,8), (2,7), (3,6), (4,5) = 4 pairs\n- Sum=19: (5,14), (6,13), (7,12), (8,11), (9,10) = 5 pairs\n- Total = 9 pairs\n\nFor n=50:\n- Max sum = 50 + 49 = 99\n- Can we get 99? Yes (49+50=99) = 1 pair\n- Can we get 999? No\n- So we look for sums ending in 99: only 99 itself\n- Count = 1\n\n# Overview\nThis problem requires finding pairs of shovels where their sum ends with the maximum possible number of trailing 9s. The key is to determine the maximum achievable trailing 9s based on the range [1, n], then count all pairs that achieve this maximum.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Shovels cost 1, 2, 3, ..., n burles\n// - We need pairs (i, j) where 1 <= i < j <= n\n// - Sum of pair = i + j\n// - Maximum possible sum = n + (n-1) = 2n - 1\n// - Minimum possible sum = 1 + 2 = 3\n//\n// Strategy:\n// 1. Find maximum number of trailing 9s achievable (check 9, 99, 999, ...)\n// 2. Count pairs where sum ends with that many 9s\n// 3. For k trailing 9s, target values are: 10^k - 1, 2*10^k - 1, 3*10^k - 1, ...\n//    (i.e., 9, 99, 999, ... or 19, 199, 1999, ... etc.)\n\nimport ballerina/io;\n\nfunction countPairsWithMaxNines(int n) returns int|error {\n    if n < 2 {\n        return error(\"n must be at least 2\");\n    }\n    \n    int maxSum = 2 * n - 1;\n    int minSum = 3; // 1 + 2\n    \n    // Find the maximum number of trailing 9s possible\n    // Check for 9, 99, 999, 9999, etc.\n    int targetMod = 10; // Start checking for sum % 10 = 9\n    int targetRemainder = 9;\n    \n    // Try to find the highest power of 10 where we can achieve all 9s\n    while (targetRemainder * 10 + 9 <= maxSum) {\n        targetMod = targetMod * 10;\n        targetRemainder = targetRemainder * 10 + 9;\n    }\n    \n    // Now count pairs where (i + j) % targetMod = targetRemainder\n    // Valid sums are: targetRemainder, targetRemainder + targetMod, targetRemainder + 2*targetMod, ...\n    \n    int count = 0;\n    int currentSum = targetRemainder;\n    \n    while currentSum <= maxSum {\n        if currentSum >= minSum {\n            // Count pairs (i, j) where i + j = currentSum and 1 <= i < j <= n\n            // For i + j = currentSum:\n            // - i ranges from 1 to floor((currentSum-1)/2) to ensure i < j\n            // - j = currentSum - i must be <= n\n            // - i must be >= 1 and j must be >= 1\n            \n            int maxI = (currentSum - 1) / 2; // Ensures i < j (since j = currentSum - i)\n            int minI = 1;\n            \n            // Ensure j = currentSum - i <= n\n            // So i >= currentSum - n\n            if currentSum > n + 1 {\n                minI = currentSum - n;\n            }\n            \n            // Ensure both i and j are valid\n            if maxI >= minI && minI >= 1 && maxI <= n {\n                // Also ensure j = currentSum - maxI >= 1 and j <= n\n                int minJ = currentSum - maxI;\n                int maxJ = currentSum - minI;\n                \n                if minJ >= 1 && maxJ <= n && minJ <= maxJ {\n                    count = count + (maxI - minI + 1);\n                }\n            }\n        }\n        \n        currentSum = currentSum + targetMod;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        int|error n = 'int:fromString(input_line.trim());\n        \n        if n is int {\n            if n < 2 {\n                io:println(\"Error: n must be at least 2\");\n                return;\n            }\n            \n            int|error result = countPairsWithMaxNines(n);\n            if result is int {\n                io:println(result);\n            } else {\n                io:println(\"Error: \" + result.message());\n            }\n        } else {\n            io:println(\"Error: Invalid input\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int|error result = countPairsWithMaxNines(7);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 3);\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    int|error result = countPairsWithMaxNines(14);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 9);\n    }\n}\n\n@test:Config {}\nfunction testExample3() {\n    int|error result = countPairsWithMaxNines(50);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testSmallCase() {\n    int|error result = countPairsWithMaxNines(2);\n    test:assertTrue(result is int);\n    if result is int {\n        // For n=2: only pair (1,2) with sum=3\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testLargerCase() {\n    int|error result = countPairsWithMaxNines(100);\n    test:assertTrue(result is int);\n    if result is int {\n        // For n=100: sum can be up to 199, max trailing 9s is 99\n        test:assertEquals(result, 1);\n    }\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - Shovels cost 1, 2, 3, ..., n burles\n// - We need pairs (i, j) where 1 <= i < j <= n\n// - Sum of pair = i + j\n// - Maximum possible sum = n + (n-1) = 2n - 1\n// - Minimum possible sum = 1 + 2 = 3\n//\n// Strategy:\n// 1. Find maximum number of trailing 9s achievable (check 9, 99, 999, ...)\n// 2. Count pairs where sum ends with that many 9s\n// 3. For k trailing 9s, target values are: 10^k - 1, 2*10^k - 1, 3*10^k - 1, ...\n//    (i.e., 9, 99, 999, ... or 19, 199, 1999, ... etc.)\n\nimport ballerina/io;\n\nfunction countPairsWithMaxNines(int n) returns int|error {\n    if n < 2 {\n        return error(\"n must be at least 2\");\n    }\n    \n    int maxSum = 2 * n - 1;\n    int minSum = 3; // 1 + 2\n    \n    // Find the maximum number of trailing 9s possible\n    // Check for 9, 99, 999, 9999, etc.\n    int targetMod = 10; // Start checking for sum % 10 = 9\n    int targetRemainder = 9;\n    \n    // Try to find the highest power of 10 where we can achieve all 9s\n    while (targetRemainder * 10 + 9 <= maxSum) {\n        targetMod = targetMod * 10;\n        targetRemainder = targetRemainder * 10 + 9;\n    }\n    \n    // Now count pairs where (i + j) % targetMod = targetRemainder\n    // Valid sums are: targetRemainder, targetRemainder + targetMod, targetRemainder + 2*targetMod, ...\n    \n    int count = 0;\n    int currentSum = targetRemainder;\n    \n    while currentSum <= maxSum {\n        if currentSum >= minSum {\n            // Count pairs (i, j) where i + j = currentSum and 1 <= i < j <= n\n            // For i + j = currentSum:\n            // - i ranges from 1 to floor((currentSum-1)/2) to ensure i < j\n            // - j = currentSum - i must be <= n\n            // - i must be >= 1 and j must be >= 1\n            \n            int maxI = (currentSum - 1) / 2; // Ensures i < j (since j = currentSum - i)\n            int minI = 1;\n            \n            // Ensure j = currentSum - i <= n\n            // So i >= currentSum - n\n            if currentSum > n + 1 {\n                minI = currentSum - n;\n            }\n            \n            // Ensure both i and j are valid\n            if maxI >= minI && minI >= 1 && maxI <= n {\n                // Also ensure j = currentSum - maxI >= 1 and j <= n\n                int minJ = currentSum - maxI;\n                int maxJ = currentSum - minI;\n                \n                if minJ >= 1 && maxJ <= n && minJ <= maxJ {\n                    count = count + (maxI - minI + 1);\n                }\n            }\n        }\n        \n        currentSum = currentSum + targetMod;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        int|error n = 'int:fromString(input_line.trim());\n        \n        if n is int {\n            if n < 2 {\n                io:println(\"Error: n must be at least 2\");\n                return;\n            }\n            \n            int|error result = countPairsWithMaxNines(n);\n            if result is int {\n                io:println(result);\n            } else {\n                io:println(\"Error: \" + result.message());\n            }\n        } else {\n            io:println(\"Error: Invalid input\");\n        }\n    }\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:30:34.943194",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find pairs of shovels (with costs 1 to n) where the sum ends with the maximum possible number of 9s. \n\nKey observations:\n- Shovel i costs i burles\n- We need pairs (i, j) where i < j\n- Sum of costs = i + j\n- We want the sum to end with maximum 9s\n- We need to count how many such pairs exist\n\nThe strategy:\n1. For a sum to end with 9s, we need to find what remainder patterns work\n2. For sum ending with \"9\": sum % 10 = 9\n3. For sum ending with \"99\": sum % 100 = 99\n4. For sum ending with \"999\": sum % 1000 = 999, etc.\n5. We check from the largest possible (based on max sum = n + (n-1)) down to find max 9s\n6. Count pairs where i + j gives the target remainder\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Two shovels with costs i and j (where 1 <= i < j <= n) sum to i + j\n// - Maximum sum is n + (n-1) = 2n - 1\n// - We need to find the maximum number of trailing 9s possible\n// - Then count pairs that achieve this\n// \n// Approach:\n// 1. Determine max trailing 9s by checking if we can achieve 9, 99, 999, etc.\n// 2. For k trailing 9s, we need (i + j) % (10^k) = 10^k - 1\n// 3. Count valid pairs efficiently using math rather than iteration\n\nimport ballerina/io;\n\nfunction countPairsWithMaxNines(int n) returns int|error {\n    if n < 2 {\n        return error(\"n must be at least 2\");\n    }\n    \n    // Maximum possible sum is n + (n-1) = 2n - 1\n    int maxSum = 2 * n - 1;\n    \n    // Find the maximum number of trailing 9s possible\n    int target = 9;  // Start with one 9\n    int multiplier = 10;\n    \n    // Check if we can achieve more 9s (99, 999, etc.)\n    while multiplier * 10 - 1 <= maxSum {\n        target = multiplier * 10 - 1;\n        multiplier = multiplier * 10;\n    }\n    \n    // Now count pairs where i + j ≡ target (mod multiplier)\n    // We need i + j = target, target + multiplier, target + 2*multiplier, ...\n    // where 1 <= i < j <= n\n    \n    int count = 0;\n    int currentSum = target;\n    \n    while currentSum <= 2 * n - 1 {\n        // For sum = currentSum, count valid pairs (i, j) where i < j\n        // i ranges from 1 to min(n, currentSum-1)\n        // j = currentSum - i must satisfy: i < j <= n\n        // So: i < currentSum - i <= n\n        // Which means: i < currentSum/2 and currentSum - i <= n\n        \n        int minI = 1;\n        int maxI = (currentSum - 1) / 2;  // Ensure i < j (i.e., i < currentSum - i)\n        \n        // Also ensure j = currentSum - i <= n\n        // So i >= currentSum - n\n        if currentSum > n {\n            minI = currentSum - n;\n        }\n        \n        if maxI >= minI && minI >= 1 && maxI <= n {\n            count = count + (maxI - minI + 1);\n        }\n        \n        currentSum = currentSum + multiplier;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter n: \");\n    if input_line is string {\n        int|error n = 'int:fromString(input_line.trim());\n        \n        if n is int {\n            if n < 2 {\n                io:println(\"Error: n must be at least 2\");\n                return;\n            }\n            \n            int|error result = countPairsWithMaxNines(n);\n            if result is int {\n                io:println(result);\n            } else {\n                io:println(\"Error: \" + result.message());\n            }\n        } else {\n            io:println(\"Error: Invalid input, please enter a valid integer\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int|error result = countPairsWithMaxNines(7);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 3);\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    int|error result = countPairsWithMaxNines(14);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 9);\n    }\n}\n\n@test:Config {}\nfunction testExample3() {\n    int|error result = countPairsWithMaxNines(50);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testSmallCase() {\n    int|error result = countPairsWithMaxNines(2);\n    test:assertTrue(result is int);\n    if result is int {\n        // For n=2: only pair (1,2) with sum=3, no 9s at end\n        // All pairs end with same number of 9s (zero), so count all\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testLargerCase() {\n    int|error result = countPairsWithMaxNines(100);\n    test:assertTrue(result is int);\n    if result is int {\n        // For n=100: pairs like (49,50)=99, (99,100)=199\n        // Maximum is 99 (two 9s), only one pair: (49,50)\n        test:assertEquals(result, 1);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Two shovels with costs i and j (where 1 <= i < j <= n) sum to i + j\n// - Maximum sum is n + (n-1) = 2n - 1\n// - We need to find the maximum number of trailing 9s possible\n// - Then count pairs that achieve this\n// \n// Approach:\n// 1. Determine max trailing 9s by checking if we can achieve 9, 99, 999, etc.\n// 2. For k trailing 9s, we need (i + j) % (10^k) = 10^k - 1\n// 3. Count valid pairs efficiently using math rather than iteration\n\nimport ballerina/io;\n\nfunction countPairsWithMaxNines(int n) returns int|error {\n    if n < 2 {\n        return error(\"n must be at least 2\");\n    }\n    \n    // Maximum possible sum is n + (n-1) = 2n - 1\n    int maxSum = 2 * n - 1;\n    \n    // Find the maximum number of trailing 9s possible\n    int target = 9;  // Start with one 9\n    int multiplier = 10;\n    \n    // Check if we can achieve more 9s (99, 999, etc.)\n    while multiplier * 10 - 1 <= maxSum {\n        target = multiplier * 10 - 1;\n        multiplier = multiplier * 10;\n    }\n    \n    // Now count pairs where i + j ≡ target (mod multiplier)\n    // We need i + j = target, target + multiplier, target + 2*multiplier, ...\n    // where 1 <= i < j <= n\n    \n    int count = 0;\n    int currentSum = target;\n    \n    while currentSum <= 2 * n - 1 {\n        // For sum = currentSum, count valid pairs (i, j) where i < j\n        // i ranges from 1 to min(n, currentSum-1)\n        // j = currentSum - i must satisfy: i < j <= n\n        // So: i < currentSum - i <= n\n        // Which means: i < currentSum/2 and currentSum - i <= n\n        \n        int minI = 1;\n        int maxI = (currentSum - 1) / 2;  // Ensure i < j (i.e., i < currentSum - i)\n        \n        // Also ensure j = currentSum - i <= n\n        // So i >= currentSum - n\n        if currentSum > n {\n            minI = currentSum - n;\n        }\n        \n        if maxI >= minI && minI >= 1 && maxI <= n {\n            count = count + (maxI - minI + 1);\n        }\n        \n        currentSum = currentSum + multiplier;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter n: \");\n    if input_line is string {\n        int|error n = 'int:fromString(input_line.trim());\n        \n        if n is int {\n            if n < 2 {\n                io:println(\"Error: n must be at least 2\");\n                return;\n            }\n            \n            int|error result = countPairsWithMaxNines(n);\n            if result is int {\n                io:println(result);\n            } else {\n                io:println(\"Error: \" + result.message());\n            }\n        } else {\n            io:println(\"Error: Invalid input, please enter a valid integer\");\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/3 tests (0.0%), need 75%",
      "error": "Only passed 0/3 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "7\n",
          "expected_output": "3\n",
          "actual_output": "Enter n: 3\n",
          "error": "Output mismatch"
        }
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:31:16.623693",
      "status": "success",
      "completion": "Looking at the issue, the main problem is that the code is prompting \"Enter n: \" which shouldn't be there for automated test cases. The input should be read directly from stdin without any prompt.\n\nLet me analyze the problem more carefully:\n\n1. We have n shovels with costs 1, 2, 3, ..., n\n2. We need pairs (i, j) where i < j\n3. Sum = i + j should end with maximum possible trailing 9s\n4. Count how many such pairs exist\n\nFor n=7:\n- Max sum = 7 + 6 = 13\n- Can we get sum ending in 9? Yes (2+7=9, 3+6=9, 4+5=9)\n- Can we get sum ending in 99? No (max sum is 13)\n- So maximum trailing 9s = 1, and count = 3\n\nFor n=14:\n- Max sum = 14 + 13 = 27\n- Sums ending in 9: 9, 19\n- Sum=9: (1,8), (2,7), (3,6), (4,5) = 4 pairs\n- Sum=19: (5,14), (6,13), (7,12), (8,11), (9,10) = 5 pairs\n- Total = 9 pairs\n\nFor n=50:\n- Max sum = 50 + 49 = 99\n- Can we get 99? Yes (49+50=99) = 1 pair\n- Can we get 999? No\n- So we look for sums ending in 99: only 99 itself\n- Count = 1\n\n# Overview\nThis problem requires finding pairs of shovels where their sum ends with the maximum possible number of trailing 9s. The key is to determine the maximum achievable trailing 9s based on the range [1, n], then count all pairs that achieve this maximum.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Shovels cost 1, 2, 3, ..., n burles\n// - We need pairs (i, j) where 1 <= i < j <= n\n// - Sum of pair = i + j\n// - Maximum possible sum = n + (n-1) = 2n - 1\n// - Minimum possible sum = 1 + 2 = 3\n//\n// Strategy:\n// 1. Find maximum number of trailing 9s achievable (check 9, 99, 999, ...)\n// 2. Count pairs where sum ends with that many 9s\n// 3. For k trailing 9s, target values are: 10^k - 1, 2*10^k - 1, 3*10^k - 1, ...\n//    (i.e., 9, 99, 999, ... or 19, 199, 1999, ... etc.)\n\nimport ballerina/io;\n\nfunction countPairsWithMaxNines(int n) returns int|error {\n    if n < 2 {\n        return error(\"n must be at least 2\");\n    }\n    \n    int maxSum = 2 * n - 1;\n    int minSum = 3; // 1 + 2\n    \n    // Find the maximum number of trailing 9s possible\n    // Check for 9, 99, 999, 9999, etc.\n    int targetMod = 10; // Start checking for sum % 10 = 9\n    int targetRemainder = 9;\n    \n    // Try to find the highest power of 10 where we can achieve all 9s\n    while (targetRemainder * 10 + 9 <= maxSum) {\n        targetMod = targetMod * 10;\n        targetRemainder = targetRemainder * 10 + 9;\n    }\n    \n    // Now count pairs where (i + j) % targetMod = targetRemainder\n    // Valid sums are: targetRemainder, targetRemainder + targetMod, targetRemainder + 2*targetMod, ...\n    \n    int count = 0;\n    int currentSum = targetRemainder;\n    \n    while currentSum <= maxSum {\n        if currentSum >= minSum {\n            // Count pairs (i, j) where i + j = currentSum and 1 <= i < j <= n\n            // For i + j = currentSum:\n            // - i ranges from 1 to floor((currentSum-1)/2) to ensure i < j\n            // - j = currentSum - i must be <= n\n            // - i must be >= 1 and j must be >= 1\n            \n            int maxI = (currentSum - 1) / 2; // Ensures i < j (since j = currentSum - i)\n            int minI = 1;\n            \n            // Ensure j = currentSum - i <= n\n            // So i >= currentSum - n\n            if currentSum > n + 1 {\n                minI = currentSum - n;\n            }\n            \n            // Ensure both i and j are valid\n            if maxI >= minI && minI >= 1 && maxI <= n {\n                // Also ensure j = currentSum - maxI >= 1 and j <= n\n                int minJ = currentSum - maxI;\n                int maxJ = currentSum - minI;\n                \n                if minJ >= 1 && maxJ <= n && minJ <= maxJ {\n                    count = count + (maxI - minI + 1);\n                }\n            }\n        }\n        \n        currentSum = currentSum + targetMod;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        int|error n = 'int:fromString(input_line.trim());\n        \n        if n is int {\n            if n < 2 {\n                io:println(\"Error: n must be at least 2\");\n                return;\n            }\n            \n            int|error result = countPairsWithMaxNines(n);\n            if result is int {\n                io:println(result);\n            } else {\n                io:println(\"Error: \" + result.message());\n            }\n        } else {\n            io:println(\"Error: Invalid input\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int|error result = countPairsWithMaxNines(7);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 3);\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    int|error result = countPairsWithMaxNines(14);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 9);\n    }\n}\n\n@test:Config {}\nfunction testExample3() {\n    int|error result = countPairsWithMaxNines(50);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testSmallCase() {\n    int|error result = countPairsWithMaxNines(2);\n    test:assertTrue(result is int);\n    if result is int {\n        // For n=2: only pair (1,2) with sum=3\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testLargerCase() {\n    int|error result = countPairsWithMaxNines(100);\n    test:assertTrue(result is int);\n    if result is int {\n        // For n=100: sum can be up to 199, max trailing 9s is 99\n        test:assertEquals(result, 1);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Shovels cost 1, 2, 3, ..., n burles\n// - We need pairs (i, j) where 1 <= i < j <= n\n// - Sum of pair = i + j\n// - Maximum possible sum = n + (n-1) = 2n - 1\n// - Minimum possible sum = 1 + 2 = 3\n//\n// Strategy:\n// 1. Find maximum number of trailing 9s achievable (check 9, 99, 999, ...)\n// 2. Count pairs where sum ends with that many 9s\n// 3. For k trailing 9s, target values are: 10^k - 1, 2*10^k - 1, 3*10^k - 1, ...\n//    (i.e., 9, 99, 999, ... or 19, 199, 1999, ... etc.)\n\nimport ballerina/io;\n\nfunction countPairsWithMaxNines(int n) returns int|error {\n    if n < 2 {\n        return error(\"n must be at least 2\");\n    }\n    \n    int maxSum = 2 * n - 1;\n    int minSum = 3; // 1 + 2\n    \n    // Find the maximum number of trailing 9s possible\n    // Check for 9, 99, 999, 9999, etc.\n    int targetMod = 10; // Start checking for sum % 10 = 9\n    int targetRemainder = 9;\n    \n    // Try to find the highest power of 10 where we can achieve all 9s\n    while (targetRemainder * 10 + 9 <= maxSum) {\n        targetMod = targetMod * 10;\n        targetRemainder = targetRemainder * 10 + 9;\n    }\n    \n    // Now count pairs where (i + j) % targetMod = targetRemainder\n    // Valid sums are: targetRemainder, targetRemainder + targetMod, targetRemainder + 2*targetMod, ...\n    \n    int count = 0;\n    int currentSum = targetRemainder;\n    \n    while currentSum <= maxSum {\n        if currentSum >= minSum {\n            // Count pairs (i, j) where i + j = currentSum and 1 <= i < j <= n\n            // For i + j = currentSum:\n            // - i ranges from 1 to floor((currentSum-1)/2) to ensure i < j\n            // - j = currentSum - i must be <= n\n            // - i must be >= 1 and j must be >= 1\n            \n            int maxI = (currentSum - 1) / 2; // Ensures i < j (since j = currentSum - i)\n            int minI = 1;\n            \n            // Ensure j = currentSum - i <= n\n            // So i >= currentSum - n\n            if currentSum > n + 1 {\n                minI = currentSum - n;\n            }\n            \n            // Ensure both i and j are valid\n            if maxI >= minI && minI >= 1 && maxI <= n {\n                // Also ensure j = currentSum - maxI >= 1 and j <= n\n                int minJ = currentSum - maxI;\n                int maxJ = currentSum - minI;\n                \n                if minJ >= 1 && maxJ <= n && minJ <= maxJ {\n                    count = count + (maxI - minI + 1);\n                }\n            }\n        }\n        \n        currentSum = currentSum + targetMod;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        int|error n = 'int:fromString(input_line.trim());\n        \n        if n is int {\n            if n < 2 {\n                io:println(\"Error: n must be at least 2\");\n                return;\n            }\n            \n            int|error result = countPairsWithMaxNines(n);\n            if result is int {\n                io:println(result);\n            } else {\n                io:println(\"Error: \" + result.message());\n            }\n        } else {\n            io:println(\"Error: Invalid input\");\n        }\n    }\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:31:57.742784"
}