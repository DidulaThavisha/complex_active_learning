{
  "entry_id": "problem_0243",
  "problem_index": 243,
  "prompt": "Title: Relatively Prime Graph\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nLet's call an undirected graph $G = (V, E)$ relatively prime if and only if for each edge $(v, u) \\in E$  $GCD(v, u) = 1$ (the greatest common divisor of $v$ and $u$ is $1$). If there is no edge between some pair of vertices $v$ and $u$ then the value of $GCD(v, u)$ doesn't matter. The vertices are numbered from $1$ to $|V|$.\n\nConstruct a relatively prime graph with $n$ vertices and $m$ edges such that it is connected and it contains neither self-loops nor multiple edges.\n\nIf there exists no valid graph with the given number of vertices and edges then output \"Impossible\".\n\nIf there are multiple answers then print any of them.\n\nInput Specification:\nThe only line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^5$) — the number of vertices and the number of edges.\n\nOutput Specification:\nIf there exists no valid graph with the given number of vertices and edges then output \"Impossible\".\n\nOtherwise print the answer in the following format:\n\nThe first line should contain the word \"Possible\".\n\nThe $i$-th of the next $m$ lines should contain the $i$-th edge $(v_i, u_i)$ of the resulting graph ($1 \\le v_i, u_i \\le n, v_i \\neq u_i$). For each pair $(v, u)$ there can be no more pairs $(v, u)$ or $(u, v)$. The vertices are numbered from $1$ to $n$.\n\nIf there are multiple answers then print any of them.\n\nDemo Input:\n['5 6\\n', '6 12\\n']\n\nDemo Output:\n['Possible\\n2 5\\n3 2\\n5 1\\n3 4\\n4 1\\n5 4\\n', 'Impossible\\n']\n\nNote:\nHere is the representation of the graph from the first example: <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/7a1353a992545456c007e3071fa0a06fe46fc64e.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/>",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:27:22.252924",
      "status": "failed",
      "completion": "# Overview\n\nThe problem asks us to construct a relatively prime graph where GCD of every edge (u,v) = 1. The graph must be connected with n vertices and m edges, no self-loops or multiple edges.\n\nKey observations:\n1. A connected graph with n vertices needs at least (n-1) edges\n2. A simple graph with n vertices can have at most n*(n-1)/2 edges\n3. For a graph to be connected and relatively prime, we can use a strategy: connect vertex 1 to all other vertices (1 to 2, 1 to 3, ..., 1 to n). This gives us (n-1) edges, all with GCD=1 since GCD(1,x)=1 for any x.\n4. After that, we can add more edges between consecutive vertices like (2,3), (3,4), (4,5)... These are relatively prime pairs.\n5. We need exactly m edges. If m < n-1, it's impossible. If m is too large (more than maximum possible edges), it's also impossible.\n\n<CODE>\n```ballerina\nimport ballerina/io;\n\n// Reasoning:\n// 1. For a connected graph with n vertices, we need at least (n-1) edges\n// 2. Maximum edges in a simple graph = n*(n-1)/2\n// 3. Strategy: First connect vertex 1 to all others (gives n-1 edges with GCD=1)\n// 4. Then add edges between consecutive odd-even pairs or primes\n// 5. Simple approach: After connecting all to vertex 1, connect consecutive vertices\n//    like 2-3, 3-4, 4-5, etc. (consecutive integers are always coprime)\n\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\nfunction constructRelativelyPrimeGraph(int n, int m) returns [boolean, [int, int][]] {\n    // Minimum edges needed for connected graph\n    if m < n - 1 {\n        return [false, []];\n    }\n    \n    // Maximum edges in simple graph\n    int maxEdges = n * (n - 1) / 2;\n    if m > maxEdges {\n        return [false, []];\n    }\n    \n    [int, int][] edges = [];\n    \n    // Step 1: Connect vertex 1 to all other vertices (n-1 edges)\n    // GCD(1, x) = 1 for all x\n    int edgeCount = 0;\n    int i = 2;\n    while i <= n && edgeCount < m {\n        edges.push([1, i]);\n        edgeCount += 1;\n        i += 1;\n    }\n    \n    // Step 2: Add more edges if needed\n    // Connect consecutive vertices: 2-3, 3-4, 4-5, etc.\n    // Consecutive integers are coprime\n    i = 2;\n    while i < n && edgeCount < m {\n        int j = i + 1;\n        if gcd(i, j) == 1 {\n            edges.push([i, j]);\n            edgeCount += 1;\n        }\n        i += 1;\n    }\n    \n    // Step 3: Add more edges between non-consecutive vertices if still needed\n    i = 2;\n    while i <= n && edgeCount < m {\n        int j = i + 2;\n        while j <= n && edgeCount < m {\n            if gcd(i, j) == 1 {\n                // Check if this edge already exists\n                boolean exists = false;\n                foreach [int, int] edge in edges {\n                    if (edge[0] == i && edge[1] == j) || (edge[0] == j && edge[1] == i) {\n                        exists = true;\n                        break;\n                    }\n                }\n                if !exists {\n                    edges.push([i, j]);\n                    edgeCount += 1;\n                }\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    if edgeCount == m {\n        return [true, edges];\n    } else {\n        return [false, []];\n    }\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        if parts.length() == 2 {\n            int|error n_result = 'int:fromString(parts[0]);\n            int|error m_result = 'int:fromString(parts[1]);\n            \n            if n_result is int && m_result is int {\n                [boolean, [int, int][]] result = constructRelativelyPrimeGraph(n_result, m_result);\n                \n                if result[0] {\n                    io:println(\"Possible\");\n                    foreach [int, int] edge in result[1] {\n                        io:println(edge[0].toString() + \" \" + edge[1].toString());\n                    }\n                } else {\n                    io:println(\"Impossible\");\n                }\n            } else {\n                io:println(\"Invalid input format\");\n            }\n        } else {\n            io:println(\"Invalid input format\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testGcdFunction() {\n    test:assertEquals(gcd(1, 5), 1);\n    test:assertEquals(gcd(2, 3), 1);\n    test:assertEquals(gcd(4, 6), 2);\n    test:assertEquals(gcd(12, 8), 4);\n}\n\n@test:Config {}\nfunction testImpossibleCase() {\n    // Not enough edges for connected graph\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 3);\n    test:assertEquals(result[0], false);\n    \n    // Too many edges\n    result = constructRelativelyPrimeGraph(3, 10);\n    test:assertEquals(result[0], false);\n}\n\n@test:Config {}\nfunction testMinimumEdges() {\n    // Minimum edges for connected graph (n-1)\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 4);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 4);\n    \n    // Verify all edges have GCD = 1\n    foreach [int, int] edge in result[1] {\n        test:assertEquals(gcd(edge[0], edge[1]), 1);\n    }\n}\n\n@test:Config {}\nfunction testValidGraph() {\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 6);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 6);\n    \n    // Verify all edges are relatively prime\n    foreach [int, int] edge in result[1] {\n        test:assertEquals(gcd(edge[0], edge[1]), 1);\n    }\n}\n\n@test:Config {}\nfunction testSmallGraph() {\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(2, 1);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 1);\n    test:assertEquals(result[1][0], [1, 2]);\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\n\n// Reasoning:\n// 1. For a connected graph with n vertices, we need at least (n-1) edges\n// 2. Maximum edges in a simple graph = n*(n-1)/2\n// 3. Strategy: First connect vertex 1 to all others (gives n-1 edges with GCD=1)\n// 4. Then add edges between consecutive odd-even pairs or primes\n// 5. Simple approach: After connecting all to vertex 1, connect consecutive vertices\n//    like 2-3, 3-4, 4-5, etc. (consecutive integers are always coprime)\n\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\nfunction constructRelativelyPrimeGraph(int n, int m) returns [boolean, [int, int][]] {\n    // Minimum edges needed for connected graph\n    if m < n - 1 {\n        return [false, []];\n    }\n    \n    // Maximum edges in simple graph\n    int maxEdges = n * (n - 1) / 2;\n    if m > maxEdges {\n        return [false, []];\n    }\n    \n    [int, int][] edges = [];\n    \n    // Step 1: Connect vertex 1 to all other vertices (n-1 edges)\n    // GCD(1, x) = 1 for all x\n    int edgeCount = 0;\n    int i = 2;\n    while i <= n && edgeCount < m {\n        edges.push([1, i]);\n        edgeCount += 1;\n        i += 1;\n    }\n    \n    // Step 2: Add more edges if needed\n    // Connect consecutive vertices: 2-3, 3-4, 4-5, etc.\n    // Consecutive integers are coprime\n    i = 2;\n    while i < n && edgeCount < m {\n        int j = i + 1;\n        if gcd(i, j) == 1 {\n            edges.push([i, j]);\n            edgeCount += 1;\n        }\n        i += 1;\n    }\n    \n    // Step 3: Add more edges between non-consecutive vertices if still needed\n    i = 2;\n    while i <= n && edgeCount < m {\n        int j = i + 2;\n        while j <= n && edgeCount < m {\n            if gcd(i, j) == 1 {\n                // Check if this edge already exists\n                boolean exists = false;\n                foreach [int, int] edge in edges {\n                    if (edge[0] == i && edge[1] == j) || (edge[0] == j && edge[1] == i) {\n                        exists = true;\n                        break;\n                    }\n                }\n                if !exists {\n                    edges.push([i, j]);\n                    edgeCount += 1;\n                }\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    if edgeCount == m {\n        return [true, edges];\n    } else {\n        return [false, []];\n    }\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        if parts.length() == 2 {\n            int|error n_result = 'int:fromString(parts[0]);\n            int|error m_result = 'int:fromString(parts[1]);\n            \n            if n_result is int && m_result is int {\n                [boolean, [int, int][]] result = constructRelativelyPrimeGraph(n_result, m_result);\n                \n                if result[0] {\n                    io:println(\"Possible\");\n                    foreach [int, int] edge in result[1] {\n                        io:println(edge[0].toString() + \" \" + edge[1].toString());\n                    }\n                } else {\n                    io:println(\"Impossible\");\n                }\n            } else {\n                io:println(\"Invalid input format\");\n            }\n        } else {\n            io:println(\"Invalid input format\");\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(93:44,93:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(93:44,93:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(93:44,93:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:27:53.222670",
      "status": "failed",
      "completion": "# Overview\n\nThe problem asks us to construct a relatively prime graph where GCD of every edge (u,v) = 1. The graph must be connected with n vertices and m edges, no self-loops or multiple edges.\n\nKey observations:\n1. A connected graph with n vertices needs at least (n-1) edges\n2. A simple graph with n vertices can have at most n*(n-1)/2 edges\n3. Strategy: Connect vertex 1 to all other vertices first (gives n-1 edges with GCD=1 since GCD(1,x)=1)\n4. Then add edges between consecutive vertices (consecutive integers are always coprime)\n5. Finally add more edges between other coprime pairs if needed\n\nThe compilation error was due to using `split()` incorrectly. In Ballerina, we need to use `regex:split()` from the regex module or use `string:split()` with proper import.\n\n<CODE>\n```ballerina\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\n// Reasoning:\n// 1. For a connected graph with n vertices, we need at least (n-1) edges\n// 2. Maximum edges in a simple graph = n*(n-1)/2\n// 3. Strategy: First connect vertex 1 to all others (gives n-1 edges with GCD=1)\n// 4. Then add edges between consecutive vertices (consecutive integers are coprime)\n// 5. Finally add more edges between coprime pairs until we reach m edges\n\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\nfunction constructRelativelyPrimeGraph(int n, int m) returns [boolean, [int, int][]] {\n    // Minimum edges needed for connected graph\n    if m < n - 1 {\n        return [false, []];\n    }\n    \n    // Maximum edges in simple graph\n    int maxEdges = n * (n - 1) / 2;\n    if m > maxEdges {\n        return [false, []];\n    }\n    \n    [int, int][] edges = [];\n    \n    // Step 1: Connect vertex 1 to all other vertices (n-1 edges)\n    // GCD(1, x) = 1 for all x\n    int edgeCount = 0;\n    int i = 2;\n    while i <= n && edgeCount < m {\n        edges.push([1, i]);\n        edgeCount += 1;\n        i += 1;\n    }\n    \n    // Step 2: Add more edges if needed\n    // Connect consecutive vertices: 2-3, 3-4, 4-5, etc.\n    // Consecutive integers are coprime\n    i = 2;\n    while i < n && edgeCount < m {\n        int j = i + 1;\n        if gcd(i, j) == 1 {\n            edges.push([i, j]);\n            edgeCount += 1;\n        }\n        i += 1;\n    }\n    \n    // Step 3: Add more edges between non-consecutive vertices if still needed\n    i = 2;\n    while i <= n && edgeCount < m {\n        int j = i + 2;\n        while j <= n && edgeCount < m {\n            if gcd(i, j) == 1 {\n                // Check if this edge already exists\n                boolean exists = false;\n                foreach [int, int] edge in edges {\n                    if (edge[0] == i && edge[1] == j) || (edge[0] == j && edge[1] == i) {\n                        exists = true;\n                        break;\n                    }\n                }\n                if !exists {\n                    edges.push([i, j]);\n                    edgeCount += 1;\n                }\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    if edgeCount == m {\n        return [true, edges];\n    } else {\n        return [false, []];\n    }\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string trimmed = input_line.trim();\n        regexp:Span[] splits = re ` `.split(trimmed);\n        \n        if splits.length() == 2 {\n            string part1 = trimmed.substring(splits[0].startIndex, splits[0].endIndex);\n            string part2 = trimmed.substring(splits[1].startIndex, splits[1].endIndex);\n            \n            int|error n_result = 'int:fromString(part1);\n            int|error m_result = 'int:fromString(part2);\n            \n            if n_result is int && m_result is int {\n                [boolean, [int, int][]] result = constructRelativelyPrimeGraph(n_result, m_result);\n                \n                if result[0] {\n                    io:println(\"Possible\");\n                    foreach [int, int] edge in result[1] {\n                        io:println(edge[0].toString() + \" \" + edge[1].toString());\n                    }\n                } else {\n                    io:println(\"Impossible\");\n                }\n            } else {\n                io:println(\"Invalid input format\");\n            }\n        } else {\n            io:println(\"Invalid input format\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testGcdFunction() {\n    test:assertEquals(gcd(1, 5), 1);\n    test:assertEquals(gcd(2, 3), 1);\n    test:assertEquals(gcd(4, 6), 2);\n    test:assertEquals(gcd(12, 8), 4);\n}\n\n@test:Config {}\nfunction testImpossibleCase() {\n    // Not enough edges for connected graph\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 3);\n    test:assertEquals(result[0], false);\n    \n    // Too many edges\n    result = constructRelativelyPrimeGraph(3, 10);\n    test:assertEquals(result[0], false);\n}\n\n@test:Config {}\nfunction testMinimumEdges() {\n    // Minimum edges for connected graph (n-1)\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 4);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 4);\n    \n    // Verify all edges have GCD = 1\n    foreach [int, int] edge in result[1] {\n        test:assertEquals(gcd(edge[0], edge[1]), 1);\n    }\n}\n\n@test:Config {}\nfunction testValidGraph() {\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 6);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 6);\n    \n    // Verify all edges are relatively prime\n    foreach [int, int] edge in result[1] {\n        test:assertEquals(gcd(edge[0], edge[1]), 1);\n    }\n}\n\n@test:Config {}\nfunction testSmallGraph() {\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(2, 1);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 1);\n    test:assertEquals(result[1][0], [1, 2]);\n}\n\n@test:Config {}\nfunction testDemoCase1() {\n    // Test case: 5 6\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(5, 6);\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 6);\n}\n\n@test:Config {}\nfunction testDemoCase2() {\n    // Test case: 6 12\n    [boolean, [int, int][]] result = constructRelativelyPrimeGraph(6, 12);\n    // 6 vertices can have at most 6*5/2 = 15 edges, so 12 is possible\n    test:assertEquals(result[0], true);\n    test:assertEquals(result[1].length(), 12);\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\nimport ballerina/lang.regexp;\n\n// Reasoning:\n// 1. For a connected graph with n vertices, we need at least (n-1) edges\n// 2. Maximum edges in a simple graph = n*(n-1)/2\n// 3. Strategy: First connect vertex 1 to all others (gives n-1 edges with GCD=1)\n// 4. Then add edges between consecutive vertices (consecutive integers are coprime)\n// 5. Finally add more edges between coprime pairs until we reach m edges\n\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\nfunction constructRelativelyPrimeGraph(int n, int m) returns [boolean, [int, int][]] {\n    // Minimum edges needed for connected graph\n    if m < n - 1 {\n        return [false, []];\n    }\n    \n    // Maximum edges in simple graph\n    int maxEdges = n * (n - 1) / 2;\n    if m > maxEdges {\n        return [false, []];\n    }\n    \n    [int, int][] edges = [];\n    \n    // Step 1: Connect vertex 1 to all other vertices (n-1 edges)\n    // GCD(1, x) = 1 for all x\n    int edgeCount = 0;\n    int i = 2;\n    while i <= n && edgeCount < m {\n        edges.push([1, i]);\n        edgeCount += 1;\n        i += 1;\n    }\n    \n    // Step 2: Add more edges if needed\n    // Connect consecutive vertices: 2-3, 3-4, 4-5, etc.\n    // Consecutive integers are coprime\n    i = 2;\n    while i < n && edgeCount < m {\n        int j = i + 1;\n        if gcd(i, j) == 1 {\n            edges.push([i, j]);\n            edgeCount += 1;\n        }\n        i += 1;\n    }\n    \n    // Step 3: Add more edges between non-consecutive vertices if still needed\n    i = 2;\n    while i <= n && edgeCount < m {\n        int j = i + 2;\n        while j <= n && edgeCount < m {\n            if gcd(i, j) == 1 {\n                // Check if this edge already exists\n                boolean exists = false;\n                foreach [int, int] edge in edges {\n                    if (edge[0] == i && edge[1] == j) || (edge[0] == j && edge[1] == i) {\n                        exists = true;\n                        break;\n                    }\n                }\n                if !exists {\n                    edges.push([i, j]);\n                    edgeCount += 1;\n                }\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    \n    if edgeCount == m {\n        return [true, edges];\n    } else {\n        return [false, []];\n    }\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    if input_line is string {\n        string trimmed = input_line.trim();\n        regexp:Span[] splits = re ` `.split(trimmed);\n        \n        if splits.length() == 2 {\n            string part1 = trimmed.substring(splits[0].startIndex, splits[0].endIndex);\n            string part2 = trimmed.substring(splits[1].startIndex, splits[1].endIndex);\n            \n            int|error n_result = 'int:fromString(part1);\n            int|error m_result = 'int:fromString(part2);\n            \n            if n_result is int && m_result is int {\n                [boolean, [int, int][]] result = constructRelativelyPrimeGraph(n_result, m_result);\n                \n                if result[0] {\n                    io:println(\"Possible\");\n                    foreach [int, int] edge in result[1] {\n                        io:println(edge[0].toString() + \" \" + edge[1].toString());\n                    }\n                } else {\n                    io:println(\"Impossible\");\n                }\n            } else {\n                io:println(\"Invalid input format\");\n            }\n        } else {\n            io:println(\"Invalid input format\");\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(94:32,94:53)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(94:32,94:53)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(94:32,94:53)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(94:32,94:53)] incompatible types: expected 'ballerina/lang.regexp:0.0.0:Span[]', found 'string[]'\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T04:28:17.612948"
}