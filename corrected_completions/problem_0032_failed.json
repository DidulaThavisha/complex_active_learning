{
  "entry_id": "problem_0032",
  "problem_index": 32,
  "prompt": "Title: Strange Addition\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nUnfortunately, Vasya can only sum pairs of integers (*a*, *b*), such that for any decimal place at least one number has digit 0 in this place. For example, Vasya can sum numbers 505 and 50, but he cannot sum 1 and 4.\n\nVasya has a set of *k* distinct non-negative integers *d*1,<=*d*2,<=...,<=*d**k*.\n\nVasya wants to choose some integers from this set so that he could sum any two chosen numbers. What maximal number of integers can he choose in the required manner?\n\nInput Specification:\nThe first input line contains integer *k* (1<=≤<=*k*<=≤<=100) — the number of integers.\n\nThe second line contains *k* distinct space-separated integers *d*1,<=*d*2,<=...,<=*d**k* (0<=≤<=*d**i*<=≤<=100).\n\nOutput Specification:\nIn the first line print a single integer *n* the maximum number of the chosen integers. In the second line print *n* distinct non-negative integers — the required integers.\n\nIf there are multiple solutions, print any of them. You can print the numbers in any order.\n\nDemo Input:\n['4\\n100 10 1 0\\n', '3\\n2 70 3\\n']\n\nDemo Output:\n['4\\n0 1 10 100 ', '2\\n2 70 ']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:29:49.628114",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the maximum subset of numbers where any two numbers can be summed according to Vasya's rule: for each decimal position, at least one of the two numbers must have a 0 in that position.\n\nThe key insight is that two numbers can be summed if and only if they don't both have non-zero digits in the same decimal position. This means we need to find the maximum subset where no two numbers violate this rule.\n\nA crucial observation: if we think about the digits at each position, numbers that have complementary patterns of zeros can be summed. The optimal strategy is to find numbers that share the maximum number of zero positions, or select all numbers that differ only in positions where at least one has a zero.\n\nAfter analysis, the solution is: we can always include all numbers that differ in at most one decimal position having non-zero digits, OR we can greedily select numbers where their union of non-zero digit positions doesn't overlap in a conflicting way. \n\nActually, a simpler approach: Check all pairs - if we can find a maximal subset where every pair is compatible, that's our answer. For small k (≤100), we can use a greedy or brute force approach.\n\nThe most pragmatic solution: Start with all numbers, then remove numbers that conflict until we have a valid set. Or use a greedy approach: sort and pick numbers that are compatible with all previously picked numbers.\n\n<CODE>\n```ballerina\nimport ballerina/io;\n\n// Reasoning:\n// Two numbers can be summed if for every decimal position (units, tens, hundreds),\n// at least one of them has a 0 digit in that position.\n// \n// Strategy:\n// 1. Parse the input to get k numbers\n// 2. For each pair of numbers, check if they can be summed\n// 3. Find the maximum subset where all pairs can be summed\n// 4. Since k is small (≤100), we can use a greedy approach:\n//    - Start with the first number\n//    - Keep adding numbers that are compatible with ALL previously selected numbers\n//    - Try different starting points to find the maximum subset\n\n// Check if two numbers can be summed according to Vasya's rule\nfunction canSum(int a, int b) returns boolean {\n    // For each decimal position, at least one must have digit 0\n    int tempA = a;\n    int tempB = b;\n    \n    // Check each digit position\n    while tempA > 0 || tempB > 0 {\n        int digitA = tempA % 10;\n        int digitB = tempB % 10;\n        \n        // If both digits are non-zero, they cannot be summed\n        if digitA != 0 && digitB != 0 {\n            return false;\n        }\n        \n        tempA = tempA / 10;\n        tempB = tempB / 10;\n    }\n    \n    return true;\n}\n\n// Check if a number is compatible with all numbers in the selected set\nfunction isCompatibleWithAll(int num, int[] selectedNumbers) returns boolean {\n    foreach int selected in selectedNumbers {\n        if !canSum(num, selected) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Find maximum subset where all pairs can be summed\nfunction findMaxSubset(int[] numbers) returns int[] {\n    int[] maxSubset = [];\n    \n    // Try starting with each number as the first element\n    foreach int i in 0 ..< numbers.length() {\n        int[] currentSubset = [numbers[i]];\n        \n        // Try to add other numbers\n        foreach int j in 0 ..< numbers.length() {\n            if i != j {\n                if isCompatibleWithAll(numbers[j], currentSubset) {\n                    currentSubset.push(numbers[j]);\n                }\n            }\n        }\n        \n        // Keep the largest subset found\n        if currentSubset.length() > maxSubset.length() {\n            maxSubset = currentSubset;\n        }\n    }\n    \n    return maxSubset;\n}\n\npublic function main() returns error? {\n    // Read k\n    string? kLine = io:readln();\n    if kLine is () {\n        return error(\"Failed to read k\");\n    }\n    \n    int k = check 'int:fromString(kLine.trim());\n    \n    if k == 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the k numbers\n    string? numbersLine = io:readln();\n    if numbersLine is () {\n        return error(\"Failed to read numbers\");\n    }\n    \n    string[] parts = numbersLine.trim().split(\" \");\n    int[] numbers = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int num = check 'int:fromString(part.trim());\n            numbers.push(num);\n        }\n    }\n    \n    // Find the maximum subset\n    int[] result = findMaxSubset(numbers);\n    \n    // Output the result\n    io:println(result.length());\n    \n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += result[i].toString();\n    }\n    if result.length() > 0 {\n        output += \" \";\n    }\n    io:println(output);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCanSumBasic() {\n    // 505 and 50 can be summed (5 and 0, 0 and 5, 5 and 0)\n    boolean result = canSum(505, 50);\n    test:assertTrue(result, \"505 and 50 should be able to be summed\");\n    \n    // 1 and 4 cannot be summed (both have non-zero in units place)\n    result = canSum(1, 4);\n    test:assertFalse(result, \"1 and 4 should not be able to be summed\");\n    \n    // 0 can be summed with any number\n    result = canSum(0, 100);\n    test:assertTrue(result, \"0 and 100 should be able to be summed\");\n    \n    // 10 and 1 can be summed (1 and 0, 0 and 1)\n    result = canSum(10, 1);\n    test:assertTrue(result, \"10 and 1 should be able to be summed\");\n}\n\n@test:Config {}\nfunction testCanSumMoreCases() {\n    // 100 and 10 can be summed\n    boolean result = canSum(100, 10);\n    test:assertTrue(result, \"100 and 10 should be able to be summed\");\n    \n    // 2 and 70 can be summed (2 and 0, 0 and 7)\n    result = canSum(2, 70);\n    test:assertTrue(result, \"2 and 70 should be able to be summed\");\n    \n    // 2 and 3 cannot be summed (both non-zero in units)\n    result = canSum(2, 3);\n    test:assertFalse(result, \"2 and 3 should not be able to be summed\");\n    \n    // Same number with itself (except 0) cannot be summed\n    result = canSum(5, 5);\n    test:assertFalse(result, \"5 and 5 should not be able to be summed\");\n}\n\n@test:Config {}\nfunction testFindMaxSubsetExample1() {\n    int[] numbers = [100, 10, 1, 0];\n    int[] result = findMaxSubset(numbers);\n    \n    // All four numbers should be selected\n    test:assertEquals(result.length(), 4, \"Should select all 4 numbers\");\n    \n    // Verify all pairs can be summed\n    foreach int i in 0 ..< result.length() {\n        foreach int j in (i + 1) ..< result.length() {\n            test:assertTrue(canSum(result[i], result[j]), \n                \"All pairs should be summable\");\n        }\n    }\n}\n\n@test:Config {}\nfunction testFindMaxSubsetExample2() {\n    int[] numbers = [2, 70, 3];\n    int[] result = findMaxSubset(numbers);\n    \n    // Should select 2 numbers (2 and 70, or just one)\n    test:assertTrue(result.length() >= 2, \"Should select at least 2 numbers\");\n    \n    // Verify all pairs can be summed\n    foreach int i in 0 ..< result.length() {\n        foreach int j in (i + 1) ..< result.length() {\n            test:assertTrue(canSum(result[i], result[j]), \n                \"All pairs should be summable\");\n        }\n    }\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\n\n// Reasoning:\n// Two numbers can be summed if for every decimal position (units, tens, hundreds),\n// at least one of them has a 0 digit in that position.\n// \n// Strategy:\n// 1. Parse the input to get k numbers\n// 2. For each pair of numbers, check if they can be summed\n// 3. Find the maximum subset where all pairs can be summed\n// 4. Since k is small (≤100), we can use a greedy approach:\n//    - Start with the first number\n//    - Keep adding numbers that are compatible with ALL previously selected numbers\n//    - Try different starting points to find the maximum subset\n\n// Check if two numbers can be summed according to Vasya's rule\nfunction canSum(int a, int b) returns boolean {\n    // For each decimal position, at least one must have digit 0\n    int tempA = a;\n    int tempB = b;\n    \n    // Check each digit position\n    while tempA > 0 || tempB > 0 {\n        int digitA = tempA % 10;\n        int digitB = tempB % 10;\n        \n        // If both digits are non-zero, they cannot be summed\n        if digitA != 0 && digitB != 0 {\n            return false;\n        }\n        \n        tempA = tempA / 10;\n        tempB = tempB / 10;\n    }\n    \n    return true;\n}\n\n// Check if a number is compatible with all numbers in the selected set\nfunction isCompatibleWithAll(int num, int[] selectedNumbers) returns boolean {\n    foreach int selected in selectedNumbers {\n        if !canSum(num, selected) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Find maximum subset where all pairs can be summed\nfunction findMaxSubset(int[] numbers) returns int[] {\n    int[] maxSubset = [];\n    \n    // Try starting with each number as the first element\n    foreach int i in 0 ..< numbers.length() {\n        int[] currentSubset = [numbers[i]];\n        \n        // Try to add other numbers\n        foreach int j in 0 ..< numbers.length() {\n            if i != j {\n                if isCompatibleWithAll(numbers[j], currentSubset) {\n                    currentSubset.push(numbers[j]);\n                }\n            }\n        }\n        \n        // Keep the largest subset found\n        if currentSubset.length() > maxSubset.length() {\n            maxSubset = currentSubset;\n        }\n    }\n    \n    return maxSubset;\n}\n\npublic function main() returns error? {\n    // Read k\n    string? kLine = io:readln();\n    if kLine is () {\n        return error(\"Failed to read k\");\n    }\n    \n    int k = check 'int:fromString(kLine.trim());\n    \n    if k == 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the k numbers\n    string? numbersLine = io:readln();\n    if numbersLine is () {\n        return error(\"Failed to read numbers\");\n    }\n    \n    string[] parts = numbersLine.trim().split(\" \");\n    int[] numbers = [];\n    \n    foreach string part in parts {\n        if part.trim().length() > 0 {\n            int num = check 'int:fromString(part.trim());\n            numbers.push(num);\n        }\n    }\n    \n    // Find the maximum subset\n    int[] result = findMaxSubset(numbers);\n    \n    // Output the result\n    io:println(result.length());\n    \n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += result[i].toString();\n    }\n    if result.length() > 0 {\n        output += \" \";\n    }\n    io:println(output);\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(96:41,96:46)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(96:41,96:46)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(96:41,96:46)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:30:26.390002",
      "status": "failed",
      "completion": "# Overview\nThis problem requires finding the maximum subset of numbers where any two numbers can be summed according to Vasya's rule: for each decimal position, at least one of the two numbers must have a 0 digit in that position.\n\nThe key insight is checking digit-by-digit compatibility. Two numbers are compatible if at every digit position (units, tens, hundreds, etc.), at least one has a 0. We use a greedy approach to find the maximum valid subset.\n\nThe compilation error was due to using `split` incorrectly - we need to use `regex:split` from the `ballerina/regex` module.\n\n<CODE>\n```ballerina\nimport ballerina/io;\nimport ballerina/regex;\n\n// Reasoning:\n// Two numbers can be summed if for every decimal position (units, tens, hundreds),\n// at least one of them has a 0 digit in that position.\n// \n// Approach:\n// 1. Extract each digit position for both numbers\n// 2. Check if at each position, at least one has digit 0\n// 3. Use greedy algorithm: try each number as starting point and build compatible subset\n// 4. Return the largest subset found\n\n// Check if two numbers can be summed according to Vasya's rule\nfunction canSum(int a, int b) returns boolean {\n    // For each decimal position, at least one must have digit 0\n    int tempA = a;\n    int tempB = b;\n    \n    // Check each digit position\n    while tempA > 0 || tempB > 0 {\n        int digitA = tempA % 10;\n        int digitB = tempB % 10;\n        \n        // If both digits are non-zero at same position, they cannot be summed\n        if digitA != 0 && digitB != 0 {\n            return false;\n        }\n        \n        tempA = tempA / 10;\n        tempB = tempB / 10;\n    }\n    \n    return true;\n}\n\n// Check if a number is compatible with all numbers in the selected set\nfunction isCompatibleWithAll(int num, int[] selectedNumbers) returns boolean {\n    foreach int selected in selectedNumbers {\n        if !canSum(num, selected) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Find maximum subset where all pairs can be summed\nfunction findMaxSubset(int[] numbers) returns int[] {\n    int[] maxSubset = [];\n    \n    // Try starting with each number as the first element\n    foreach int i in 0 ..< numbers.length() {\n        int[] currentSubset = [numbers[i]];\n        \n        // Try to add other numbers that are compatible with all in current subset\n        foreach int j in 0 ..< numbers.length() {\n            if i != j {\n                if isCompatibleWithAll(numbers[j], currentSubset) {\n                    currentSubset.push(numbers[j]);\n                }\n            }\n        }\n        \n        // Keep the largest subset found\n        if currentSubset.length() > maxSubset.length() {\n            maxSubset = currentSubset;\n        }\n    }\n    \n    return maxSubset;\n}\n\npublic function main() returns error? {\n    // Read k\n    string? kLine = io:readln();\n    if kLine is () {\n        return error(\"Failed to read k\");\n    }\n    \n    int k = check 'int:fromString(kLine.trim());\n    \n    if k == 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the k numbers\n    string? numbersLine = io:readln();\n    if numbersLine is () {\n        return error(\"Failed to read numbers\");\n    }\n    \n    // Split by whitespace using regex\n    string[] parts = regex:split(numbersLine.trim(), \"\\\\s+\");\n    int[] numbers = [];\n    \n    foreach string part in parts {\n        string trimmed = part.trim();\n        if trimmed.length() > 0 {\n            int num = check 'int:fromString(trimmed);\n            numbers.push(num);\n        }\n    }\n    \n    // Find the maximum subset\n    int[] result = findMaxSubset(numbers);\n    \n    // Output the result\n    io:println(result.length());\n    \n    // Build output string\n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += result[i].toString();\n    }\n    if result.length() > 0 {\n        output += \" \";\n    }\n    io:println(output);\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCanSumBasic() {\n    // 505 and 50 can be summed (digit by digit: 5&0, 0&5, 5&0)\n    boolean result = canSum(505, 50);\n    test:assertTrue(result, \"505 and 50 should be able to be summed\");\n    \n    // 1 and 4 cannot be summed (both have non-zero in units place)\n    result = canSum(1, 4);\n    test:assertFalse(result, \"1 and 4 should not be able to be summed\");\n    \n    // 0 can be summed with any number (all digits are 0)\n    result = canSum(0, 100);\n    test:assertTrue(result, \"0 and 100 should be able to be summed\");\n    \n    // 10 and 1 can be summed (1&1 no!, wait: 10 is 1,0 and 1 is 0,1 - so 1&0, 0&1 - yes!)\n    // Actually 10 has digits 0,1 (units, tens) and 1 has digits 1,0 - at units: 0&1 ok, at tens: 1&0 ok\n    result = canSum(10, 1);\n    test:assertTrue(result, \"10 and 1 should be able to be summed\");\n}\n\n@test:Config {}\nfunction testCanSumMoreCases() {\n    // 100 and 10: 100 is 0,0,1 and 10 is 0,1,0 - at each position at least one is 0\n    boolean result = canSum(100, 10);\n    test:assertTrue(result, \"100 and 10 should be able to be summed\");\n    \n    // 2 and 70: 2 is 2,0 and 70 is 0,7 - at units: 2&0 ok, at tens: 0&7 ok\n    result = canSum(2, 70);\n    test:assertTrue(result, \"2 and 70 should be able to be summed\");\n    \n    // 2 and 3: both are non-zero in units place\n    result = canSum(2, 3);\n    test:assertFalse(result, \"2 and 3 should not be able to be summed\");\n    \n    // Same non-zero number cannot be summed with itself\n    result = canSum(5, 5);\n    test:assertFalse(result, \"5 and 5 should not be able to be summed\");\n}\n\n@test:Config {}\nfunction testFindMaxSubsetExample1() {\n    // Example: 100, 10, 1, 0\n    // 100: 0,0,1  10: 0,1,0  1: 1,0,0  0: 0,0,0\n    // All pairs should be compatible\n    int[] numbers = [100, 10, 1, 0];\n    int[] result = findMaxSubset(numbers);\n    \n    test:assertEquals(result.length(), 4, \"Should select all 4 numbers\");\n    \n    // Verify all pairs can be summed\n    foreach int i in 0 ..< result.length() {\n        foreach int j in (i + 1) ..< result.length() {\n            test:assertTrue(canSum(result[i], result[j]), \n                \"All pairs should be summable\");\n        }\n    }\n}\n\n@test:Config {}\nfunction testFindMaxSubsetExample2() {\n    // Example: 2, 70, 3\n    // 2: 2,0  70: 0,7  3: 3,0\n    // 2 and 70 ok, 2 and 3 not ok (both non-zero at units), 70 and 3 ok\n    int[] numbers = [2, 70, 3];\n    int[] result = findMaxSubset(numbers);\n    \n    // Maximum should be 2 (either 2,70 or 70,3)\n    test:assertTrue(result.length() >= 2, \"Should select at least 2 numbers\");\n    \n    // Verify all pairs can be summed\n    foreach int i in 0 ..< result.length() {\n        foreach int j in (i + 1) ..< result.length() {\n            test:assertTrue(canSum(result[i], result[j]), \n                \"All pairs in result should be summable\");\n        }\n    }\n}\n\n@test:Config {}\nfunction testIsCompatibleWithAll() {\n    int[] subset = [0, 10, 100];\n    \n    // 1 should be compatible with 0, 10, 100\n    boolean result = isCompatibleWithAll(1, subset);\n    test:assertTrue(result, \"1 should be compatible with [0, 10, 100]\");\n    \n    // 11 should not be compatible (11 has 1,1 - conflicts with 10's 0,1 at units)\n    result = isCompatibleWithAll(11, subset);\n    test:assertFalse(result, \"11 should not be compatible with [0, 10, 100]\");\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\nimport ballerina/regex;\n\n// Reasoning:\n// Two numbers can be summed if for every decimal position (units, tens, hundreds),\n// at least one of them has a 0 digit in that position.\n// \n// Approach:\n// 1. Extract each digit position for both numbers\n// 2. Check if at each position, at least one has digit 0\n// 3. Use greedy algorithm: try each number as starting point and build compatible subset\n// 4. Return the largest subset found\n\n// Check if two numbers can be summed according to Vasya's rule\nfunction canSum(int a, int b) returns boolean {\n    // For each decimal position, at least one must have digit 0\n    int tempA = a;\n    int tempB = b;\n    \n    // Check each digit position\n    while tempA > 0 || tempB > 0 {\n        int digitA = tempA % 10;\n        int digitB = tempB % 10;\n        \n        // If both digits are non-zero at same position, they cannot be summed\n        if digitA != 0 && digitB != 0 {\n            return false;\n        }\n        \n        tempA = tempA / 10;\n        tempB = tempB / 10;\n    }\n    \n    return true;\n}\n\n// Check if a number is compatible with all numbers in the selected set\nfunction isCompatibleWithAll(int num, int[] selectedNumbers) returns boolean {\n    foreach int selected in selectedNumbers {\n        if !canSum(num, selected) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Find maximum subset where all pairs can be summed\nfunction findMaxSubset(int[] numbers) returns int[] {\n    int[] maxSubset = [];\n    \n    // Try starting with each number as the first element\n    foreach int i in 0 ..< numbers.length() {\n        int[] currentSubset = [numbers[i]];\n        \n        // Try to add other numbers that are compatible with all in current subset\n        foreach int j in 0 ..< numbers.length() {\n            if i != j {\n                if isCompatibleWithAll(numbers[j], currentSubset) {\n                    currentSubset.push(numbers[j]);\n                }\n            }\n        }\n        \n        // Keep the largest subset found\n        if currentSubset.length() > maxSubset.length() {\n            maxSubset = currentSubset;\n        }\n    }\n    \n    return maxSubset;\n}\n\npublic function main() returns error? {\n    // Read k\n    string? kLine = io:readln();\n    if kLine is () {\n        return error(\"Failed to read k\");\n    }\n    \n    int k = check 'int:fromString(kLine.trim());\n    \n    if k == 0 {\n        io:println(\"0\");\n        io:println(\"\");\n        return;\n    }\n    \n    // Read the k numbers\n    string? numbersLine = io:readln();\n    if numbersLine is () {\n        return error(\"Failed to read numbers\");\n    }\n    \n    // Split by whitespace using regex\n    string[] parts = regex:split(numbersLine.trim(), \"\\\\s+\");\n    int[] numbers = [];\n    \n    foreach string part in parts {\n        string trimmed = part.trim();\n        if trimmed.length() > 0 {\n            int num = check 'int:fromString(trimmed);\n            numbers.push(num);\n        }\n    }\n    \n    // Find the maximum subset\n    int[] result = findMaxSubset(numbers);\n    \n    // Output the result\n    io:println(result.length());\n    \n    // Build output string\n    string output = \"\";\n    foreach int i in 0 ..< result.length() {\n        if i > 0 {\n            output += \" \";\n        }\n        output += result[i].toString();\n    }\n    if result.length() > 0 {\n        output += \" \";\n    }\n    io:println(output);\n    \n    return;\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4\n100 10 1 0\n",
          "expected_output": "4\n0 1 10 100 ",
          "actual_output": "4\n100 10 1 0 \n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T00:31:06.851530"
}