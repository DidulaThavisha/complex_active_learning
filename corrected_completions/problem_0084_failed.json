{
  "entry_id": "problem_0084",
  "problem_index": 84,
  "prompt": "Title: Resource Distribution\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nOne department of some software company has $n$ servers of different specifications. Servers are indexed with consecutive integers from $1$ to $n$. Suppose that the specifications of the $j$-th server may be expressed with a single integer number $c_j$ of artificial resource units.\n\nIn order for production to work, it is needed to deploy two services $S_1$ and $S_2$ to process incoming requests using the servers of the department. Processing of incoming requests of service $S_i$ takes $x_i$ resource units.\n\nThe described situation happens in an advanced company, that is why each service may be deployed using not only one server, but several servers simultaneously. If service $S_i$ is deployed using $k_i$ servers, then the load is divided equally between these servers and each server requires only $x_i / k_i$ (that may be a fractional number) resource units.\n\nEach server may be left unused at all, or be used for deploying exactly one of the services (but not for two of them simultaneously). The service should not use more resources than the server provides.\n\nDetermine if it is possible to deploy both services using the given servers, and if yes, determine which servers should be used for deploying each of the services.\n\nInput Specification:\nThe first line contains three integers $n$, $x_1$, $x_2$ ($2 \\leq n \\leq 300\\,000$, $1 \\leq x_1, x_2 \\leq 10^9$) — the number of servers that the department may use, and resource units requirements for each of the services.\n\nThe second line contains $n$ space-separated integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq 10^9$) — the number of resource units provided by each of the servers.\n\nOutput Specification:\nIf it is impossible to deploy both services using the given servers, print the only word \"No\" (without the quotes).\n\nOtherwise print the word \"Yes\" (without the quotes). \n\nIn the second line print two integers $k_1$ and $k_2$ ($1 \\leq k_1, k_2 \\leq n$) — the number of servers used for each of the services.\n\nIn the third line print $k_1$ integers, the indices of the servers that will be used for the first service.\n\nIn the fourth line print $k_2$ integers, the indices of the servers that will be used for the second service.\n\nNo index may appear twice among the indices you print in the last two lines. If there are several possible answers, it is allowed to print any of them.\n\nDemo Input:\n['6 8 16\\n3 5 2 9 8 7\\n', '4 20 32\\n21 11 11 12\\n', '4 11 32\\n5 5 16 16\\n', '5 12 20\\n7 8 4 11 9\\n']\n\nDemo Output:\n['Yes\\n3 2\\n1 2 6\\n5 4', 'Yes\\n1 3\\n1\\n2 3 4\\n', 'No\\n', 'No\\n']\n\nNote:\nIn the first sample test each of the servers 1, 2 and 6 will will provide $8 / 3 = 2.(6)$ resource units and each of the servers 5, 4 will provide $16 / 2 = 8$ resource units.\n\nIn the second sample test the first server will provide $20$ resource units and each of the remaining servers will provide $32 / 3 = 10.(6)$ resource units.",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:26:41.848478",
      "status": "failed",
      "completion": "# Overview\n\nThis problem requires distributing servers between two services such that each service gets enough total resources. The key insight is:\n- Service S1 needs x1 resources, distributed across k1 servers (each server needs x1/k1 capacity)\n- Service S2 needs x2 resources, distributed across k2 servers (each server needs x2/k2 capacity)\n- Each server can only be used for one service\n- We need to find a valid assignment or determine it's impossible\n\nThe strategy:\n1. Sort servers by capacity (keeping track of original indices)\n2. Try different splits: assign the largest servers to one service and remaining to another\n3. For each split, check if the highest capacity server in each group can handle the per-server load\n4. The key is that if we use k servers for a service, the largest server must have capacity >= x/k\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We need to distribute n servers between two services\n// - Service 1 needs x1 total resources, Service 2 needs x2 total resources\n// - If service i uses ki servers, each needs at least xi/ki capacity\n// - Strategy: Sort servers by capacity and try different distributions\n// - For a valid distribution with k1 servers for S1 and k2 servers for S2:\n//   - The k1-th largest server must have capacity >= x1/k1\n//   - The k2-th largest server (from remaining) must have capacity >= x2/k2\n\nimport ballerina/io;\n\ntype ServerInfo record {|\n    int index;\n    int capacity;\n|};\n\nfunction solveResourceDistribution(int n, int x1, int x2, int[] capacities) returns string {\n    // Create array of server info with original indices\n    ServerInfo[] servers = [];\n    foreach int i in 0 ..< n {\n        servers.push({index: i + 1, capacity: capacities[i]});\n    }\n    \n    // Sort servers by capacity in descending order\n    ServerInfo[] sorted = from var s in servers\n                          order by s.capacity descending\n                          select s;\n    \n    // Try assigning first k1 servers to service 1, rest to service 2\n    foreach int k1 in 1 ... n - 1 {\n        int k2 = n - k1;\n        \n        // Check if k1 servers can handle service 1\n        // The k1-th server (smallest in the group) needs capacity >= x1/k1\n        decimal minCapacity1 = <decimal>sorted[k1 - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        // Check if remaining k2 servers can handle service 2\n        decimal minCapacity2 = <decimal>sorted[n - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            // Found a valid assignment\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k1 {\n                service1.push(sorted[i].index);\n            }\n            foreach int i in k1 ..< n {\n                service2.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    // Try assigning first k2 servers to service 2, rest to service 1\n    foreach int k2 in 1 ... n - 1 {\n        int k1 = n - k2;\n        \n        decimal minCapacity2 = <decimal>sorted[k2 - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        decimal minCapacity1 = <decimal>sorted[n - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k2 {\n                service2.push(sorted[i].index);\n            }\n            foreach int i in k2 ..< n {\n                service1.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    return \"No\";\n}\n\nfunction formatIndices(int[] indices) returns string {\n    if indices.length() == 0 {\n        return \"\";\n    }\n    string result = indices[0].toString();\n    foreach int i in 1 ..< indices.length() {\n        result += \" \" + indices[i].toString();\n    }\n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n, x1, x2\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x1 = check 'int:fromString(parts1[1]);\n    int x2 = check 'int:fromString(parts1[2]);\n    \n    // Read second line: capacities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read capacities\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] capacities = [];\n    foreach string part in parts2 {\n        capacities.push(check 'int:fromString(part));\n    }\n    \n    string result = solveResourceDistribution(n, x1, x2, capacities);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] capacities = [3, 5, 2, 9, 8, 7];\n    string result = solveResourceDistribution(6, 8, 16, capacities);\n    test:assertTrue(result.startsWith(\"Yes\"), \"Should find valid distribution\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] capacities = [21, 11, 11, 12];\n    string result = solveResourceDistribution(4, 20, 32, capacities);\n    test:assertTrue(result.startsWith(\"Yes\"), \"Should find valid distribution\");\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] capacities = [5, 5, 16, 16];\n    string result = solveResourceDistribution(4, 11, 32, capacities);\n    test:assertEquals(result, \"No\", \"Should return No for impossible case\");\n}\n\n@test:Config {}\nfunction testExample4() {\n    int[] capacities = [7, 8, 4, 11, 9];\n    string result = solveResourceDistribution(5, 12, 20, capacities);\n    test:assertEquals(result, \"No\", \"Should return No for impossible case\");\n}\n\n@test:Config {}\nfunction testSimpleCase() {\n    int[] capacities = [100, 100];\n    string result = solveResourceDistribution(2, 50, 50, capacities);\n    test:assertTrue(result.startsWith(\"Yes\"), \"Should handle simple valid case\");\n}\n\n@test:Config {}\nfunction testFormatIndices() {\n    int[] indices = [1, 2, 3];\n    string formatted = formatIndices(indices);\n    test:assertEquals(formatted, \"1 2 3\", \"Should format indices correctly\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We need to distribute n servers between two services\n// - Service 1 needs x1 total resources, Service 2 needs x2 total resources\n// - If service i uses ki servers, each needs at least xi/ki capacity\n// - Strategy: Sort servers by capacity and try different distributions\n// - For a valid distribution with k1 servers for S1 and k2 servers for S2:\n//   - The k1-th largest server must have capacity >= x1/k1\n//   - The k2-th largest server (from remaining) must have capacity >= x2/k2\n\nimport ballerina/io;\n\ntype ServerInfo record {|\n    int index;\n    int capacity;\n|};\n\nfunction solveResourceDistribution(int n, int x1, int x2, int[] capacities) returns string {\n    // Create array of server info with original indices\n    ServerInfo[] servers = [];\n    foreach int i in 0 ..< n {\n        servers.push({index: i + 1, capacity: capacities[i]});\n    }\n    \n    // Sort servers by capacity in descending order\n    ServerInfo[] sorted = from var s in servers\n                          order by s.capacity descending\n                          select s;\n    \n    // Try assigning first k1 servers to service 1, rest to service 2\n    foreach int k1 in 1 ... n - 1 {\n        int k2 = n - k1;\n        \n        // Check if k1 servers can handle service 1\n        // The k1-th server (smallest in the group) needs capacity >= x1/k1\n        decimal minCapacity1 = <decimal>sorted[k1 - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        // Check if remaining k2 servers can handle service 2\n        decimal minCapacity2 = <decimal>sorted[n - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            // Found a valid assignment\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k1 {\n                service1.push(sorted[i].index);\n            }\n            foreach int i in k1 ..< n {\n                service2.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    // Try assigning first k2 servers to service 2, rest to service 1\n    foreach int k2 in 1 ... n - 1 {\n        int k1 = n - k2;\n        \n        decimal minCapacity2 = <decimal>sorted[k2 - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        decimal minCapacity1 = <decimal>sorted[n - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k2 {\n                service2.push(sorted[i].index);\n            }\n            foreach int i in k2 ..< n {\n                service1.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    return \"No\";\n}\n\nfunction formatIndices(int[] indices) returns string {\n    if indices.length() == 0 {\n        return \"\";\n    }\n    string result = indices[0].toString();\n    foreach int i in 1 ..< indices.length() {\n        result += \" \" + indices[i].toString();\n    }\n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n, x1, x2\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x1 = check 'int:fromString(parts1[1]);\n    int x2 = check 'int:fromString(parts1[2]);\n    \n    // Read second line: capacities\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read capacities\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] capacities = [];\n    foreach string part in parts2 {\n        capacities.push(check 'int:fromString(part));\n    }\n    \n    string result = solveResourceDistribution(n, x1, x2, capacities);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 4,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(112:36,112:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(127:36,127:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(112:36,112:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(127:36,127:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(112:36,112:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(127:36,127:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:27:13.109929",
      "status": "failed",
      "completion": "Looking at the compilation error, the issue is that `split` is not a direct method on `string` in Ballerina. I need to use `regex:split` from the standard library instead.\n\nLet me analyze the problem:\n1. We have n servers with different capacities\n2. We need to distribute them between two services S1 and S2\n3. If service Si uses ki servers, each server needs capacity >= xi/ki\n4. The key insight: if we sort servers by capacity and assign the top k1 to one service, the weakest server in that group (the k1-th largest overall) must meet the requirement\n\nStrategy:\n- Sort servers by capacity descending\n- Try all possible splits where we assign top k1 servers to S1 and remaining k2 to S2\n- Also try the reverse (top k2 to S2, remaining to S1)\n- For each split, check if the minimum capacity in each group meets the per-server requirement\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We need to distribute n servers between two services S1 and S2\n// - Service 1 needs x1 total resources, Service 2 needs x2 total resources  \n// - If service i uses ki servers, each server needs capacity >= xi/ki\n// - Strategy: Sort servers by capacity (descending) and try different distributions\n// - For k1 servers assigned to S1 (the top k1), the weakest (k1-th) must have capacity >= x1/k1\n// - For k2 servers assigned to S2 (the remaining), the weakest must have capacity >= x2/k2\n// - We try both: (top k1 for S1, rest for S2) and (top k2 for S2, rest for S1)\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype ServerInfo record {|\n    int index;\n    int capacity;\n|};\n\nfunction solveResourceDistribution(int n, int x1, int x2, int[] capacities) returns string {\n    // Create array of server info with original indices (1-based)\n    ServerInfo[] servers = [];\n    foreach int i in 0 ..< n {\n        servers.push({index: i + 1, capacity: capacities[i]});\n    }\n    \n    // Sort servers by capacity in descending order\n    ServerInfo[] sorted = from var s in servers\n                          order by s.capacity descending\n                          select s;\n    \n    // Try assigning first k1 servers (highest capacity) to service 1, rest to service 2\n    foreach int k1 in 1 ... n - 1 {\n        int k2 = n - k1;\n        \n        // The weakest server in service 1 group is at position k1-1 (0-indexed)\n        decimal minCapacity1 = <decimal>sorted[k1 - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        // The weakest server in service 2 group is at position n-1 (last one)\n        decimal minCapacity2 = <decimal>sorted[n - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            // Found a valid assignment\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k1 {\n                service1.push(sorted[i].index);\n            }\n            foreach int i in k1 ..< n {\n                service2.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    // Try assigning first k2 servers (highest capacity) to service 2, rest to service 1\n    foreach int k2 in 1 ... n - 1 {\n        int k1 = n - k2;\n        \n        // The weakest server in service 2 group is at position k2-1\n        decimal minCapacity2 = <decimal>sorted[k2 - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        // The weakest server in service 1 group is at position n-1 (last one)\n        decimal minCapacity1 = <decimal>sorted[n - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k2 {\n                service2.push(sorted[i].index);\n            }\n            foreach int i in k2 ..< n {\n                service1.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    return \"No\";\n}\n\nfunction formatIndices(int[] indices) returns string {\n    if indices.length() == 0 {\n        return \"\";\n    }\n    string result = indices[0].toString();\n    foreach int i in 1 ..< indices.length() {\n        result += \" \" + indices[i].toString();\n    }\n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n, x1, x2\n    string line1Input = io:readln();\n    string line1 = line1Input.trim();\n    \n    string[] parts1 = regex:split(line1, \" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x1 = check 'int:fromString(parts1[1]);\n    int x2 = check 'int:fromString(parts1[2]);\n    \n    // Read second line: capacities\n    string line2Input = io:readln();\n    string line2 = line2Input.trim();\n    \n    string[] parts2 = regex:split(line2, \" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] capacities = [];\n    foreach string part in parts2 {\n        capacities.push(check 'int:fromString(part));\n    }\n    \n    string result = solveResourceDistribution(n, x1, x2, capacities);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] capacities = [3, 5, 2, 9, 8, 7];\n    string result = solveResourceDistribution(6, 8, 16, capacities);\n    test:assertTrue(result.startsWith(\"Yes\"), \"Example 1 should find valid distribution\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] capacities = [21, 11, 11, 12];\n    string result = solveResourceDistribution(4, 20, 32, capacities);\n    test:assertTrue(result.startsWith(\"Yes\"), \"Example 2 should find valid distribution\");\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] capacities = [5, 5, 16, 16];\n    string result = solveResourceDistribution(4, 11, 32, capacities);\n    test:assertEquals(result, \"No\", \"Example 3 should return No for impossible case\");\n}\n\n@test:Config {}\nfunction testExample4() {\n    int[] capacities = [7, 8, 4, 11, 9];\n    string result = solveResourceDistribution(5, 12, 20, capacities);\n    test:assertEquals(result, \"No\", \"Example 4 should return No for impossible case\");\n}\n\n@test:Config {}\nfunction testSimpleValidCase() {\n    int[] capacities = [100, 100];\n    string result = solveResourceDistribution(2, 50, 50, capacities);\n    test:assertTrue(result.startsWith(\"Yes\"), \"Should handle simple valid case with equal servers\");\n}\n\n@test:Config {}\nfunction testFormatIndicesFunction() {\n    int[] indices = [1, 2, 3];\n    string formatted = formatIndices(indices);\n    test:assertEquals(formatted, \"1 2 3\", \"Should format indices with spaces\");\n}\n\n@test:Config {}\nfunction testFormatIndicesSingle() {\n    int[] indices = [5];\n    string formatted = formatIndices(indices);\n    test:assertEquals(formatted, \"5\", \"Should format single index correctly\");\n}\n\n@test:Config {}\nfunction testFormatIndicesEmpty() {\n    int[] indices = [];\n    string formatted = formatIndices(indices);\n    test:assertEquals(formatted, \"\", \"Should return empty string for empty array\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We need to distribute n servers between two services S1 and S2\n// - Service 1 needs x1 total resources, Service 2 needs x2 total resources  \n// - If service i uses ki servers, each server needs capacity >= xi/ki\n// - Strategy: Sort servers by capacity (descending) and try different distributions\n// - For k1 servers assigned to S1 (the top k1), the weakest (k1-th) must have capacity >= x1/k1\n// - For k2 servers assigned to S2 (the remaining), the weakest must have capacity >= x2/k2\n// - We try both: (top k1 for S1, rest for S2) and (top k2 for S2, rest for S1)\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype ServerInfo record {|\n    int index;\n    int capacity;\n|};\n\nfunction solveResourceDistribution(int n, int x1, int x2, int[] capacities) returns string {\n    // Create array of server info with original indices (1-based)\n    ServerInfo[] servers = [];\n    foreach int i in 0 ..< n {\n        servers.push({index: i + 1, capacity: capacities[i]});\n    }\n    \n    // Sort servers by capacity in descending order\n    ServerInfo[] sorted = from var s in servers\n                          order by s.capacity descending\n                          select s;\n    \n    // Try assigning first k1 servers (highest capacity) to service 1, rest to service 2\n    foreach int k1 in 1 ... n - 1 {\n        int k2 = n - k1;\n        \n        // The weakest server in service 1 group is at position k1-1 (0-indexed)\n        decimal minCapacity1 = <decimal>sorted[k1 - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        // The weakest server in service 2 group is at position n-1 (last one)\n        decimal minCapacity2 = <decimal>sorted[n - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            // Found a valid assignment\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k1 {\n                service1.push(sorted[i].index);\n            }\n            foreach int i in k1 ..< n {\n                service2.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    // Try assigning first k2 servers (highest capacity) to service 2, rest to service 1\n    foreach int k2 in 1 ... n - 1 {\n        int k1 = n - k2;\n        \n        // The weakest server in service 2 group is at position k2-1\n        decimal minCapacity2 = <decimal>sorted[k2 - 1].capacity;\n        decimal required2 = <decimal>x2 / <decimal>k2;\n        \n        // The weakest server in service 1 group is at position n-1 (last one)\n        decimal minCapacity1 = <decimal>sorted[n - 1].capacity;\n        decimal required1 = <decimal>x1 / <decimal>k1;\n        \n        if minCapacity1 >= required1 && minCapacity2 >= required2 {\n            int[] service1 = [];\n            int[] service2 = [];\n            \n            foreach int i in 0 ..< k2 {\n                service2.push(sorted[i].index);\n            }\n            foreach int i in k2 ..< n {\n                service1.push(sorted[i].index);\n            }\n            \n            string result = \"Yes\\n\";\n            result += k1.toString() + \" \" + k2.toString() + \"\\n\";\n            result += formatIndices(service1) + \"\\n\";\n            result += formatIndices(service2);\n            return result;\n        }\n    }\n    \n    return \"No\";\n}\n\nfunction formatIndices(int[] indices) returns string {\n    if indices.length() == 0 {\n        return \"\";\n    }\n    string result = indices[0].toString();\n    foreach int i in 1 ..< indices.length() {\n        result += \" \" + indices[i].toString();\n    }\n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n, x1, x2\n    string line1Input = io:readln();\n    string line1 = line1Input.trim();\n    \n    string[] parts1 = regex:split(line1, \" \");\n    if parts1.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int x1 = check 'int:fromString(parts1[1]);\n    int x2 = check 'int:fromString(parts1[2]);\n    \n    // Read second line: capacities\n    string line2Input = io:readln();\n    string line2 = line2Input.trim();\n    \n    string[] parts2 = regex:split(line2, \" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of capacities\");\n    }\n    \n    int[] capacities = [];\n    foreach string part in parts2 {\n        capacities.push(check 'int:fromString(part));\n    }\n    \n    string result = solveResourceDistribution(n, x1, x2, capacities);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 4,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 2/4 tests (50.0%), need 75%",
      "error": "Only passed 2/4 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "6 8 16\n3 5 2 9 8 7\n",
          "expected_output": "Yes\n3 2\n1 2 6\n5 4",
          "actual_output": "Yes\n4 2\n6 2 1 3\n4 5\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 2/4 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T01:27:58.703253"
}