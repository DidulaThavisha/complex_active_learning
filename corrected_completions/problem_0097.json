{
  "entry_id": "problem_0097",
  "problem_index": 97,
  "prompt": "Title: Vasya and Basketball\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nVasya follows a basketball game and marks the distances from which each team makes a throw. He knows that each successful throw has value of either 2 or 3 points. A throw is worth 2 points if the distance it was made from doesn't exceed some value of *d* meters, and a throw is worth 3 points if the distance is larger than *d* meters, where *d* is some non-negative integer.\n\nVasya would like the advantage of the points scored by the first team (the points of the first team minus the points of the second team) to be maximum. For that he can mentally choose the value of *d*. Help him to do that.\n\nInput Specification:\nThe first line contains integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of throws of the first team. Then follow *n* integer numbers — the distances of throws *a**i* (1<=≤<=*a**i*<=≤<=2·109). \n\nThen follows number *m* (1<=≤<=*m*<=≤<=2·105) — the number of the throws of the second team. Then follow *m* integer numbers — the distances of throws of *b**i* (1<=≤<=*b**i*<=≤<=2·109).\n\nOutput Specification:\nPrint two numbers in the format a:b — the score that is possible considering the problem conditions where the result of subtraction *a*<=-<=*b* is maximum. If there are several such scores, find the one in which number *a* is maximum.\n\nDemo Input:\n['3\\n1 2 3\\n2\\n5 6\\n', '5\\n6 7 8 9 10\\n5\\n1 2 3 4 5\\n']\n\nDemo Output:\n['9:6\\n', '15:10\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem requires finding an optimal distance threshold `d` such that throws <= d are worth 2 points and throws > d are worth 3 points. We need to maximize the score difference (team1 - team2), and if there are ties, maximize team1's score.\n\nThe key issue in the previous code was using `split()` which doesn't exist in Ballerina's string type. We need to use `regex:split()` from the `ballerina/regex` module instead.\n\nStrategy:\n1. Try all possible threshold values `d` (we only need to check d values at actual throw distances and boundary cases)\n2. For each `d`, calculate scores for both teams (throws <= d get 2 points, throws > d get 3 points)\n3. Track the best score difference and if tied, the maximum team1 score\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For any distance threshold d, throws at distance <= d score 2 points, throws > d score 3 points\n// - We want to maximize (score1 - score2), with ties broken by maximizing score1\n// - We only need to test specific values of d: \n//   * d = 0 (one less than minimum, so all throws are 3-pointers)\n//   * d = each unique throw distance (to test transitions)\n//   * d = very large (so all throws are 2-pointers)\n// - For each candidate d, count throws <= d (2-pointers) and > d (3-pointers) for each team\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate score for a team given a threshold d\n// throws <= d get 2 points, throws > d get 3 points\nfunction calculateScore(int[] throws, int d) returns int {\n    int twoPointers = 0;\n    int threePointers = 0;\n    \n    foreach int distance in throws {\n        if distance <= d {\n            twoPointers += 1;\n        } else {\n            threePointers += 1;\n        }\n    }\n    \n    return twoPointers * 2 + threePointers * 3;\n}\n\n// Find optimal d value and return the best score as \"a:b\"\nfunction findOptimalScore(int[] team1Throws, int[] team2Throws) returns string {\n    // Collect all possible d values to test\n    // We need to test d values that represent boundaries where scoring changes\n    int[] candidateDs = [];\n    \n    // Test d = 0 (all throws are 3-pointers since all distances > 0)\n    candidateDs.push(0);\n    \n    // Add all throw distances as potential thresholds\n    foreach int distance in team1Throws {\n        candidateDs.push(distance);\n    }\n    foreach int distance in team2Throws {\n        candidateDs.push(distance);\n    }\n    \n    // Add a very large number to test all 2-pointers\n    candidateDs.push(2000000000);\n    \n    int maxDiff = -2147483648; // minimum int value\n    int bestScore1 = 0;\n    int bestScore2 = 0;\n    \n    // Try each candidate d value\n    foreach int d in candidateDs {\n        int score1 = calculateScore(team1Throws, d);\n        int score2 = calculateScore(team2Throws, d);\n        int diff = score1 - score2;\n        \n        // Update if we found a better difference, or same difference but higher score1\n        if diff > maxDiff || (diff == maxDiff && score1 > bestScore1) {\n            maxDiff = diff;\n            bestScore1 = score1;\n            bestScore2 = score2;\n        }\n    }\n    \n    return bestScore1.toString() + \":\" + bestScore2.toString();\n}\n\npublic function main() returns error? {\n    // Read n (number of throws for team 1)\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read team 1 throws\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts1 = regex:split(line2.trim(), \"\\\\s+\");\n    int[] team1Throws = [];\n    foreach string part in parts1 {\n        if part.trim().length() > 0 {\n            team1Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Read m (number of throws for team 2)\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read input\");\n    }\n    int m = check 'int:fromString(line3.trim());\n    \n    // Read team 2 throws\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts2 = regex:split(line4.trim(), \"\\\\s+\");\n    int[] team2Throws = [];\n    foreach string part in parts2 {\n        if part.trim().length() > 0 {\n            team2Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Find and print optimal score\n    string result = findOptimalScore(team1Throws, team2Throws);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] team1 = [1, 2, 3];\n    int[] team2 = [5, 6];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"9:6\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] team1 = [6, 7, 8, 9, 10];\n    int[] team2 = [1, 2, 3, 4, 5];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"15:10\");\n}\n\n@test:Config {}\nfunction testAllTwoPointers() {\n    int[] team1 = [1, 2];\n    int[] team2 = [1, 2];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"4:4\");\n}\n\n@test:Config {}\nfunction testAllThreePointers() {\n    int[] team1 = [10, 20, 30];\n    int[] team2 = [40];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"9:3\");\n}\n\n@test:Config {}\nfunction testCalculateScoreAllTwo() {\n    int[] throws = [1, 2, 3, 4, 5];\n    int score = calculateScore(throws, 1000000000);\n    test:assertEquals(score, 10); // All 2-pointers\n}\n\n@test:Config {}\nfunction testCalculateScoreAllThree() {\n    int[] throws = [1, 2, 3, 4, 5];\n    int score = calculateScore(throws, 0);\n    test:assertEquals(score, 15); // All 3-pointers\n}\n\n@test:Config {}\nfunction testCalculateScoreMixed() {\n    int[] throws = [1, 2, 5, 6];\n    int score = calculateScore(throws, 3);\n    test:assertEquals(score, 10); // 2 two-pointers (1,2) and 2 three-pointers (5,6)\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - For any distance threshold d, throws at distance <= d score 2 points, throws > d score 3 points\n// - We want to maximize (score1 - score2), with ties broken by maximizing score1\n// - We only need to test specific values of d: \n//   * d = 0 (one less than minimum, so all throws are 3-pointers)\n//   * d = each unique throw distance (to test transitions)\n//   * d = very large (so all throws are 2-pointers)\n// - For each candidate d, count throws <= d (2-pointers) and > d (3-pointers) for each team\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate score for a team given a threshold d\n// throws <= d get 2 points, throws > d get 3 points\nfunction calculateScore(int[] throws, int d) returns int {\n    int twoPointers = 0;\n    int threePointers = 0;\n    \n    foreach int distance in throws {\n        if distance <= d {\n            twoPointers += 1;\n        } else {\n            threePointers += 1;\n        }\n    }\n    \n    return twoPointers * 2 + threePointers * 3;\n}\n\n// Find optimal d value and return the best score as \"a:b\"\nfunction findOptimalScore(int[] team1Throws, int[] team2Throws) returns string {\n    // Collect all possible d values to test\n    // We need to test d values that represent boundaries where scoring changes\n    int[] candidateDs = [];\n    \n    // Test d = 0 (all throws are 3-pointers since all distances > 0)\n    candidateDs.push(0);\n    \n    // Add all throw distances as potential thresholds\n    foreach int distance in team1Throws {\n        candidateDs.push(distance);\n    }\n    foreach int distance in team2Throws {\n        candidateDs.push(distance);\n    }\n    \n    // Add a very large number to test all 2-pointers\n    candidateDs.push(2000000000);\n    \n    int maxDiff = -2147483648; // minimum int value\n    int bestScore1 = 0;\n    int bestScore2 = 0;\n    \n    // Try each candidate d value\n    foreach int d in candidateDs {\n        int score1 = calculateScore(team1Throws, d);\n        int score2 = calculateScore(team2Throws, d);\n        int diff = score1 - score2;\n        \n        // Update if we found a better difference, or same difference but higher score1\n        if diff > maxDiff || (diff == maxDiff && score1 > bestScore1) {\n            maxDiff = diff;\n            bestScore1 = score1;\n            bestScore2 = score2;\n        }\n    }\n    \n    return bestScore1.toString() + \":\" + bestScore2.toString();\n}\n\npublic function main() returns error? {\n    // Read n (number of throws for team 1)\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read team 1 throws\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts1 = regex:split(line2.trim(), \"\\\\s+\");\n    int[] team1Throws = [];\n    foreach string part in parts1 {\n        if part.trim().length() > 0 {\n            team1Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Read m (number of throws for team 2)\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read input\");\n    }\n    int m = check 'int:fromString(line3.trim());\n    \n    // Read team 2 throws\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts2 = regex:split(line4.trim(), \"\\\\s+\");\n    int[] team2Throws = [];\n    foreach string part in parts2 {\n        if part.trim().length() > 0 {\n            team2Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Find and print optimal score\n    string result = findOptimalScore(team1Throws, team2Throws);\n    io:println(result);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:40:57.252367",
      "status": "failed",
      "completion": "# Overview\nThis problem requires finding an optimal distance threshold `d` such that throws <= d are worth 2 points and throws > d are worth 3 points. We need to maximize the score difference (team1 - team2), and if there are ties, maximize team1's score.\n\nThe strategy is to:\n1. Try all possible values of `d` (which can be any distance from the throws, or 0, or infinity)\n2. For each `d`, calculate scores for both teams\n3. Track the best score difference and corresponding scores\n4. Key insight: We only need to check `d` values at the actual throw distances (and d=0 meaning all 3-pointers)\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For any distance threshold d, throws at distance <= d score 2 points, throws > d score 3 points\n// - We want to maximize (score1 - score2)\n// - We only need to test specific values of d: we can test d = each unique throw distance - 1\n// - Also test d = 0 (all 3-pointers) and d = infinity (all 2-pointers)\n// - For efficiency, we can sort the arrays and use binary search or counting\n// - For each candidate d, count how many throws are <= d (2-pointers) and > d (3-pointers) for each team\n\nimport ballerina/io;\n\n// Calculate score for a team given a threshold d\n// throws <= d get 2 points, throws > d get 3 points\nfunction calculateScore(int[] throws, int d) returns int {\n    int twoPointers = 0;\n    int threePointers = 0;\n    \n    foreach int distance in throws {\n        if distance <= d {\n            twoPointers += 1;\n        } else {\n            threePointers += 1;\n        }\n    }\n    \n    return twoPointers * 2 + threePointers * 3;\n}\n\n// Find optimal d value and return the best score as \"a:b\"\nfunction findOptimalScore(int[] team1Throws, int[] team2Throws) returns string {\n    // Collect all possible d values to test\n    // We test d = distance - 1 for each throw, plus d = max_value (all 2-pointers)\n    int[] candidateDs = [];\n    \n    // Add 0 to test all 3-pointers\n    candidateDs.push(0);\n    \n    // Add all throw distances as potential thresholds\n    foreach int distance in team1Throws {\n        candidateDs.push(distance);\n    }\n    foreach int distance in team2Throws {\n        candidateDs.push(distance);\n    }\n    \n    // Add a very large number to test all 2-pointers\n    candidateDs.push(2000000000);\n    \n    int maxDiff = -2147483648; // minimum int value\n    int bestScore1 = 0;\n    int bestScore2 = 0;\n    \n    // Try each candidate d value\n    foreach int d in candidateDs {\n        int score1 = calculateScore(team1Throws, d);\n        int score2 = calculateScore(team2Throws, d);\n        int diff = score1 - score2;\n        \n        // Update if we found a better difference, or same difference but higher score1\n        if diff > maxDiff || (diff == maxDiff && score1 > bestScore1) {\n            maxDiff = diff;\n            bestScore1 = score1;\n            bestScore2 = score2;\n        }\n    }\n    \n    return bestScore1.toString() + \":\" + bestScore2.toString();\n}\n\npublic function main() returns error? {\n    // Read n (number of throws for team 1)\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read team 1 throws\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts1 = line2.trim().split(\" \");\n    int[] team1Throws = [];\n    foreach string part in parts1 {\n        if part.trim().length() > 0 {\n            team1Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Read m (number of throws for team 2)\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read input\");\n    }\n    int m = check 'int:fromString(line3.trim());\n    \n    // Read team 2 throws\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts2 = line4.trim().split(\" \");\n    int[] team2Throws = [];\n    foreach string part in parts2 {\n        if part.trim().length() > 0 {\n            team2Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Find and print optimal score\n    string result = findOptimalScore(team1Throws, team2Throws);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] team1 = [1, 2, 3];\n    int[] team2 = [5, 6];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"9:6\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] team1 = [6, 7, 8, 9, 10];\n    int[] team2 = [1, 2, 3, 4, 5];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"15:10\");\n}\n\n@test:Config {}\nfunction testAllTwoPointers() {\n    int[] team1 = [1, 2];\n    int[] team2 = [1, 2];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"4:4\");\n}\n\n@test:Config {}\nfunction testAllThreePointers() {\n    int[] team1 = [10, 20, 30];\n    int[] team2 = [40];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"9:3\");\n}\n\n@test:Config {}\nfunction testCalculateScoreAllTwo() {\n    int[] throws = [1, 2, 3, 4, 5];\n    int score = calculateScore(throws, 1000000000);\n    test:assertEquals(score, 10); // All 2-pointers\n}\n\n@test:Config {}\nfunction testCalculateScoreAllThree() {\n    int[] throws = [1, 2, 3, 4, 5];\n    int score = calculateScore(throws, 0);\n    test:assertEquals(score, 15); // All 3-pointers\n}\n\n@test:Config {}\nfunction testCalculateScoreMixed() {\n    int[] throws = [1, 2, 5, 6];\n    int score = calculateScore(throws, 3);\n    test:assertEquals(score, 10); // 2 two-pointers (1,2) and 2 three-pointers (5,6)\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - For any distance threshold d, throws at distance <= d score 2 points, throws > d score 3 points\n// - We want to maximize (score1 - score2)\n// - We only need to test specific values of d: we can test d = each unique throw distance - 1\n// - Also test d = 0 (all 3-pointers) and d = infinity (all 2-pointers)\n// - For efficiency, we can sort the arrays and use binary search or counting\n// - For each candidate d, count how many throws are <= d (2-pointers) and > d (3-pointers) for each team\n\nimport ballerina/io;\n\n// Calculate score for a team given a threshold d\n// throws <= d get 2 points, throws > d get 3 points\nfunction calculateScore(int[] throws, int d) returns int {\n    int twoPointers = 0;\n    int threePointers = 0;\n    \n    foreach int distance in throws {\n        if distance <= d {\n            twoPointers += 1;\n        } else {\n            threePointers += 1;\n        }\n    }\n    \n    return twoPointers * 2 + threePointers * 3;\n}\n\n// Find optimal d value and return the best score as \"a:b\"\nfunction findOptimalScore(int[] team1Throws, int[] team2Throws) returns string {\n    // Collect all possible d values to test\n    // We test d = distance - 1 for each throw, plus d = max_value (all 2-pointers)\n    int[] candidateDs = [];\n    \n    // Add 0 to test all 3-pointers\n    candidateDs.push(0);\n    \n    // Add all throw distances as potential thresholds\n    foreach int distance in team1Throws {\n        candidateDs.push(distance);\n    }\n    foreach int distance in team2Throws {\n        candidateDs.push(distance);\n    }\n    \n    // Add a very large number to test all 2-pointers\n    candidateDs.push(2000000000);\n    \n    int maxDiff = -2147483648; // minimum int value\n    int bestScore1 = 0;\n    int bestScore2 = 0;\n    \n    // Try each candidate d value\n    foreach int d in candidateDs {\n        int score1 = calculateScore(team1Throws, d);\n        int score2 = calculateScore(team2Throws, d);\n        int diff = score1 - score2;\n        \n        // Update if we found a better difference, or same difference but higher score1\n        if diff > maxDiff || (diff == maxDiff && score1 > bestScore1) {\n            maxDiff = diff;\n            bestScore1 = score1;\n            bestScore2 = score2;\n        }\n    }\n    \n    return bestScore1.toString() + \":\" + bestScore2.toString();\n}\n\npublic function main() returns error? {\n    // Read n (number of throws for team 1)\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read team 1 throws\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts1 = line2.trim().split(\" \");\n    int[] team1Throws = [];\n    foreach string part in parts1 {\n        if part.trim().length() > 0 {\n            team1Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Read m (number of throws for team 2)\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read input\");\n    }\n    int m = check 'int:fromString(line3.trim());\n    \n    // Read team 2 throws\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts2 = line4.trim().split(\" \");\n    int[] team2Throws = [];\n    foreach string part in parts2 {\n        if part.trim().length() > 0 {\n            team2Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Find and print optimal score\n    string result = findOptimalScore(team1Throws, team2Throws);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(82:36,82:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(102:36,102:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(82:36,82:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(102:36,102:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(82:36,82:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(102:36,102:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:41:28.179388",
      "status": "success",
      "completion": "# Overview\nThis problem requires finding an optimal distance threshold `d` such that throws <= d are worth 2 points and throws > d are worth 3 points. We need to maximize the score difference (team1 - team2), and if there are ties, maximize team1's score.\n\nThe key issue in the previous code was using `split()` which doesn't exist in Ballerina's string type. We need to use `regex:split()` from the `ballerina/regex` module instead.\n\nStrategy:\n1. Try all possible threshold values `d` (we only need to check d values at actual throw distances and boundary cases)\n2. For each `d`, calculate scores for both teams (throws <= d get 2 points, throws > d get 3 points)\n3. Track the best score difference and if tied, the maximum team1 score\n\n<CODE>\n```ballerina\n// Reasoning:\n// - For any distance threshold d, throws at distance <= d score 2 points, throws > d score 3 points\n// - We want to maximize (score1 - score2), with ties broken by maximizing score1\n// - We only need to test specific values of d: \n//   * d = 0 (one less than minimum, so all throws are 3-pointers)\n//   * d = each unique throw distance (to test transitions)\n//   * d = very large (so all throws are 2-pointers)\n// - For each candidate d, count throws <= d (2-pointers) and > d (3-pointers) for each team\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate score for a team given a threshold d\n// throws <= d get 2 points, throws > d get 3 points\nfunction calculateScore(int[] throws, int d) returns int {\n    int twoPointers = 0;\n    int threePointers = 0;\n    \n    foreach int distance in throws {\n        if distance <= d {\n            twoPointers += 1;\n        } else {\n            threePointers += 1;\n        }\n    }\n    \n    return twoPointers * 2 + threePointers * 3;\n}\n\n// Find optimal d value and return the best score as \"a:b\"\nfunction findOptimalScore(int[] team1Throws, int[] team2Throws) returns string {\n    // Collect all possible d values to test\n    // We need to test d values that represent boundaries where scoring changes\n    int[] candidateDs = [];\n    \n    // Test d = 0 (all throws are 3-pointers since all distances > 0)\n    candidateDs.push(0);\n    \n    // Add all throw distances as potential thresholds\n    foreach int distance in team1Throws {\n        candidateDs.push(distance);\n    }\n    foreach int distance in team2Throws {\n        candidateDs.push(distance);\n    }\n    \n    // Add a very large number to test all 2-pointers\n    candidateDs.push(2000000000);\n    \n    int maxDiff = -2147483648; // minimum int value\n    int bestScore1 = 0;\n    int bestScore2 = 0;\n    \n    // Try each candidate d value\n    foreach int d in candidateDs {\n        int score1 = calculateScore(team1Throws, d);\n        int score2 = calculateScore(team2Throws, d);\n        int diff = score1 - score2;\n        \n        // Update if we found a better difference, or same difference but higher score1\n        if diff > maxDiff || (diff == maxDiff && score1 > bestScore1) {\n            maxDiff = diff;\n            bestScore1 = score1;\n            bestScore2 = score2;\n        }\n    }\n    \n    return bestScore1.toString() + \":\" + bestScore2.toString();\n}\n\npublic function main() returns error? {\n    // Read n (number of throws for team 1)\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read team 1 throws\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts1 = regex:split(line2.trim(), \"\\\\s+\");\n    int[] team1Throws = [];\n    foreach string part in parts1 {\n        if part.trim().length() > 0 {\n            team1Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Read m (number of throws for team 2)\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read input\");\n    }\n    int m = check 'int:fromString(line3.trim());\n    \n    // Read team 2 throws\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts2 = regex:split(line4.trim(), \"\\\\s+\");\n    int[] team2Throws = [];\n    foreach string part in parts2 {\n        if part.trim().length() > 0 {\n            team2Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Find and print optimal score\n    string result = findOptimalScore(team1Throws, team2Throws);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] team1 = [1, 2, 3];\n    int[] team2 = [5, 6];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"9:6\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] team1 = [6, 7, 8, 9, 10];\n    int[] team2 = [1, 2, 3, 4, 5];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"15:10\");\n}\n\n@test:Config {}\nfunction testAllTwoPointers() {\n    int[] team1 = [1, 2];\n    int[] team2 = [1, 2];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"4:4\");\n}\n\n@test:Config {}\nfunction testAllThreePointers() {\n    int[] team1 = [10, 20, 30];\n    int[] team2 = [40];\n    string result = findOptimalScore(team1, team2);\n    test:assertEquals(result, \"9:3\");\n}\n\n@test:Config {}\nfunction testCalculateScoreAllTwo() {\n    int[] throws = [1, 2, 3, 4, 5];\n    int score = calculateScore(throws, 1000000000);\n    test:assertEquals(score, 10); // All 2-pointers\n}\n\n@test:Config {}\nfunction testCalculateScoreAllThree() {\n    int[] throws = [1, 2, 3, 4, 5];\n    int score = calculateScore(throws, 0);\n    test:assertEquals(score, 15); // All 3-pointers\n}\n\n@test:Config {}\nfunction testCalculateScoreMixed() {\n    int[] throws = [1, 2, 5, 6];\n    int score = calculateScore(throws, 3);\n    test:assertEquals(score, 10); // 2 two-pointers (1,2) and 2 three-pointers (5,6)\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - For any distance threshold d, throws at distance <= d score 2 points, throws > d score 3 points\n// - We want to maximize (score1 - score2), with ties broken by maximizing score1\n// - We only need to test specific values of d: \n//   * d = 0 (one less than minimum, so all throws are 3-pointers)\n//   * d = each unique throw distance (to test transitions)\n//   * d = very large (so all throws are 2-pointers)\n// - For each candidate d, count throws <= d (2-pointers) and > d (3-pointers) for each team\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate score for a team given a threshold d\n// throws <= d get 2 points, throws > d get 3 points\nfunction calculateScore(int[] throws, int d) returns int {\n    int twoPointers = 0;\n    int threePointers = 0;\n    \n    foreach int distance in throws {\n        if distance <= d {\n            twoPointers += 1;\n        } else {\n            threePointers += 1;\n        }\n    }\n    \n    return twoPointers * 2 + threePointers * 3;\n}\n\n// Find optimal d value and return the best score as \"a:b\"\nfunction findOptimalScore(int[] team1Throws, int[] team2Throws) returns string {\n    // Collect all possible d values to test\n    // We need to test d values that represent boundaries where scoring changes\n    int[] candidateDs = [];\n    \n    // Test d = 0 (all throws are 3-pointers since all distances > 0)\n    candidateDs.push(0);\n    \n    // Add all throw distances as potential thresholds\n    foreach int distance in team1Throws {\n        candidateDs.push(distance);\n    }\n    foreach int distance in team2Throws {\n        candidateDs.push(distance);\n    }\n    \n    // Add a very large number to test all 2-pointers\n    candidateDs.push(2000000000);\n    \n    int maxDiff = -2147483648; // minimum int value\n    int bestScore1 = 0;\n    int bestScore2 = 0;\n    \n    // Try each candidate d value\n    foreach int d in candidateDs {\n        int score1 = calculateScore(team1Throws, d);\n        int score2 = calculateScore(team2Throws, d);\n        int diff = score1 - score2;\n        \n        // Update if we found a better difference, or same difference but higher score1\n        if diff > maxDiff || (diff == maxDiff && score1 > bestScore1) {\n            maxDiff = diff;\n            bestScore1 = score1;\n            bestScore2 = score2;\n        }\n    }\n    \n    return bestScore1.toString() + \":\" + bestScore2.toString();\n}\n\npublic function main() returns error? {\n    // Read n (number of throws for team 1)\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read team 1 throws\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts1 = regex:split(line2.trim(), \"\\\\s+\");\n    int[] team1Throws = [];\n    foreach string part in parts1 {\n        if part.trim().length() > 0 {\n            team1Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Read m (number of throws for team 2)\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read input\");\n    }\n    int m = check 'int:fromString(line3.trim());\n    \n    // Read team 2 throws\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read input\");\n    }\n    string[] parts2 = regex:split(line4.trim(), \"\\\\s+\");\n    int[] team2Throws = [];\n    foreach string part in parts2 {\n        if part.trim().length() > 0 {\n            team2Throws.push(check 'int:fromString(part.trim()));\n        }\n    }\n    \n    // Find and print optimal score\n    string result = findOptimalScore(team1Throws, team2Throws);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T01:41:59.322877"
}