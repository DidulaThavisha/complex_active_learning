{
  "entry_id": "problem_0217",
  "problem_index": 217,
  "prompt": "Title: Cycle in Graph\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou've got a undirected graph *G*, consisting of *n* nodes. We will consider the nodes of the graph indexed by integers from 1 to *n*. We know that each node of graph *G* is connected by edges with at least *k* other nodes of this graph. Your task is to find in the given graph a simple cycle of length of at least *k*<=+<=1.\n\nA simple cycle of length *d* (*d*<=&gt;<=1) in graph *G* is a sequence of distinct graph nodes *v*1,<=*v*2,<=...,<=*v**d* such, that nodes *v*1 and *v**d* are connected by an edge of the graph, also for any integer *i* (1<=≤<=*i*<=&lt;<=*d*) nodes *v**i* and *v**i*<=+<=1 are connected by an edge of the graph.\n\nInput Specification:\nThe first line contains three integers *n*, *m*, *k* (3<=≤<=*n*,<=*m*<=≤<=105; 2<=≤<=*k*<=≤<=*n*<=-<=1) — the number of the nodes of the graph, the number of the graph's edges and the lower limit on the degree of the graph node. Next *m* lines contain pairs of integers. The *i*-th line contains integers *a**i*, *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*; *a**i*<=≠<=*b**i*) — the indexes of the graph nodes that are connected by the *i*-th edge. \n\nIt is guaranteed that the given graph doesn't contain any multiple edges or self-loops. It is guaranteed that each node of the graph is connected by the edges with at least *k* other nodes of the graph.\n\nOutput Specification:\nIn the first line print integer *r* (*r*<=≥<=*k*<=+<=1) — the length of the found cycle. In the next line print *r* distinct integers *v*1,<=*v*2,<=...,<=*v**r* (1<=≤<=*v**i*<=≤<=*n*) — the found simple cycle.\n\nIt is guaranteed that the answer exists. If there are multiple correct answers, you are allowed to print any of them.\n\nDemo Input:\n['3 3 2\\n1 2\\n2 3\\n3 1\\n', '4 6 3\\n4 3\\n1 2\\n1 3\\n1 4\\n2 3\\n2 4\\n']\n\nDemo Output:\n['3\\n1 2 3 ', '4\\n3 4 1 2 ']\n\nNote:\nnone",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:59:42.177218",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find a simple cycle of length at least k+1 in an undirected graph where each node has degree at least k. We can use DFS (Depth-First Search) to find such a cycle. The key insight is that if we perform DFS and encounter a node that's already in our current path (not the immediate parent), we've found a cycle. Since every node has degree at least k, we're guaranteed to find a cycle of sufficient length.\n\nThe algorithm:\n1. Build an adjacency list representation of the graph\n2. Perform DFS from any node, keeping track of the current path and parent relationships\n3. When we visit a node that's already in our current path, we've found a cycle\n4. Extract the cycle from the path and check if its length is at least k+1\n5. If not, continue searching from other nodes\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Use DFS to explore the graph and maintain the current path\n// - When we encounter a back edge (an edge to a node already in the current path),\n//   we've found a cycle\n// - Extract the cycle from the path starting from the revisited node\n// - Since each node has degree >= k, we're guaranteed to find a cycle of length >= k+1\n// - Use a visited set to track nodes in current DFS path\n// - Use parent tracking to avoid considering the edge we just came from\n\nimport ballerina/io;\n\ntype Graph record {|\n    map<int[]> adjacencyList;\n    int n;\n|};\n\nfunction buildGraph(int n, int[][] edges) returns Graph {\n    map<int[]> adjacencyList = {};\n    \n    // Initialize adjacency list for all nodes\n    int i = 1;\n    while i <= n {\n        adjacencyList[i.toString()] = [];\n        i += 1;\n    }\n    \n    // Add edges to adjacency list\n    foreach int[] edge in edges {\n        int u = edge[0];\n        int v = edge[1];\n        \n        int[] uNeighbors = adjacencyList.get(u.toString());\n        uNeighbors.push(v);\n        adjacencyList[u.toString()] = uNeighbors;\n        \n        int[] vNeighbors = adjacencyList.get(v.toString());\n        vNeighbors.push(u);\n        adjacencyList[v.toString()] = vNeighbors;\n    }\n    \n    return {adjacencyList: adjacencyList, n: n};\n}\n\nfunction findCycle(Graph graph, int k) returns int[]? {\n    map<boolean> visited = {};\n    map<boolean> inPath = {};\n    int[] path = [];\n    map<int> parent = {};\n    \n    int start = 1;\n    while start <= graph.n {\n        if visited.hasKey(start.toString()) {\n            start += 1;\n            continue;\n        }\n        \n        int[]? cycle = dfs(graph, start, -1, visited, inPath, path, parent, k);\n        if cycle is int[] {\n            return cycle;\n        }\n        start += 1;\n    }\n    \n    return ();\n}\n\nfunction dfs(Graph graph, int node, int par, map<boolean> visited, map<boolean> inPath, int[] path, map<int> parent, int k) returns int[]? {\n    visited[node.toString()] = true;\n    inPath[node.toString()] = true;\n    path.push(node);\n    parent[node.toString()] = par;\n    \n    int[] neighbors = graph.adjacencyList.get(node.toString());\n    \n    foreach int neighbor in neighbors {\n        if neighbor == par {\n            continue;\n        }\n        \n        if inPath.hasKey(neighbor.toString()) && inPath.get(neighbor.toString()) {\n            // Found a cycle - extract it from path\n            int[] cycle = [];\n            int idx = path.length() - 1;\n            while idx >= 0 {\n                cycle.push(path[idx]);\n                if path[idx] == neighbor {\n                    break;\n                }\n                idx -= 1;\n            }\n            \n            if cycle.length() >= k + 1 {\n                return cycle;\n            }\n        } else if !visited.hasKey(neighbor.toString()) {\n            int[]? cycle = dfs(graph, neighbor, node, visited, inPath, path, parent, k);\n            if cycle is int[] {\n                return cycle;\n            }\n        }\n    }\n    \n    // Backtrack\n    inPath[node.toString()] = false;\n    _ = path.pop();\n    \n    return ();\n}\n\npublic function main() returns error? {\n    // Read first line: n, m, k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read m edges\n    int[][] edges = [];\n    int edgeCount = 0;\n    while edgeCount < m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            return error(\"Failed to read edge line\");\n        }\n        \n        string[] edgeParts = edgeLine.trim().split(\" \");\n        if edgeParts.length() != 2 {\n            return error(\"Invalid edge format\");\n        }\n        \n        int u = check 'int:fromString(edgeParts[0]);\n        int v = check 'int:fromString(edgeParts[1]);\n        edges.push([u, v]);\n        edgeCount += 1;\n    }\n    \n    // Build graph and find cycle\n    Graph graph = buildGraph(n, edges);\n    int[]? cycle = findCycle(graph, k);\n    \n    if cycle is int[] {\n        io:println(cycle.length());\n        string output = \"\";\n        foreach int i in 0 ..< cycle.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += cycle[i].toString();\n        }\n        io:println(output + \" \");\n    } else {\n        return error(\"No cycle found\");\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSimpleTriangle() {\n    Graph graph = buildGraph(3, [[1, 2], [2, 3], [3, 1]]);\n    int[]? cycle = findCycle(graph, 2);\n    \n    test:assertTrue(cycle is int[]);\n    if cycle is int[] {\n        test:assertEquals(cycle.length(), 3);\n    }\n}\n\n@test:Config {}\nfunction testCompleteGraphFourNodes() {\n    Graph graph = buildGraph(4, [[4, 3], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]);\n    int[]? cycle = findCycle(graph, 3);\n    \n    test:assertTrue(cycle is int[]);\n    if cycle is int[] {\n        test:assertTrue(cycle.length() >= 4);\n    }\n}\n\n@test:Config {}\nfunction testBuildGraphStructure() {\n    Graph graph = buildGraph(3, [[1, 2], [2, 3]]);\n    \n    test:assertEquals(graph.n, 3);\n    test:assertTrue(graph.adjacencyList.hasKey(\"1\"));\n    test:assertTrue(graph.adjacencyList.hasKey(\"2\"));\n    test:assertTrue(graph.adjacencyList.hasKey(\"3\"));\n}\n\n@test:Config {}\nfunction testCycleLengthRequirement() {\n    Graph graph = buildGraph(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [1, 3]]);\n    int[]? cycle = findCycle(graph, 2);\n    \n    test:assertTrue(cycle is int[]);\n    if cycle is int[] {\n        test:assertTrue(cycle.length() >= 3);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Use DFS to explore the graph and maintain the current path\n// - When we encounter a back edge (an edge to a node already in the current path),\n//   we've found a cycle\n// - Extract the cycle from the path starting from the revisited node\n// - Since each node has degree >= k, we're guaranteed to find a cycle of length >= k+1\n// - Use a visited set to track nodes in current DFS path\n// - Use parent tracking to avoid considering the edge we just came from\n\nimport ballerina/io;\n\ntype Graph record {|\n    map<int[]> adjacencyList;\n    int n;\n|};\n\nfunction buildGraph(int n, int[][] edges) returns Graph {\n    map<int[]> adjacencyList = {};\n    \n    // Initialize adjacency list for all nodes\n    int i = 1;\n    while i <= n {\n        adjacencyList[i.toString()] = [];\n        i += 1;\n    }\n    \n    // Add edges to adjacency list\n    foreach int[] edge in edges {\n        int u = edge[0];\n        int v = edge[1];\n        \n        int[] uNeighbors = adjacencyList.get(u.toString());\n        uNeighbors.push(v);\n        adjacencyList[u.toString()] = uNeighbors;\n        \n        int[] vNeighbors = adjacencyList.get(v.toString());\n        vNeighbors.push(u);\n        adjacencyList[v.toString()] = vNeighbors;\n    }\n    \n    return {adjacencyList: adjacencyList, n: n};\n}\n\nfunction findCycle(Graph graph, int k) returns int[]? {\n    map<boolean> visited = {};\n    map<boolean> inPath = {};\n    int[] path = [];\n    map<int> parent = {};\n    \n    int start = 1;\n    while start <= graph.n {\n        if visited.hasKey(start.toString()) {\n            start += 1;\n            continue;\n        }\n        \n        int[]? cycle = dfs(graph, start, -1, visited, inPath, path, parent, k);\n        if cycle is int[] {\n            return cycle;\n        }\n        start += 1;\n    }\n    \n    return ();\n}\n\nfunction dfs(Graph graph, int node, int par, map<boolean> visited, map<boolean> inPath, int[] path, map<int> parent, int k) returns int[]? {\n    visited[node.toString()] = true;\n    inPath[node.toString()] = true;\n    path.push(node);\n    parent[node.toString()] = par;\n    \n    int[] neighbors = graph.adjacencyList.get(node.toString());\n    \n    foreach int neighbor in neighbors {\n        if neighbor == par {\n            continue;\n        }\n        \n        if inPath.hasKey(neighbor.toString()) && inPath.get(neighbor.toString()) {\n            // Found a cycle - extract it from path\n            int[] cycle = [];\n            int idx = path.length() - 1;\n            while idx >= 0 {\n                cycle.push(path[idx]);\n                if path[idx] == neighbor {\n                    break;\n                }\n                idx -= 1;\n            }\n            \n            if cycle.length() >= k + 1 {\n                return cycle;\n            }\n        } else if !visited.hasKey(neighbor.toString()) {\n            int[]? cycle = dfs(graph, neighbor, node, visited, inPath, path, parent, k);\n            if cycle is int[] {\n                return cycle;\n            }\n        }\n    }\n    \n    // Backtrack\n    inPath[node.toString()] = false;\n    _ = path.pop();\n    \n    return ();\n}\n\npublic function main() returns error? {\n    // Read first line: n, m, k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int m = check 'int:fromString(parts[1]);\n    int k = check 'int:fromString(parts[2]);\n    \n    // Read m edges\n    int[][] edges = [];\n    int edgeCount = 0;\n    while edgeCount < m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            return error(\"Failed to read edge line\");\n        }\n        \n        string[] edgeParts = edgeLine.trim().split(\" \");\n        if edgeParts.length() != 2 {\n            return error(\"Invalid edge format\");\n        }\n        \n        int u = check 'int:fromString(edgeParts[0]);\n        int v = check 'int:fromString(edgeParts[1]);\n        edges.push([u, v]);\n        edgeCount += 1;\n    }\n    \n    // Build graph and find cycle\n    Graph graph = buildGraph(n, edges);\n    int[]? cycle = findCycle(graph, k);\n    \n    if cycle is int[] {\n        io:println(cycle.length());\n        string output = \"\";\n        foreach int i in 0 ..< cycle.length() {\n            if i > 0 {\n                output += \" \";\n            }\n            output += cycle[i].toString();\n        }\n        io:println(output + \" \");\n    } else {\n        return error(\"No cycle found\");\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(50:9,50:14)] invalid token 'start'\nERROR [main.bal:(50:15,50:15)] missing identifier\nERROR [main.bal:(51:11,51:16)] action invocation as an expression not allowed here\nERROR [main.bal:(51:17,51:19)] invalid expression in start action\nERROR [main.bal:(52:27,52:32)] action invocation as an expression not allowed here\nERROR [main.bal:(53:19,53:20)] invalid expression in start action\nERROR [main.bal:(53:20,53:21)] invalid token '='\nERROR [main.bal:(57:35,57:40)] action invocation as",
      "error": "Compilation error: ERROR [main.bal:(50:9,50:14)] invalid token 'start'\nERROR [main.bal:(50:15,50:15)] missing identifier\nERROR [main.bal:(51:11,51:16)] action invocation as an expression not allowed here\nERROR [main.bal:(51:17,51:19)] invalid expression in start action\nERROR [main.bal:(52:27,52:32)] action invocation as an expression not allowed here\nERROR [main.bal:(53:19,53:20)] invalid expression in start action\nERROR [main.bal:(53:20,53:21)] invalid token '='\nERROR [main.bal:(57:35,57:40)] action invocation as",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(50:9,50:14)] invalid token 'start'\nERROR [main.bal:(50:15,50:15)] missing identifier\nERROR [main.bal:(51:11,51:16)] action invocation as an expression not allowed here\nERROR [main.bal:(51:17,51:19)] invalid expression in start action\nERROR [main.bal:(52:27,52:32)] action invocation as an expression not allowed here\nERROR [main.bal:(53:19,53:20)] invalid expression in start action\nERROR [main.bal:(53:20,53:21)] invalid token '='\nERROR [main.bal:(57:35,57:40)] action invocation as an expression not allowed here\nERROR [main.bal:(61:15,61:16)] invalid expression in start action\nERROR [main.bal:(61:16,61:17)] invalid token '='\nERROR [main.bal:(117:35,117:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(135:46,135:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:00:13.838129",
      "status": "failed",
      "completion": "Looking at the compilation errors, I can see the main issues:\n\n1. `start` is a reserved keyword in Ballerina - I need to rename this variable\n2. `string` doesn't have a `split` method in Ballerina - I need to use `regex:split` from the standard library or manually parse\n3. Some syntax issues with the loop structure\n\nLet me fix these issues and provide a corrected solution:\n\n# Overview\nThis problem requires finding a simple cycle of length at least k+1 in an undirected graph where each node has degree at least k. I'll use DFS (Depth-First Search) to traverse the graph and detect back edges. When we find a back edge (to a node already in our current path), we extract the cycle. The key insight is that with minimum degree k, we're guaranteed to find a cycle of sufficient length.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Build adjacency list representation of the graph\n// - Use DFS to explore paths and track current path nodes\n// - When we encounter a node already in current path (back edge), extract cycle\n// - The cycle is formed by nodes from the back edge target to current node in path\n// - Continue until we find a cycle of length >= k+1\n// - Use maps to track visited nodes and nodes in current DFS path\n// - Avoid the parent node when checking neighbors (to not count the edge we came from)\n\nimport ballerina/io;\n\ntype Graph record {|\n    map<int[]> adjacencyList;\n    int n;\n|};\n\nfunction buildGraph(int n, int[][] edges) returns Graph {\n    map<int[]> adjacencyList = {};\n    \n    // Initialize adjacency list for all nodes\n    int i = 1;\n    while i <= n {\n        adjacencyList[i.toString()] = [];\n        i = i + 1;\n    }\n    \n    // Add edges to adjacency list (undirected graph)\n    foreach int[] edge in edges {\n        int u = edge[0];\n        int v = edge[1];\n        \n        int[] uNeighbors = adjacencyList.get(u.toString());\n        uNeighbors.push(v);\n        adjacencyList[u.toString()] = uNeighbors;\n        \n        int[] vNeighbors = adjacencyList.get(v.toString());\n        vNeighbors.push(u);\n        adjacencyList[v.toString()] = vNeighbors;\n    }\n    \n    return {adjacencyList: adjacencyList, n: n};\n}\n\nfunction findCycle(Graph graph, int k) returns int[]? {\n    map<boolean> visited = {};\n    map<boolean> inPath = {};\n    int[] path = [];\n    \n    int currentNode = 1;\n    while currentNode <= graph.n {\n        if visited.hasKey(currentNode.toString()) {\n            currentNode = currentNode + 1;\n            continue;\n        }\n        \n        int[]? cycle = dfs(graph, currentNode, -1, visited, inPath, path, k);\n        if cycle is int[] {\n            return cycle;\n        }\n        currentNode = currentNode + 1;\n    }\n    \n    return ();\n}\n\nfunction dfs(Graph graph, int node, int par, map<boolean> visited, map<boolean> inPath, int[] path, int k) returns int[]? {\n    visited[node.toString()] = true;\n    inPath[node.toString()] = true;\n    path.push(node);\n    \n    int[] neighbors = graph.adjacencyList.get(node.toString());\n    \n    foreach int neighbor in neighbors {\n        if neighbor == par {\n            continue;\n        }\n        \n        if inPath.hasKey(neighbor.toString()) && inPath.get(neighbor.toString()) {\n            // Found a back edge - extract cycle from path\n            int[] cycle = [];\n            int idx = path.length() - 1;\n            while idx >= 0 {\n                cycle.push(path[idx]);\n                if path[idx] == neighbor {\n                    break;\n                }\n                idx = idx - 1;\n            }\n            \n            if cycle.length() >= k + 1 {\n                return cycle;\n            }\n        } else if !visited.hasKey(neighbor.toString()) {\n            int[]? cycle = dfs(graph, neighbor, node, visited, inPath, path, k);\n            if cycle is int[] {\n                return cycle;\n            }\n        }\n    }\n    \n    // Backtrack\n    inPath[node.toString()] = false;\n    _ = path.pop();\n    \n    return ();\n}\n\n// Helper function to parse space-separated integers\nfunction parseInts(string line) returns int[]|error {\n    int[] result = [];\n    string trimmed = line.trim();\n    string current = \"\";\n    \n    int i = 0;\n    while i < trimmed.length() {\n        string char = trimmed.substring(i, i + 1);\n        if char == \" \" {\n            if current.length() > 0 {\n                result.push(check 'int:fromString(current));\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i = i + 1;\n    }\n    \n    if current.length() > 0 {\n        result.push(check 'int:fromString(current));\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n, m, k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    int[] firstLine = check parseInts(line1);\n    if firstLine.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = firstLine[0];\n    int m = firstLine[1];\n    int k = firstLine[2];\n    \n    // Read m edges\n    int[][] edges = [];\n    int edgeCount = 0;\n    while edgeCount < m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            return error(\"Failed to read edge line\");\n        }\n        \n        int[] edgeParts = check parseInts(edgeLine);\n        if edgeParts.length() != 2 {\n            return error(\"Invalid edge format\");\n        }\n        \n        edges.push(edgeParts);\n        edgeCount = edgeCount + 1;\n    }\n    \n    // Build graph and find cycle\n    Graph graph = buildGraph(n, edges);\n    int[]? cycle = findCycle(graph, k);\n    \n    if cycle is int[] {\n        io:println(cycle.length());\n        string output = \"\";\n        int i = 0;\n        while i < cycle.length() {\n            if i > 0 {\n                output = output + \" \";\n            }\n            output = output + cycle[i].toString();\n            i = i + 1;\n        }\n        io:println(output + \" \");\n    } else {\n        return error(\"No cycle found\");\n    }\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSimpleTriangle() {\n    Graph graph = buildGraph(3, [[1, 2], [2, 3], [3, 1]]);\n    int[]? cycle = findCycle(graph, 2);\n    \n    test:assertTrue(cycle is int[]);\n    if cycle is int[] {\n        test:assertEquals(cycle.length(), 3);\n    }\n}\n\n@test:Config {}\nfunction testCompleteGraphFourNodes() {\n    Graph graph = buildGraph(4, [[4, 3], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]);\n    int[]? cycle = findCycle(graph, 3);\n    \n    test:assertTrue(cycle is int[]);\n    if cycle is int[] {\n        test:assertTrue(cycle.length() >= 4);\n    }\n}\n\n@test:Config {}\nfunction testBuildGraphStructure() {\n    Graph graph = buildGraph(3, [[1, 2], [2, 3]]);\n    \n    test:assertEquals(graph.n, 3);\n    test:assertTrue(graph.adjacencyList.hasKey(\"1\"));\n    test:assertTrue(graph.adjacencyList.hasKey(\"2\"));\n    test:assertTrue(graph.adjacencyList.hasKey(\"3\"));\n}\n\n@test:Config {}\nfunction testCycleLengthRequirement() {\n    Graph graph = buildGraph(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1], [1, 3]]);\n    int[]? cycle = findCycle(graph, 2);\n    \n    test:assertTrue(cycle is int[]);\n    if cycle is int[] {\n        test:assertTrue(cycle.length() >= 3);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Build adjacency list representation of the graph\n// - Use DFS to explore paths and track current path nodes\n// - When we encounter a node already in current path (back edge), extract cycle\n// - The cycle is formed by nodes from the back edge target to current node in path\n// - Continue until we find a cycle of length >= k+1\n// - Use maps to track visited nodes and nodes in current DFS path\n// - Avoid the parent node when checking neighbors (to not count the edge we came from)\n\nimport ballerina/io;\n\ntype Graph record {|\n    map<int[]> adjacencyList;\n    int n;\n|};\n\nfunction buildGraph(int n, int[][] edges) returns Graph {\n    map<int[]> adjacencyList = {};\n    \n    // Initialize adjacency list for all nodes\n    int i = 1;\n    while i <= n {\n        adjacencyList[i.toString()] = [];\n        i = i + 1;\n    }\n    \n    // Add edges to adjacency list (undirected graph)\n    foreach int[] edge in edges {\n        int u = edge[0];\n        int v = edge[1];\n        \n        int[] uNeighbors = adjacencyList.get(u.toString());\n        uNeighbors.push(v);\n        adjacencyList[u.toString()] = uNeighbors;\n        \n        int[] vNeighbors = adjacencyList.get(v.toString());\n        vNeighbors.push(u);\n        adjacencyList[v.toString()] = vNeighbors;\n    }\n    \n    return {adjacencyList: adjacencyList, n: n};\n}\n\nfunction findCycle(Graph graph, int k) returns int[]? {\n    map<boolean> visited = {};\n    map<boolean> inPath = {};\n    int[] path = [];\n    \n    int currentNode = 1;\n    while currentNode <= graph.n {\n        if visited.hasKey(currentNode.toString()) {\n            currentNode = currentNode + 1;\n            continue;\n        }\n        \n        int[]? cycle = dfs(graph, currentNode, -1, visited, inPath, path, k);\n        if cycle is int[] {\n            return cycle;\n        }\n        currentNode = currentNode + 1;\n    }\n    \n    return ();\n}\n\nfunction dfs(Graph graph, int node, int par, map<boolean> visited, map<boolean> inPath, int[] path, int k) returns int[]? {\n    visited[node.toString()] = true;\n    inPath[node.toString()] = true;\n    path.push(node);\n    \n    int[] neighbors = graph.adjacencyList.get(node.toString());\n    \n    foreach int neighbor in neighbors {\n        if neighbor == par {\n            continue;\n        }\n        \n        if inPath.hasKey(neighbor.toString()) && inPath.get(neighbor.toString()) {\n            // Found a back edge - extract cycle from path\n            int[] cycle = [];\n            int idx = path.length() - 1;\n            while idx >= 0 {\n                cycle.push(path[idx]);\n                if path[idx] == neighbor {\n                    break;\n                }\n                idx = idx - 1;\n            }\n            \n            if cycle.length() >= k + 1 {\n                return cycle;\n            }\n        } else if !visited.hasKey(neighbor.toString()) {\n            int[]? cycle = dfs(graph, neighbor, node, visited, inPath, path, k);\n            if cycle is int[] {\n                return cycle;\n            }\n        }\n    }\n    \n    // Backtrack\n    inPath[node.toString()] = false;\n    _ = path.pop();\n    \n    return ();\n}\n\n// Helper function to parse space-separated integers\nfunction parseInts(string line) returns int[]|error {\n    int[] result = [];\n    string trimmed = line.trim();\n    string current = \"\";\n    \n    int i = 0;\n    while i < trimmed.length() {\n        string char = trimmed.substring(i, i + 1);\n        if char == \" \" {\n            if current.length() > 0 {\n                result.push(check 'int:fromString(current));\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i = i + 1;\n    }\n    \n    if current.length() > 0 {\n        result.push(check 'int:fromString(current));\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read first line: n, m, k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    int[] firstLine = check parseInts(line1);\n    if firstLine.length() != 3 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = firstLine[0];\n    int m = firstLine[1];\n    int k = firstLine[2];\n    \n    // Read m edges\n    int[][] edges = [];\n    int edgeCount = 0;\n    while edgeCount < m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            return error(\"Failed to read edge line\");\n        }\n        \n        int[] edgeParts = check parseInts(edgeLine);\n        if edgeParts.length() != 2 {\n            return error(\"Invalid edge format\");\n        }\n        \n        edges.push(edgeParts);\n        edgeCount = edgeCount + 1;\n    }\n    \n    // Build graph and find cycle\n    Graph graph = buildGraph(n, edges);\n    int[]? cycle = findCycle(graph, k);\n    \n    if cycle is int[] {\n        io:println(cycle.length());\n        string output = \"\";\n        int i = 0;\n        while i < cycle.length() {\n            if i > 0 {\n                output = output + \" \";\n            }\n            output = output + cycle[i].toString();\n            i = i + 1;\n        }\n        io:println(output + \" \");\n    } else {\n        return error(\"No cycle found\");\n    }\n    \n    return;\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "3 3 2\n1 2\n2 3\n3 1\n",
          "expected_output": "3\n1 2 3 ",
          "actual_output": "3\n3 2 1 \n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T04:00:49.770846"
}