{
  "entry_id": "problem_0198",
  "problem_index": 198,
  "prompt": "Title: Color Stripe\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nA colored stripe is represented by a horizontal row of *n* square cells, each cell is pained one of *k* colors. Your task is to repaint the minimum number of cells so that no two neighbouring cells are of the same color. You can use any color from 1 to *k* to repaint the cells.\n\nInput Specification:\nThe first input line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=5·105; 2<=≤<=*k*<=≤<=26). The second line contains *n* uppercase English letters. Letter \"A\" stands for the first color, letter \"B\" stands for the second color and so on. The first *k* English letters may be used. Each letter represents the color of the corresponding cell of the stripe.\n\nOutput Specification:\nPrint a single integer — the required minimum number of repaintings. In the second line print any possible variant of the repainted stripe.\n\nDemo Input:\n['6 3\\nABBACC\\n', '3 2\\nBBB\\n']\n\nDemo Output:\n['2\\nABCACA\\n', '1\\nBAB\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem requires repainting a colored stripe so that no two adjacent cells have the same color, minimizing repaints. We use a greedy left-to-right scan: when two adjacent cells match, we repaint the second cell to a color different from both neighbors. The key fixes are: using proper string manipulation (regex split instead of split method), and correctly converting integers to characters for color generation.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Greedy approach: scan left to right, fix conflicts as we encounter them\n// - When cell[i] == cell[i-1], we repaint cell[i]\n// - When choosing a new color for cell[i], avoid:\n//   1. cell[i-1] (left neighbor - must be different)\n//   2. cell[i+1] (right neighbor if exists - to prevent future conflicts)\n// - Since k >= 2, we can always find a valid color\n// - Use 'A', 'B', 'C'... for colors (ASCII 65, 66, 67...)\n// - Fix compilation issues:\n//   * Use regex:split instead of string.split()\n//   * Properly convert int to char using checkpanic or proper casting\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveColorStripe(int n, int k, string stripe) returns [int, string] {\n    // Convert string to array of single-character strings for manipulation\n    string[] cells = [];\n    foreach int i in 0 ..< n {\n        cells.push(stripe.substring(i, i + 1));\n    }\n    \n    int repaints = 0;\n    \n    // Scan through the stripe and fix conflicts\n    foreach int i in 1 ..< n {\n        if cells[i] == cells[i - 1] {\n            // Need to repaint cell i\n            string leftColor = cells[i - 1];\n            string rightColor = (i + 1 < n) ? cells[i + 1] : \"\";\n            \n            // Find a valid color (different from left and right neighbors)\n            string newColor = \"\";\n            foreach int colorIdx in 0 ..< k {\n                // Convert index to character: 0->A, 1->B, etc.\n                // ASCII value of 'A' is 65\n                int asciiValue = 65 + colorIdx;\n                string candidateColor = checkpanic string:fromCodePointInt(asciiValue);\n                \n                if candidateColor != leftColor && candidateColor != rightColor {\n                    newColor = candidateColor;\n                    break;\n                }\n            }\n            \n            cells[i] = newColor;\n            repaints += 1;\n        }\n    }\n    \n    // Reconstruct the stripe string\n    string result = \"\";\n    foreach string cell in cells {\n        result += cell;\n    }\n    \n    return [repaints, result];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        io:println(\"Error: First line must contain two integers\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error k = 'int:fromString(parts[1]);\n    \n    if n is error {\n        io:println(\"Error: Invalid value for n\");\n        return;\n    }\n    \n    if k is error {\n        io:println(\"Error: Invalid value for k\");\n        return;\n    }\n    \n    // Validate constraints\n    if n < 1 || k < 2 {\n        io:println(\"Error: Invalid constraints (n >= 1, k >= 2)\");\n        return;\n    }\n    \n    // Read second line: the stripe\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No stripe input provided\");\n        return;\n    }\n    \n    string stripe = line2.trim();\n    \n    if stripe.length() != n {\n        io:println(\"Error: Stripe length doesn't match n\");\n        return;\n    }\n    \n    // Solve the problem\n    [int, string] result = solveColorStripe(n, k, stripe);\n    \n    // Output results\n    io:println(result[0]);\n    io:println(result[1]);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    [int, string] result = solveColorStripe(6, 3, \"ABBACC\");\n    test:assertEquals(result[0], 2);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    [int, string] result = solveColorStripe(3, 2, \"BBB\");\n    test:assertEquals(result[0], 1);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testNoRepaints() {\n    [int, string] result = solveColorStripe(5, 2, \"ABABA\");\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1], \"ABABA\");\n}\n\n@test:Config {}\nfunction testAllSameColor() {\n    [int, string] result = solveColorStripe(4, 2, \"AAAA\");\n    test:assertEquals(result[0], 2);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testTwoCells() {\n    [int, string] result = solveColorStripe(2, 2, \"AA\");\n    test:assertEquals(result[0], 1);\n    string stripe = result[1];\n    test:assertTrue(stripe.substring(0, 1) != stripe.substring(1, 2));\n}\n\n@test:Config {}\nfunction testLargerK() {\n    [int, string] result = solveColorStripe(5, 5, \"AABBC\");\n    test:assertEquals(result[0], 1);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// - Greedy approach: scan left to right, fix conflicts as we encounter them\n// - When cell[i] == cell[i-1], we repaint cell[i]\n// - When choosing a new color for cell[i], avoid:\n//   1. cell[i-1] (left neighbor - must be different)\n//   2. cell[i+1] (right neighbor if exists - to prevent future conflicts)\n// - Since k >= 2, we can always find a valid color\n// - Use 'A', 'B', 'C'... for colors (ASCII 65, 66, 67...)\n// - Fix compilation issues:\n//   * Use regex:split instead of string.split()\n//   * Properly convert int to char using checkpanic or proper casting\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveColorStripe(int n, int k, string stripe) returns [int, string] {\n    // Convert string to array of single-character strings for manipulation\n    string[] cells = [];\n    foreach int i in 0 ..< n {\n        cells.push(stripe.substring(i, i + 1));\n    }\n    \n    int repaints = 0;\n    \n    // Scan through the stripe and fix conflicts\n    foreach int i in 1 ..< n {\n        if cells[i] == cells[i - 1] {\n            // Need to repaint cell i\n            string leftColor = cells[i - 1];\n            string rightColor = (i + 1 < n) ? cells[i + 1] : \"\";\n            \n            // Find a valid color (different from left and right neighbors)\n            string newColor = \"\";\n            foreach int colorIdx in 0 ..< k {\n                // Convert index to character: 0->A, 1->B, etc.\n                // ASCII value of 'A' is 65\n                int asciiValue = 65 + colorIdx;\n                string candidateColor = checkpanic string:fromCodePointInt(asciiValue);\n                \n                if candidateColor != leftColor && candidateColor != rightColor {\n                    newColor = candidateColor;\n                    break;\n                }\n            }\n            \n            cells[i] = newColor;\n            repaints += 1;\n        }\n    }\n    \n    // Reconstruct the stripe string\n    string result = \"\";\n    foreach string cell in cells {\n        result += cell;\n    }\n    \n    return [repaints, result];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        io:println(\"Error: First line must contain two integers\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error k = 'int:fromString(parts[1]);\n    \n    if n is error {\n        io:println(\"Error: Invalid value for n\");\n        return;\n    }\n    \n    if k is error {\n        io:println(\"Error: Invalid value for k\");\n        return;\n    }\n    \n    // Validate constraints\n    if n < 1 || k < 2 {\n        io:println(\"Error: Invalid constraints (n >= 1, k >= 2)\");\n        return;\n    }\n    \n    // Read second line: the stripe\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No stripe input provided\");\n        return;\n    }\n    \n    string stripe = line2.trim();\n    \n    if stripe.length() != n {\n        io:println(\"Error: Stripe length doesn't match n\");\n        return;\n    }\n    \n    // Solve the problem\n    [int, string] result = solveColorStripe(n, k, stripe);\n    \n    // Output results\n    io:println(result[0]);\n    io:println(result[1]);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:38:40.813559",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to repaint a colored stripe such that no two neighboring cells have the same color, minimizing the number of repaints. We use a greedy approach: iterate through the stripe, and whenever we find two adjacent cells with the same color, we repaint the second cell to a color different from both its neighbors.\n\nThe strategy is:\n1. Parse input to get n (length), k (number of colors), and the stripe string\n2. Convert the stripe to a character array for easier manipulation\n3. Iterate through adjacent pairs; when colors match, find a replacement color that differs from both neighbors\n4. Count the repaints and output the result\n\n<CODE>\n```ballerina\n// Reasoning:\n// - We need to ensure no two adjacent cells have the same color\n// - Greedy approach: scan left to right, when we find a conflict, repaint the current cell\n// - When repainting cell i, we need to avoid:\n//   1. The color of cell i-1 (left neighbor)\n//   2. The color of cell i+1 (right neighbor, if exists)\n// - Since k >= 2, we can always find a valid color\n// - We'll use 'A', 'B', 'C', etc. as colors (first k letters)\n\nimport ballerina/io;\n\nfunction solveColorStripe(int n, int k, string stripe) returns [int, string] {\n    // Convert string to array of characters for easier manipulation\n    string[] cells = [];\n    foreach int i in 0 ..< n {\n        cells.push(stripe.substring(i, i + 1));\n    }\n    \n    int repaints = 0;\n    \n    // Iterate through the stripe and fix conflicts\n    foreach int i in 1 ..< n {\n        if cells[i] == cells[i - 1] {\n            // Need to repaint cell i\n            // Find a color different from left neighbor and right neighbor (if exists)\n            string leftColor = cells[i - 1];\n            string rightColor = (i + 1 < n) ? cells[i + 1] : \"\";\n            \n            // Try colors starting from 'A'\n            string newColor = \"\";\n            foreach int colorIdx in 0 ..< k {\n                string candidateColor = string `${<string:Char>(65 + colorIdx)}`;\n                if candidateColor != leftColor && candidateColor != rightColor {\n                    newColor = candidateColor;\n                    break;\n                }\n            }\n            \n            cells[i] = newColor;\n            repaints += 1;\n        }\n    }\n    \n    // Reconstruct the stripe string\n    string result = \"\";\n    foreach string cell in cells {\n        result += cell;\n    }\n    \n    return [repaints, result];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        io:println(\"Error: First line must contain two integers\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error k = 'int:fromString(parts[1]);\n    \n    if n is error {\n        io:println(\"Error: Invalid value for n\");\n        return;\n    }\n    \n    if k is error {\n        io:println(\"Error: Invalid value for k\");\n        return;\n    }\n    \n    // Read second line: the stripe\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No stripe input provided\");\n        return;\n    }\n    \n    string stripe = line2.trim();\n    \n    if stripe.length() != n {\n        io:println(\"Error: Stripe length doesn't match n\");\n        return;\n    }\n    \n    // Solve the problem\n    [int, string] result = solveColorStripe(n, k, stripe);\n    \n    // Output results\n    io:println(result[0]);\n    io:println(result[1]);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    [int, string] result = solveColorStripe(6, 3, \"ABBACC\");\n    test:assertEquals(result[0], 2);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    [int, string] result = solveColorStripe(3, 2, \"BBB\");\n    test:assertEquals(result[0], 1);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testNoRepaints() {\n    [int, string] result = solveColorStripe(5, 2, \"ABABA\");\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1], \"ABABA\");\n}\n\n@test:Config {}\nfunction testAllSameColor() {\n    [int, string] result = solveColorStripe(4, 2, \"AAAA\");\n    test:assertEquals(result[0], 2);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testTwoCells() {\n    [int, string] result = solveColorStripe(2, 2, \"AA\");\n    test:assertEquals(result[0], 1);\n    string stripe = result[1];\n    test:assertTrue(stripe.substring(0, 1) != stripe.substring(1, 2));\n}\n\n@test:Config {}\nfunction testLargerK() {\n    [int, string] result = solveColorStripe(5, 5, \"AABBC\");\n    test:assertEquals(result[0], 1);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - We need to ensure no two adjacent cells have the same color\n// - Greedy approach: scan left to right, when we find a conflict, repaint the current cell\n// - When repainting cell i, we need to avoid:\n//   1. The color of cell i-1 (left neighbor)\n//   2. The color of cell i+1 (right neighbor, if exists)\n// - Since k >= 2, we can always find a valid color\n// - We'll use 'A', 'B', 'C', etc. as colors (first k letters)\n\nimport ballerina/io;\n\nfunction solveColorStripe(int n, int k, string stripe) returns [int, string] {\n    // Convert string to array of characters for easier manipulation\n    string[] cells = [];\n    foreach int i in 0 ..< n {\n        cells.push(stripe.substring(i, i + 1));\n    }\n    \n    int repaints = 0;\n    \n    // Iterate through the stripe and fix conflicts\n    foreach int i in 1 ..< n {\n        if cells[i] == cells[i - 1] {\n            // Need to repaint cell i\n            // Find a color different from left neighbor and right neighbor (if exists)\n            string leftColor = cells[i - 1];\n            string rightColor = (i + 1 < n) ? cells[i + 1] : \"\";\n            \n            // Try colors starting from 'A'\n            string newColor = \"\";\n            foreach int colorIdx in 0 ..< k {\n                string candidateColor = string `${<string:Char>(65 + colorIdx)}`;\n                if candidateColor != leftColor && candidateColor != rightColor {\n                    newColor = candidateColor;\n                    break;\n                }\n            }\n            \n            cells[i] = newColor;\n            repaints += 1;\n        }\n    }\n    \n    // Reconstruct the stripe string\n    string result = \"\";\n    foreach string cell in cells {\n        result += cell;\n    }\n    \n    return [repaints, result];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        io:println(\"Error: First line must contain two integers\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error k = 'int:fromString(parts[1]);\n    \n    if n is error {\n        io:println(\"Error: Invalid value for n\");\n        return;\n    }\n    \n    if k is error {\n        io:println(\"Error: Invalid value for k\");\n        return;\n    }\n    \n    // Read second line: the stripe\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No stripe input provided\");\n        return;\n    }\n    \n    string stripe = line2.trim();\n    \n    if stripe.length() != n {\n        io:println(\"Error: Stripe length doesn't match n\");\n        return;\n    }\n    \n    // Solve the problem\n    [int, string] result = solveColorStripe(n, k, stripe);\n    \n    // Output results\n    io:println(result[0]);\n    io:println(result[1]);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(32:51,32:79)] incompatible types: 'int' cannot be cast to 'string:Char'\nERROR [main.bal:(61:35,61:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(32:51,32:79)] incompatible types: 'int' cannot be cast to 'string:Char'\nERROR [main.bal:(61:35,61:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(32:51,32:79)] incompatible types: 'int' cannot be cast to 'string:Char'\nERROR [main.bal:(61:35,61:40)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:39:08.517686",
      "status": "success",
      "completion": "# Overview\nThis problem requires repainting a colored stripe so that no two adjacent cells have the same color, minimizing repaints. We use a greedy left-to-right scan: when two adjacent cells match, we repaint the second cell to a color different from both neighbors. The key fixes are: using proper string manipulation (regex split instead of split method), and correctly converting integers to characters for color generation.\n\n<CODE>\n```ballerina\n// Reasoning:\n// - Greedy approach: scan left to right, fix conflicts as we encounter them\n// - When cell[i] == cell[i-1], we repaint cell[i]\n// - When choosing a new color for cell[i], avoid:\n//   1. cell[i-1] (left neighbor - must be different)\n//   2. cell[i+1] (right neighbor if exists - to prevent future conflicts)\n// - Since k >= 2, we can always find a valid color\n// - Use 'A', 'B', 'C'... for colors (ASCII 65, 66, 67...)\n// - Fix compilation issues:\n//   * Use regex:split instead of string.split()\n//   * Properly convert int to char using checkpanic or proper casting\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveColorStripe(int n, int k, string stripe) returns [int, string] {\n    // Convert string to array of single-character strings for manipulation\n    string[] cells = [];\n    foreach int i in 0 ..< n {\n        cells.push(stripe.substring(i, i + 1));\n    }\n    \n    int repaints = 0;\n    \n    // Scan through the stripe and fix conflicts\n    foreach int i in 1 ..< n {\n        if cells[i] == cells[i - 1] {\n            // Need to repaint cell i\n            string leftColor = cells[i - 1];\n            string rightColor = (i + 1 < n) ? cells[i + 1] : \"\";\n            \n            // Find a valid color (different from left and right neighbors)\n            string newColor = \"\";\n            foreach int colorIdx in 0 ..< k {\n                // Convert index to character: 0->A, 1->B, etc.\n                // ASCII value of 'A' is 65\n                int asciiValue = 65 + colorIdx;\n                string candidateColor = checkpanic string:fromCodePointInt(asciiValue);\n                \n                if candidateColor != leftColor && candidateColor != rightColor {\n                    newColor = candidateColor;\n                    break;\n                }\n            }\n            \n            cells[i] = newColor;\n            repaints += 1;\n        }\n    }\n    \n    // Reconstruct the stripe string\n    string result = \"\";\n    foreach string cell in cells {\n        result += cell;\n    }\n    \n    return [repaints, result];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        io:println(\"Error: First line must contain two integers\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error k = 'int:fromString(parts[1]);\n    \n    if n is error {\n        io:println(\"Error: Invalid value for n\");\n        return;\n    }\n    \n    if k is error {\n        io:println(\"Error: Invalid value for k\");\n        return;\n    }\n    \n    // Validate constraints\n    if n < 1 || k < 2 {\n        io:println(\"Error: Invalid constraints (n >= 1, k >= 2)\");\n        return;\n    }\n    \n    // Read second line: the stripe\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No stripe input provided\");\n        return;\n    }\n    \n    string stripe = line2.trim();\n    \n    if stripe.length() != n {\n        io:println(\"Error: Stripe length doesn't match n\");\n        return;\n    }\n    \n    // Solve the problem\n    [int, string] result = solveColorStripe(n, k, stripe);\n    \n    // Output results\n    io:println(result[0]);\n    io:println(result[1]);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    [int, string] result = solveColorStripe(6, 3, \"ABBACC\");\n    test:assertEquals(result[0], 2);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    [int, string] result = solveColorStripe(3, 2, \"BBB\");\n    test:assertEquals(result[0], 1);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testNoRepaints() {\n    [int, string] result = solveColorStripe(5, 2, \"ABABA\");\n    test:assertEquals(result[0], 0);\n    test:assertEquals(result[1], \"ABABA\");\n}\n\n@test:Config {}\nfunction testAllSameColor() {\n    [int, string] result = solveColorStripe(4, 2, \"AAAA\");\n    test:assertEquals(result[0], 2);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n\n@test:Config {}\nfunction testTwoCells() {\n    [int, string] result = solveColorStripe(2, 2, \"AA\");\n    test:assertEquals(result[0], 1);\n    string stripe = result[1];\n    test:assertTrue(stripe.substring(0, 1) != stripe.substring(1, 2));\n}\n\n@test:Config {}\nfunction testLargerK() {\n    [int, string] result = solveColorStripe(5, 5, \"AABBC\");\n    test:assertEquals(result[0], 1);\n    // Verify no adjacent cells are the same\n    string stripe = result[1];\n    foreach int i in 1 ..< stripe.length() {\n        test:assertTrue(stripe.substring(i, i + 1) != stripe.substring(i - 1, i));\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - Greedy approach: scan left to right, fix conflicts as we encounter them\n// - When cell[i] == cell[i-1], we repaint cell[i]\n// - When choosing a new color for cell[i], avoid:\n//   1. cell[i-1] (left neighbor - must be different)\n//   2. cell[i+1] (right neighbor if exists - to prevent future conflicts)\n// - Since k >= 2, we can always find a valid color\n// - Use 'A', 'B', 'C'... for colors (ASCII 65, 66, 67...)\n// - Fix compilation issues:\n//   * Use regex:split instead of string.split()\n//   * Properly convert int to char using checkpanic or proper casting\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction solveColorStripe(int n, int k, string stripe) returns [int, string] {\n    // Convert string to array of single-character strings for manipulation\n    string[] cells = [];\n    foreach int i in 0 ..< n {\n        cells.push(stripe.substring(i, i + 1));\n    }\n    \n    int repaints = 0;\n    \n    // Scan through the stripe and fix conflicts\n    foreach int i in 1 ..< n {\n        if cells[i] == cells[i - 1] {\n            // Need to repaint cell i\n            string leftColor = cells[i - 1];\n            string rightColor = (i + 1 < n) ? cells[i + 1] : \"\";\n            \n            // Find a valid color (different from left and right neighbors)\n            string newColor = \"\";\n            foreach int colorIdx in 0 ..< k {\n                // Convert index to character: 0->A, 1->B, etc.\n                // ASCII value of 'A' is 65\n                int asciiValue = 65 + colorIdx;\n                string candidateColor = checkpanic string:fromCodePointInt(asciiValue);\n                \n                if candidateColor != leftColor && candidateColor != rightColor {\n                    newColor = candidateColor;\n                    break;\n                }\n            }\n            \n            cells[i] = newColor;\n            repaints += 1;\n        }\n    }\n    \n    // Reconstruct the stripe string\n    string result = \"\";\n    foreach string cell in cells {\n        result += cell;\n    }\n    \n    return [repaints, result];\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    // Use regex:split instead of string.split()\n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        io:println(\"Error: First line must contain two integers\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error k = 'int:fromString(parts[1]);\n    \n    if n is error {\n        io:println(\"Error: Invalid value for n\");\n        return;\n    }\n    \n    if k is error {\n        io:println(\"Error: Invalid value for k\");\n        return;\n    }\n    \n    // Validate constraints\n    if n < 1 || k < 2 {\n        io:println(\"Error: Invalid constraints (n >= 1, k >= 2)\");\n        return;\n    }\n    \n    // Read second line: the stripe\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No stripe input provided\");\n        return;\n    }\n    \n    string stripe = line2.trim();\n    \n    if stripe.length() != n {\n        io:println(\"Error: Stripe length doesn't match n\");\n        return;\n    }\n    \n    // Solve the problem\n    [int, string] result = solveColorStripe(n, k, stripe);\n    \n    // Output results\n    io:println(result[0]);\n    io:println(result[1]);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:39:40.804408"
}