{
  "entry_id": "problem_0063",
  "problem_index": 63,
  "prompt": "Title: Hamsters and Tigers\n\nTime Limit: 2 seconds\n\nMemory Limit: 256 megabytes\n\nProblem Description:\nToday there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.\n\nInput Specification:\nThe first line contains number *n* (2<=≤<=*n*<=≤<=1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of *n* symbols \"H\" and \"T\". The \"H\"s correspond to hamsters and the \"T\"s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.\n\nOutput Specification:\nPrint the single number which is the minimal number of swaps that let the trainer to achieve his goal.\n\nDemo Input:\n['3\\nHTH\\n', '9\\nHTHTHTHHT\\n']\n\nDemo Output:\n['0\\n', '2\\n']\n\nNote:\nIn the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem asks us to find the minimum number of swaps needed to group all hamsters together and all tigers together in a circular arrangement. Since they're in a circle, we need to consider all possible contiguous positions where we could place all hamsters (or tigers). The optimal solution is to find a window of size equal to the number of hamsters and count how many tigers are in that window - those tigers need to be swapped out. We try all possible windows in the circle and pick the one requiring minimum swaps.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Since animals are in a circle, we can group either all hamsters together or all tigers together\n// 2. If we decide to group hamsters, we need a contiguous window of size = count of hamsters\n// 3. For each possible window position in the circle, count how many tigers are in it\n// 4. Those tigers need to be swapped with hamsters outside the window\n// 5. The minimum count across all windows is our answer\n// 6. We try all n possible positions for the window in the circular arrangement\n\nimport ballerina/io;\n\nfunction minSwaps(int n, string animals) returns int|error {\n    // Count total hamsters\n    int hamsterCount = 0;\n    foreach int i in 0 ..< n {\n        if animals[i] == \"H\" {\n            hamsterCount += 1;\n        }\n    }\n    \n    // If all are hamsters or all are tigers, no swaps needed\n    if hamsterCount == 0 || hamsterCount == n {\n        return 0;\n    }\n    \n    // Try all possible windows of size hamsterCount in the circular array\n    int minSwapsNeeded = n; // worst case\n    \n    foreach int startPos in 0 ..< n {\n        // Count tigers in the window starting at startPos with length hamsterCount\n        int tigersInWindow = 0;\n        foreach int offset in 0 ..< hamsterCount {\n            int pos = (startPos + offset) % n;\n            if animals[pos] == \"T\" {\n                tigersInWindow += 1;\n            }\n        }\n        \n        // Number of swaps needed for this window = number of tigers in it\n        if tigersInWindow < minSwapsNeeded {\n            minSwapsNeeded = tigersInWindow;\n        }\n    }\n    \n    return minSwapsNeeded;\n}\n\npublic function main() returns error? {\n    // Read number of animals\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Validate n\n    if n < 2 || n > 1000 {\n        io:println(\"Error: n must be between 2 and 1000\");\n        return;\n    }\n    \n    // Read animals string\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No animals string provided\");\n        return;\n    }\n    \n    string animals = line2.trim();\n    \n    // Validate length\n    if animals.length() != n {\n        io:println(\"Error: Animals string length doesn't match n\");\n        return;\n    }\n    \n    // Validate characters\n    foreach int i in 0 ..< n {\n        string char = animals[i];\n        if char != \"H\" && char != \"T\" {\n            io:println(\"Error: Invalid character in animals string\");\n            return;\n        }\n    }\n    \n    // Calculate and print result\n    int result = check minSwaps(n, animals);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMinSwapsExample1() {\n    int|error result = minSwaps(3, \"HTH\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsExample2() {\n    int|error result = minSwaps(9, \"HTHTHTXHHT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 2);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsAllHamstersTogether() {\n    int|error result = minSwaps(5, \"HHHTT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsAlternating() {\n    int|error result = minSwaps(6, \"HTHTHTHT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsCircularCase() {\n    // THHHT - hamsters at positions 1,2,3\n    // Window of 3 hamsters: \n    // Starting at 0: THH -> 1 tiger\n    // Starting at 1: HHH -> 0 tigers (but wraps: positions 1,2,3)\n    // Starting at 2: HHT -> 1 tiger\n    // etc.\n    int|error result = minSwaps(5, \"THHHT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsTwoAnimals() {\n    int|error result = minSwaps(2, \"HT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Since animals are in a circle, we can group either all hamsters together or all tigers together\n// 2. If we decide to group hamsters, we need a contiguous window of size = count of hamsters\n// 3. For each possible window position in the circle, count how many tigers are in it\n// 4. Those tigers need to be swapped with hamsters outside the window\n// 5. The minimum count across all windows is our answer\n// 6. We try all n possible positions for the window in the circular arrangement\n\nimport ballerina/io;\n\nfunction minSwaps(int n, string animals) returns int|error {\n    // Count total hamsters\n    int hamsterCount = 0;\n    foreach int i in 0 ..< n {\n        if animals[i] == \"H\" {\n            hamsterCount += 1;\n        }\n    }\n    \n    // If all are hamsters or all are tigers, no swaps needed\n    if hamsterCount == 0 || hamsterCount == n {\n        return 0;\n    }\n    \n    // Try all possible windows of size hamsterCount in the circular array\n    int minSwapsNeeded = n; // worst case\n    \n    foreach int startPos in 0 ..< n {\n        // Count tigers in the window starting at startPos with length hamsterCount\n        int tigersInWindow = 0;\n        foreach int offset in 0 ..< hamsterCount {\n            int pos = (startPos + offset) % n;\n            if animals[pos] == \"T\" {\n                tigersInWindow += 1;\n            }\n        }\n        \n        // Number of swaps needed for this window = number of tigers in it\n        if tigersInWindow < minSwapsNeeded {\n            minSwapsNeeded = tigersInWindow;\n        }\n    }\n    \n    return minSwapsNeeded;\n}\n\npublic function main() returns error? {\n    // Read number of animals\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Validate n\n    if n < 2 || n > 1000 {\n        io:println(\"Error: n must be between 2 and 1000\");\n        return;\n    }\n    \n    // Read animals string\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No animals string provided\");\n        return;\n    }\n    \n    string animals = line2.trim();\n    \n    // Validate length\n    if animals.length() != n {\n        io:println(\"Error: Animals string length doesn't match n\");\n        return;\n    }\n    \n    // Validate characters\n    foreach int i in 0 ..< n {\n        string char = animals[i];\n        if char != \"H\" && char != \"T\" {\n            io:println(\"Error: Invalid character in animals string\");\n            return;\n        }\n    }\n    \n    // Calculate and print result\n    int result = check minSwaps(n, animals);\n    io:println(result);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:04:30.906412",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to find the minimum number of swaps needed to group all hamsters together and all tigers together in a circular arrangement. Since they're in a circle, we need to consider all possible contiguous positions where we could place all hamsters (or tigers). The optimal solution is to find a window of size equal to the number of hamsters and count how many tigers are in that window - those tigers need to be swapped out. We try all possible windows in the circle and pick the one requiring minimum swaps.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Since animals are in a circle, we can group either all hamsters together or all tigers together\n// 2. If we decide to group hamsters, we need a contiguous window of size = count of hamsters\n// 3. For each possible window position in the circle, count how many tigers are in it\n// 4. Those tigers need to be swapped with hamsters outside the window\n// 5. The minimum count across all windows is our answer\n// 6. We try all n possible positions for the window in the circular arrangement\n\nimport ballerina/io;\n\nfunction minSwaps(int n, string animals) returns int|error {\n    // Count total hamsters\n    int hamsterCount = 0;\n    foreach int i in 0 ..< n {\n        if animals[i] == \"H\" {\n            hamsterCount += 1;\n        }\n    }\n    \n    // If all are hamsters or all are tigers, no swaps needed\n    if hamsterCount == 0 || hamsterCount == n {\n        return 0;\n    }\n    \n    // Try all possible windows of size hamsterCount in the circular array\n    int minSwapsNeeded = n; // worst case\n    \n    foreach int startPos in 0 ..< n {\n        // Count tigers in the window starting at startPos with length hamsterCount\n        int tigersInWindow = 0;\n        foreach int offset in 0 ..< hamsterCount {\n            int pos = (startPos + offset) % n;\n            if animals[pos] == \"T\" {\n                tigersInWindow += 1;\n            }\n        }\n        \n        // Number of swaps needed for this window = number of tigers in it\n        if tigersInWindow < minSwapsNeeded {\n            minSwapsNeeded = tigersInWindow;\n        }\n    }\n    \n    return minSwapsNeeded;\n}\n\npublic function main() returns error? {\n    // Read number of animals\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Validate n\n    if n < 2 || n > 1000 {\n        io:println(\"Error: n must be between 2 and 1000\");\n        return;\n    }\n    \n    // Read animals string\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No animals string provided\");\n        return;\n    }\n    \n    string animals = line2.trim();\n    \n    // Validate length\n    if animals.length() != n {\n        io:println(\"Error: Animals string length doesn't match n\");\n        return;\n    }\n    \n    // Validate characters\n    foreach int i in 0 ..< n {\n        string char = animals[i];\n        if char != \"H\" && char != \"T\" {\n            io:println(\"Error: Invalid character in animals string\");\n            return;\n        }\n    }\n    \n    // Calculate and print result\n    int result = check minSwaps(n, animals);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMinSwapsExample1() {\n    int|error result = minSwaps(3, \"HTH\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsExample2() {\n    int|error result = minSwaps(9, \"HTHTHTXHHT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 2);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsAllHamstersTogether() {\n    int|error result = minSwaps(5, \"HHHTT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsAlternating() {\n    int|error result = minSwaps(6, \"HTHTHTHT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsCircularCase() {\n    // THHHT - hamsters at positions 1,2,3\n    // Window of 3 hamsters: \n    // Starting at 0: THH -> 1 tiger\n    // Starting at 1: HHH -> 0 tigers (but wraps: positions 1,2,3)\n    // Starting at 2: HHT -> 1 tiger\n    // etc.\n    int|error result = minSwaps(5, \"THHHT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testMinSwapsTwoAnimals() {\n    int|error result = minSwaps(2, \"HT\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Since animals are in a circle, we can group either all hamsters together or all tigers together\n// 2. If we decide to group hamsters, we need a contiguous window of size = count of hamsters\n// 3. For each possible window position in the circle, count how many tigers are in it\n// 4. Those tigers need to be swapped with hamsters outside the window\n// 5. The minimum count across all windows is our answer\n// 6. We try all n possible positions for the window in the circular arrangement\n\nimport ballerina/io;\n\nfunction minSwaps(int n, string animals) returns int|error {\n    // Count total hamsters\n    int hamsterCount = 0;\n    foreach int i in 0 ..< n {\n        if animals[i] == \"H\" {\n            hamsterCount += 1;\n        }\n    }\n    \n    // If all are hamsters or all are tigers, no swaps needed\n    if hamsterCount == 0 || hamsterCount == n {\n        return 0;\n    }\n    \n    // Try all possible windows of size hamsterCount in the circular array\n    int minSwapsNeeded = n; // worst case\n    \n    foreach int startPos in 0 ..< n {\n        // Count tigers in the window starting at startPos with length hamsterCount\n        int tigersInWindow = 0;\n        foreach int offset in 0 ..< hamsterCount {\n            int pos = (startPos + offset) % n;\n            if animals[pos] == \"T\" {\n                tigersInWindow += 1;\n            }\n        }\n        \n        // Number of swaps needed for this window = number of tigers in it\n        if tigersInWindow < minSwapsNeeded {\n            minSwapsNeeded = tigersInWindow;\n        }\n    }\n    \n    return minSwapsNeeded;\n}\n\npublic function main() returns error? {\n    // Read number of animals\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: No input provided\");\n        return;\n    }\n    \n    int n = check 'int:fromString(line1.trim());\n    \n    // Validate n\n    if n < 2 || n > 1000 {\n        io:println(\"Error: n must be between 2 and 1000\");\n        return;\n    }\n    \n    // Read animals string\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: No animals string provided\");\n        return;\n    }\n    \n    string animals = line2.trim();\n    \n    // Validate length\n    if animals.length() != n {\n        io:println(\"Error: Animals string length doesn't match n\");\n        return;\n    }\n    \n    // Validate characters\n    foreach int i in 0 ..< n {\n        string char = animals[i];\n        if char != \"H\" && char != \"T\" {\n            io:println(\"Error: Invalid character in animals string\");\n            return;\n        }\n    }\n    \n    // Calculate and print result\n    int result = check minSwaps(n, animals);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T01:05:05.270746"
}