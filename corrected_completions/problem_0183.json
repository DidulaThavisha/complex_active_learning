{
  "entry_id": "problem_0183",
  "problem_index": 183,
  "prompt": "Title: Guest From the Past\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nKolya Gerasimov loves kefir very much. He lives in year 1984 and knows all the details of buying this delicious drink. One day, as you probably know, he found himself in year 2084, and buying kefir there is much more complicated.\n\nKolya is hungry, so he went to the nearest milk shop. In 2084 you may buy kefir in a plastic liter bottle, that costs *a* rubles, or in glass liter bottle, that costs *b* rubles. Also, you may return empty glass bottle and get *c* (*c*<=&lt;<=*b*) rubles back, but you cannot return plastic bottles.\n\nKolya has *n* rubles and he is really hungry, so he wants to drink as much kefir as possible. There were no plastic bottles in his 1984, so Kolya doesn't know how to act optimally and asks for your help.\n\nInput Specification:\nFirst line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=1018) — the number of rubles Kolya has at the beginning.\n\nThen follow three lines containing integers *a*, *b* and *c* (1<=≤<=*a*<=≤<=1018, 1<=≤<=*c*<=&lt;<=*b*<=≤<=1018) — the cost of one plastic liter bottle, the cost of one glass liter bottle and the money one can get back by returning an empty glass bottle, respectively.\n\nOutput Specification:\nPrint the only integer — maximum number of liters of kefir, that Kolya can drink.\n\nDemo Input:\n['10\\n11\\n9\\n8\\n', '10\\n5\\n6\\n1\\n']\n\nDemo Output:\n['2\\n', '2\\n']\n\nNote:\nIn the first sample, Kolya can buy one glass bottle, then return it and buy one more glass bottle. Thus he will drink 2 liters of kefir.\n\nIn the second sample, Kolya can buy two plastic bottle and get two liters of kefir, or he can buy one liter glass bottle, then return it and buy one plastic bottle. In both cases he will drink two liters of kefir.",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the failing test case, I need to analyze the problem more carefully.\n\n**Test Input:**\n- n=10, a=11, b=9, c=8\n- Expected: 2\n- My output: 10\n\nThe issue is clear: when I calculate `remaining / costPerGlass`, I'm getting `9 / 1 = 9`, giving me 10 total glass bottles. But this is wrong!\n\n**The key insight I missed:** After buying the first glass bottle and returning it, I have `n - b + c = 10 - 9 + 8 = 9` rubles. To buy the next glass bottle, I need `b = 9` rubles. After buying it and returning it, I get `c = 8` back. But now I only have 8 rubles, which is NOT enough to buy another glass bottle (needs 9).\n\n**The correct logic:** After the first glass bottle, I can keep buying glass bottles as long as I have at least `b` rubles (not `b - c`). Each cycle: spend `b`, get `c` back, net cost is `b - c`.\n\nLet me trace through correctly:\n- Start: 10 rubles\n- Buy glass: 10 - 9 = 1 ruble, drink 1 liter\n- Return glass: 1 + 8 = 9 rubles\n- Buy glass: 9 - 9 = 0 rubles, drink 1 liter (total 2)\n- Return glass: 0 + 8 = 8 rubles\n- Can't buy glass (need 9) or plastic (need 11)\n- Total: 2 liters ✓\n\n**The fix:** After buying the first glass bottle, I need to check if `remaining >= b` to buy more, not just divide by `(b-c)`.\n\n# Overview\nThis problem requires finding the maximum kefir that can be purchased with two options: plastic bottles (cost `a`, no return) and glass bottles (cost `b`, return for `c`). The key is that glass bottles can be reused: buy for `b`, return for `c`, effective cost `b-c` per cycle. We compare: (1) only plastic, (2) glass bottles repeatedly, (3) glass then switch to plastic.\n\n<CODE>\n```ballerina\n// Reasoning:\n// We need to maximize liters of kefir with n rubles\n// Option 1: Plastic bottles cost 'a', cannot return\n// Option 2: Glass bottles cost 'b', return for 'c' (c < b)\n//\n// Key insight for glass bottles:\n// - First glass bottle: costs b, after drinking return for c, net spent = b-c\n// - Subsequent bottles: need b rubles to buy, get c back, net cost = b-c per liter\n// - BUT: we need to have at least b rubles to buy the next bottle!\n//\n// Strategy comparison:\n// 1. Only plastic: n / a liters\n// 2. Glass bottles: \n//    - If n >= b, buy first glass\n//    - After first: have (n - b + c) rubles\n//    - Keep buying while we have >= b rubles\n//    - Each purchase costs b, returns c\n// 3. Glass then plastic: after glass purchases, use remaining for plastic\n//\n// Important: When buying glass repeatedly, we need >= b to buy next bottle,\n// not just b-c. The b-c is the net cost, but we need b upfront.\n\nimport ballerina/io;\n\nfunction maxKefir(int n, int a, int b, int c) returns int {\n    int maxLiters = 0;\n    \n    // Strategy 1: Only plastic bottles\n    int plasticOnly = n / a;\n    maxLiters = plasticOnly;\n    \n    // Strategy 2 & 3: Glass bottles (possibly followed by plastic)\n    if n >= b {\n        int glassBottles = 0;\n        int money = n;\n        \n        // Buy glass bottles while we have enough money\n        while money >= b {\n            glassBottles = glassBottles + 1;\n            money = money - b + c; // Spend b, get c back\n        }\n        \n        // With remaining money, try to buy plastic bottles\n        int plasticBottles = money / a;\n        int totalLiters = glassBottles + plasticBottles;\n        \n        if totalLiters > maxLiters {\n            maxLiters = totalLiters;\n        }\n    }\n    \n    return maxLiters;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read a\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read a\");\n    }\n    int a = check 'int:fromString(line2.trim());\n    \n    // Read b\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read b\");\n    }\n    int b = check 'int:fromString(line3.trim());\n    \n    // Read c\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read c\");\n    }\n    int c = check 'int:fromString(line4.trim());\n    \n    int result = maxKefir(n, a, b, c);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxKefirExample1() {\n    // n=10, a=11, b=9, c=8\n    // Glass strategy: \n    //   Buy 1st: 10-9=1, return: 1+8=9, bottles=1\n    //   Buy 2nd: 9-9=0, return: 0+8=8, bottles=2\n    //   Can't buy 3rd (need 9, have 8)\n    // Plastic: can't afford (need 11)\n    // Total: 2 liters\n    int result = maxKefir(10, 11, 9, 8);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxKefirExample2() {\n    // n=10, a=5, b=6, c=1\n    // Plastic: 10/5 = 2 liters\n    // Glass: \n    //   Buy 1st: 10-6=4, return: 4+1=5, bottles=1\n    //   Buy 2nd: 5-6=-1, can't afford\n    //   Remaining 5, plastic: 5/5=1\n    //   Total: 1+1=2\n    // Both strategies give 2\n    int result = maxKefir(10, 5, 6, 1);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxKefirNoMoney() {\n    // Can't afford anything\n    int result = maxKefir(5, 10, 10, 5);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMaxKefirPlasticBetter() {\n    // When plastic is cheaper\n    int result = maxKefir(100, 10, 50, 1);\n    // Plastic: 100/10 = 10\n    // Glass: buy 1 for 50, return for 1, have 51\n    //        buy 2nd for 50, can't (need 50, have 51-50=1 after, wait we have 51)\n    //        buy 2nd: 51-50=1, return: 1+1=2\n    //        can't buy 3rd (need 50, have 2)\n    //        plastic with 2: 2/10=0\n    //        total: 2\n    // Plastic wins: 10\n    test:assertEquals(result, 10);\n}\n\n@test:Config {}\nfunction testMaxKefirGlassBetter() {\n    // When glass has very good return rate\n    int result = maxKefir(100, 50, 51, 50);\n    // Plastic: 100/50 = 2\n    // Glass: buy for 51, return for 50\n    //        1st: 100-51=49, return: 49+50=99\n    //        2nd: 99-51=48, return: 48+50=98\n    //        ...continues while >= 51\n    //        Net cost per bottle after first: 51-50=1\n    //        Total glass: (100-51)/1 + 1 = 49+1 = 50\n    //        Actually: money=100, buy 1: money=49+50=99\n    //                  buy 2: 99-51+50=98, buy 3: 98-51+50=97...\n    //        Pattern: 100,99,98,...,51,50 (can't buy at 50)\n    //        Count: 100-50 = 50 bottles\n    test:assertEquals(result, 50);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// We need to maximize liters of kefir with n rubles\n// Option 1: Plastic bottles cost 'a', cannot return\n// Option 2: Glass bottles cost 'b', return for 'c' (c < b)\n//\n// Key insight for glass bottles:\n// - First glass bottle: costs b, after drinking return for c, net spent = b-c\n// - Subsequent bottles: need b rubles to buy, get c back, net cost = b-c per liter\n// - BUT: we need to have at least b rubles to buy the next bottle!\n//\n// Strategy comparison:\n// 1. Only plastic: n / a liters\n// 2. Glass bottles: \n//    - If n >= b, buy first glass\n//    - After first: have (n - b + c) rubles\n//    - Keep buying while we have >= b rubles\n//    - Each purchase costs b, returns c\n// 3. Glass then plastic: after glass purchases, use remaining for plastic\n//\n// Important: When buying glass repeatedly, we need >= b to buy next bottle,\n// not just b-c. The b-c is the net cost, but we need b upfront.\n\nimport ballerina/io;\n\nfunction maxKefir(int n, int a, int b, int c) returns int {\n    int maxLiters = 0;\n    \n    // Strategy 1: Only plastic bottles\n    int plasticOnly = n / a;\n    maxLiters = plasticOnly;\n    \n    // Strategy 2 & 3: Glass bottles (possibly followed by plastic)\n    if n >= b {\n        int glassBottles = 0;\n        int money = n;\n        \n        // Buy glass bottles while we have enough money\n        while money >= b {\n            glassBottles = glassBottles + 1;\n            money = money - b + c; // Spend b, get c back\n        }\n        \n        // With remaining money, try to buy plastic bottles\n        int plasticBottles = money / a;\n        int totalLiters = glassBottles + plasticBottles;\n        \n        if totalLiters > maxLiters {\n            maxLiters = totalLiters;\n        }\n    }\n    \n    return maxLiters;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read a\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read a\");\n    }\n    int a = check 'int:fromString(line2.trim());\n    \n    // Read b\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read b\");\n    }\n    int b = check 'int:fromString(line3.trim());\n    \n    // Read c\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read c\");\n    }\n    int c = check 'int:fromString(line4.trim());\n    \n    int result = maxKefir(n, a, b, c);\n    io:println(result);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:20:56.817839",
      "status": "failed",
      "completion": "# Overview\nThis problem is about maximizing the amount of kefir Kolya can drink given his money and two purchasing options: plastic bottles (can't return) and glass bottles (can return for partial refund). We need to compare strategies:\n1. Buy only plastic bottles\n2. Buy glass bottles and keep returning them\n3. Buy glass bottles first, then switch to plastic with remaining money\n\nThe key insight is that with glass bottles, after buying the first one, subsequent bottles only cost (b-c) since we get c back. We need to find the optimal strategy that maximizes liters.\n\n<CODE>\n```ballerina\n// Reasoning:\n// We have n rubles initially\n// Plastic bottle: costs a rubles, cannot return\n// Glass bottle: costs b rubles, returns c rubles when empty (c < b)\n//\n// Strategy analysis:\n// 1. Only plastic: n / a liters\n// 2. Only glass: First bottle costs b, then each subsequent costs (b-c)\n//    - If we can afford first glass bottle (n >= b):\n//      - We drink 1 liter, get c back, now have (n - b + c)\n//      - Effective cost per additional glass bottle is (b - c)\n//      - Total glass bottles: 1 + (n - b + c) / (b - c) if (b - c) > 0\n//      - If b == c, after first bottle we can keep buying forever (but that's impossible per constraint c < b)\n// 3. Mix: Buy some glass bottles, then use remaining to buy plastic\n//\n// Edge cases:\n// - If we can't afford any bottle, return 0\n// - If b - c is very small, glass is much better\n// - Compare all strategies and take maximum\n\nimport ballerina/io;\n\nfunction maxKefir(int n, int a, int b, int c) returns int {\n    int maxLiters = 0;\n    \n    // Strategy 1: Only plastic bottles\n    int plasticOnly = n / a;\n    maxLiters = plasticOnly;\n    \n    // Strategy 2: Only glass bottles (or glass then plastic)\n    if n >= b {\n        // We can afford at least one glass bottle\n        int glassBottles = 1;\n        int remaining = n - b + c; // After buying first glass and returning it\n        \n        int costPerGlass = b - c;\n        if costPerGlass > 0 {\n            // How many more glass bottles can we buy?\n            int additionalGlass = remaining / costPerGlass;\n            glassBottles = glassBottles + additionalGlass;\n            remaining = remaining - (additionalGlass * costPerGlass);\n            \n            // With remaining money, can we buy plastic?\n            int additionalPlastic = remaining / a;\n            int totalLiters = glassBottles + additionalPlastic;\n            \n            if totalLiters > maxLiters {\n                maxLiters = totalLiters;\n            }\n        } else {\n            // This shouldn't happen as c < b, but handle it\n            maxLiters = plasticOnly;\n        }\n    }\n    \n    return maxLiters;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read a\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read a\");\n    }\n    int a = check 'int:fromString(line2.trim());\n    \n    // Read b\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read b\");\n    }\n    int b = check 'int:fromString(line3.trim());\n    \n    // Read c\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read c\");\n    }\n    int c = check 'int:fromString(line4.trim());\n    \n    int result = maxKefir(n, a, b, c);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxKefirExample1() {\n    // n=10, a=11, b=9, c=8\n    // Glass: buy 1 for 9, return for 8, have 10-9+8=9\n    // Buy another for 9, but only have 9, so we get it, return for 8\n    // We have 8 left, can't afford another glass (needs 9)\n    // Can't afford plastic (needs 11)\n    // Total: 2 liters\n    int result = maxKefir(10, 11, 9, 8);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxKefirExample2() {\n    // n=10, a=5, b=6, c=1\n    // Plastic only: 10/5 = 2 liters\n    // Glass: buy 1 for 6, return for 1, have 10-6+1=5\n    //        cost per additional glass = 6-1=5\n    //        additional glass: 5/5 = 1, so total 2 glass\n    //        remaining: 5-5=0, no plastic\n    // Both give 2 liters\n    int result = maxKefir(10, 5, 6, 1);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxKefirNoMoney() {\n    // Can't afford anything\n    int result = maxKefir(5, 10, 10, 5);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMaxKefirPlasticBetter() {\n    // When plastic is cheaper and better option\n    int result = maxKefir(100, 10, 50, 1);\n    // Plastic: 100/10 = 10\n    // Glass: 1 bottle for 50, return for 1, have 51 left\n    //        Additional: 51/49 = 1, total 2 glass\n    //        Remaining: 51-49=2, no plastic\n    // Plastic is better: 10 liters\n    test:assertEquals(result, 10);\n}\n\n@test:Config {}\nfunction testMaxKefirGlassBetter() {\n    // When glass with small difference is better\n    int result = maxKefir(100, 50, 51, 50);\n    // Plastic: 100/50 = 2\n    // Glass: 1 for 51, return for 50, have 99\n    //        cost per additional: 51-50=1\n    //        additional: 99/1 = 99, total 100 glass\n    // Glass is much better\n    test:assertEquals(result, 100);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// We have n rubles initially\n// Plastic bottle: costs a rubles, cannot return\n// Glass bottle: costs b rubles, returns c rubles when empty (c < b)\n//\n// Strategy analysis:\n// 1. Only plastic: n / a liters\n// 2. Only glass: First bottle costs b, then each subsequent costs (b-c)\n//    - If we can afford first glass bottle (n >= b):\n//      - We drink 1 liter, get c back, now have (n - b + c)\n//      - Effective cost per additional glass bottle is (b - c)\n//      - Total glass bottles: 1 + (n - b + c) / (b - c) if (b - c) > 0\n//      - If b == c, after first bottle we can keep buying forever (but that's impossible per constraint c < b)\n// 3. Mix: Buy some glass bottles, then use remaining to buy plastic\n//\n// Edge cases:\n// - If we can't afford any bottle, return 0\n// - If b - c is very small, glass is much better\n// - Compare all strategies and take maximum\n\nimport ballerina/io;\n\nfunction maxKefir(int n, int a, int b, int c) returns int {\n    int maxLiters = 0;\n    \n    // Strategy 1: Only plastic bottles\n    int plasticOnly = n / a;\n    maxLiters = plasticOnly;\n    \n    // Strategy 2: Only glass bottles (or glass then plastic)\n    if n >= b {\n        // We can afford at least one glass bottle\n        int glassBottles = 1;\n        int remaining = n - b + c; // After buying first glass and returning it\n        \n        int costPerGlass = b - c;\n        if costPerGlass > 0 {\n            // How many more glass bottles can we buy?\n            int additionalGlass = remaining / costPerGlass;\n            glassBottles = glassBottles + additionalGlass;\n            remaining = remaining - (additionalGlass * costPerGlass);\n            \n            // With remaining money, can we buy plastic?\n            int additionalPlastic = remaining / a;\n            int totalLiters = glassBottles + additionalPlastic;\n            \n            if totalLiters > maxLiters {\n                maxLiters = totalLiters;\n            }\n        } else {\n            // This shouldn't happen as c < b, but handle it\n            maxLiters = plasticOnly;\n        }\n    }\n    \n    return maxLiters;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read a\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read a\");\n    }\n    int a = check 'int:fromString(line2.trim());\n    \n    // Read b\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read b\");\n    }\n    int b = check 'int:fromString(line3.trim());\n    \n    // Read c\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read c\");\n    }\n    int c = check 'int:fromString(line4.trim());\n    \n    int result = maxKefir(n, a, b, c);\n    io:println(result);\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "10\n11\n9\n8\n",
          "expected_output": "2\n",
          "actual_output": "10\n",
          "error": "Output mismatch"
        }
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:21:37.097617",
      "status": "success",
      "completion": "Looking at the failing test case, I need to analyze the problem more carefully.\n\n**Test Input:**\n- n=10, a=11, b=9, c=8\n- Expected: 2\n- My output: 10\n\nThe issue is clear: when I calculate `remaining / costPerGlass`, I'm getting `9 / 1 = 9`, giving me 10 total glass bottles. But this is wrong!\n\n**The key insight I missed:** After buying the first glass bottle and returning it, I have `n - b + c = 10 - 9 + 8 = 9` rubles. To buy the next glass bottle, I need `b = 9` rubles. After buying it and returning it, I get `c = 8` back. But now I only have 8 rubles, which is NOT enough to buy another glass bottle (needs 9).\n\n**The correct logic:** After the first glass bottle, I can keep buying glass bottles as long as I have at least `b` rubles (not `b - c`). Each cycle: spend `b`, get `c` back, net cost is `b - c`.\n\nLet me trace through correctly:\n- Start: 10 rubles\n- Buy glass: 10 - 9 = 1 ruble, drink 1 liter\n- Return glass: 1 + 8 = 9 rubles\n- Buy glass: 9 - 9 = 0 rubles, drink 1 liter (total 2)\n- Return glass: 0 + 8 = 8 rubles\n- Can't buy glass (need 9) or plastic (need 11)\n- Total: 2 liters ✓\n\n**The fix:** After buying the first glass bottle, I need to check if `remaining >= b` to buy more, not just divide by `(b-c)`.\n\n# Overview\nThis problem requires finding the maximum kefir that can be purchased with two options: plastic bottles (cost `a`, no return) and glass bottles (cost `b`, return for `c`). The key is that glass bottles can be reused: buy for `b`, return for `c`, effective cost `b-c` per cycle. We compare: (1) only plastic, (2) glass bottles repeatedly, (3) glass then switch to plastic.\n\n<CODE>\n```ballerina\n// Reasoning:\n// We need to maximize liters of kefir with n rubles\n// Option 1: Plastic bottles cost 'a', cannot return\n// Option 2: Glass bottles cost 'b', return for 'c' (c < b)\n//\n// Key insight for glass bottles:\n// - First glass bottle: costs b, after drinking return for c, net spent = b-c\n// - Subsequent bottles: need b rubles to buy, get c back, net cost = b-c per liter\n// - BUT: we need to have at least b rubles to buy the next bottle!\n//\n// Strategy comparison:\n// 1. Only plastic: n / a liters\n// 2. Glass bottles: \n//    - If n >= b, buy first glass\n//    - After first: have (n - b + c) rubles\n//    - Keep buying while we have >= b rubles\n//    - Each purchase costs b, returns c\n// 3. Glass then plastic: after glass purchases, use remaining for plastic\n//\n// Important: When buying glass repeatedly, we need >= b to buy next bottle,\n// not just b-c. The b-c is the net cost, but we need b upfront.\n\nimport ballerina/io;\n\nfunction maxKefir(int n, int a, int b, int c) returns int {\n    int maxLiters = 0;\n    \n    // Strategy 1: Only plastic bottles\n    int plasticOnly = n / a;\n    maxLiters = plasticOnly;\n    \n    // Strategy 2 & 3: Glass bottles (possibly followed by plastic)\n    if n >= b {\n        int glassBottles = 0;\n        int money = n;\n        \n        // Buy glass bottles while we have enough money\n        while money >= b {\n            glassBottles = glassBottles + 1;\n            money = money - b + c; // Spend b, get c back\n        }\n        \n        // With remaining money, try to buy plastic bottles\n        int plasticBottles = money / a;\n        int totalLiters = glassBottles + plasticBottles;\n        \n        if totalLiters > maxLiters {\n            maxLiters = totalLiters;\n        }\n    }\n    \n    return maxLiters;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read a\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read a\");\n    }\n    int a = check 'int:fromString(line2.trim());\n    \n    // Read b\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read b\");\n    }\n    int b = check 'int:fromString(line3.trim());\n    \n    // Read c\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read c\");\n    }\n    int c = check 'int:fromString(line4.trim());\n    \n    int result = maxKefir(n, a, b, c);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxKefirExample1() {\n    // n=10, a=11, b=9, c=8\n    // Glass strategy: \n    //   Buy 1st: 10-9=1, return: 1+8=9, bottles=1\n    //   Buy 2nd: 9-9=0, return: 0+8=8, bottles=2\n    //   Can't buy 3rd (need 9, have 8)\n    // Plastic: can't afford (need 11)\n    // Total: 2 liters\n    int result = maxKefir(10, 11, 9, 8);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxKefirExample2() {\n    // n=10, a=5, b=6, c=1\n    // Plastic: 10/5 = 2 liters\n    // Glass: \n    //   Buy 1st: 10-6=4, return: 4+1=5, bottles=1\n    //   Buy 2nd: 5-6=-1, can't afford\n    //   Remaining 5, plastic: 5/5=1\n    //   Total: 1+1=2\n    // Both strategies give 2\n    int result = maxKefir(10, 5, 6, 1);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxKefirNoMoney() {\n    // Can't afford anything\n    int result = maxKefir(5, 10, 10, 5);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testMaxKefirPlasticBetter() {\n    // When plastic is cheaper\n    int result = maxKefir(100, 10, 50, 1);\n    // Plastic: 100/10 = 10\n    // Glass: buy 1 for 50, return for 1, have 51\n    //        buy 2nd for 50, can't (need 50, have 51-50=1 after, wait we have 51)\n    //        buy 2nd: 51-50=1, return: 1+1=2\n    //        can't buy 3rd (need 50, have 2)\n    //        plastic with 2: 2/10=0\n    //        total: 2\n    // Plastic wins: 10\n    test:assertEquals(result, 10);\n}\n\n@test:Config {}\nfunction testMaxKefirGlassBetter() {\n    // When glass has very good return rate\n    int result = maxKefir(100, 50, 51, 50);\n    // Plastic: 100/50 = 2\n    // Glass: buy for 51, return for 50\n    //        1st: 100-51=49, return: 49+50=99\n    //        2nd: 99-51=48, return: 48+50=98\n    //        ...continues while >= 51\n    //        Net cost per bottle after first: 51-50=1\n    //        Total glass: (100-51)/1 + 1 = 49+1 = 50\n    //        Actually: money=100, buy 1: money=49+50=99\n    //                  buy 2: 99-51+50=98, buy 3: 98-51+50=97...\n    //        Pattern: 100,99,98,...,51,50 (can't buy at 50)\n    //        Count: 100-50 = 50 bottles\n    test:assertEquals(result, 50);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// We need to maximize liters of kefir with n rubles\n// Option 1: Plastic bottles cost 'a', cannot return\n// Option 2: Glass bottles cost 'b', return for 'c' (c < b)\n//\n// Key insight for glass bottles:\n// - First glass bottle: costs b, after drinking return for c, net spent = b-c\n// - Subsequent bottles: need b rubles to buy, get c back, net cost = b-c per liter\n// - BUT: we need to have at least b rubles to buy the next bottle!\n//\n// Strategy comparison:\n// 1. Only plastic: n / a liters\n// 2. Glass bottles: \n//    - If n >= b, buy first glass\n//    - After first: have (n - b + c) rubles\n//    - Keep buying while we have >= b rubles\n//    - Each purchase costs b, returns c\n// 3. Glass then plastic: after glass purchases, use remaining for plastic\n//\n// Important: When buying glass repeatedly, we need >= b to buy next bottle,\n// not just b-c. The b-c is the net cost, but we need b upfront.\n\nimport ballerina/io;\n\nfunction maxKefir(int n, int a, int b, int c) returns int {\n    int maxLiters = 0;\n    \n    // Strategy 1: Only plastic bottles\n    int plasticOnly = n / a;\n    maxLiters = plasticOnly;\n    \n    // Strategy 2 & 3: Glass bottles (possibly followed by plastic)\n    if n >= b {\n        int glassBottles = 0;\n        int money = n;\n        \n        // Buy glass bottles while we have enough money\n        while money >= b {\n            glassBottles = glassBottles + 1;\n            money = money - b + c; // Spend b, get c back\n        }\n        \n        // With remaining money, try to buy plastic bottles\n        int plasticBottles = money / a;\n        int totalLiters = glassBottles + plasticBottles;\n        \n        if totalLiters > maxLiters {\n            maxLiters = totalLiters;\n        }\n    }\n    \n    return maxLiters;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read n\");\n    }\n    int n = check 'int:fromString(line1.trim());\n    \n    // Read a\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read a\");\n    }\n    int a = check 'int:fromString(line2.trim());\n    \n    // Read b\n    string? line3 = io:readln();\n    if line3 is () {\n        return error(\"Failed to read b\");\n    }\n    int b = check 'int:fromString(line3.trim());\n    \n    // Read c\n    string? line4 = io:readln();\n    if line4 is () {\n        return error(\"Failed to read c\");\n    }\n    int c = check 'int:fromString(line4.trim());\n    \n    int result = maxKefir(n, a, b, c);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:22:53.865507"
}