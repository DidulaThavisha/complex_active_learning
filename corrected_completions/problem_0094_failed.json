{
  "entry_id": "problem_0094",
  "problem_index": 94,
  "prompt": "Title: Lazy Student\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nStudent Vladislav came to his programming exam completely unprepared as usual. He got a question about some strange algorithm on a graph — something that will definitely never be useful in real life. He asked a girl sitting next to him to lend him some cheat papers for this questions and found there the following definition:\n\nThe minimum spanning tree *T* of graph *G* is such a tree that it contains all the vertices of the original graph *G*, and the sum of the weights of its edges is the minimum possible among all such trees.\n\nVladislav drew a graph with *n* vertices and *m* edges containing no loops and multiple edges. He found one of its minimum spanning trees and then wrote for each edge its weight and whether it is included in the found tree or not. Unfortunately, the piece of paper where the graph was painted is gone and the teacher is getting very angry and demands to see the original graph. Help Vladislav come up with a graph so that the information about the minimum spanning tree remains correct.\n\nInput Specification:\nThe first line of the input contains two integers *n* and *m* () — the number of vertices and the number of edges in the graph.\n\nEach of the next *m* lines describes an edge of the graph and consists of two integers *a**j* and *b**j* (1<=≤<=*a**j*<=≤<=109,<=*b**j*<==<={0,<=1}). The first of these numbers is the weight of the edge and the second number is equal to 1 if this edge was included in the minimum spanning tree found by Vladislav, or 0 if it was not.\n\nIt is guaranteed that exactly *n*<=-<=1 number {*b**j*} are equal to one and exactly *m*<=-<=*n*<=+<=1 of them are equal to zero.\n\nOutput Specification:\nIf Vladislav has made a mistake and such graph doesn't exist, print <=-<=1.\n\nOtherwise print *m* lines. On the *j*-th line print a pair of vertices (*u**j*,<=*v**j*) (1<=≤<=*u**j*,<=*v**j*<=≤<=*n*,<=*u**j*<=≠<=*v**j*), that should be connected by the *j*-th edge. The edges are numbered in the same order as in the input. The graph, determined by these edges, must be connected, contain no loops or multiple edges and its edges with *b**j*<==<=1 must define the minimum spanning tree. In case there are multiple possible solutions, print any of them.\n\nDemo Input:\n['4 5\\n2 1\\n3 1\\n4 0\\n1 1\\n5 0\\n', '3 3\\n1 0\\n2 1\\n3 1\\n']\n\nDemo Output:\n['2 4\\n1 4\\n3 4\\n3 1\\n3 2\\n', '-1\\n']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:37:34.353406",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to reconstruct a graph given information about edge weights and whether each edge is part of a Minimum Spanning Tree (MST). The key insight is that:\n1. MST edges (b=1) must have n-1 edges connecting all vertices\n2. Non-MST edges (b=0) must have weight >= any MST edge they would replace\n3. We need to assign vertices to edges such that MST edges form a spanning tree\n\nThe algorithm:\n- First, collect MST edges and non-MST edges separately\n- Build a tree using MST edges by assigning vertices sequentially\n- For non-MST edges, they must connect vertices already in the tree, and their weight must be >= the maximum weight MST edge (otherwise they would be in the MST)\n- Validate that non-MST edges don't violate MST property\n\n<CODE>\n```ballerina\n// Problem: Reconstruct a graph from MST information\n// Approach:\n// 1. Read n vertices and m edges\n// 2. Separate edges into MST edges (b=1) and non-MST edges (b=0)\n// 3. Build spanning tree with MST edges - assign vertices sequentially\n// 4. For non-MST edges, connect already-connected vertices\n// 5. Validate: non-MST edge weight should be >= max MST edge weight on path it would create\n\nimport ballerina/io;\n\ntype Edge record {\n    int weight;\n    int inMST;\n    int index;\n};\n\n// Function to solve the lazy student problem\nfunction solveLazyStudent(int n, Edge[] edges) returns string[]|int {\n    // Separate MST and non-MST edges\n    Edge[] mstEdges = [];\n    Edge[] nonMstEdges = [];\n    \n    foreach Edge e in edges {\n        if e.inMST == 1 {\n            mstEdges.push(e);\n        } else {\n            nonMstEdges.push(e);\n        }\n    }\n    \n    // Validate: must have exactly n-1 MST edges\n    if mstEdges.length() != n - 1 {\n        return -1;\n    }\n    \n    // If only 1 vertex, check if there are no edges\n    if n == 1 {\n        if edges.length() == 0 {\n            return [];\n        }\n        return -1;\n    }\n    \n    // Build result array\n    string[] result = [];\n    foreach int i in 0 ..< edges.length() {\n        result.push(\"\");\n    }\n    \n    // Assign vertices to MST edges to form a tree\n    // Strategy: chain vertices 1->2->3->...->n\n    int nextVertex = 1;\n    foreach int i in 0 ..< mstEdges.length() {\n        Edge e = mstEdges[i];\n        int u = nextVertex;\n        int v = nextVertex + 1;\n        nextVertex = nextVertex + 1;\n        result[e.index] = u.toString() + \" \" + v.toString();\n    }\n    \n    // Find max MST edge weight\n    int maxMstWeight = 0;\n    if mstEdges.length() > 0 {\n        maxMstWeight = mstEdges[0].weight;\n        foreach Edge e in mstEdges {\n            if e.weight > maxMstWeight {\n                maxMstWeight = e.weight;\n            }\n        }\n    }\n    \n    // Assign non-MST edges\n    // They should connect vertices already in tree\n    // and have weight >= max MST weight to justify not being in MST\n    foreach Edge e in nonMstEdges {\n        // Connect vertices that would create a cycle (any two vertices in the tree)\n        // Use vertices 1 and n (endpoints of the chain)\n        if e.weight < maxMstWeight {\n            return -1;\n        }\n        result[e.index] = \"1 \" + n.toString();\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error m = 'int:fromString(parts[1]);\n    \n    if n is error || m is error {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read m edges\n    Edge[] edges = [];\n    foreach int i in 0 ..< m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        string[] edgeParts = edgeLine.trim().split(\" \");\n        if edgeParts.length() != 2 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int|error weight = 'int:fromString(edgeParts[0]);\n        int|error inMST = 'int:fromString(edgeParts[1]);\n        \n        if weight is error || inMST is error {\n            io:println(\"-1\");\n            return;\n        }\n        \n        if inMST != 0 && inMST != 1 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        edges.push({weight: weight, inMST: inMST, index: i});\n    }\n    \n    // Solve\n    string[]|int result = solveLazyStudent(n, edges);\n    \n    if result is int {\n        io:println(\"-1\");\n    } else {\n        foreach string line in result {\n            io:println(line);\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBasicCase() {\n    Edge[] edges = [\n        {weight: 2, inMST: 1, index: 0},\n        {weight: 3, inMST: 1, index: 1},\n        {weight: 4, inMST: 0, index: 2},\n        {weight: 1, inMST: 1, index: 3},\n        {weight: 5, inMST: 0, index: 4}\n    ];\n    \n    string[]|int result = solveLazyStudent(4, edges);\n    test:assertTrue(result is string[]);\n    if result is string[] {\n        test:assertEquals(result.length(), 5);\n    }\n}\n\n@test:Config {}\nfunction testInvalidMSTEdgeCount() {\n    // 3 vertices but only 1 MST edge (should be 2)\n    Edge[] edges = [\n        {weight: 1, inMST: 0, index: 0},\n        {weight: 2, inMST: 1, index: 1},\n        {weight: 3, inMST: 1, index: 2}\n    ];\n    \n    string[]|int result = solveLazyStudent(3, edges);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testNonMSTEdgeTooLight() {\n    // Non-MST edge with weight less than MST edge should fail\n    Edge[] edges = [\n        {weight: 5, inMST: 1, index: 0},\n        {weight: 6, inMST: 1, index: 1},\n        {weight: 3, inMST: 0, index: 2}  // This is lighter than MST edges\n    ];\n    \n    string[]|int result = solveLazyStudent(3, edges);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testSingleVertex() {\n    Edge[] edges = [];\n    string[]|int result = solveLazyStudent(1, edges);\n    test:assertTrue(result is string[]);\n    if result is string[] {\n        test:assertEquals(result.length(), 0);\n    }\n}\n\n@test:Config {}\nfunction testTwoVertices() {\n    Edge[] edges = [\n        {weight: 10, inMST: 1, index: 0}\n    ];\n    \n    string[]|int result = solveLazyStudent(2, edges);\n    test:assertTrue(result is string[]);\n    if result is string[] {\n        test:assertEquals(result.length(), 1);\n    }\n}\n```\n</TESTS>",
      "code": "// Problem: Reconstruct a graph from MST information\n// Approach:\n// 1. Read n vertices and m edges\n// 2. Separate edges into MST edges (b=1) and non-MST edges (b=0)\n// 3. Build spanning tree with MST edges - assign vertices sequentially\n// 4. For non-MST edges, connect already-connected vertices\n// 5. Validate: non-MST edge weight should be >= max MST edge weight on path it would create\n\nimport ballerina/io;\n\ntype Edge record {\n    int weight;\n    int inMST;\n    int index;\n};\n\n// Function to solve the lazy student problem\nfunction solveLazyStudent(int n, Edge[] edges) returns string[]|int {\n    // Separate MST and non-MST edges\n    Edge[] mstEdges = [];\n    Edge[] nonMstEdges = [];\n    \n    foreach Edge e in edges {\n        if e.inMST == 1 {\n            mstEdges.push(e);\n        } else {\n            nonMstEdges.push(e);\n        }\n    }\n    \n    // Validate: must have exactly n-1 MST edges\n    if mstEdges.length() != n - 1 {\n        return -1;\n    }\n    \n    // If only 1 vertex, check if there are no edges\n    if n == 1 {\n        if edges.length() == 0 {\n            return [];\n        }\n        return -1;\n    }\n    \n    // Build result array\n    string[] result = [];\n    foreach int i in 0 ..< edges.length() {\n        result.push(\"\");\n    }\n    \n    // Assign vertices to MST edges to form a tree\n    // Strategy: chain vertices 1->2->3->...->n\n    int nextVertex = 1;\n    foreach int i in 0 ..< mstEdges.length() {\n        Edge e = mstEdges[i];\n        int u = nextVertex;\n        int v = nextVertex + 1;\n        nextVertex = nextVertex + 1;\n        result[e.index] = u.toString() + \" \" + v.toString();\n    }\n    \n    // Find max MST edge weight\n    int maxMstWeight = 0;\n    if mstEdges.length() > 0 {\n        maxMstWeight = mstEdges[0].weight;\n        foreach Edge e in mstEdges {\n            if e.weight > maxMstWeight {\n                maxMstWeight = e.weight;\n            }\n        }\n    }\n    \n    // Assign non-MST edges\n    // They should connect vertices already in tree\n    // and have weight >= max MST weight to justify not being in MST\n    foreach Edge e in nonMstEdges {\n        // Connect vertices that would create a cycle (any two vertices in the tree)\n        // Use vertices 1 and n (endpoints of the chain)\n        if e.weight < maxMstWeight {\n            return -1;\n        }\n        result[e.index] = \"1 \" + n.toString();\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error m = 'int:fromString(parts[1]);\n    \n    if n is error || m is error {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read m edges\n    Edge[] edges = [];\n    foreach int i in 0 ..< m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        string[] edgeParts = edgeLine.trim().split(\" \");\n        if edgeParts.length() != 2 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int|error weight = 'int:fromString(edgeParts[0]);\n        int|error inMST = 'int:fromString(edgeParts[1]);\n        \n        if weight is error || inMST is error {\n            io:println(\"-1\");\n            return;\n        }\n        \n        if inMST != 0 && inMST != 1 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        edges.push({weight: weight, inMST: inMST, index: i});\n    }\n    \n    // Solve\n    string[]|int result = solveLazyStudent(n, edges);\n    \n    if result is int {\n        io:println(\"-1\");\n    } else {\n        foreach string line in result {\n            io:println(line);\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(94:35,94:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:46,117:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(94:35,94:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:46,117:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(94:35,94:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(117:46,117:51)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:38:08.463734",
      "status": "failed",
      "completion": "Looking at the compilation errors, the issue is that I'm using `.split()` method which doesn't exist in Ballerina. I need to use the `regex:split()` function from the `ballerina/regex` module instead.\n\nLet me also reconsider the algorithm:\n1. MST edges form a spanning tree (n-1 edges for n vertices)\n2. Non-MST edges can't have weight less than the maximum MST edge weight that they would compete with\n3. Need to construct actual graph edges (vertex pairs) that satisfy MST properties\n\n# Overview\nThis problem requires reconstructing a graph from MST edge information. Key insights:\n- MST edges (b=1) must form a connected spanning tree with n-1 edges\n- Non-MST edges (b=0) must have weights >= maximum MST edge weight (otherwise they'd be in MST)\n- Build the tree by chaining vertices, then add non-MST edges that create cycles\n\nThe solution:\n1. Parse input and separate MST/non-MST edges\n2. Validate we have exactly n-1 MST edges\n3. Build a chain tree: 1-2-3-...-n using MST edges\n4. For non-MST edges, connect endpoints (creates cycle) and validate weight >= max MST weight\n\n<CODE>\n```ballerina\n// Reasoning:\n// - MST of n vertices has exactly n-1 edges forming a spanning tree\n// - Non-MST edges must not violate MST property (weight should be >= competing MST edges)\n// - Strategy: Build chain tree 1-2-3-...-n with MST edges, add non-MST edges between endpoints\n// - Validation: non-MST edge weight must be >= max MST edge weight\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Edge record {\n    int weight;\n    int inMST;\n    int index;\n};\n\n// Function to solve the lazy student problem\nfunction solveLazyStudent(int n, Edge[] edges) returns string[]|int {\n    // Separate MST and non-MST edges\n    Edge[] mstEdges = [];\n    Edge[] nonMstEdges = [];\n    \n    foreach Edge e in edges {\n        if e.inMST == 1 {\n            mstEdges.push(e);\n        } else {\n            nonMstEdges.push(e);\n        }\n    }\n    \n    // Validate: must have exactly n-1 MST edges\n    if mstEdges.length() != n - 1 {\n        return -1;\n    }\n    \n    // Special case: single vertex with no edges\n    if n == 1 {\n        if edges.length() == 0 {\n            return [];\n        }\n        return -1;\n    }\n    \n    // Build result array\n    string[] result = [];\n    foreach int i in 0 ..< edges.length() {\n        result.push(\"\");\n    }\n    \n    // Assign vertices to MST edges to form a chain tree: 1-2, 2-3, 3-4, ..., (n-1)-n\n    int nextVertex = 1;\n    foreach int i in 0 ..< mstEdges.length() {\n        Edge e = mstEdges[i];\n        int u = nextVertex;\n        int v = nextVertex + 1;\n        nextVertex = nextVertex + 1;\n        result[e.index] = u.toString() + \" \" + v.toString();\n    }\n    \n    // Find max MST edge weight\n    int maxMstWeight = 0;\n    if mstEdges.length() > 0 {\n        maxMstWeight = mstEdges[0].weight;\n        foreach Edge e in mstEdges {\n            if e.weight > maxMstWeight {\n                maxMstWeight = e.weight;\n            }\n        }\n    }\n    \n    // Assign non-MST edges\n    // Connect vertices 1 and n (creates a cycle in the chain)\n    // Weight must be >= maxMstWeight to justify not being in MST\n    foreach Edge e in nonMstEdges {\n        if e.weight < maxMstWeight {\n            return -1;\n        }\n        result[e.index] = \"1 \" + n.toString();\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error m = 'int:fromString(parts[1]);\n    \n    if n is error || m is error {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read m edges\n    Edge[] edges = [];\n    foreach int i in 0 ..< m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        string[] edgeParts = regex:split(edgeLine.trim(), \" \");\n        if edgeParts.length() != 2 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int|error weight = 'int:fromString(edgeParts[0]);\n        int|error inMST = 'int:fromString(edgeParts[1]);\n        \n        if weight is error || inMST is error {\n            io:println(\"-1\");\n            return;\n        }\n        \n        if inMST != 0 && inMST != 1 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        edges.push({weight: weight, inMST: inMST, index: i});\n    }\n    \n    // Solve\n    string[]|int result = solveLazyStudent(n, edges);\n    \n    if result is int {\n        io:println(\"-1\");\n    } else {\n        foreach string line in result {\n            io:println(line);\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBasicCase() {\n    Edge[] edges = [\n        {weight: 2, inMST: 1, index: 0},\n        {weight: 3, inMST: 1, index: 1},\n        {weight: 4, inMST: 0, index: 2},\n        {weight: 1, inMST: 1, index: 3},\n        {weight: 5, inMST: 0, index: 4}\n    ];\n    \n    string[]|int result = solveLazyStudent(4, edges);\n    test:assertTrue(result is string[]);\n    if result is string[] {\n        test:assertEquals(result.length(), 5);\n    }\n}\n\n@test:Config {}\nfunction testInvalidMSTEdgeCount() {\n    // 3 vertices but only 1 MST edge (should be 2)\n    Edge[] edges = [\n        {weight: 1, inMST: 0, index: 0},\n        {weight: 2, inMST: 1, index: 1},\n        {weight: 3, inMST: 1, index: 2}\n    ];\n    \n    string[]|int result = solveLazyStudent(4, edges);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testNonMSTEdgeTooLight() {\n    // Non-MST edge with weight less than MST edge should fail\n    Edge[] edges = [\n        {weight: 5, inMST: 1, index: 0},\n        {weight: 6, inMST: 1, index: 1},\n        {weight: 3, inMST: 0, index: 2}\n    ];\n    \n    string[]|int result = solveLazyStudent(3, edges);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testSingleVertex() {\n    Edge[] edges = [];\n    string[]|int result = solveLazyStudent(1, edges);\n    test:assertTrue(result is string[]);\n    if result is string[] {\n        test:assertEquals(result.length(), 0);\n    }\n}\n\n@test:Config {}\nfunction testTwoVertices() {\n    Edge[] edges = [\n        {weight: 10, inMST: 1, index: 0}\n    ];\n    \n    string[]|int result = solveLazyStudent(2, edges);\n    test:assertTrue(result is string[]);\n    if result is string[] {\n        test:assertEquals(result.length(), 1);\n    }\n}\n\n@test:Config {}\nfunction testValidNonMSTEdges() {\n    // Non-MST edges with weight >= max MST weight should succeed\n    Edge[] edges = [\n        {weight: 2, inMST: 1, index: 0},\n        {weight: 3, inMST: 1, index: 1},\n        {weight: 5, inMST: 0, index: 2}\n    ];\n    \n    string[]|int result = solveLazyStudent(3, edges);\n    test:assertTrue(result is string[]);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// - MST of n vertices has exactly n-1 edges forming a spanning tree\n// - Non-MST edges must not violate MST property (weight should be >= competing MST edges)\n// - Strategy: Build chain tree 1-2-3-...-n with MST edges, add non-MST edges between endpoints\n// - Validation: non-MST edge weight must be >= max MST edge weight\n\nimport ballerina/io;\nimport ballerina/regex;\n\ntype Edge record {\n    int weight;\n    int inMST;\n    int index;\n};\n\n// Function to solve the lazy student problem\nfunction solveLazyStudent(int n, Edge[] edges) returns string[]|int {\n    // Separate MST and non-MST edges\n    Edge[] mstEdges = [];\n    Edge[] nonMstEdges = [];\n    \n    foreach Edge e in edges {\n        if e.inMST == 1 {\n            mstEdges.push(e);\n        } else {\n            nonMstEdges.push(e);\n        }\n    }\n    \n    // Validate: must have exactly n-1 MST edges\n    if mstEdges.length() != n - 1 {\n        return -1;\n    }\n    \n    // Special case: single vertex with no edges\n    if n == 1 {\n        if edges.length() == 0 {\n            return [];\n        }\n        return -1;\n    }\n    \n    // Build result array\n    string[] result = [];\n    foreach int i in 0 ..< edges.length() {\n        result.push(\"\");\n    }\n    \n    // Assign vertices to MST edges to form a chain tree: 1-2, 2-3, 3-4, ..., (n-1)-n\n    int nextVertex = 1;\n    foreach int i in 0 ..< mstEdges.length() {\n        Edge e = mstEdges[i];\n        int u = nextVertex;\n        int v = nextVertex + 1;\n        nextVertex = nextVertex + 1;\n        result[e.index] = u.toString() + \" \" + v.toString();\n    }\n    \n    // Find max MST edge weight\n    int maxMstWeight = 0;\n    if mstEdges.length() > 0 {\n        maxMstWeight = mstEdges[0].weight;\n        foreach Edge e in mstEdges {\n            if e.weight > maxMstWeight {\n                maxMstWeight = e.weight;\n            }\n        }\n    }\n    \n    // Assign non-MST edges\n    // Connect vertices 1 and n (creates a cycle in the chain)\n    // Weight must be >= maxMstWeight to justify not being in MST\n    foreach Edge e in nonMstEdges {\n        if e.weight < maxMstWeight {\n            return -1;\n        }\n        result[e.index] = \"1 \" + n.toString();\n    }\n    \n    return result;\n}\n\npublic function main() returns error? {\n    // Read n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        io:println(\"-1\");\n        return;\n    }\n    \n    int|error n = 'int:fromString(parts[0]);\n    int|error m = 'int:fromString(parts[1]);\n    \n    if n is error || m is error {\n        io:println(\"-1\");\n        return;\n    }\n    \n    // Read m edges\n    Edge[] edges = [];\n    foreach int i in 0 ..< m {\n        string? edgeLine = io:readln();\n        if edgeLine is () {\n            io:println(\"-1\");\n            return;\n        }\n        \n        string[] edgeParts = regex:split(edgeLine.trim(), \" \");\n        if edgeParts.length() != 2 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        int|error weight = 'int:fromString(edgeParts[0]);\n        int|error inMST = 'int:fromString(edgeParts[1]);\n        \n        if weight is error || inMST is error {\n            io:println(\"-1\");\n            return;\n        }\n        \n        if inMST != 0 && inMST != 1 {\n            io:println(\"-1\");\n            return;\n        }\n        \n        edges.push({weight: weight, inMST: inMST, index: i});\n    }\n    \n    // Solve\n    string[]|int result = solveLazyStudent(n, edges);\n    \n    if result is int {\n        io:println(\"-1\");\n    } else {\n        foreach string line in result {\n            io:println(line);\n        }\n    }\n}",
      "tests_passed": 1,
      "tests_total": 2,
      "tests_pass_rate": 0.5,
      "validation_msg": "Only passed 1/2 tests (50.0%), need 75%",
      "error": "Only passed 1/2 tests (50.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4 5\n2 1\n3 1\n4 0\n1 1\n5 0\n",
          "expected_output": "2 4\n1 4\n3 4\n3 1\n3 2\n",
          "actual_output": "1 2\n2 3\n1 4\n3 4\n1 4\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 1/2 tests (50.0%), need 75%",
  "timestamp": "2026-01-05T01:38:46.357706"
}