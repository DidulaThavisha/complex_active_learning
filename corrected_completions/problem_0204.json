{
  "entry_id": "problem_0204",
  "problem_index": 204,
  "prompt": "Title: Geometric Progression\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nPolycarp loves geometric progressions very much. Since he was only three years old, he loves only the progressions of length three. He also has a favorite integer *k* and a sequence *a*, consisting of *n* integers.\n\nHe wants to know how many subsequences of length three can be selected from *a*, so that they form a geometric progression with common ratio *k*.\n\nA subsequence of length three is a combination of three such indexes *i*1,<=*i*2,<=*i*3, that 1<=≤<=*i*1<=&lt;<=*i*2<=&lt;<=*i*3<=≤<=*n*. That is, a subsequence of length three are such groups of three elements that are not necessarily consecutive in the sequence, but their indexes are strictly increasing.\n\nA geometric progression with common ratio *k* is a sequence of numbers of the form *b*·*k*0,<=*b*·*k*1,<=...,<=*b*·*k**r*<=-<=1.\n\nPolycarp is only three years old, so he can not calculate this number himself. Help him to do it.\n\nInput Specification:\nThe first line of the input contains two integers, *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=2·105), showing how many numbers Polycarp's sequence has and his favorite number.\n\nThe second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109) — elements of the sequence.\n\nOutput Specification:\nOutput a single number — the number of ways to choose a subsequence of length three, such that it forms a geometric progression with a common ratio *k*.\n\nDemo Input:\n['5 2\\n1 1 2 2 4\\n', '3 1\\n1 1 1\\n', '10 3\\n1 2 6 2 3 6 9 18 3 9\\n']\n\nDemo Output:\n['4', '1', '6']\n\nNote:\nIn the first sample test the answer is four, as any of the two 1s can be chosen as the first element, the second element can be any of the 2s, and the third element of the subsequence must be equal to 4.",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\n\nThis problem asks us to count subsequences of length 3 that form a geometric progression with ratio k. For three elements at indices i1 < i2 < i3 to form a geometric progression with ratio k, we need: a[i2] = a[i1] * k and a[i3] = a[i2] * k.\n\nThe approach:\n1. For each element at index i (middle element), count how many elements before it can be the first element (a[j] = a[i]/k where j < i)\n2. Count how many elements after it can be the third element (a[m] = a[i]*k where m > i)\n3. Multiply these two counts to get the number of valid triplets with a[i] as the middle element\n4. Sum across all possible middle elements\n\nWe'll use maps to track counts of elements before and after each position to make the solution efficient.\n\n<CODE>\n```ballerina\n// Reasoning:\n// For a geometric progression with ratio k: first, first*k, first*k*k\n// Or equivalently: middle/k, middle, middle*k\n// \n// Strategy:\n// 1. For each position i (as the middle element):\n//    - Count how many elements before i equal a[i]/k (can be first element)\n//    - Count how many elements after i equal a[i]*k (can be third element)\n//    - Multiply these counts and add to total\n// 2. Use maps to track frequency of elements before and after each position\n// 3. Handle edge case when k=0 or k=1 carefully\n// 4. Check divisibility when computing a[i]/k to avoid floating point issues\n// \n// Fix: Use regex:split() from ballerina/lang.regexp module instead of string.split()\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\nfunction countGeometricProgressions(int n, int k, int[] a) returns int {\n    int totalCount = 0;\n    \n    // Special case: k = 1 means all three elements must be equal\n    if k == 1 {\n        // For each position i (middle element)\n        map<int> countBefore = {};\n        map<int> countAfter = {};\n        \n        // Initially, all elements are \"after\"\n        foreach int val in a {\n            string key = val.toString();\n            countAfter[key] = (countAfter[key] ?: 0) + 1;\n        }\n        \n        foreach int i in 0 ..< n {\n            int middle = a[i];\n            string middleKey = middle.toString();\n            \n            // Remove current element from \"after\" count\n            countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n            \n            // For k=1, we need all three to be equal\n            int beforeCount = countBefore[middleKey] ?: 0;\n            int afterCount = countAfter[middleKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n            \n            // Add current element to \"before\" count\n            countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n        }\n        \n        return totalCount;\n    }\n    \n    // For k = 0, we need: a[i1] (any), a[i2] = 0, a[i3] = 0\n    if k == 0 {\n        int countZeros = 0;\n        foreach int val in a {\n            if val == 0 {\n                countZeros += 1;\n            }\n        }\n        \n        // We need at least 2 zeros for a[i2] and a[i3]\n        if countZeros < 2 {\n            return 0;\n        }\n        \n        // For each non-zero or zero element before, count pairs of zeros after\n        int elementsBefore = 0;\n        int zerosRemaining = countZeros;\n        \n        foreach int i in 0 ..< n {\n            if a[i] == 0 {\n                zerosRemaining -= 1;\n                // If current is 0 (middle), we need another 0 after\n                // and any element before\n                if zerosRemaining > 0 {\n                    totalCount += elementsBefore * zerosRemaining;\n                }\n                elementsBefore += 1;\n            } else {\n                // Current is non-zero, can't be middle in k=0 progression\n                elementsBefore += 1;\n            }\n        }\n        \n        return totalCount;\n    }\n    \n    // For general k != 0 and k != 1\n    // For each position i, count elements before and after\n    map<int> countBefore = {};\n    map<int> countAfter = {};\n    \n    // Initially, all elements are \"after\"\n    foreach int val in a {\n        string key = val.toString();\n        countAfter[key] = (countAfter[key] ?: 0) + 1;\n    }\n    \n    // Iterate through each position as potential middle element\n    foreach int i in 0 ..< n {\n        int middle = a[i];\n        string middleKey = middle.toString();\n        \n        // Remove current element from \"after\" count\n        countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n        \n        // Check if middle/k and middle*k exist\n        // For middle/k to be valid, middle must be divisible by k\n        if middle % k == 0 {\n            int first = middle / k;\n            int third = middle * k;\n            \n            string firstKey = first.toString();\n            string thirdKey = third.toString();\n            \n            int beforeCount = countBefore[firstKey] ?: 0;\n            int afterCount = countAfter[thirdKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n        }\n        \n        // Add current element to \"before\" count\n        countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n    }\n    \n    return totalCount;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string trimmedLine1 = line1.trim();\n    regexp:RegExp spacePattern = re ` +`;\n    string[] parts1 = spacePattern.split(trimmedLine1);\n    \n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: array elements\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string trimmedLine2 = line2.trim();\n    string[] parts2 = spacePattern.split(trimmedLine2);\n    \n    if parts2.length() != n {\n        return error(\"Array length doesn't match n\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        a.push(val);\n    }\n    \n    int result = countGeometricProgressions(n, k, a);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testGeometricProgressions1() {\n    int[] a = [1, 1, 2, 2, 4];\n    int result = countGeometricProgressions(5, 2, a);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testGeometricProgressions2() {\n    int[] a = [1, 1, 1];\n    int result = countGeometricProgressions(3, 1, a);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testGeometricProgressions3() {\n    int[] a = [1, 2, 6, 2, 3, 6, 9, 18, 3, 9];\n    int result = countGeometricProgressions(10, 3, a);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsEmpty() {\n    int[] a = [5, 10, 15];\n    int result = countGeometricProgressions(3, 2, a);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsNegative() {\n    int[] a = [-2, -4, -8];\n    int result = countGeometricProgressions(3, 2, a);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsSingle() {\n    int[] a = [1];\n    int result = countGeometricProgressions(1, 2, a);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// For a geometric progression with ratio k: first, first*k, first*k*k\n// Or equivalently: middle/k, middle, middle*k\n// \n// Strategy:\n// 1. For each position i (as the middle element):\n//    - Count how many elements before i equal a[i]/k (can be first element)\n//    - Count how many elements after i equal a[i]*k (can be third element)\n//    - Multiply these counts and add to total\n// 2. Use maps to track frequency of elements before and after each position\n// 3. Handle edge case when k=0 or k=1 carefully\n// 4. Check divisibility when computing a[i]/k to avoid floating point issues\n// \n// Fix: Use regex:split() from ballerina/lang.regexp module instead of string.split()\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\nfunction countGeometricProgressions(int n, int k, int[] a) returns int {\n    int totalCount = 0;\n    \n    // Special case: k = 1 means all three elements must be equal\n    if k == 1 {\n        // For each position i (middle element)\n        map<int> countBefore = {};\n        map<int> countAfter = {};\n        \n        // Initially, all elements are \"after\"\n        foreach int val in a {\n            string key = val.toString();\n            countAfter[key] = (countAfter[key] ?: 0) + 1;\n        }\n        \n        foreach int i in 0 ..< n {\n            int middle = a[i];\n            string middleKey = middle.toString();\n            \n            // Remove current element from \"after\" count\n            countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n            \n            // For k=1, we need all three to be equal\n            int beforeCount = countBefore[middleKey] ?: 0;\n            int afterCount = countAfter[middleKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n            \n            // Add current element to \"before\" count\n            countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n        }\n        \n        return totalCount;\n    }\n    \n    // For k = 0, we need: a[i1] (any), a[i2] = 0, a[i3] = 0\n    if k == 0 {\n        int countZeros = 0;\n        foreach int val in a {\n            if val == 0 {\n                countZeros += 1;\n            }\n        }\n        \n        // We need at least 2 zeros for a[i2] and a[i3]\n        if countZeros < 2 {\n            return 0;\n        }\n        \n        // For each non-zero or zero element before, count pairs of zeros after\n        int elementsBefore = 0;\n        int zerosRemaining = countZeros;\n        \n        foreach int i in 0 ..< n {\n            if a[i] == 0 {\n                zerosRemaining -= 1;\n                // If current is 0 (middle), we need another 0 after\n                // and any element before\n                if zerosRemaining > 0 {\n                    totalCount += elementsBefore * zerosRemaining;\n                }\n                elementsBefore += 1;\n            } else {\n                // Current is non-zero, can't be middle in k=0 progression\n                elementsBefore += 1;\n            }\n        }\n        \n        return totalCount;\n    }\n    \n    // For general k != 0 and k != 1\n    // For each position i, count elements before and after\n    map<int> countBefore = {};\n    map<int> countAfter = {};\n    \n    // Initially, all elements are \"after\"\n    foreach int val in a {\n        string key = val.toString();\n        countAfter[key] = (countAfter[key] ?: 0) + 1;\n    }\n    \n    // Iterate through each position as potential middle element\n    foreach int i in 0 ..< n {\n        int middle = a[i];\n        string middleKey = middle.toString();\n        \n        // Remove current element from \"after\" count\n        countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n        \n        // Check if middle/k and middle*k exist\n        // For middle/k to be valid, middle must be divisible by k\n        if middle % k == 0 {\n            int first = middle / k;\n            int third = middle * k;\n            \n            string firstKey = first.toString();\n            string thirdKey = third.toString();\n            \n            int beforeCount = countBefore[firstKey] ?: 0;\n            int afterCount = countAfter[thirdKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n        }\n        \n        // Add current element to \"before\" count\n        countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n    }\n    \n    return totalCount;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string trimmedLine1 = line1.trim();\n    regexp:RegExp spacePattern = re ` +`;\n    string[] parts1 = spacePattern.split(trimmedLine1);\n    \n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: array elements\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string trimmedLine2 = line2.trim();\n    string[] parts2 = spacePattern.split(trimmedLine2);\n    \n    if parts2.length() != n {\n        return error(\"Array length doesn't match n\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        a.push(val);\n    }\n    \n    int result = countGeometricProgressions(n, k, a);\n    io:println(result);\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:44:55.277360",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to count subsequences of length 3 that form a geometric progression with ratio k. For three elements at indices i1 < i2 < i3 to form a geometric progression with ratio k, we need: a[i2] = a[i1] * k and a[i3] = a[i2] * k.\n\nThe approach:\n1. For each element at index i (middle element), count how many elements before it can be the first element (a[j] = a[i]/k where j < i)\n2. Count how many elements after it can be the third element (a[m] = a[i]*k where m > i)\n3. Multiply these two counts to get the number of valid triplets with a[i] as the middle element\n4. Sum across all possible middle elements\n\nWe'll use maps to track counts of elements before and after each position to make the solution efficient.\n\n<CODE>\n```ballerina\n// Reasoning:\n// For a geometric progression with ratio k: first, first*k, first*k*k\n// Or equivalently: middle/k, middle, middle*k\n// \n// Strategy:\n// 1. For each position i (as the middle element):\n//    - Count how many elements before i equal a[i]/k (can be first element)\n//    - Count how many elements after i equal a[i]*k (can be third element)\n//    - Multiply these counts and add to total\n// 2. Use maps to track frequency of elements before and after each position\n// 3. Handle edge case when k=0 or k=1 carefully\n// 4. Check divisibility when computing a[i]/k to avoid floating point issues\n\nimport ballerina/io;\n\nfunction countGeometricProgressions(int n, int k, int[] a) returns int {\n    int totalCount = 0;\n    \n    // Edge case: k = 0 means we need a[i2] = 0 and a[i3] = 0 for any a[i1]\n    // This is a degenerate case - we'll handle it separately\n    if k == 0 {\n        // Count zeros in the array\n        int zeroCount = 0;\n        foreach int val in a {\n            if val == 0 {\n                zeroCount += 1;\n            }\n        }\n        // We need at least 2 consecutive zeros after any element\n        // For each position i, count elements before, and pairs of zeros after\n        int nonZerosBefore = 0;\n        int zerosAfter = zeroCount;\n        \n        foreach int i in 0 ..< n {\n            if a[i] == 0 {\n                zerosAfter -= 1;\n            }\n            \n            // If current is 0, next must be 0, count how many 0s after this\n            if a[i] == 0 && zerosAfter > 0 {\n                totalCount += nonZerosBefore * zerosAfter;\n            }\n            \n            if a[i] != 0 {\n                nonZerosBefore += 1;\n            } else {\n                // Current is 0, and we had zeros before\n                int zerosBefore = i - nonZerosBefore;\n                if zerosBefore > 0 && zerosAfter > 0 {\n                    totalCount += zerosBefore * zerosAfter;\n                }\n            }\n        }\n        return totalCount;\n    }\n    \n    // For each position i, count elements before and after\n    map<int> countBefore = {};\n    map<int> countAfter = {};\n    \n    // Initially, all elements are \"after\"\n    foreach int val in a {\n        string key = val.toString();\n        countAfter[key] = (countAfter[key] ?: 0) + 1;\n    }\n    \n    // Iterate through each position as potential middle element\n    foreach int i in 0 ..< n {\n        int middle = a[i];\n        string middleKey = middle.toString();\n        \n        // Remove current element from \"after\" count\n        countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n        \n        // Check if middle/k and middle*k exist\n        // For middle/k to be valid, middle must be divisible by k\n        if k != 0 && middle % k == 0 {\n            int first = middle / k;\n            int third = middle * k;\n            \n            string firstKey = first.toString();\n            string thirdKey = third.toString();\n            \n            int beforeCount = countBefore[firstKey] ?: 0;\n            int afterCount = countAfter[thirdKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n        }\n        \n        // Add current element to \"before\" count\n        countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n    }\n    \n    return totalCount;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: array elements\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Array length doesn't match n\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        a.push(val);\n    }\n    \n    int result = countGeometricProgressions(n, k, a);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testGeometricProgressions1() {\n    int[] a = [1, 1, 2, 2, 4];\n    int result = countGeometricProgressions(5, 2, a);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testGeometricProgressions2() {\n    int[] a = [1, 1, 1];\n    int result = countGeometricProgressions(3, 1, a);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testGeometricProgressions3() {\n    int[] a = [1, 2, 6, 2, 3, 6, 9, 18, 3, 9];\n    int result = countGeometricProgressions(10, 3, a);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsEmpty() {\n    int[] a = [5, 10, 15];\n    int result = countGeometricProgressions(3, 2, a);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsNegative() {\n    int[] a = [-2, -4, -8];\n    int result = countGeometricProgressions(3, 2, a);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsSingle() {\n    int[] a = [1];\n    int result = countGeometricProgressions(1, 2, a);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// For a geometric progression with ratio k: first, first*k, first*k*k\n// Or equivalently: middle/k, middle, middle*k\n// \n// Strategy:\n// 1. For each position i (as the middle element):\n//    - Count how many elements before i equal a[i]/k (can be first element)\n//    - Count how many elements after i equal a[i]*k (can be third element)\n//    - Multiply these counts and add to total\n// 2. Use maps to track frequency of elements before and after each position\n// 3. Handle edge case when k=0 or k=1 carefully\n// 4. Check divisibility when computing a[i]/k to avoid floating point issues\n\nimport ballerina/io;\n\nfunction countGeometricProgressions(int n, int k, int[] a) returns int {\n    int totalCount = 0;\n    \n    // Edge case: k = 0 means we need a[i2] = 0 and a[i3] = 0 for any a[i1]\n    // This is a degenerate case - we'll handle it separately\n    if k == 0 {\n        // Count zeros in the array\n        int zeroCount = 0;\n        foreach int val in a {\n            if val == 0 {\n                zeroCount += 1;\n            }\n        }\n        // We need at least 2 consecutive zeros after any element\n        // For each position i, count elements before, and pairs of zeros after\n        int nonZerosBefore = 0;\n        int zerosAfter = zeroCount;\n        \n        foreach int i in 0 ..< n {\n            if a[i] == 0 {\n                zerosAfter -= 1;\n            }\n            \n            // If current is 0, next must be 0, count how many 0s after this\n            if a[i] == 0 && zerosAfter > 0 {\n                totalCount += nonZerosBefore * zerosAfter;\n            }\n            \n            if a[i] != 0 {\n                nonZerosBefore += 1;\n            } else {\n                // Current is 0, and we had zeros before\n                int zerosBefore = i - nonZerosBefore;\n                if zerosBefore > 0 && zerosAfter > 0 {\n                    totalCount += zerosBefore * zerosAfter;\n                }\n            }\n        }\n        return totalCount;\n    }\n    \n    // For each position i, count elements before and after\n    map<int> countBefore = {};\n    map<int> countAfter = {};\n    \n    // Initially, all elements are \"after\"\n    foreach int val in a {\n        string key = val.toString();\n        countAfter[key] = (countAfter[key] ?: 0) + 1;\n    }\n    \n    // Iterate through each position as potential middle element\n    foreach int i in 0 ..< n {\n        int middle = a[i];\n        string middleKey = middle.toString();\n        \n        // Remove current element from \"after\" count\n        countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n        \n        // Check if middle/k and middle*k exist\n        // For middle/k to be valid, middle must be divisible by k\n        if k != 0 && middle % k == 0 {\n            int first = middle / k;\n            int third = middle * k;\n            \n            string firstKey = first.toString();\n            string thirdKey = third.toString();\n            \n            int beforeCount = countBefore[firstKey] ?: 0;\n            int afterCount = countAfter[thirdKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n        }\n        \n        // Add current element to \"before\" count\n        countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n    }\n    \n    return totalCount;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: array elements\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Array length doesn't match n\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        a.push(val);\n    }\n    \n    int result = countGeometricProgressions(n, k, a);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(104:36,104:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(118:36,118:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(104:36,104:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(118:36,118:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(104:36,104:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(118:36,118:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:45:33.728502",
      "status": "success",
      "completion": "# Overview\n\nThis problem asks us to count subsequences of length 3 that form a geometric progression with ratio k. For three elements at indices i1 < i2 < i3 to form a geometric progression with ratio k, we need: a[i2] = a[i1] * k and a[i3] = a[i2] * k.\n\nThe approach:\n1. For each element at index i (middle element), count how many elements before it can be the first element (a[j] = a[i]/k where j < i)\n2. Count how many elements after it can be the third element (a[m] = a[i]*k where m > i)\n3. Multiply these two counts to get the number of valid triplets with a[i] as the middle element\n4. Sum across all possible middle elements\n\nWe'll use maps to track counts of elements before and after each position to make the solution efficient.\n\n<CODE>\n```ballerina\n// Reasoning:\n// For a geometric progression with ratio k: first, first*k, first*k*k\n// Or equivalently: middle/k, middle, middle*k\n// \n// Strategy:\n// 1. For each position i (as the middle element):\n//    - Count how many elements before i equal a[i]/k (can be first element)\n//    - Count how many elements after i equal a[i]*k (can be third element)\n//    - Multiply these counts and add to total\n// 2. Use maps to track frequency of elements before and after each position\n// 3. Handle edge case when k=0 or k=1 carefully\n// 4. Check divisibility when computing a[i]/k to avoid floating point issues\n// \n// Fix: Use regex:split() from ballerina/lang.regexp module instead of string.split()\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\nfunction countGeometricProgressions(int n, int k, int[] a) returns int {\n    int totalCount = 0;\n    \n    // Special case: k = 1 means all three elements must be equal\n    if k == 1 {\n        // For each position i (middle element)\n        map<int> countBefore = {};\n        map<int> countAfter = {};\n        \n        // Initially, all elements are \"after\"\n        foreach int val in a {\n            string key = val.toString();\n            countAfter[key] = (countAfter[key] ?: 0) + 1;\n        }\n        \n        foreach int i in 0 ..< n {\n            int middle = a[i];\n            string middleKey = middle.toString();\n            \n            // Remove current element from \"after\" count\n            countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n            \n            // For k=1, we need all three to be equal\n            int beforeCount = countBefore[middleKey] ?: 0;\n            int afterCount = countAfter[middleKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n            \n            // Add current element to \"before\" count\n            countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n        }\n        \n        return totalCount;\n    }\n    \n    // For k = 0, we need: a[i1] (any), a[i2] = 0, a[i3] = 0\n    if k == 0 {\n        int countZeros = 0;\n        foreach int val in a {\n            if val == 0 {\n                countZeros += 1;\n            }\n        }\n        \n        // We need at least 2 zeros for a[i2] and a[i3]\n        if countZeros < 2 {\n            return 0;\n        }\n        \n        // For each non-zero or zero element before, count pairs of zeros after\n        int elementsBefore = 0;\n        int zerosRemaining = countZeros;\n        \n        foreach int i in 0 ..< n {\n            if a[i] == 0 {\n                zerosRemaining -= 1;\n                // If current is 0 (middle), we need another 0 after\n                // and any element before\n                if zerosRemaining > 0 {\n                    totalCount += elementsBefore * zerosRemaining;\n                }\n                elementsBefore += 1;\n            } else {\n                // Current is non-zero, can't be middle in k=0 progression\n                elementsBefore += 1;\n            }\n        }\n        \n        return totalCount;\n    }\n    \n    // For general k != 0 and k != 1\n    // For each position i, count elements before and after\n    map<int> countBefore = {};\n    map<int> countAfter = {};\n    \n    // Initially, all elements are \"after\"\n    foreach int val in a {\n        string key = val.toString();\n        countAfter[key] = (countAfter[key] ?: 0) + 1;\n    }\n    \n    // Iterate through each position as potential middle element\n    foreach int i in 0 ..< n {\n        int middle = a[i];\n        string middleKey = middle.toString();\n        \n        // Remove current element from \"after\" count\n        countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n        \n        // Check if middle/k and middle*k exist\n        // For middle/k to be valid, middle must be divisible by k\n        if middle % k == 0 {\n            int first = middle / k;\n            int third = middle * k;\n            \n            string firstKey = first.toString();\n            string thirdKey = third.toString();\n            \n            int beforeCount = countBefore[firstKey] ?: 0;\n            int afterCount = countAfter[thirdKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n        }\n        \n        // Add current element to \"before\" count\n        countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n    }\n    \n    return totalCount;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string trimmedLine1 = line1.trim();\n    regexp:RegExp spacePattern = re ` +`;\n    string[] parts1 = spacePattern.split(trimmedLine1);\n    \n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: array elements\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string trimmedLine2 = line2.trim();\n    string[] parts2 = spacePattern.split(trimmedLine2);\n    \n    if parts2.length() != n {\n        return error(\"Array length doesn't match n\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        a.push(val);\n    }\n    \n    int result = countGeometricProgressions(n, k, a);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testGeometricProgressions1() {\n    int[] a = [1, 1, 2, 2, 4];\n    int result = countGeometricProgressions(5, 2, a);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testGeometricProgressions2() {\n    int[] a = [1, 1, 1];\n    int result = countGeometricProgressions(3, 1, a);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testGeometricProgressions3() {\n    int[] a = [1, 2, 6, 2, 3, 6, 9, 18, 3, 9];\n    int result = countGeometricProgressions(10, 3, a);\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsEmpty() {\n    int[] a = [5, 10, 15];\n    int result = countGeometricProgressions(3, 2, a);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsNegative() {\n    int[] a = [-2, -4, -8];\n    int result = countGeometricProgressions(3, 2, a);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testGeometricProgressionsSingle() {\n    int[] a = [1];\n    int result = countGeometricProgressions(1, 2, a);\n    test:assertEquals(result, 0);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// For a geometric progression with ratio k: first, first*k, first*k*k\n// Or equivalently: middle/k, middle, middle*k\n// \n// Strategy:\n// 1. For each position i (as the middle element):\n//    - Count how many elements before i equal a[i]/k (can be first element)\n//    - Count how many elements after i equal a[i]*k (can be third element)\n//    - Multiply these counts and add to total\n// 2. Use maps to track frequency of elements before and after each position\n// 3. Handle edge case when k=0 or k=1 carefully\n// 4. Check divisibility when computing a[i]/k to avoid floating point issues\n// \n// Fix: Use regex:split() from ballerina/lang.regexp module instead of string.split()\n\nimport ballerina/io;\nimport ballerina/lang.regexp;\n\nfunction countGeometricProgressions(int n, int k, int[] a) returns int {\n    int totalCount = 0;\n    \n    // Special case: k = 1 means all three elements must be equal\n    if k == 1 {\n        // For each position i (middle element)\n        map<int> countBefore = {};\n        map<int> countAfter = {};\n        \n        // Initially, all elements are \"after\"\n        foreach int val in a {\n            string key = val.toString();\n            countAfter[key] = (countAfter[key] ?: 0) + 1;\n        }\n        \n        foreach int i in 0 ..< n {\n            int middle = a[i];\n            string middleKey = middle.toString();\n            \n            // Remove current element from \"after\" count\n            countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n            \n            // For k=1, we need all three to be equal\n            int beforeCount = countBefore[middleKey] ?: 0;\n            int afterCount = countAfter[middleKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n            \n            // Add current element to \"before\" count\n            countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n        }\n        \n        return totalCount;\n    }\n    \n    // For k = 0, we need: a[i1] (any), a[i2] = 0, a[i3] = 0\n    if k == 0 {\n        int countZeros = 0;\n        foreach int val in a {\n            if val == 0 {\n                countZeros += 1;\n            }\n        }\n        \n        // We need at least 2 zeros for a[i2] and a[i3]\n        if countZeros < 2 {\n            return 0;\n        }\n        \n        // For each non-zero or zero element before, count pairs of zeros after\n        int elementsBefore = 0;\n        int zerosRemaining = countZeros;\n        \n        foreach int i in 0 ..< n {\n            if a[i] == 0 {\n                zerosRemaining -= 1;\n                // If current is 0 (middle), we need another 0 after\n                // and any element before\n                if zerosRemaining > 0 {\n                    totalCount += elementsBefore * zerosRemaining;\n                }\n                elementsBefore += 1;\n            } else {\n                // Current is non-zero, can't be middle in k=0 progression\n                elementsBefore += 1;\n            }\n        }\n        \n        return totalCount;\n    }\n    \n    // For general k != 0 and k != 1\n    // For each position i, count elements before and after\n    map<int> countBefore = {};\n    map<int> countAfter = {};\n    \n    // Initially, all elements are \"after\"\n    foreach int val in a {\n        string key = val.toString();\n        countAfter[key] = (countAfter[key] ?: 0) + 1;\n    }\n    \n    // Iterate through each position as potential middle element\n    foreach int i in 0 ..< n {\n        int middle = a[i];\n        string middleKey = middle.toString();\n        \n        // Remove current element from \"after\" count\n        countAfter[middleKey] = (countAfter[middleKey] ?: 1) - 1;\n        \n        // Check if middle/k and middle*k exist\n        // For middle/k to be valid, middle must be divisible by k\n        if middle % k == 0 {\n            int first = middle / k;\n            int third = middle * k;\n            \n            string firstKey = first.toString();\n            string thirdKey = third.toString();\n            \n            int beforeCount = countBefore[firstKey] ?: 0;\n            int afterCount = countAfter[thirdKey] ?: 0;\n            \n            totalCount += beforeCount * afterCount;\n        }\n        \n        // Add current element to \"before\" count\n        countBefore[middleKey] = (countBefore[middleKey] ?: 0) + 1;\n    }\n    \n    return totalCount;\n}\n\npublic function main() returns error? {\n    // Read first line: n and k\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string trimmedLine1 = line1.trim();\n    regexp:RegExp spacePattern = re ` +`;\n    string[] parts1 = spacePattern.split(trimmedLine1);\n    \n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int k = check 'int:fromString(parts1[1]);\n    \n    // Read second line: array elements\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read array input\");\n    }\n    \n    string trimmedLine2 = line2.trim();\n    string[] parts2 = spacePattern.split(trimmedLine2);\n    \n    if parts2.length() != n {\n        return error(\"Array length doesn't match n\");\n    }\n    \n    int[] a = [];\n    foreach string part in parts2 {\n        int val = check 'int:fromString(part);\n        a.push(val);\n    }\n    \n    int result = countGeometricProgressions(n, k, a);\n    io:println(result);\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T03:46:16.532234"
}