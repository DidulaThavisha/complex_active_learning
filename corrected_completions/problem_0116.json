{
  "entry_id": "problem_0116",
  "problem_index": 116,
  "prompt": "Title: Chain Reaction\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nThere are *n* beacons located at distinct positions on a number line. The *i*-th beacon has position *a**i* and power level *b**i*. When the *i*-th beacon is activated, it destroys all beacons to its left (direction of decreasing coordinates) within distance *b**i* inclusive. The beacon itself is not destroyed however. Saitama will activate the beacons one at a time from right to left. If a beacon is destroyed, it cannot be activated.\n\nSaitama wants Genos to add a beacon strictly to the right of all the existing beacons, with any position and any power level, such that the least possible number of beacons are destroyed. Note that Genos's placement of the beacon means it will be the first beacon activated. Help Genos by finding the minimum number of beacons that could be destroyed.\n\nInput Specification:\nThe first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the initial number of beacons.\n\nThe *i*-th of next *n* lines contains two integers *a**i* and *b**i* (0<=≤<=*a**i*<=≤<=1<=000<=000, 1<=≤<=*b**i*<=≤<=1<=000<=000) — the position and power level of the *i*-th beacon respectively. No two beacons will have the same position, so *a**i*<=≠<=*a**j* if *i*<=≠<=*j*.\n\nOutput Specification:\nPrint a single integer — the minimum number of beacons that could be destroyed if exactly one beacon is added.\n\nDemo Input:\n['4\\n1 9\\n3 1\\n6 1\\n7 4\\n', '7\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\\n6 1\\n7 1\\n']\n\nDemo Output:\n['1\\n', '3\\n']\n\nNote:\nFor the first sample case, the minimum number of beacons destroyed is 1. One way to achieve this is to place a beacon at position 9 with power level 2.\n\nFor the second sample case, the minimum number of beacons destroyed is 3. One way to achieve this is to place a beacon at position 1337 with power level 42.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\n\nThis problem requires finding the minimum number of beacons destroyed when we add one beacon to the right of all existing beacons. The key insight is that we need to simulate the chain reaction for different scenarios where our added beacon initially destroys 0, 1, 2, ... or all beacons.\n\nThe main fix needed is to use `regex:split()` from ballerina/regex module instead of the non-existent `split()` method on strings. However, since we want to limit library usage, we'll implement a simple string splitting function ourselves.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Beacons are activated from right to left\n// 2. When activated, a beacon destroys all beacons to its left within its power range\n// 3. Destroyed beacons cannot be activated\n// 4. We add a beacon to the right (activated first) and want to minimize destruction\n//\n// Strategy:\n// - Try all scenarios where our added beacon initially destroys k beacons (k = 0 to n)\n// - For each scenario, simulate the chain reaction on the remaining beacons\n// - Return the minimum destruction count\n//\n// Key fix: Implement string splitting without using regex library\n\nimport ballerina/io;\n\ntype Beacon record {\n    int position;\n    int power;\n};\n\n// Helper function to split string by space\nfunction splitBySpace(string input) returns string[] {\n    string[] result = [];\n    string current = \"\";\n    int i = 0;\n    while i < input.length() {\n        string char = input.substring(i, i + 1);\n        if char == \" \" {\n            if current.length() > 0 {\n                result.push(current);\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i += 1;\n    }\n    if current.length() > 0 {\n        result.push(current);\n    }\n    return result;\n}\n\n// Simulate chain reaction for a given set of beacons\n// Returns number of beacons destroyed\nfunction simulateChainReaction(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    if n == 0 {\n        return 0;\n    }\n    \n    // Track which beacons are destroyed\n    boolean[] destroyed = [];\n    foreach int i in 0 ..< n {\n        destroyed.push(false);\n    }\n    \n    int destroyedCount = 0;\n    \n    // Activate beacons from right to left\n    int i = n - 1;\n    while i >= 0 {\n        if !destroyed[i] {\n            // Activate beacon i - it destroys beacons to its left within range\n            int leftBoundary = beacons[i].position - beacons[i].power;\n            \n            // Check all beacons to the left\n            int j = i - 1;\n            while j >= 0 {\n                // If beacon j is within range and not already destroyed\n                if beacons[j].position >= leftBoundary && !destroyed[j] {\n                    destroyed[j] = true;\n                    destroyedCount += 1;\n                }\n                j -= 1;\n            }\n        }\n        i -= 1;\n    }\n    \n    return destroyedCount;\n}\n\n// Find minimum number of beacons that can be destroyed\nfunction findMinimumDestroyed(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    \n    if n == 0 {\n        return 0;\n    }\n    \n    int minDestroyed = n; // worst case: all destroyed\n    \n    // Try each scenario: our added beacon initially destroys k rightmost beacons\n    // k ranges from 0 to n\n    foreach int k in 0 ... n {\n        // Scenario: destroy rightmost k beacons initially\n        // Then simulate chain reaction on remaining (n-k) beacons\n        Beacon[] remaining = [];\n        foreach int i in 0 ..< (n - k) {\n            remaining.push(beacons[i]);\n        }\n        \n        int destroyed = k + simulateChainReaction(remaining);\n        \n        if destroyed < minDestroyed {\n            minDestroyed = destroyed;\n        }\n    }\n    \n    return minDestroyed;\n}\n\npublic function main() returns error? {\n    // Read number of beacons\n    string nLine = check io:readln();\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read beacon positions and powers\n    Beacon[] beacons = [];\n    foreach int i in 0 ..< n {\n        string line = check io:readln();\n        string[] parts = splitBySpace(line.trim());\n        \n        if parts.length() != 2 {\n            return error(\"Invalid beacon data format\");\n        }\n        \n        int position = check 'int:fromString(parts[0]);\n        int power = check 'int:fromString(parts[1]);\n        \n        beacons.push({position: position, power: power});\n    }\n    \n    int result = findMinimumDestroyed(beacons);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSampleCase1() {\n    Beacon[] beacons = [\n        {position: 1, power: 9},\n        {position: 3, power: 1},\n        {position: 6, power: 1},\n        {position: 7, power: 4}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testSampleCase2() {\n    Beacon[] beacons = [\n        {position: 1, power: 1},\n        {position: 2, power: 1},\n        {position: 3, power: 1},\n        {position: 4, power: 1},\n        {position: 5, power: 1},\n        {position: 6, power: 1},\n        {position: 7, power: 1}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testSingleBeacon() {\n    Beacon[] beacons = [\n        {position: 5, power: 10}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testNoBeacons() {\n    Beacon[] beacons = [];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testChainReactionSimulation() {\n    Beacon[] beacons = [\n        {position: 1, power: 1},\n        {position: 3, power: 5}\n    ];\n    int result = simulateChainReaction(beacons);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testSplitBySpace() {\n    string[] result = splitBySpace(\"10 20\");\n    test:assertEquals(result.length(), 2);\n    test:assertEquals(result[0], \"10\");\n    test:assertEquals(result[1], \"20\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Beacons are activated from right to left\n// 2. When activated, a beacon destroys all beacons to its left within its power range\n// 3. Destroyed beacons cannot be activated\n// 4. We add a beacon to the right (activated first) and want to minimize destruction\n//\n// Strategy:\n// - Try all scenarios where our added beacon initially destroys k beacons (k = 0 to n)\n// - For each scenario, simulate the chain reaction on the remaining beacons\n// - Return the minimum destruction count\n//\n// Key fix: Implement string splitting without using regex library\n\nimport ballerina/io;\n\ntype Beacon record {\n    int position;\n    int power;\n};\n\n// Helper function to split string by space\nfunction splitBySpace(string input) returns string[] {\n    string[] result = [];\n    string current = \"\";\n    int i = 0;\n    while i < input.length() {\n        string char = input.substring(i, i + 1);\n        if char == \" \" {\n            if current.length() > 0 {\n                result.push(current);\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i += 1;\n    }\n    if current.length() > 0 {\n        result.push(current);\n    }\n    return result;\n}\n\n// Simulate chain reaction for a given set of beacons\n// Returns number of beacons destroyed\nfunction simulateChainReaction(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    if n == 0 {\n        return 0;\n    }\n    \n    // Track which beacons are destroyed\n    boolean[] destroyed = [];\n    foreach int i in 0 ..< n {\n        destroyed.push(false);\n    }\n    \n    int destroyedCount = 0;\n    \n    // Activate beacons from right to left\n    int i = n - 1;\n    while i >= 0 {\n        if !destroyed[i] {\n            // Activate beacon i - it destroys beacons to its left within range\n            int leftBoundary = beacons[i].position - beacons[i].power;\n            \n            // Check all beacons to the left\n            int j = i - 1;\n            while j >= 0 {\n                // If beacon j is within range and not already destroyed\n                if beacons[j].position >= leftBoundary && !destroyed[j] {\n                    destroyed[j] = true;\n                    destroyedCount += 1;\n                }\n                j -= 1;\n            }\n        }\n        i -= 1;\n    }\n    \n    return destroyedCount;\n}\n\n// Find minimum number of beacons that can be destroyed\nfunction findMinimumDestroyed(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    \n    if n == 0 {\n        return 0;\n    }\n    \n    int minDestroyed = n; // worst case: all destroyed\n    \n    // Try each scenario: our added beacon initially destroys k rightmost beacons\n    // k ranges from 0 to n\n    foreach int k in 0 ... n {\n        // Scenario: destroy rightmost k beacons initially\n        // Then simulate chain reaction on remaining (n-k) beacons\n        Beacon[] remaining = [];\n        foreach int i in 0 ..< (n - k) {\n            remaining.push(beacons[i]);\n        }\n        \n        int destroyed = k + simulateChainReaction(remaining);\n        \n        if destroyed < minDestroyed {\n            minDestroyed = destroyed;\n        }\n    }\n    \n    return minDestroyed;\n}\n\npublic function main() returns error? {\n    // Read number of beacons\n    string nLine = check io:readln();\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read beacon positions and powers\n    Beacon[] beacons = [];\n    foreach int i in 0 ..< n {\n        string line = check io:readln();\n        string[] parts = splitBySpace(line.trim());\n        \n        if parts.length() != 2 {\n            return error(\"Invalid beacon data format\");\n        }\n        \n        int position = check 'int:fromString(parts[0]);\n        int power = check 'int:fromString(parts[1]);\n        \n        beacons.push({position: position, power: power});\n    }\n    \n    int result = findMinimumDestroyed(beacons);\n    io:println(result);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:02:49.366026",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to find the minimum number of beacons that will be destroyed when we add one beacon to the right of all existing beacons and activate them from right to left.\n\nKey insights:\n1. When we activate a beacon at position `a` with power `b`, it destroys all beacons in range `[a-b, a)` (to its left)\n2. Destroyed beacons cannot be activated\n3. We add a new beacon to the right (activated first) and want to minimize total destruction\n4. We need to simulate the chain reaction for different scenarios\n\nThe strategy is to:\n- Try each beacon position as a potential \"first to survive\" (all beacons to its left get destroyed initially by our added beacon)\n- For each scenario, simulate the chain reaction from that point\n- Also consider the case where our added beacon doesn't destroy any existing beacons\n- Return the minimum destruction count\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We have n beacons on a number line, each with position a[i] and power b[i]\n// 2. When beacon i is activated, it destroys all beacons to its left within distance b[i]\n// 3. We activate from right to left, skipping destroyed beacons\n// 4. We add one beacon to the right that activates first\n// 5. Goal: minimize total destroyed beacons\n//\n// Approach:\n// - For each possible \"starting point\" (beacon index where we start the chain),\n//   simulate how many beacons get destroyed\n// - The added beacon can destroy 0, 1, 2, ... or all beacons initially\n// - Then simulate the chain reaction for surviving beacons\n// - Track minimum destruction across all scenarios\n\nimport ballerina/io;\n\ntype Beacon record {\n    int position;\n    int power;\n};\n\n// Simulate chain reaction starting from a given set of beacons\n// Returns the number of beacons destroyed\nfunction simulateChainReaction(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    if n == 0 {\n        return 0;\n    }\n    \n    boolean[] destroyed = [];\n    foreach int i in 0 ..< n {\n        destroyed.push(false);\n    }\n    \n    int destroyedCount = 0;\n    \n    // Activate beacons from right to left\n    int i = n - 1;\n    while i >= 0 {\n        if !destroyed[i] {\n            // Activate beacon i, it destroys beacons to its left within range\n            int leftBoundary = beacons[i].position - beacons[i].power;\n            \n            // Mark all beacons to the left within range as destroyed\n            int j = i - 1;\n            while j >= 0 {\n                if beacons[j].position >= leftBoundary && !destroyed[j] {\n                    destroyed[j] = true;\n                    destroyedCount += 1;\n                }\n                j -= 1;\n            }\n        }\n        i -= 1;\n    }\n    \n    return destroyedCount;\n}\n\nfunction findMinimumDestroyed(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    \n    if n == 0 {\n        return 0;\n    }\n    \n    int minDestroyed = n; // worst case: all destroyed\n    \n    // Try each possible scenario: our added beacon destroys the rightmost k beacons\n    // k ranges from 0 to n\n    foreach int k in 0 ... n {\n        // If we destroy the rightmost k beacons initially\n        // Then simulate chain reaction on remaining beacons (first n-k beacons)\n        Beacon[] remaining = [];\n        foreach int i in 0 ..< (n - k) {\n            remaining.push(beacons[i]);\n        }\n        \n        int destroyed = k + simulateChainReaction(remaining);\n        \n        if destroyed < minDestroyed {\n            minDestroyed = destroyed;\n        }\n    }\n    \n    return minDestroyed;\n}\n\npublic function main() returns error? {\n    // Read number of beacons\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read beacon positions and powers\n    Beacon[] beacons = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read beacon data\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid beacon data format\");\n        }\n        \n        int position = check 'int:fromString(parts[0]);\n        int power = check 'int:fromString(parts[1]);\n        \n        beacons.push({position: position, power: power});\n    }\n    \n    int result = findMinimumDestroyed(beacons);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSampleCase1() {\n    Beacon[] beacons = [\n        {position: 1, power: 9},\n        {position: 3, power: 1},\n        {position: 6, power: 1},\n        {position: 7, power: 4}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testSampleCase2() {\n    Beacon[] beacons = [\n        {position: 1, power: 1},\n        {position: 2, power: 1},\n        {position: 3, power: 1},\n        {position: 4, power: 1},\n        {position: 5, power: 1},\n        {position: 6, power: 1},\n        {position: 7, power: 1}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testSingleBeacon() {\n    Beacon[] beacons = [\n        {position: 5, power: 10}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testNoBeacons() {\n    Beacon[] beacons = [];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testChainReactionSimulation() {\n    Beacon[] beacons = [\n        {position: 1, power: 1},\n        {position: 3, power: 5}\n    ];\n    int result = simulateChainReaction(beacons);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We have n beacons on a number line, each with position a[i] and power b[i]\n// 2. When beacon i is activated, it destroys all beacons to its left within distance b[i]\n// 3. We activate from right to left, skipping destroyed beacons\n// 4. We add one beacon to the right that activates first\n// 5. Goal: minimize total destroyed beacons\n//\n// Approach:\n// - For each possible \"starting point\" (beacon index where we start the chain),\n//   simulate how many beacons get destroyed\n// - The added beacon can destroy 0, 1, 2, ... or all beacons initially\n// - Then simulate the chain reaction for surviving beacons\n// - Track minimum destruction across all scenarios\n\nimport ballerina/io;\n\ntype Beacon record {\n    int position;\n    int power;\n};\n\n// Simulate chain reaction starting from a given set of beacons\n// Returns the number of beacons destroyed\nfunction simulateChainReaction(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    if n == 0 {\n        return 0;\n    }\n    \n    boolean[] destroyed = [];\n    foreach int i in 0 ..< n {\n        destroyed.push(false);\n    }\n    \n    int destroyedCount = 0;\n    \n    // Activate beacons from right to left\n    int i = n - 1;\n    while i >= 0 {\n        if !destroyed[i] {\n            // Activate beacon i, it destroys beacons to its left within range\n            int leftBoundary = beacons[i].position - beacons[i].power;\n            \n            // Mark all beacons to the left within range as destroyed\n            int j = i - 1;\n            while j >= 0 {\n                if beacons[j].position >= leftBoundary && !destroyed[j] {\n                    destroyed[j] = true;\n                    destroyedCount += 1;\n                }\n                j -= 1;\n            }\n        }\n        i -= 1;\n    }\n    \n    return destroyedCount;\n}\n\nfunction findMinimumDestroyed(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    \n    if n == 0 {\n        return 0;\n    }\n    \n    int minDestroyed = n; // worst case: all destroyed\n    \n    // Try each possible scenario: our added beacon destroys the rightmost k beacons\n    // k ranges from 0 to n\n    foreach int k in 0 ... n {\n        // If we destroy the rightmost k beacons initially\n        // Then simulate chain reaction on remaining beacons (first n-k beacons)\n        Beacon[] remaining = [];\n        foreach int i in 0 ..< (n - k) {\n            remaining.push(beacons[i]);\n        }\n        \n        int destroyed = k + simulateChainReaction(remaining);\n        \n        if destroyed < minDestroyed {\n            minDestroyed = destroyed;\n        }\n    }\n    \n    return minDestroyed;\n}\n\npublic function main() returns error? {\n    // Read number of beacons\n    string? nLine = io:readln();\n    if nLine is () {\n        return error(\"Failed to read input\");\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read beacon positions and powers\n    Beacon[] beacons = [];\n    foreach int i in 0 ..< n {\n        string? line = io:readln();\n        if line is () {\n            return error(\"Failed to read beacon data\");\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() != 2 {\n            return error(\"Invalid beacon data format\");\n        }\n        \n        int position = check 'int:fromString(parts[0]);\n        int power = check 'int:fromString(parts[1]);\n        \n        beacons.push({position: position, power: power});\n    }\n    \n    int result = findMinimumDestroyed(beacons);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(106:38,106:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(106:38,106:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(106:38,106:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:03:18.034931",
      "status": "success",
      "completion": "# Overview\n\nThis problem requires finding the minimum number of beacons destroyed when we add one beacon to the right of all existing beacons. The key insight is that we need to simulate the chain reaction for different scenarios where our added beacon initially destroys 0, 1, 2, ... or all beacons.\n\nThe main fix needed is to use `regex:split()` from ballerina/regex module instead of the non-existent `split()` method on strings. However, since we want to limit library usage, we'll implement a simple string splitting function ourselves.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Beacons are activated from right to left\n// 2. When activated, a beacon destroys all beacons to its left within its power range\n// 3. Destroyed beacons cannot be activated\n// 4. We add a beacon to the right (activated first) and want to minimize destruction\n//\n// Strategy:\n// - Try all scenarios where our added beacon initially destroys k beacons (k = 0 to n)\n// - For each scenario, simulate the chain reaction on the remaining beacons\n// - Return the minimum destruction count\n//\n// Key fix: Implement string splitting without using regex library\n\nimport ballerina/io;\n\ntype Beacon record {\n    int position;\n    int power;\n};\n\n// Helper function to split string by space\nfunction splitBySpace(string input) returns string[] {\n    string[] result = [];\n    string current = \"\";\n    int i = 0;\n    while i < input.length() {\n        string char = input.substring(i, i + 1);\n        if char == \" \" {\n            if current.length() > 0 {\n                result.push(current);\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i += 1;\n    }\n    if current.length() > 0 {\n        result.push(current);\n    }\n    return result;\n}\n\n// Simulate chain reaction for a given set of beacons\n// Returns number of beacons destroyed\nfunction simulateChainReaction(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    if n == 0 {\n        return 0;\n    }\n    \n    // Track which beacons are destroyed\n    boolean[] destroyed = [];\n    foreach int i in 0 ..< n {\n        destroyed.push(false);\n    }\n    \n    int destroyedCount = 0;\n    \n    // Activate beacons from right to left\n    int i = n - 1;\n    while i >= 0 {\n        if !destroyed[i] {\n            // Activate beacon i - it destroys beacons to its left within range\n            int leftBoundary = beacons[i].position - beacons[i].power;\n            \n            // Check all beacons to the left\n            int j = i - 1;\n            while j >= 0 {\n                // If beacon j is within range and not already destroyed\n                if beacons[j].position >= leftBoundary && !destroyed[j] {\n                    destroyed[j] = true;\n                    destroyedCount += 1;\n                }\n                j -= 1;\n            }\n        }\n        i -= 1;\n    }\n    \n    return destroyedCount;\n}\n\n// Find minimum number of beacons that can be destroyed\nfunction findMinimumDestroyed(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    \n    if n == 0 {\n        return 0;\n    }\n    \n    int minDestroyed = n; // worst case: all destroyed\n    \n    // Try each scenario: our added beacon initially destroys k rightmost beacons\n    // k ranges from 0 to n\n    foreach int k in 0 ... n {\n        // Scenario: destroy rightmost k beacons initially\n        // Then simulate chain reaction on remaining (n-k) beacons\n        Beacon[] remaining = [];\n        foreach int i in 0 ..< (n - k) {\n            remaining.push(beacons[i]);\n        }\n        \n        int destroyed = k + simulateChainReaction(remaining);\n        \n        if destroyed < minDestroyed {\n            minDestroyed = destroyed;\n        }\n    }\n    \n    return minDestroyed;\n}\n\npublic function main() returns error? {\n    // Read number of beacons\n    string nLine = check io:readln();\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read beacon positions and powers\n    Beacon[] beacons = [];\n    foreach int i in 0 ..< n {\n        string line = check io:readln();\n        string[] parts = splitBySpace(line.trim());\n        \n        if parts.length() != 2 {\n            return error(\"Invalid beacon data format\");\n        }\n        \n        int position = check 'int:fromString(parts[0]);\n        int power = check 'int:fromString(parts[1]);\n        \n        beacons.push({position: position, power: power});\n    }\n    \n    int result = findMinimumDestroyed(beacons);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSampleCase1() {\n    Beacon[] beacons = [\n        {position: 1, power: 9},\n        {position: 3, power: 1},\n        {position: 6, power: 1},\n        {position: 7, power: 4}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testSampleCase2() {\n    Beacon[] beacons = [\n        {position: 1, power: 1},\n        {position: 2, power: 1},\n        {position: 3, power: 1},\n        {position: 4, power: 1},\n        {position: 5, power: 1},\n        {position: 6, power: 1},\n        {position: 7, power: 1}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testSingleBeacon() {\n    Beacon[] beacons = [\n        {position: 5, power: 10}\n    ];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testNoBeacons() {\n    Beacon[] beacons = [];\n    int result = findMinimumDestroyed(beacons);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testChainReactionSimulation() {\n    Beacon[] beacons = [\n        {position: 1, power: 1},\n        {position: 3, power: 5}\n    ];\n    int result = simulateChainReaction(beacons);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testSplitBySpace() {\n    string[] result = splitBySpace(\"10 20\");\n    test:assertEquals(result.length(), 2);\n    test:assertEquals(result[0], \"10\");\n    test:assertEquals(result[1], \"20\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Beacons are activated from right to left\n// 2. When activated, a beacon destroys all beacons to its left within its power range\n// 3. Destroyed beacons cannot be activated\n// 4. We add a beacon to the right (activated first) and want to minimize destruction\n//\n// Strategy:\n// - Try all scenarios where our added beacon initially destroys k beacons (k = 0 to n)\n// - For each scenario, simulate the chain reaction on the remaining beacons\n// - Return the minimum destruction count\n//\n// Key fix: Implement string splitting without using regex library\n\nimport ballerina/io;\n\ntype Beacon record {\n    int position;\n    int power;\n};\n\n// Helper function to split string by space\nfunction splitBySpace(string input) returns string[] {\n    string[] result = [];\n    string current = \"\";\n    int i = 0;\n    while i < input.length() {\n        string char = input.substring(i, i + 1);\n        if char == \" \" {\n            if current.length() > 0 {\n                result.push(current);\n                current = \"\";\n            }\n        } else {\n            current = current + char;\n        }\n        i += 1;\n    }\n    if current.length() > 0 {\n        result.push(current);\n    }\n    return result;\n}\n\n// Simulate chain reaction for a given set of beacons\n// Returns number of beacons destroyed\nfunction simulateChainReaction(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    if n == 0 {\n        return 0;\n    }\n    \n    // Track which beacons are destroyed\n    boolean[] destroyed = [];\n    foreach int i in 0 ..< n {\n        destroyed.push(false);\n    }\n    \n    int destroyedCount = 0;\n    \n    // Activate beacons from right to left\n    int i = n - 1;\n    while i >= 0 {\n        if !destroyed[i] {\n            // Activate beacon i - it destroys beacons to its left within range\n            int leftBoundary = beacons[i].position - beacons[i].power;\n            \n            // Check all beacons to the left\n            int j = i - 1;\n            while j >= 0 {\n                // If beacon j is within range and not already destroyed\n                if beacons[j].position >= leftBoundary && !destroyed[j] {\n                    destroyed[j] = true;\n                    destroyedCount += 1;\n                }\n                j -= 1;\n            }\n        }\n        i -= 1;\n    }\n    \n    return destroyedCount;\n}\n\n// Find minimum number of beacons that can be destroyed\nfunction findMinimumDestroyed(Beacon[] beacons) returns int {\n    int n = beacons.length();\n    \n    if n == 0 {\n        return 0;\n    }\n    \n    int minDestroyed = n; // worst case: all destroyed\n    \n    // Try each scenario: our added beacon initially destroys k rightmost beacons\n    // k ranges from 0 to n\n    foreach int k in 0 ... n {\n        // Scenario: destroy rightmost k beacons initially\n        // Then simulate chain reaction on remaining (n-k) beacons\n        Beacon[] remaining = [];\n        foreach int i in 0 ..< (n - k) {\n            remaining.push(beacons[i]);\n        }\n        \n        int destroyed = k + simulateChainReaction(remaining);\n        \n        if destroyed < minDestroyed {\n            minDestroyed = destroyed;\n        }\n    }\n    \n    return minDestroyed;\n}\n\npublic function main() returns error? {\n    // Read number of beacons\n    string nLine = check io:readln();\n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read beacon positions and powers\n    Beacon[] beacons = [];\n    foreach int i in 0 ..< n {\n        string line = check io:readln();\n        string[] parts = splitBySpace(line.trim());\n        \n        if parts.length() != 2 {\n            return error(\"Invalid beacon data format\");\n        }\n        \n        int position = check 'int:fromString(parts[0]);\n        int power = check 'int:fromString(parts[1]);\n        \n        beacons.push({position: position, power: power});\n    }\n    \n    int result = findMinimumDestroyed(beacons);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T02:03:51.403412"
}