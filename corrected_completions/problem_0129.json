{
  "entry_id": "problem_0129",
  "problem_index": 129,
  "prompt": "Title: Nastya Studies Informatics\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nToday on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.\n\nWe define a pair of integers (*a*,<=*b*) good, if *GCD*(*a*,<=*b*)<==<=*x* and *LCM*(*a*,<=*b*)<==<=*y*, where *GCD*(*a*,<=*b*) denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of *a* and *b*, and *LCM*(*a*,<=*b*) denotes the [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of *a* and *b*.\n\nYou are given two integers *x* and *y*. You are to find the number of good pairs of integers (*a*,<=*b*) such that *l*<=≤<=*a*,<=*b*<=≤<=*r*. Note that pairs (*a*,<=*b*) and (*b*,<=*a*) are considered different if *a*<=≠<=*b*.\n\nInput Specification:\nThe only line contains four integers *l*,<=*r*,<=*x*,<=*y* (1<=≤<=*l*<=≤<=*r*<=≤<=109, 1<=≤<=*x*<=≤<=*y*<=≤<=109).\n\nOutput Specification:\nIn the only line print the only integer — the answer for the problem.\n\nDemo Input:\n['1 2 1 2\\n', '1 12 1 12\\n', '50 100 3 30\\n']\n\nDemo Output:\n['2\\n', '4\\n', '0\\n']\n\nNote:\nIn the first example there are two suitable good pairs of integers (*a*, *b*): (1, 2) and (2, 1).\n\nIn the second example there are four suitable good pairs of integers (*a*, *b*): (1, 12), (12, 1), (3, 4) and (4, 3).\n\nIn the third example there are good pairs of integers, for example, (3, 30), but none of them fits the condition *l* ≤ *a*, *b* ≤ *r*.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem asks us to find the number of pairs (a, b) where l ≤ a, b ≤ r such that GCD(a, b) = x and LCM(a, b) = y.\n\nKey insights:\n1. For any two numbers a and b: GCD(a, b) * LCM(a, b) = a * b\n2. If GCD(a, b) = x, then a = x * m and b = x * n where GCD(m, n) = 1 (m and n are coprime)\n3. If LCM(a, b) = y, then y must be divisible by x (since GCD divides LCM)\n4. Given GCD = x and LCM = y, we can write a = x * m and b = x * n where m * n = y / x and GCD(m, n) = 1\n5. We need to find all factor pairs (m, n) of (y/x) that are coprime, then check if x*m and x*n are in range [l, r]\n\nThe compilation error was due to using `split()` on a string, which is not available in Ballerina's standard library. We need to use `regex:split()` from the `ballerina/regex` module instead.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First check if y is divisible by x (necessary condition)\n// 2. Calculate k = y / x\n// 3. Find all divisors of k\n// 4. For each divisor pair (m, n) where m * n = k, check if GCD(m, n) = 1\n// 5. If coprime, then a = x * m and b = x * n form a valid pair\n// 6. Check if both a and b are in range [l, r]\n// 7. Count all such valid pairs\n// 8. Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to calculate GCD using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int num1 = a;\n    int num2 = b;\n    while num2 != 0 {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\n// Function to find all divisors of a number\nfunction getDivisors(int n) returns int[] {\n    int[] divisors = [];\n    int i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n        i += 1;\n    }\n    return divisors;\n}\n\n// Main function to count good pairs\nfunction countGoodPairs(int l, int r, int x, int y) returns int {\n    // If y is not divisible by x, no valid pairs exist\n    if y % x != 0 {\n        return 0;\n    }\n    \n    int k = y / x;\n    int[] divisors = getDivisors(k);\n    int count = 0;\n    \n    // Check each divisor pair\n    foreach int m in divisors {\n        int n = k / m;\n        \n        // Check if m and n are coprime\n        if gcd(m, n) == 1 {\n            int a = x * m;\n            int b = x * n;\n            \n            // Check if both a and b are in range [l, r]\n            if a >= l && a <= r && b >= l && b <= r {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() == 4 {\n            int|error l_val = 'int:fromString(parts[0]);\n            int|error r_val = 'int:fromString(parts[1]);\n            int|error x_val = 'int:fromString(parts[2]);\n            int|error y_val = 'int:fromString(parts[3]);\n            \n            if l_val is int && r_val is int && x_val is int && y_val is int {\n                int result = countGoodPairs(l_val, r_val, x_val, y_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 4 integers\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCountGoodPairs1() {\n    // Test case 1: l=1, r=2, x=1, y=2\n    // Valid pairs: (1,2) and (2,1)\n    int result = countGoodPairs(1, 2, 1, 2);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testCountGoodPairs2() {\n    // Test case 2: l=1, r=12, x=1, y=12\n    // Valid pairs: (1,12), (12,1), (3,4), (4,3)\n    int result = countGoodPairs(1, 12, 1, 12);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testCountGoodPairs3() {\n    // Test case 3: l=50, r=100, x=3, y=30\n    // No valid pairs in range\n    int result = countGoodPairs(50, 100, 3, 30);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testCountGoodPairs4() {\n    // Test case 4: When y is not divisible by x\n    int result = countGoodPairs(1, 10, 3, 10);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testGcd() {\n    // Test GCD function\n    test:assertEquals(gcd(12, 8), 4);\n    test:assertEquals(gcd(7, 5), 1);\n    test:assertEquals(gcd(100, 50), 50);\n    test:assertEquals(gcd(17, 19), 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. First check if y is divisible by x (necessary condition)\n// 2. Calculate k = y / x\n// 3. Find all divisors of k\n// 4. For each divisor pair (m, n) where m * n = k, check if GCD(m, n) = 1\n// 5. If coprime, then a = x * m and b = x * n form a valid pair\n// 6. Check if both a and b are in range [l, r]\n// 7. Count all such valid pairs\n// 8. Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to calculate GCD using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int num1 = a;\n    int num2 = b;\n    while num2 != 0 {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\n// Function to find all divisors of a number\nfunction getDivisors(int n) returns int[] {\n    int[] divisors = [];\n    int i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n        i += 1;\n    }\n    return divisors;\n}\n\n// Main function to count good pairs\nfunction countGoodPairs(int l, int r, int x, int y) returns int {\n    // If y is not divisible by x, no valid pairs exist\n    if y % x != 0 {\n        return 0;\n    }\n    \n    int k = y / x;\n    int[] divisors = getDivisors(k);\n    int count = 0;\n    \n    // Check each divisor pair\n    foreach int m in divisors {\n        int n = k / m;\n        \n        // Check if m and n are coprime\n        if gcd(m, n) == 1 {\n            int a = x * m;\n            int b = x * n;\n            \n            // Check if both a and b are in range [l, r]\n            if a >= l && a <= r && b >= l && b <= r {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() == 4 {\n            int|error l_val = 'int:fromString(parts[0]);\n            int|error r_val = 'int:fromString(parts[1]);\n            int|error x_val = 'int:fromString(parts[2]);\n            int|error y_val = 'int:fromString(parts[3]);\n            \n            if l_val is int && r_val is int && x_val is int && y_val is int {\n                int result = countGoodPairs(l_val, r_val, x_val, y_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 4 integers\");\n        }\n    }\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:16:50.424241",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the number of pairs (a, b) where l ≤ a, b ≤ r such that GCD(a, b) = x and LCM(a, b) = y.\n\nKey insights:\n1. For any two numbers a and b: GCD(a, b) * LCM(a, b) = a * b\n2. If GCD(a, b) = x, then a = x * m and b = x * n where GCD(m, n) = 1 (m and n are coprime)\n3. If LCM(a, b) = y, then y must be divisible by x (since GCD divides LCM)\n4. Given GCD = x and LCM = y, we can write a = x * m and b = x * n where m * n = y / x and GCD(m, n) = 1\n5. We need to find all factor pairs (m, n) of (y/x) that are coprime, then check if x*m and x*n are in range [l, r]\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First check if y is divisible by x (necessary condition)\n// 2. Calculate k = y / x\n// 3. Find all divisors of k\n// 4. For each divisor pair (m, n) where m * n = k, check if GCD(m, n) = 1\n// 5. If coprime, then a = x * m and b = x * n form a valid pair\n// 6. Check if both a and b are in range [l, r]\n// 7. Count all such valid pairs\n\nimport ballerina/io;\n\n// Function to calculate GCD using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int num1 = a;\n    int num2 = b;\n    while num2 != 0 {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\n// Function to find all divisors of a number\nfunction getDivisors(int n) returns int[] {\n    int[] divisors = [];\n    int i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n        i += 1;\n    }\n    return divisors;\n}\n\n// Main function to count good pairs\nfunction countGoodPairs(int l, int r, int x, int y) returns int {\n    // If y is not divisible by x, no valid pairs exist\n    if y % x != 0 {\n        return 0;\n    }\n    \n    int k = y / x;\n    int[] divisors = getDivisors(k);\n    int count = 0;\n    \n    // Check each divisor pair\n    foreach int m in divisors {\n        int n = k / m;\n        \n        // Check if m and n are coprime\n        if gcd(m, n) == 1 {\n            int a = x * m;\n            int b = x * n;\n            \n            // Check if both a and b are in range [l, r]\n            if a >= l && a <= r && b >= l && b <= r {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() == 4 {\n            int|error l_val = 'int:fromString(parts[0]);\n            int|error r_val = 'int:fromString(parts[1]);\n            int|error x_val = 'int:fromString(parts[2]);\n            int|error y_val = 'int:fromString(parts[3]);\n            \n            if l_val is int && r_val is int && x_val is int && y_val is int {\n                int result = countGoodPairs(l_val, r_val, x_val, y_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 4 integers\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCountGoodPairs1() {\n    // Test case 1: l=1, r=2, x=1, y=2\n    // Valid pairs: (1,2) and (2,1)\n    int result = countGoodPairs(1, 2, 1, 2);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testCountGoodPairs2() {\n    // Test case 2: l=1, r=12, x=1, y=12\n    // Valid pairs: (1,12), (12,1), (3,4), (4,3)\n    int result = countGoodPairs(1, 12, 1, 12);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testCountGoodPairs3() {\n    // Test case 3: l=50, r=100, x=3, y=30\n    // No valid pairs in range\n    int result = countGoodPairs(50, 100, 3, 30);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testCountGoodPairs4() {\n    // Test case 4: When y is not divisible by x\n    int result = countGoodPairs(1, 10, 3, 10);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testGcd() {\n    // Test GCD function\n    test:assertEquals(gcd(12, 8), 4);\n    test:assertEquals(gcd(7, 5), 1);\n    test:assertEquals(gcd(100, 50), 50);\n    test:assertEquals(gcd(17, 19), 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. First check if y is divisible by x (necessary condition)\n// 2. Calculate k = y / x\n// 3. Find all divisors of k\n// 4. For each divisor pair (m, n) where m * n = k, check if GCD(m, n) = 1\n// 5. If coprime, then a = x * m and b = x * n form a valid pair\n// 6. Check if both a and b are in range [l, r]\n// 7. Count all such valid pairs\n\nimport ballerina/io;\n\n// Function to calculate GCD using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int num1 = a;\n    int num2 = b;\n    while num2 != 0 {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\n// Function to find all divisors of a number\nfunction getDivisors(int n) returns int[] {\n    int[] divisors = [];\n    int i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n        i += 1;\n    }\n    return divisors;\n}\n\n// Main function to count good pairs\nfunction countGoodPairs(int l, int r, int x, int y) returns int {\n    // If y is not divisible by x, no valid pairs exist\n    if y % x != 0 {\n        return 0;\n    }\n    \n    int k = y / x;\n    int[] divisors = getDivisors(k);\n    int count = 0;\n    \n    // Check each divisor pair\n    foreach int m in divisors {\n        int n = k / m;\n        \n        // Check if m and n are coprime\n        if gcd(m, n) == 1 {\n            int a = x * m;\n            int b = x * n;\n            \n            // Check if both a and b are in range [l, r]\n            if a >= l && a <= r && b >= l && b <= r {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() == 4 {\n            int|error l_val = 'int:fromString(parts[0]);\n            int|error r_val = 'int:fromString(parts[1]);\n            int|error x_val = 'int:fromString(parts[2]);\n            int|error y_val = 'int:fromString(parts[3]);\n            \n            if l_val is int && r_val is int && x_val is int && y_val is int {\n                int result = countGoodPairs(l_val, r_val, x_val, y_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 4 integers\");\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(74:44,74:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(74:44,74:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(74:44,74:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:17:14.238683",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to find the number of pairs (a, b) where l ≤ a, b ≤ r such that GCD(a, b) = x and LCM(a, b) = y.\n\nKey insights:\n1. For any two numbers a and b: GCD(a, b) * LCM(a, b) = a * b\n2. If GCD(a, b) = x, then a = x * m and b = x * n where GCD(m, n) = 1 (m and n are coprime)\n3. If LCM(a, b) = y, then y must be divisible by x (since GCD divides LCM)\n4. Given GCD = x and LCM = y, we can write a = x * m and b = x * n where m * n = y / x and GCD(m, n) = 1\n5. We need to find all factor pairs (m, n) of (y/x) that are coprime, then check if x*m and x*n are in range [l, r]\n\nThe compilation error was due to using `split()` on a string, which is not available in Ballerina's standard library. We need to use `regex:split()` from the `ballerina/regex` module instead.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. First check if y is divisible by x (necessary condition)\n// 2. Calculate k = y / x\n// 3. Find all divisors of k\n// 4. For each divisor pair (m, n) where m * n = k, check if GCD(m, n) = 1\n// 5. If coprime, then a = x * m and b = x * n form a valid pair\n// 6. Check if both a and b are in range [l, r]\n// 7. Count all such valid pairs\n// 8. Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to calculate GCD using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int num1 = a;\n    int num2 = b;\n    while num2 != 0 {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\n// Function to find all divisors of a number\nfunction getDivisors(int n) returns int[] {\n    int[] divisors = [];\n    int i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n        i += 1;\n    }\n    return divisors;\n}\n\n// Main function to count good pairs\nfunction countGoodPairs(int l, int r, int x, int y) returns int {\n    // If y is not divisible by x, no valid pairs exist\n    if y % x != 0 {\n        return 0;\n    }\n    \n    int k = y / x;\n    int[] divisors = getDivisors(k);\n    int count = 0;\n    \n    // Check each divisor pair\n    foreach int m in divisors {\n        int n = k / m;\n        \n        // Check if m and n are coprime\n        if gcd(m, n) == 1 {\n            int a = x * m;\n            int b = x * n;\n            \n            // Check if both a and b are in range [l, r]\n            if a >= l && a <= r && b >= l && b <= r {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() == 4 {\n            int|error l_val = 'int:fromString(parts[0]);\n            int|error r_val = 'int:fromString(parts[1]);\n            int|error x_val = 'int:fromString(parts[2]);\n            int|error y_val = 'int:fromString(parts[3]);\n            \n            if l_val is int && r_val is int && x_val is int && y_val is int {\n                int result = countGoodPairs(l_val, r_val, x_val, y_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 4 integers\");\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCountGoodPairs1() {\n    // Test case 1: l=1, r=2, x=1, y=2\n    // Valid pairs: (1,2) and (2,1)\n    int result = countGoodPairs(1, 2, 1, 2);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testCountGoodPairs2() {\n    // Test case 2: l=1, r=12, x=1, y=12\n    // Valid pairs: (1,12), (12,1), (3,4), (4,3)\n    int result = countGoodPairs(1, 12, 1, 12);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testCountGoodPairs3() {\n    // Test case 3: l=50, r=100, x=3, y=30\n    // No valid pairs in range\n    int result = countGoodPairs(50, 100, 3, 30);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testCountGoodPairs4() {\n    // Test case 4: When y is not divisible by x\n    int result = countGoodPairs(1, 10, 3, 10);\n    test:assertEquals(result, 0);\n}\n\n@test:Config {}\nfunction testGcd() {\n    // Test GCD function\n    test:assertEquals(gcd(12, 8), 4);\n    test:assertEquals(gcd(7, 5), 1);\n    test:assertEquals(gcd(100, 50), 50);\n    test:assertEquals(gcd(17, 19), 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. First check if y is divisible by x (necessary condition)\n// 2. Calculate k = y / x\n// 3. Find all divisors of k\n// 4. For each divisor pair (m, n) where m * n = k, check if GCD(m, n) = 1\n// 5. If coprime, then a = x * m and b = x * n form a valid pair\n// 6. Check if both a and b are in range [l, r]\n// 7. Count all such valid pairs\n// 8. Use regex:split() instead of string.split() for parsing input\n\nimport ballerina/io;\nimport ballerina/regex;\n\n// Function to calculate GCD using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int num1 = a;\n    int num2 = b;\n    while num2 != 0 {\n        int temp = num2;\n        num2 = num1 % num2;\n        num1 = temp;\n    }\n    return num1;\n}\n\n// Function to find all divisors of a number\nfunction getDivisors(int n) returns int[] {\n    int[] divisors = [];\n    int i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            divisors.push(i);\n            if i != n / i {\n                divisors.push(n / i);\n            }\n        }\n        i += 1;\n    }\n    return divisors;\n}\n\n// Main function to count good pairs\nfunction countGoodPairs(int l, int r, int x, int y) returns int {\n    // If y is not divisible by x, no valid pairs exist\n    if y % x != 0 {\n        return 0;\n    }\n    \n    int k = y / x;\n    int[] divisors = getDivisors(k);\n    int count = 0;\n    \n    // Check each divisor pair\n    foreach int m in divisors {\n        int n = k / m;\n        \n        // Check if m and n are coprime\n        if gcd(m, n) == 1 {\n            int a = x * m;\n            int b = x * n;\n            \n            // Check if both a and b are in range [l, r]\n            if a >= l && a <= r && b >= l && b <= r {\n                count += 1;\n            }\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        string[] parts = regex:split(trimmed, \" \");\n        \n        if parts.length() == 4 {\n            int|error l_val = 'int:fromString(parts[0]);\n            int|error r_val = 'int:fromString(parts[1]);\n            int|error x_val = 'int:fromString(parts[2]);\n            int|error y_val = 'int:fromString(parts[3]);\n            \n            if l_val is int && r_val is int && x_val is int && y_val is int {\n                int result = countGoodPairs(l_val, r_val, x_val, y_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 4 integers\");\n        }\n    }\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T02:17:46.014961"
}