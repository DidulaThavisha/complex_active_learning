{
  "entry_id": "problem_0158",
  "problem_index": 158,
  "prompt": "Title: Four Segments\n\nTime Limit: 2 seconds\n\nMemory Limit: 64 megabytes\n\nProblem Description:\nSeveral months later Alex finally got his brother Bob's creation by post. And now, in his turn, Alex wants to boast about something to his brother. He thought for a while, and came to the conclusion that he has no ready creations, and decided to write a program for rectangles detection. According to his plan, the program detects if the four given segments form a rectangle of a positive area and with sides parallel to coordinate axes. As Alex does badly at school and can't write this program by himself, he asks you to help him.\n\nInput Specification:\nThe input data contain four lines. Each of these lines contains four integers *x*1, *y*1, *x*2, *y*2 (<=-<=109<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=109) — coordinates of segment's beginning and end positions. The given segments can degenerate into points.\n\nOutput Specification:\nOutput the word «YES», if the given four segments form the required rectangle, otherwise output «NO».\n\nDemo Input:\n['1 1 6 1\\n1 0 6 0\\n6 0 6 1\\n1 1 1 0\\n', '0 0 0 3\\n2 0 0 0\\n2 2 2 0\\n0 2 2 2\\n']\n\nDemo Output:\n['YES\\n', 'NO\\n']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem requires checking if four given line segments form a rectangle with positive area and sides parallel to coordinate axes. The approach is to:\n1. Parse the four segments from input\n2. Classify each segment as horizontal or vertical (parallel to axes)\n3. Verify we have exactly 2 horizontal and 2 vertical segments\n4. Check that the segments form a closed rectangle with positive area\n5. Ensure all segments are edges of the rectangle (no extra length)\n\n<CODE>\n```ballerina\n// Reasoning:\n// A valid rectangle with sides parallel to axes must have:\n// - Exactly 2 horizontal segments (same y-coordinates for both endpoints)\n// - Exactly 2 vertical segments (same x-coordinates for both endpoints)\n// - The horizontal segments must have the same length and different y-coordinates\n// - The vertical segments must have the same length and different x-coordinates\n// - The segments must connect to form a closed rectangle\n// - The rectangle must have positive area\n//\n// Strategy:\n// 1. Read and parse 4 segments\n// 2. Normalize each segment (ensure point1 <= point2)\n// 3. Classify segments as horizontal or vertical\n// 4. Check if we have exactly 2 horizontal and 2 vertical segments\n// 5. Verify they form a rectangle by checking coordinates match properly\n\nimport ballerina/io;\n\ntype Segment record {\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n};\n\n// Normalize segment so that the smaller coordinate comes first\nfunction normalizeSegment(Segment seg) returns Segment {\n    if seg.x1 == seg.x2 {\n        // Vertical segment - normalize by y\n        if seg.y1 > seg.y2 {\n            return {x1: seg.x1, y1: seg.y2, x2: seg.x2, y2: seg.y1};\n        }\n    } else {\n        // Horizontal or diagonal - normalize by x\n        if seg.x1 > seg.x2 {\n            return {x1: seg.x2, y1: seg.y2, x2: seg.x1, y2: seg.y1};\n        }\n    }\n    return seg;\n}\n\nfunction isRectangle(Segment[] segments) returns boolean {\n    if segments.length() != 4 {\n        return false;\n    }\n    \n    // Normalize all segments\n    Segment[] normalized = [];\n    foreach Segment seg in segments {\n        normalized.push(normalizeSegment(seg));\n    }\n    \n    // Separate into horizontal and vertical segments\n    Segment[] horizontal = [];\n    Segment[] vertical = [];\n    \n    foreach Segment seg in normalized {\n        if seg.y1 == seg.y2 {\n            // Horizontal segment\n            if seg.x1 == seg.x2 {\n                // Degenerate point\n                return false;\n            }\n            horizontal.push(seg);\n        } else if seg.x1 == seg.x2 {\n            // Vertical segment\n            if seg.y1 == seg.y2 {\n                // Degenerate point (already handled above)\n                return false;\n            }\n            vertical.push(seg);\n        } else {\n            // Diagonal segment - not allowed\n            return false;\n        }\n    }\n    \n    // Must have exactly 2 horizontal and 2 vertical\n    if horizontal.length() != 2 || vertical.length() != 2 {\n        return false;\n    }\n    \n    // Check horizontal segments\n    Segment h1 = horizontal[0];\n    Segment h2 = horizontal[1];\n    \n    // Both should have same x-range\n    if h1.x1 != h2.x1 || h1.x2 != h2.x2 {\n        return false;\n    }\n    \n    // They should be at different y-coordinates\n    if h1.y1 == h2.y1 {\n        return false;\n    }\n    \n    int minY = h1.y1 < h2.y1 ? h1.y1 : h2.y1;\n    int maxY = h1.y1 > h2.y1 ? h1.y1 : h2.y1;\n    int minX = h1.x1;\n    int maxX = h1.x2;\n    \n    // Check vertical segments\n    Segment v1 = vertical[0];\n    Segment v2 = vertical[1];\n    \n    // Both should have same y-range\n    if v1.y1 != v2.y1 || v1.y2 != v2.y2 {\n        return false;\n    }\n    \n    // They should be at different x-coordinates\n    if v1.x1 == v2.x1 {\n        return false;\n    }\n    \n    // Check if vertical segments match the horizontal segments' coordinates\n    if v1.y1 != minY || v1.y2 != maxY {\n        return false;\n    }\n    \n    int vMinX = v1.x1 < v2.x1 ? v1.x1 : v2.x1;\n    int vMaxX = v1.x1 > v2.x1 ? v1.x1 : v2.x1;\n    \n    if vMinX != minX || vMaxX != maxX {\n        return false;\n    }\n    \n    // Check positive area\n    int width = maxX - minX;\n    int height = maxY - minY;\n    \n    if width <= 0 || height <= 0 {\n        return false;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    Segment[] segments = [];\n    \n    // Read 4 lines of input\n    int i = 0;\n    while i < 4 {\n        string? line = io:readln();\n        if line is string {\n            string[] parts = re`\\s+`.split(line.trim());\n            if parts.length() == 4 {\n                int|error x1 = int:fromString(parts[0]);\n                int|error y1 = int:fromString(parts[1]);\n                int|error x2 = int:fromString(parts[2]);\n                int|error y2 = int:fromString(parts[3]);\n                \n                if x1 is int && y1 is int && x2 is int && y2 is int {\n                    segments.push({x1: x1, y1: y1, x2: x2, y2: y2});\n                    i += 1;\n                } else {\n                    return error(\"Invalid integer input\");\n                }\n            } else {\n                return error(\"Invalid input format\");\n            }\n        } else {\n            return error(\"Failed to read input\");\n        }\n    }\n    \n    boolean result = isRectangle(segments);\n    io:println(result ? \"YES\" : \"NO\");\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testValidRectangle() {\n    Segment[] segments = [\n        {x1: 1, y1: 1, x2: 6, y2: 1},\n        {x1: 1, y1: 0, x2: 6, y2: 0},\n        {x1: 6, y1: 0, x2: 6, y2: 1},\n        {x1: 1, y1: 1, x2: 1, y2: 0}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, true, \"Should form a valid rectangle\");\n}\n\n@test:Config {}\nfunction testInvalidRectangle() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 0, y2: 3},\n        {x1: 2, y1: 0, x2: 0, y2: 0},\n        {x1: 2, y1: 2, x2: 2, y2: 0},\n        {x1: 0, y1: 2, x2: 2, y2: 2}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, false, \"Should not form a valid rectangle\");\n}\n\n@test:Config {}\nfunction testDegenerateSegment() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 0, y2: 0},\n        {x1: 0, y1: 0, x2: 1, y2: 0},\n        {x1: 1, y1: 0, x2: 1, y2: 1},\n        {x1: 0, y1: 1, x2: 1, y2: 1}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, false, \"Degenerate segments should not form rectangle\");\n}\n\n@test:Config {}\nfunction testSimpleRectangle() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 2, y2: 0},\n        {x1: 0, y1: 3, x2: 2, y2: 3},\n        {x1: 0, y1: 0, x2: 0, y2: 3},\n        {x1: 2, y1: 0, x2: 2, y2: 3}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, true, \"Should form a valid 2x3 rectangle\");\n}\n\n@test:Config {}\nfunction testDiagonalSegment() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 1, y2: 1},\n        {x1: 0, y1: 1, x2: 1, y2: 1},\n        {x1: 0, y1: 0, x2: 0, y2: 1},\n        {x1: 1, y1: 0, x2: 1, y2: 1}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, false, \"Diagonal segments should not form valid rectangle\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// A valid rectangle with sides parallel to axes must have:\n// - Exactly 2 horizontal segments (same y-coordinates for both endpoints)\n// - Exactly 2 vertical segments (same x-coordinates for both endpoints)\n// - The horizontal segments must have the same length and different y-coordinates\n// - The vertical segments must have the same length and different x-coordinates\n// - The segments must connect to form a closed rectangle\n// - The rectangle must have positive area\n//\n// Strategy:\n// 1. Read and parse 4 segments\n// 2. Normalize each segment (ensure point1 <= point2)\n// 3. Classify segments as horizontal or vertical\n// 4. Check if we have exactly 2 horizontal and 2 vertical segments\n// 5. Verify they form a rectangle by checking coordinates match properly\n\nimport ballerina/io;\n\ntype Segment record {\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n};\n\n// Normalize segment so that the smaller coordinate comes first\nfunction normalizeSegment(Segment seg) returns Segment {\n    if seg.x1 == seg.x2 {\n        // Vertical segment - normalize by y\n        if seg.y1 > seg.y2 {\n            return {x1: seg.x1, y1: seg.y2, x2: seg.x2, y2: seg.y1};\n        }\n    } else {\n        // Horizontal or diagonal - normalize by x\n        if seg.x1 > seg.x2 {\n            return {x1: seg.x2, y1: seg.y2, x2: seg.x1, y2: seg.y1};\n        }\n    }\n    return seg;\n}\n\nfunction isRectangle(Segment[] segments) returns boolean {\n    if segments.length() != 4 {\n        return false;\n    }\n    \n    // Normalize all segments\n    Segment[] normalized = [];\n    foreach Segment seg in segments {\n        normalized.push(normalizeSegment(seg));\n    }\n    \n    // Separate into horizontal and vertical segments\n    Segment[] horizontal = [];\n    Segment[] vertical = [];\n    \n    foreach Segment seg in normalized {\n        if seg.y1 == seg.y2 {\n            // Horizontal segment\n            if seg.x1 == seg.x2 {\n                // Degenerate point\n                return false;\n            }\n            horizontal.push(seg);\n        } else if seg.x1 == seg.x2 {\n            // Vertical segment\n            if seg.y1 == seg.y2 {\n                // Degenerate point (already handled above)\n                return false;\n            }\n            vertical.push(seg);\n        } else {\n            // Diagonal segment - not allowed\n            return false;\n        }\n    }\n    \n    // Must have exactly 2 horizontal and 2 vertical\n    if horizontal.length() != 2 || vertical.length() != 2 {\n        return false;\n    }\n    \n    // Check horizontal segments\n    Segment h1 = horizontal[0];\n    Segment h2 = horizontal[1];\n    \n    // Both should have same x-range\n    if h1.x1 != h2.x1 || h1.x2 != h2.x2 {\n        return false;\n    }\n    \n    // They should be at different y-coordinates\n    if h1.y1 == h2.y1 {\n        return false;\n    }\n    \n    int minY = h1.y1 < h2.y1 ? h1.y1 : h2.y1;\n    int maxY = h1.y1 > h2.y1 ? h1.y1 : h2.y1;\n    int minX = h1.x1;\n    int maxX = h1.x2;\n    \n    // Check vertical segments\n    Segment v1 = vertical[0];\n    Segment v2 = vertical[1];\n    \n    // Both should have same y-range\n    if v1.y1 != v2.y1 || v1.y2 != v2.y2 {\n        return false;\n    }\n    \n    // They should be at different x-coordinates\n    if v1.x1 == v2.x1 {\n        return false;\n    }\n    \n    // Check if vertical segments match the horizontal segments' coordinates\n    if v1.y1 != minY || v1.y2 != maxY {\n        return false;\n    }\n    \n    int vMinX = v1.x1 < v2.x1 ? v1.x1 : v2.x1;\n    int vMaxX = v1.x1 > v2.x1 ? v1.x1 : v2.x1;\n    \n    if vMinX != minX || vMaxX != maxX {\n        return false;\n    }\n    \n    // Check positive area\n    int width = maxX - minX;\n    int height = maxY - minY;\n    \n    if width <= 0 || height <= 0 {\n        return false;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    Segment[] segments = [];\n    \n    // Read 4 lines of input\n    int i = 0;\n    while i < 4 {\n        string? line = io:readln();\n        if line is string {\n            string[] parts = re`\\s+`.split(line.trim());\n            if parts.length() == 4 {\n                int|error x1 = int:fromString(parts[0]);\n                int|error y1 = int:fromString(parts[1]);\n                int|error x2 = int:fromString(parts[2]);\n                int|error y2 = int:fromString(parts[3]);\n                \n                if x1 is int && y1 is int && x2 is int && y2 is int {\n                    segments.push({x1: x1, y1: y1, x2: x2, y2: y2});\n                    i += 1;\n                } else {\n                    return error(\"Invalid integer input\");\n                }\n            } else {\n                return error(\"Invalid input format\");\n            }\n        } else {\n            return error(\"Failed to read input\");\n        }\n    }\n    \n    boolean result = isRectangle(segments);\n    io:println(result ? \"YES\" : \"NO\");\n    \n    return;\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:45:16.629098",
      "status": "success",
      "completion": "# Overview\nThis problem requires checking if four given line segments form a rectangle with positive area and sides parallel to coordinate axes. The approach is to:\n1. Parse the four segments from input\n2. Classify each segment as horizontal or vertical (parallel to axes)\n3. Verify we have exactly 2 horizontal and 2 vertical segments\n4. Check that the segments form a closed rectangle with positive area\n5. Ensure all segments are edges of the rectangle (no extra length)\n\n<CODE>\n```ballerina\n// Reasoning:\n// A valid rectangle with sides parallel to axes must have:\n// - Exactly 2 horizontal segments (same y-coordinates for both endpoints)\n// - Exactly 2 vertical segments (same x-coordinates for both endpoints)\n// - The horizontal segments must have the same length and different y-coordinates\n// - The vertical segments must have the same length and different x-coordinates\n// - The segments must connect to form a closed rectangle\n// - The rectangle must have positive area\n//\n// Strategy:\n// 1. Read and parse 4 segments\n// 2. Normalize each segment (ensure point1 <= point2)\n// 3. Classify segments as horizontal or vertical\n// 4. Check if we have exactly 2 horizontal and 2 vertical segments\n// 5. Verify they form a rectangle by checking coordinates match properly\n\nimport ballerina/io;\n\ntype Segment record {\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n};\n\n// Normalize segment so that the smaller coordinate comes first\nfunction normalizeSegment(Segment seg) returns Segment {\n    if seg.x1 == seg.x2 {\n        // Vertical segment - normalize by y\n        if seg.y1 > seg.y2 {\n            return {x1: seg.x1, y1: seg.y2, x2: seg.x2, y2: seg.y1};\n        }\n    } else {\n        // Horizontal or diagonal - normalize by x\n        if seg.x1 > seg.x2 {\n            return {x1: seg.x2, y1: seg.y2, x2: seg.x1, y2: seg.y1};\n        }\n    }\n    return seg;\n}\n\nfunction isRectangle(Segment[] segments) returns boolean {\n    if segments.length() != 4 {\n        return false;\n    }\n    \n    // Normalize all segments\n    Segment[] normalized = [];\n    foreach Segment seg in segments {\n        normalized.push(normalizeSegment(seg));\n    }\n    \n    // Separate into horizontal and vertical segments\n    Segment[] horizontal = [];\n    Segment[] vertical = [];\n    \n    foreach Segment seg in normalized {\n        if seg.y1 == seg.y2 {\n            // Horizontal segment\n            if seg.x1 == seg.x2 {\n                // Degenerate point\n                return false;\n            }\n            horizontal.push(seg);\n        } else if seg.x1 == seg.x2 {\n            // Vertical segment\n            if seg.y1 == seg.y2 {\n                // Degenerate point (already handled above)\n                return false;\n            }\n            vertical.push(seg);\n        } else {\n            // Diagonal segment - not allowed\n            return false;\n        }\n    }\n    \n    // Must have exactly 2 horizontal and 2 vertical\n    if horizontal.length() != 2 || vertical.length() != 2 {\n        return false;\n    }\n    \n    // Check horizontal segments\n    Segment h1 = horizontal[0];\n    Segment h2 = horizontal[1];\n    \n    // Both should have same x-range\n    if h1.x1 != h2.x1 || h1.x2 != h2.x2 {\n        return false;\n    }\n    \n    // They should be at different y-coordinates\n    if h1.y1 == h2.y1 {\n        return false;\n    }\n    \n    int minY = h1.y1 < h2.y1 ? h1.y1 : h2.y1;\n    int maxY = h1.y1 > h2.y1 ? h1.y1 : h2.y1;\n    int minX = h1.x1;\n    int maxX = h1.x2;\n    \n    // Check vertical segments\n    Segment v1 = vertical[0];\n    Segment v2 = vertical[1];\n    \n    // Both should have same y-range\n    if v1.y1 != v2.y1 || v1.y2 != v2.y2 {\n        return false;\n    }\n    \n    // They should be at different x-coordinates\n    if v1.x1 == v2.x1 {\n        return false;\n    }\n    \n    // Check if vertical segments match the horizontal segments' coordinates\n    if v1.y1 != minY || v1.y2 != maxY {\n        return false;\n    }\n    \n    int vMinX = v1.x1 < v2.x1 ? v1.x1 : v2.x1;\n    int vMaxX = v1.x1 > v2.x1 ? v1.x1 : v2.x1;\n    \n    if vMinX != minX || vMaxX != maxX {\n        return false;\n    }\n    \n    // Check positive area\n    int width = maxX - minX;\n    int height = maxY - minY;\n    \n    if width <= 0 || height <= 0 {\n        return false;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    Segment[] segments = [];\n    \n    // Read 4 lines of input\n    int i = 0;\n    while i < 4 {\n        string? line = io:readln();\n        if line is string {\n            string[] parts = re`\\s+`.split(line.trim());\n            if parts.length() == 4 {\n                int|error x1 = int:fromString(parts[0]);\n                int|error y1 = int:fromString(parts[1]);\n                int|error x2 = int:fromString(parts[2]);\n                int|error y2 = int:fromString(parts[3]);\n                \n                if x1 is int && y1 is int && x2 is int && y2 is int {\n                    segments.push({x1: x1, y1: y1, x2: x2, y2: y2});\n                    i += 1;\n                } else {\n                    return error(\"Invalid integer input\");\n                }\n            } else {\n                return error(\"Invalid input format\");\n            }\n        } else {\n            return error(\"Failed to read input\");\n        }\n    }\n    \n    boolean result = isRectangle(segments);\n    io:println(result ? \"YES\" : \"NO\");\n    \n    return;\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testValidRectangle() {\n    Segment[] segments = [\n        {x1: 1, y1: 1, x2: 6, y2: 1},\n        {x1: 1, y1: 0, x2: 6, y2: 0},\n        {x1: 6, y1: 0, x2: 6, y2: 1},\n        {x1: 1, y1: 1, x2: 1, y2: 0}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, true, \"Should form a valid rectangle\");\n}\n\n@test:Config {}\nfunction testInvalidRectangle() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 0, y2: 3},\n        {x1: 2, y1: 0, x2: 0, y2: 0},\n        {x1: 2, y1: 2, x2: 2, y2: 0},\n        {x1: 0, y1: 2, x2: 2, y2: 2}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, false, \"Should not form a valid rectangle\");\n}\n\n@test:Config {}\nfunction testDegenerateSegment() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 0, y2: 0},\n        {x1: 0, y1: 0, x2: 1, y2: 0},\n        {x1: 1, y1: 0, x2: 1, y2: 1},\n        {x1: 0, y1: 1, x2: 1, y2: 1}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, false, \"Degenerate segments should not form rectangle\");\n}\n\n@test:Config {}\nfunction testSimpleRectangle() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 2, y2: 0},\n        {x1: 0, y1: 3, x2: 2, y2: 3},\n        {x1: 0, y1: 0, x2: 0, y2: 3},\n        {x1: 2, y1: 0, x2: 2, y2: 3}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, true, \"Should form a valid 2x3 rectangle\");\n}\n\n@test:Config {}\nfunction testDiagonalSegment() {\n    Segment[] segments = [\n        {x1: 0, y1: 0, x2: 1, y2: 1},\n        {x1: 0, y1: 1, x2: 1, y2: 1},\n        {x1: 0, y1: 0, x2: 0, y2: 1},\n        {x1: 1, y1: 0, x2: 1, y2: 1}\n    ];\n    boolean result = isRectangle(segments);\n    test:assertEquals(result, false, \"Diagonal segments should not form valid rectangle\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// A valid rectangle with sides parallel to axes must have:\n// - Exactly 2 horizontal segments (same y-coordinates for both endpoints)\n// - Exactly 2 vertical segments (same x-coordinates for both endpoints)\n// - The horizontal segments must have the same length and different y-coordinates\n// - The vertical segments must have the same length and different x-coordinates\n// - The segments must connect to form a closed rectangle\n// - The rectangle must have positive area\n//\n// Strategy:\n// 1. Read and parse 4 segments\n// 2. Normalize each segment (ensure point1 <= point2)\n// 3. Classify segments as horizontal or vertical\n// 4. Check if we have exactly 2 horizontal and 2 vertical segments\n// 5. Verify they form a rectangle by checking coordinates match properly\n\nimport ballerina/io;\n\ntype Segment record {\n    int x1;\n    int y1;\n    int x2;\n    int y2;\n};\n\n// Normalize segment so that the smaller coordinate comes first\nfunction normalizeSegment(Segment seg) returns Segment {\n    if seg.x1 == seg.x2 {\n        // Vertical segment - normalize by y\n        if seg.y1 > seg.y2 {\n            return {x1: seg.x1, y1: seg.y2, x2: seg.x2, y2: seg.y1};\n        }\n    } else {\n        // Horizontal or diagonal - normalize by x\n        if seg.x1 > seg.x2 {\n            return {x1: seg.x2, y1: seg.y2, x2: seg.x1, y2: seg.y1};\n        }\n    }\n    return seg;\n}\n\nfunction isRectangle(Segment[] segments) returns boolean {\n    if segments.length() != 4 {\n        return false;\n    }\n    \n    // Normalize all segments\n    Segment[] normalized = [];\n    foreach Segment seg in segments {\n        normalized.push(normalizeSegment(seg));\n    }\n    \n    // Separate into horizontal and vertical segments\n    Segment[] horizontal = [];\n    Segment[] vertical = [];\n    \n    foreach Segment seg in normalized {\n        if seg.y1 == seg.y2 {\n            // Horizontal segment\n            if seg.x1 == seg.x2 {\n                // Degenerate point\n                return false;\n            }\n            horizontal.push(seg);\n        } else if seg.x1 == seg.x2 {\n            // Vertical segment\n            if seg.y1 == seg.y2 {\n                // Degenerate point (already handled above)\n                return false;\n            }\n            vertical.push(seg);\n        } else {\n            // Diagonal segment - not allowed\n            return false;\n        }\n    }\n    \n    // Must have exactly 2 horizontal and 2 vertical\n    if horizontal.length() != 2 || vertical.length() != 2 {\n        return false;\n    }\n    \n    // Check horizontal segments\n    Segment h1 = horizontal[0];\n    Segment h2 = horizontal[1];\n    \n    // Both should have same x-range\n    if h1.x1 != h2.x1 || h1.x2 != h2.x2 {\n        return false;\n    }\n    \n    // They should be at different y-coordinates\n    if h1.y1 == h2.y1 {\n        return false;\n    }\n    \n    int minY = h1.y1 < h2.y1 ? h1.y1 : h2.y1;\n    int maxY = h1.y1 > h2.y1 ? h1.y1 : h2.y1;\n    int minX = h1.x1;\n    int maxX = h1.x2;\n    \n    // Check vertical segments\n    Segment v1 = vertical[0];\n    Segment v2 = vertical[1];\n    \n    // Both should have same y-range\n    if v1.y1 != v2.y1 || v1.y2 != v2.y2 {\n        return false;\n    }\n    \n    // They should be at different x-coordinates\n    if v1.x1 == v2.x1 {\n        return false;\n    }\n    \n    // Check if vertical segments match the horizontal segments' coordinates\n    if v1.y1 != minY || v1.y2 != maxY {\n        return false;\n    }\n    \n    int vMinX = v1.x1 < v2.x1 ? v1.x1 : v2.x1;\n    int vMaxX = v1.x1 > v2.x1 ? v1.x1 : v2.x1;\n    \n    if vMinX != minX || vMaxX != maxX {\n        return false;\n    }\n    \n    // Check positive area\n    int width = maxX - minX;\n    int height = maxY - minY;\n    \n    if width <= 0 || height <= 0 {\n        return false;\n    }\n    \n    return true;\n}\n\npublic function main() returns error? {\n    Segment[] segments = [];\n    \n    // Read 4 lines of input\n    int i = 0;\n    while i < 4 {\n        string? line = io:readln();\n        if line is string {\n            string[] parts = re`\\s+`.split(line.trim());\n            if parts.length() == 4 {\n                int|error x1 = int:fromString(parts[0]);\n                int|error y1 = int:fromString(parts[1]);\n                int|error x2 = int:fromString(parts[2]);\n                int|error y2 = int:fromString(parts[3]);\n                \n                if x1 is int && y1 is int && x2 is int && y2 is int {\n                    segments.push({x1: x1, y1: y1, x2: x2, y2: y2});\n                    i += 1;\n                } else {\n                    return error(\"Invalid integer input\");\n                }\n            } else {\n                return error(\"Invalid input format\");\n            }\n        } else {\n            return error(\"Failed to read input\");\n        }\n    }\n    \n    boolean result = isRectangle(segments);\n    io:println(result ? \"YES\" : \"NO\");\n    \n    return;\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T02:45:58.816505"
}