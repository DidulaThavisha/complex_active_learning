{
  "entry_id": "problem_0016",
  "problem_index": 16,
  "prompt": "Title: Help Victoria the Wise\n\nTime Limit: 1 seconds\n\nMemory Limit: 256 megabytes\n\nProblem Description:\nVasilisa the Wise from a far away kingdom got a present from her friend Helga the Wise from a farther away kingdom. The present is a surprise box, yet Vasilisa the Wise doesn't know yet what the surprise actually is because she cannot open the box. She hopes that you can help her in that.\n\nThe box's lock is constructed like that. The box itself is represented by an absolutely perfect black cube with the identical deepening on each face (those are some foreign nanotechnologies that the far away kingdom scientists haven't dreamt of). The box is accompanied by six gems whose form matches the deepenings in the box's faces. The box can only be opened after it is correctly decorated by the gems, that is, when each deepening contains exactly one gem. Two ways of decorating the box are considered the same if they can be obtained one from the other one by arbitrarily rotating the box (note that the box is represented by a perfect nanotechnological cube)\n\nNow Vasilisa the Wise wants to know by the given set of colors the following: in how many ways would she decorate the box in the worst case to open it? To answer this question it is useful to know that two gems of one color are indistinguishable from each other. Help Vasilisa to solve this challenging problem.\n\nInput Specification:\nThe first line contains exactly 6 characters without spaces from the set {R, O, Y, G, B, V} — they are the colors of gems with which the box should be decorated.\n\nOutput Specification:\nPrint the required number of different ways to decorate the box.\n\nDemo Input:\n['YYYYYY\\n', 'BOOOOB\\n', 'ROYGBV\\n']\n\nDemo Output:\n['1\\n', '2\\n', '30\\n']\n\nNote:\nnone",
  "rating": 1700,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:12:23.274472",
      "status": "failed",
      "completion": "# Overview\n\nThis problem is about counting distinct ways to decorate a cube with 6 colored gems, where rotations of the cube are considered identical. This is a classic application of Burnside's lemma (also known as the Cauchy-Frobenius lemma) from group theory.\n\nThe rotation group of a cube has 24 elements:\n- 1 identity rotation\n- 6 face rotations (90° and 270° around each of 3 axes)\n- 3 face rotations (180° around each of 3 axes)\n- 8 vertex rotations (120° and 240° around each of 4 body diagonals)\n- 6 edge rotations (180° around each of 6 edge-to-edge axes)\n\nFor each rotation, we count how many colorings remain unchanged under that rotation, then average across all rotations.\n\n<CODE>\n```ballerina\n// Reasoning:\n// This is a Burnside's lemma problem for counting distinct cube colorings under rotation.\n// \n// The cube has 24 rotational symmetries:\n// - 1 identity: all 6 faces stay fixed\n// - 6 rotations by 90° and 270° around face centers (3 axes × 2 rotations): creates 2 cycles\n// - 3 rotations by 180° around face centers: creates 3 cycles of 2\n// - 8 rotations by 120° and 240° around vertices (4 diagonals × 2): creates 2 cycles of 3\n// - 6 rotations by 180° around edge midpoints: creates 3 cycles of 2\n//\n// For each symmetry, count colorings fixed by that symmetry by checking if colors\n// in each cycle are identical. The answer is the average over all 24 symmetries.\n\nimport ballerina/io;\n\n// Count frequency of each color in the input\nfunction countColors(string colors) returns map<int> {\n    map<int> freq = {};\n    foreach int i in 0 ..< colors.length() {\n        string char = colors.substring(i, i + 1);\n        if freq.hasKey(char) {\n            freq[char] = freq.get(char) + 1;\n        } else {\n            freq[char] = 1;\n        }\n    }\n    return freq;\n}\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    foreach int i in 2 ... n {\n        result *= i;\n    }\n    return result;\n}\n\n// Count arrangements with given cycle structure\nfunction countWithCycles(map<int> colorFreq, int[] cycleSizes) returns int {\n    // We need to assign colors to cycles such that all positions in a cycle get the same color\n    // This is equivalent to partitioning the colors according to cycle sizes\n    \n    int[]freqs = [];\n    foreach int freq in colorFreq {\n        freqs.push(freq);\n    }\n    \n    // Use dynamic programming to count valid assignments\n    return countAssignments(freqs, cycleSizes, 0, 0);\n}\n\n// Recursively count assignments of colors to cycles\nfunction countAssignments(int[] colorFreqs, int[] cycleSizes, int cycleIdx, int colorIdx) returns int {\n    if cycleIdx >= cycleSizes.length() {\n        return 1; // All cycles assigned\n    }\n    \n    if colorIdx >= colorFreqs.length() {\n        return 0; // No more colors available\n    }\n    \n    int needed = cycleSizes[cycleIdx];\n    int available = colorFreqs[colorIdx];\n    \n    int count = 0;\n    \n    // Try not using current color for this cycle\n    count += countAssignments(colorFreqs, cycleSizes, cycleIdx, colorIdx + 1);\n    \n    // Try using current color if enough available\n    if available >= needed {\n        int[] newFreqs = colorFreqs.clone();\n        newFreqs[colorIdx] = available - needed;\n        count += countAssignments(newFreqs, cycleSizes, cycleIdx + 1, colorIdx);\n    }\n    \n    return count;\n}\n\nfunction countCubeColorings(string colors) returns int|error {\n    if colors.length() != 6 {\n        return error(\"Input must have exactly 6 colors\");\n    }\n    \n    map<int> colorFreq = countColors(colors);\n    \n    int total = 0;\n    \n    // Identity: 6 cycles of size 1\n    total += countWithCycles(colorFreq, [1, 1, 1, 1, 1, 1]);\n    \n    // 90° and 270° face rotations (6 total): 2 cycles - one of size 4, one of size 2\n    total += 6 * countWithCycles(colorFreq, [4, 2]);\n    \n    // 180° face rotations (3 total): 3 cycles of size 2\n    total += 3 * countWithCycles(colorFreq, [2, 2, 2]);\n    \n    // 120° and 240° vertex rotations (8 total): 2 cycles of size 3\n    total += 8 * countWithCycles(colorFreq, [3, 3]);\n    \n    // 180° edge rotations (6 total): 3 cycles of size 2\n    total += 6 * countWithCycles(colorFreq, [2, 2, 2]);\n    \n    // Apply Burnside's lemma: divide by group size (24)\n    return total / 24;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter 6 colors (R, O, Y, G, B, V): \");\n    \n    if input_line is string {\n        string colors = input_line.trim();\n        \n        int|error result = countCubeColorings(colors);\n        \n        if result is int {\n            io:println(result);\n        } else {\n            io:println(\"Error: \" + result.message());\n        }\n    } else {\n        io:println(\"Error: Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testAllSameColor() {\n    int|error result = countCubeColorings(\"YYYYYY\");\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testTwoColors() {\n    int|error result = countCubeColorings(\"BOOOOB\");\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testAllDifferentColors() {\n    int|error result = countCubeColorings(\"ROYGBV\");\n    test:assertEquals(result, 30);\n}\n\n@test:Config {}\nfunction testThreeColors() {\n    int|error result = countCubeColorings(\"RRRRYY\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertTrue(result > 0);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// This is a Burnside's lemma problem for counting distinct cube colorings under rotation.\n// \n// The cube has 24 rotational symmetries:\n// - 1 identity: all 6 faces stay fixed\n// - 6 rotations by 90° and 270° around face centers (3 axes × 2 rotations): creates 2 cycles\n// - 3 rotations by 180° around face centers: creates 3 cycles of 2\n// - 8 rotations by 120° and 240° around vertices (4 diagonals × 2): creates 2 cycles of 3\n// - 6 rotations by 180° around edge midpoints: creates 3 cycles of 2\n//\n// For each symmetry, count colorings fixed by that symmetry by checking if colors\n// in each cycle are identical. The answer is the average over all 24 symmetries.\n\nimport ballerina/io;\n\n// Count frequency of each color in the input\nfunction countColors(string colors) returns map<int> {\n    map<int> freq = {};\n    foreach int i in 0 ..< colors.length() {\n        string char = colors.substring(i, i + 1);\n        if freq.hasKey(char) {\n            freq[char] = freq.get(char) + 1;\n        } else {\n            freq[char] = 1;\n        }\n    }\n    return freq;\n}\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    foreach int i in 2 ... n {\n        result *= i;\n    }\n    return result;\n}\n\n// Count arrangements with given cycle structure\nfunction countWithCycles(map<int> colorFreq, int[] cycleSizes) returns int {\n    // We need to assign colors to cycles such that all positions in a cycle get the same color\n    // This is equivalent to partitioning the colors according to cycle sizes\n    \n    int[]freqs = [];\n    foreach int freq in colorFreq {\n        freqs.push(freq);\n    }\n    \n    // Use dynamic programming to count valid assignments\n    return countAssignments(freqs, cycleSizes, 0, 0);\n}\n\n// Recursively count assignments of colors to cycles\nfunction countAssignments(int[] colorFreqs, int[] cycleSizes, int cycleIdx, int colorIdx) returns int {\n    if cycleIdx >= cycleSizes.length() {\n        return 1; // All cycles assigned\n    }\n    \n    if colorIdx >= colorFreqs.length() {\n        return 0; // No more colors available\n    }\n    \n    int needed = cycleSizes[cycleIdx];\n    int available = colorFreqs[colorIdx];\n    \n    int count = 0;\n    \n    // Try not using current color for this cycle\n    count += countAssignments(colorFreqs, cycleSizes, cycleIdx, colorIdx + 1);\n    \n    // Try using current color if enough available\n    if available >= needed {\n        int[] newFreqs = colorFreqs.clone();\n        newFreqs[colorIdx] = available - needed;\n        count += countAssignments(newFreqs, cycleSizes, cycleIdx + 1, colorIdx);\n    }\n    \n    return count;\n}\n\nfunction countCubeColorings(string colors) returns int|error {\n    if colors.length() != 6 {\n        return error(\"Input must have exactly 6 colors\");\n    }\n    \n    map<int> colorFreq = countColors(colors);\n    \n    int total = 0;\n    \n    // Identity: 6 cycles of size 1\n    total += countWithCycles(colorFreq, [1, 1, 1, 1, 1, 1]);\n    \n    // 90° and 270° face rotations (6 total): 2 cycles - one of size 4, one of size 2\n    total += 6 * countWithCycles(colorFreq, [4, 2]);\n    \n    // 180° face rotations (3 total): 3 cycles of size 2\n    total += 3 * countWithCycles(colorFreq, [2, 2, 2]);\n    \n    // 120° and 240° vertex rotations (8 total): 2 cycles of size 3\n    total += 8 * countWithCycles(colorFreq, [3, 3]);\n    \n    // 180° edge rotations (6 total): 3 cycles of size 2\n    total += 6 * countWithCycles(colorFreq, [2, 2, 2]);\n    \n    // Apply Burnside's lemma: divide by group size (24)\n    return total / 24;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter 6 colors (R, O, Y, G, B, V): \");\n    \n    if input_line is string {\n        string colors = input_line.trim();\n        \n        int|error result = countCubeColorings(colors);\n        \n        if result is int {\n            io:println(result);\n        } else {\n            io:println(\"Error: \" + result.message());\n        }\n    } else {\n        io:println(\"Error: Failed to read input\");\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/3 tests (0.0%), need 75%",
      "error": "Only passed 0/3 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "YYYYYY\n",
          "expected_output": "1\n",
          "actual_output": "Enter 6 colors (R, O, Y, G, B, V): 1\n",
          "error": "Output mismatch"
        }
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:13:06.316749",
      "status": "failed",
      "completion": "Looking at the error, I can see two main issues:\n1. The prompt text \"Enter 6 colors...\" should not be present - we just need to read and output\n2. My Burnside's lemma implementation has a bug in the cycle counting logic\n\nLet me trace through the logic more carefully:\n- For Burnside's lemma, I need to count fixed colorings under each rotation\n- A coloring is fixed if all faces in each cycle have the same color\n- I need to count how many ways to assign colors to cycles, where a cycle of size k requires k gems of the same color\n\nThe key issue is in my `countWithCycles` function - I need to properly count partitions of the color multiset according to cycle structure.\n\n# Overview\n\nThis problem counts distinct ways to color a cube's 6 faces considering rotational symmetry. We use Burnside's lemma which states: the number of distinct objects = (1/|G|) × Σ(fixed points under each group element), where G is the rotation group.\n\nThe cube's rotation group has 24 elements with different cycle structures on the 6 faces. For each rotation type, we count colorings that remain unchanged (faces in same cycle must have same color).\n\n<CODE>\n```ballerina\n// Reasoning:\n// Apply Burnside's lemma to count distinct cube colorings under rotation.\n// \n// Cube rotation group has 24 symmetries with these cycle structures:\n// - 1 identity: [1,1,1,1,1,1] - 6 independent faces\n// - 6 face 90°/270°: [1,1,4] - 2 opposite faces fixed, 4 rotating\n// - 3 face 180°: [2,2,2] - 3 pairs of opposite faces swapping\n// - 8 vertex 120°/240°: [3,3] - 2 groups of 3 faces cycling\n// - 6 edge 180°: [2,2,2] - 3 pairs swapping\n//\n// For each symmetry, count colorings where all faces in a cycle have same color.\n// This requires partitioning our color multiset to match cycle sizes.\n\nimport ballerina/io;\n\n// Compute how many ways to partition colors into groups of specified sizes\nfunction countPartitions(int[] colorCounts, int[] cycleSizes) returns int {\n    // Sort both arrays for consistent processing\n    int[] sortedCycles = cycleSizes.clone();\n    sortedCycles.sort();\n    \n    return partitionHelper(colorCounts.clone(), sortedCycles, 0);\n}\n\nfunction partitionHelper(int[] colorCounts, int[] cycleSizes, int cycleIndex) returns int {\n    if cycleIndex >= cycleSizes.length() {\n        return 1; // Successfully assigned all cycles\n    }\n    \n    int needed = cycleSizes[cycleIndex];\n    int ways = 0;\n    \n    // Try each color that has enough gems for this cycle\n    foreach int i in 0 ..< colorCounts.length() {\n        if colorCounts[i] >= needed {\n            int[] newCounts = colorCounts.clone();\n            newCounts[i] = newCounts[i] - needed;\n            ways += partitionHelper(newCounts, cycleSizes, cycleIndex + 1);\n        }\n    }\n    \n    return ways;\n}\n\nfunction countCubeColorings(string colors) returns int|error {\n    if colors.length() != 6 {\n        return error(\"Input must have exactly 6 colors\");\n    }\n    \n    // Count frequency of each color\n    map<int> freqMap = {};\n    foreach int i in 0 ..< 6 {\n        string c = colors.substring(i, i + 1);\n        if freqMap.hasKey(c) {\n            freqMap[c] = freqMap.get(c) + 1;\n        } else {\n            freqMap[c] = 1;\n        }\n    }\n    \n    // Convert to array of counts\n    int[] colorCounts = [];\n    foreach int count in freqMap {\n        colorCounts.push(count);\n    }\n    \n    int total = 0;\n    \n    // 1 identity rotation: all faces independent\n    total += countPartitions(colorCounts, [1, 1, 1, 1, 1, 1]);\n    \n    // 6 face rotations (90° and 270°): cycle structure [1, 1, 4]\n    // 2 opposite faces fixed, 4 faces form a cycle\n    total += 6 * countPartitions(colorCounts, [1, 1, 4]);\n    \n    // 3 face rotations (180°): cycle structure [2, 2, 2]\n    // 3 pairs of opposite faces\n    total += 3 * countPartitions(colorCounts, [2, 2, 2]);\n    \n    // 8 vertex rotations (120° and 240°): cycle structure [3, 3]\n    // 2 groups of 3 faces each\n    total += 8 * countPartitions(colorCounts, [3, 3]);\n    \n    // 6 edge rotations (180°): cycle structure [2, 2, 2]\n    // 3 pairs of faces\n    total += 6 * countPartitions(colorCounts, [2, 2, 2]);\n    \n    // Burnside's lemma: divide by group order\n    return total / 24;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string colors = input_line.trim();\n        \n        int|error result = countCubeColorings(colors);\n        \n        if result is int {\n            io:println(result);\n        } else {\n            return result;\n        }\n    } else {\n        return error(\"Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testAllSameColor() {\n    int|error result = countCubeColorings(\"YYYYYY\");\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testTwoColors() {\n    int|error result = countCubeColorings(\"BOOOOB\");\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testAllDifferentColors() {\n    int|error result = countCubeColorings(\"ROYGBV\");\n    test:assertEquals(result, 30);\n}\n\n@test:Config {}\nfunction testSymmetricPattern() {\n    int|error result = countCubeColorings(\"RRGGBB\");\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertTrue(result > 0 && result <= 30);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// Apply Burnside's lemma to count distinct cube colorings under rotation.\n// \n// Cube rotation group has 24 symmetries with these cycle structures:\n// - 1 identity: [1,1,1,1,1,1] - 6 independent faces\n// - 6 face 90°/270°: [1,1,4] - 2 opposite faces fixed, 4 rotating\n// - 3 face 180°: [2,2,2] - 3 pairs of opposite faces swapping\n// - 8 vertex 120°/240°: [3,3] - 2 groups of 3 faces cycling\n// - 6 edge 180°: [2,2,2] - 3 pairs swapping\n//\n// For each symmetry, count colorings where all faces in a cycle have same color.\n// This requires partitioning our color multiset to match cycle sizes.\n\nimport ballerina/io;\n\n// Compute how many ways to partition colors into groups of specified sizes\nfunction countPartitions(int[] colorCounts, int[] cycleSizes) returns int {\n    // Sort both arrays for consistent processing\n    int[] sortedCycles = cycleSizes.clone();\n    sortedCycles.sort();\n    \n    return partitionHelper(colorCounts.clone(), sortedCycles, 0);\n}\n\nfunction partitionHelper(int[] colorCounts, int[] cycleSizes, int cycleIndex) returns int {\n    if cycleIndex >= cycleSizes.length() {\n        return 1; // Successfully assigned all cycles\n    }\n    \n    int needed = cycleSizes[cycleIndex];\n    int ways = 0;\n    \n    // Try each color that has enough gems for this cycle\n    foreach int i in 0 ..< colorCounts.length() {\n        if colorCounts[i] >= needed {\n            int[] newCounts = colorCounts.clone();\n            newCounts[i] = newCounts[i] - needed;\n            ways += partitionHelper(newCounts, cycleSizes, cycleIndex + 1);\n        }\n    }\n    \n    return ways;\n}\n\nfunction countCubeColorings(string colors) returns int|error {\n    if colors.length() != 6 {\n        return error(\"Input must have exactly 6 colors\");\n    }\n    \n    // Count frequency of each color\n    map<int> freqMap = {};\n    foreach int i in 0 ..< 6 {\n        string c = colors.substring(i, i + 1);\n        if freqMap.hasKey(c) {\n            freqMap[c] = freqMap.get(c) + 1;\n        } else {\n            freqMap[c] = 1;\n        }\n    }\n    \n    // Convert to array of counts\n    int[] colorCounts = [];\n    foreach int count in freqMap {\n        colorCounts.push(count);\n    }\n    \n    int total = 0;\n    \n    // 1 identity rotation: all faces independent\n    total += countPartitions(colorCounts, [1, 1, 1, 1, 1, 1]);\n    \n    // 6 face rotations (90° and 270°): cycle structure [1, 1, 4]\n    // 2 opposite faces fixed, 4 faces form a cycle\n    total += 6 * countPartitions(colorCounts, [1, 1, 4]);\n    \n    // 3 face rotations (180°): cycle structure [2, 2, 2]\n    // 3 pairs of opposite faces\n    total += 3 * countPartitions(colorCounts, [2, 2, 2]);\n    \n    // 8 vertex rotations (120° and 240°): cycle structure [3, 3]\n    // 2 groups of 3 faces each\n    total += 8 * countPartitions(colorCounts, [3, 3]);\n    \n    // 6 edge rotations (180°): cycle structure [2, 2, 2]\n    // 3 pairs of faces\n    total += 6 * countPartitions(colorCounts, [2, 2, 2]);\n    \n    // Burnside's lemma: divide by group order\n    return total / 24;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string colors = input_line.trim();\n        \n        int|error result = countCubeColorings(colors);\n        \n        if result is int {\n            io:println(result);\n        } else {\n            return result;\n        }\n    } else {\n        return error(\"Failed to read input\");\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(20:5,20:25)] variable assignment is required\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(20:5,20:25)] variable assignment is required\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(20:5,20:25)] variable assignment is required\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(20:5,20:25)] variable assignment is required\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T00:14:33.284037"
}