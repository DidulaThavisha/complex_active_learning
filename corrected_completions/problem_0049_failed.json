{
  "entry_id": "problem_0049",
  "problem_index": 49,
  "prompt": "Title: Three-level Laser\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nAn atom of element X can exist in *n* distinct states with energies *E*1<=&lt;<=*E*2<=&lt;<=...<=&lt;<=*E**n*. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. \n\nThree distinct states *i*, *j* and *k* are selected, where *i*<=&lt;<=*j*<=&lt;<=*k*. After that the following process happens: \n 1.  initially the atom is in the state *i*,1.  we spend *E**k*<=-<=*E**i* energy to put the atom in the state *k*,1.  the atom emits a photon with useful energy *E**k*<=-<=*E**j* and changes its state to the state *j*,1.  the atom spontaneously changes its state to the state *i*, losing energy *E**j*<=-<=*E**i*,1.  the process repeats from step 1. \nLet's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.\n\nDue to some limitations, Arkady can only choose such three states that *E**k*<=-<=*E**i*<=≤<=*U*.\n\nHelp Arkady to find such the maximum possible energy conversion efficiency within the above constraints.\n\nInput Specification:\nThe first line contains two integers *n* and *U* (3<=≤<=*n*<=≤<=105, 1<=≤<=*U*<=≤<=109) — the number of states and the maximum possible difference between *E**k* and *E**i*.\n\nThe second line contains a sequence of integers *E*1,<=*E*2,<=...,<=*E**n* (1<=≤<=*E*1<=&lt;<=*E*2...<=&lt;<=*E**n*<=≤<=109). It is guaranteed that all *E**i* are given in increasing order.\n\nOutput Specification:\nIf it is not possible to choose three states that satisfy all constraints, print -1.\n\nOtherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10<=-<=9.\n\nFormally, let your answer be *a*, and the jury's answer be *b*. Your answer is considered correct if .\n\nDemo Input:\n['4 4\\n1 3 5 7\\n', '10 8\\n10 13 15 16 17 19 20 22 24 25\\n', '3 1\\n2 5 10\\n']\n\nDemo Output:\n['0.5\\n', '0.875\\n', '-1\\n']\n\nNote:\nIn the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/147ae7a830722917b0aa37d064df8eb74cfefb97.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/>.\n\nIn the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/f68f268de4eb2242167e6ec64e6b8aa60a5703ae.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/>.",
  "rating": 1600,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:47:46.141989",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find three distinct energy states i, j, k (where i < j < k) from a sorted array such that:\n1. E[k] - E[i] ≤ U (constraint)\n2. The efficiency η = (E[k] - E[j]) / (E[k] - E[i]) is maximized\n\nThe efficiency is maximized when E[j] is as close to E[k] as possible while E[i] is as far from E[k] as possible (within the constraint). We need to check all valid triplets.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to find three indices i < j < k where E[k] - E[i] <= U\n// 2. Efficiency = (E[k] - E[j]) / (E[k] - E[i])\n// 3. To maximize efficiency, we want E[j] close to E[k] and E[i] far from E[k]\n// 4. For each possible k, we find the leftmost valid i (where E[k] - E[i] <= U)\n// 5. Then for each valid i, we try j = k-1 (closest to k) since that maximizes numerator\n// 6. We can optimize by iterating through all k values and finding valid i values\n// 7. For each pair (i,k), the best j is k-1 if i < k-1, ensuring i < j < k\n\nimport ballerina/io;\n\nfunction findMaxEfficiency(int n, int u, int[] energies) returns float|error {\n    float maxEfficiency = -1.0;\n    \n    // Try all possible combinations of i, j, k where i < j < k\n    int i = 0;\n    while i < n - 2 {\n        int k = i + 2;\n        while k < n {\n            int diff = energies[k] - energies[i];\n            \n            // Check if this pair (i, k) satisfies the constraint\n            if diff <= u {\n                // Try all j between i and k\n                int j = i + 1;\n                while j < k {\n                    float numerator = <float>(energies[k] - energies[j]);\n                    float denominator = <float>(energies[k] - energies[i]);\n                    \n                    if denominator > 0.0 {\n                        float efficiency = numerator / denominator;\n                        if efficiency > maxEfficiency {\n                            maxEfficiency = efficiency;\n                        }\n                    }\n                    j = j + 1;\n                }\n            }\n            k = k + 1;\n        }\n        i = i + 1;\n    }\n    \n    return maxEfficiency;\n}\n\npublic function main() returns error? {\n    // Read first line: n and U\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int u = check 'int:fromString(parts1[1]);\n    \n    // Read second line: energy levels\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of energy levels\");\n    }\n    \n    int[] energies = [];\n    foreach string part in parts2 {\n        int energy = check 'int:fromString(part);\n        energies.push(energy);\n    }\n    \n    // Find maximum efficiency\n    float|error result = findMaxEfficiency(n, u, energies);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        if result < 0.0 {\n            io:println(\"-1\");\n        } else {\n            io:println(result);\n        }\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] energies = [1, 3, 5, 7];\n    float|error result = findMaxEfficiency(4, 4, energies);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertEquals(result, 0.5, msg = \"Example 1 failed\");\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] energies = [10, 13, 15, 16, 17, 19, 20, 22, 24, 25];\n    float|error result = findMaxEfficiency(10, 8, energies);\n    test:assertTrue(result is float);\n    if result is float {\n        // States 4,5,9 (indices 3,4,8): (24-17)/(24-16) = 7/8 = 0.875\n        test:assertTrue(result >= 0.874 && result <= 0.876, msg = \"Example 2 failed\");\n    }\n}\n\n@test:Config {}\nfunction testExample3() {\n    int[] energies = [2, 5, 10];\n    float|error result = findMaxEfficiency(3, 1, energies);\n    test:assertTrue(result is float);\n    if result is float {\n        test:assertEquals(result, -1.0, msg = \"Example 3 should return -1\");\n    }\n}\n\n@test:Config {}\nfunction testMinimalCase() {\n    int[] energies = [1, 2, 3];\n    float|error result = findMaxEfficiency(3, 10, energies);\n    test:assertTrue(result is float);\n    if result is float {\n        // i=0, j=1, k=2: (3-2)/(3-1) = 1/2 = 0.5\n        test:assertEquals(result, 0.5, msg = \"Minimal case failed\");\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need to find three indices i < j < k where E[k] - E[i] <= U\n// 2. Efficiency = (E[k] - E[j]) / (E[k] - E[i])\n// 3. To maximize efficiency, we want E[j] close to E[k] and E[i] far from E[k]\n// 4. For each possible k, we find the leftmost valid i (where E[k] - E[i] <= U)\n// 5. Then for each valid i, we try j = k-1 (closest to k) since that maximizes numerator\n// 6. We can optimize by iterating through all k values and finding valid i values\n// 7. For each pair (i,k), the best j is k-1 if i < k-1, ensuring i < j < k\n\nimport ballerina/io;\n\nfunction findMaxEfficiency(int n, int u, int[] energies) returns float|error {\n    float maxEfficiency = -1.0;\n    \n    // Try all possible combinations of i, j, k where i < j < k\n    int i = 0;\n    while i < n - 2 {\n        int k = i + 2;\n        while k < n {\n            int diff = energies[k] - energies[i];\n            \n            // Check if this pair (i, k) satisfies the constraint\n            if diff <= u {\n                // Try all j between i and k\n                int j = i + 1;\n                while j < k {\n                    float numerator = <float>(energies[k] - energies[j]);\n                    float denominator = <float>(energies[k] - energies[i]);\n                    \n                    if denominator > 0.0 {\n                        float efficiency = numerator / denominator;\n                        if efficiency > maxEfficiency {\n                            maxEfficiency = efficiency;\n                        }\n                    }\n                    j = j + 1;\n                }\n            }\n            k = k + 1;\n        }\n        i = i + 1;\n    }\n    \n    return maxEfficiency;\n}\n\npublic function main() returns error? {\n    // Read first line: n and U\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int u = check 'int:fromString(parts1[1]);\n    \n    // Read second line: energy levels\n    string? line2 = io:readln();\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of energy levels\");\n    }\n    \n    int[] energies = [];\n    foreach string part in parts2 {\n        int energy = check 'int:fromString(part);\n        energies.push(energy);\n    }\n    \n    // Find maximum efficiency\n    float|error result = findMaxEfficiency(n, u, energies);\n    \n    if result is error {\n        io:println(\"-1\");\n    } else {\n        if result < 0.0 {\n            io:println(\"-1\");\n        } else {\n            io:println(result);\n        }\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(54:36,54:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(68:36,68:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(54:36,54:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(68:36,68:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(54:36,54:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(68:36,68:41)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:48:11.903559",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find three distinct energy states i, j, k (where i < j < k) from a sorted array such that:\n1. E[k] - E[i] ≤ U (constraint)\n2. The efficiency η = (E[k] - E[j]) / (E[k] - E[i]) is maximized\n\nThe key insight is that for a fixed pair (i, k), the efficiency is maximized when j is as close to k as possible (j = k-1). We iterate through all valid (i, k) pairs and check if there's a valid j between them.\n\nThe compilation error was due to using `split()` method incorrectly. In Ballerina, we need to use `regex:split()` from the `ballerina/regex` module or use `string:split()`.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need three indices i < j < k where E[k] - E[i] <= U\n// 2. Efficiency = (E[k] - E[j]) / (E[k] - E[i])\n// 3. To maximize efficiency: maximize numerator and minimize denominator\n//    - For fixed (i,k), best j is k-1 (closest to k, maximizing E[k] - E[j])\n// 4. Algorithm: iterate all valid (i,k) pairs where E[k]-E[i] <= U\n//    - For each such pair with i+2 <= k, set j = k-1\n//    - Calculate efficiency and track maximum\n// 5. Return -1 if no valid triplet exists\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction findMaxEfficiency(int n, int u, int[] energies) returns float {\n    float maxEfficiency = -1.0;\n    \n    // Try all possible pairs (i, k) where i < k\n    int i = 0;\n    while i < n - 2 {\n        int k = i + 2;\n        while k < n {\n            int diff = energies[k] - energies[i];\n            \n            // Check if this pair (i, k) satisfies the constraint E[k] - E[i] <= U\n            if diff <= u {\n                // For this valid (i,k) pair, try j = k-1 for maximum efficiency\n                // We need i < j < k, so j must be at least i+1 and at most k-1\n                int j = k - 1;\n                if j > i {\n                    float numerator = <float>(energies[k] - energies[j]);\n                    float denominator = <float>(energies[k] - energies[i]);\n                    \n                    if denominator > 0.0 {\n                        float efficiency = numerator / denominator;\n                        if efficiency > maxEfficiency {\n                            maxEfficiency = efficiency;\n                        }\n                    }\n                }\n            } else {\n                // Since energies are sorted, if E[k] - E[i] > U,\n                // then for this i, all larger k will also violate constraint\n                break;\n            }\n            k = k + 1;\n        }\n        i = i + 1;\n    }\n    \n    return maxEfficiency;\n}\n\npublic function main() returns error? {\n    // Read first line: n and U\n    string? line1 = io:readln(\"Enter n and U: \");\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int u = check 'int:fromString(parts1[1]);\n    \n    // Validate input\n    if n < 3 {\n        return error(\"n must be at least 3\");\n    }\n    \n    // Read second line: energy levels\n    string? line2 = io:readln(\"Enter energy levels: \");\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of energy levels\");\n    }\n    \n    int[] energies = [];\n    foreach string part in parts2 {\n        int energy = check 'int:fromString(part.trim());\n        energies.push(energy);\n    }\n    \n    // Find maximum efficiency\n    float result = findMaxEfficiency(n, u, energies);\n    \n    if result < 0.0 {\n        io:println(\"-1\");\n    } else {\n        io:println(result);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // States 1,2,3 (indices 0,1,2): E=[1,3,5,7]\n    // Efficiency = (5-3)/(5-1) = 2/4 = 0.5\n    int[] energies = [1, 3, 5, 7];\n    float result = findMaxEfficiency(4, 4, energies);\n    test:assertEquals(result, 0.5, msg = \"Example 1 failed\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    // States 4,5,9 (indices 3,4,8): E[3]=16, E[4]=17, E[8]=24\n    // Efficiency = (24-17)/(24-16) = 7/8 = 0.875\n    int[] energies = [10, 13, 15, 16, 17, 19, 20, 22, 24, 25];\n    float result = findMaxEfficiency(10, 8, energies);\n    test:assertTrue(result >= 0.874 && result <= 0.876, msg = \"Example 2 failed\");\n}\n\n@test:Config {}\nfunction testExample3() {\n    // No valid triplet where E[k] - E[i] <= 1\n    // Min difference for 3 elements: 10-2 = 8 > 1\n    int[] energies = [2, 5, 10];\n    float result = findMaxEfficiency(3, 1, energies);\n    test:assertEquals(result, -1.0, msg = \"Example 3 should return -1\");\n}\n\n@test:Config {}\nfunction testMinimalCase() {\n    // i=0, j=1, k=2: E=[1,2,3]\n    // Efficiency = (3-2)/(3-1) = 1/2 = 0.5\n    int[] energies = [1, 2, 3];\n    float result = findMaxEfficiency(3, 10, energies);\n    test:assertEquals(result, 0.5, msg = \"Minimal case failed\");\n}\n\n@test:Config {}\nfunction testLargeConstraint() {\n    // With large U, all triplets are valid\n    // Best is i=0, j=2, k=3: (10-7)/(10-1) = 3/9 = 0.333...\n    int[] energies = [1, 3, 7, 10];\n    float result = findMaxEfficiency(4, 100, energies);\n    test:assertTrue(result > 0.33 && result < 0.34, msg = \"Large constraint case failed\");\n}\n\n@test:Config {}\nfunction testEqualSpacing() {\n    // Equal spacing: [5, 10, 15, 20]\n    // Best with U=15: i=0, j=2, k=3: (20-15)/(20-5) = 5/15 = 0.333...\n    int[] energies = [5, 10, 15, 20];\n    float result = findMaxEfficiency(4, 15, energies);\n    test:assertTrue(result > 0.33 && result < 0.34, msg = \"Equal spacing case failed\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need three indices i < j < k where E[k] - E[i] <= U\n// 2. Efficiency = (E[k] - E[j]) / (E[k] - E[i])\n// 3. To maximize efficiency: maximize numerator and minimize denominator\n//    - For fixed (i,k), best j is k-1 (closest to k, maximizing E[k] - E[j])\n// 4. Algorithm: iterate all valid (i,k) pairs where E[k]-E[i] <= U\n//    - For each such pair with i+2 <= k, set j = k-1\n//    - Calculate efficiency and track maximum\n// 5. Return -1 if no valid triplet exists\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction findMaxEfficiency(int n, int u, int[] energies) returns float {\n    float maxEfficiency = -1.0;\n    \n    // Try all possible pairs (i, k) where i < k\n    int i = 0;\n    while i < n - 2 {\n        int k = i + 2;\n        while k < n {\n            int diff = energies[k] - energies[i];\n            \n            // Check if this pair (i, k) satisfies the constraint E[k] - E[i] <= U\n            if diff <= u {\n                // For this valid (i,k) pair, try j = k-1 for maximum efficiency\n                // We need i < j < k, so j must be at least i+1 and at most k-1\n                int j = k - 1;\n                if j > i {\n                    float numerator = <float>(energies[k] - energies[j]);\n                    float denominator = <float>(energies[k] - energies[i]);\n                    \n                    if denominator > 0.0 {\n                        float efficiency = numerator / denominator;\n                        if efficiency > maxEfficiency {\n                            maxEfficiency = efficiency;\n                        }\n                    }\n                }\n            } else {\n                // Since energies are sorted, if E[k] - E[i] > U,\n                // then for this i, all larger k will also violate constraint\n                break;\n            }\n            k = k + 1;\n        }\n        i = i + 1;\n    }\n    \n    return maxEfficiency;\n}\n\npublic function main() returns error? {\n    // Read first line: n and U\n    string? line1 = io:readln(\"Enter n and U: \");\n    if line1 is () {\n        return error(\"Failed to read first line\");\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int u = check 'int:fromString(parts1[1]);\n    \n    // Validate input\n    if n < 3 {\n        return error(\"n must be at least 3\");\n    }\n    \n    // Read second line: energy levels\n    string? line2 = io:readln(\"Enter energy levels: \");\n    if line2 is () {\n        return error(\"Failed to read second line\");\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        return error(\"Invalid number of energy levels\");\n    }\n    \n    int[] energies = [];\n    foreach string part in parts2 {\n        int energy = check 'int:fromString(part.trim());\n        energies.push(energy);\n    }\n    \n    // Find maximum efficiency\n    float result = findMaxEfficiency(n, u, energies);\n    \n    if result < 0.0 {\n        io:println(\"-1\");\n    } else {\n        io:println(result);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/3 tests (0.0%), need 75%",
      "error": "Only passed 0/3 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4 4\n1 3 5 7\n",
          "expected_output": "0.5\n",
          "actual_output": "Enter n and U: Enter energy levels: 0.5\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/3 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T00:48:52.477992"
}