{
  "entry_id": "problem_0008",
  "problem_index": 8,
  "prompt": "Title: Petya and Exam\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nIt's hard times now. Today Petya needs to score 100 points on Informatics exam. The tasks seem easy to Petya, but he thinks he lacks time to finish them all, so he asks you to help with one..\n\nThere is a glob pattern in the statements (a string consisting of lowercase English letters, characters \"?\" and \"*\"). It is known that character \"*\" occurs no more than once in the pattern.\n\nAlso, *n* query strings are given, it is required to determine for each of them if the pattern matches it or not.\n\nEverything seemed easy to Petya, but then he discovered that the special pattern characters differ from their usual meaning.\n\nA pattern matches a string if it is possible to replace each character \"?\" with one good lowercase English letter, and the character \"*\" (if there is one) with any, including empty, string of bad lowercase English letters, so that the resulting string is the same as the given string.\n\nThe good letters are given to Petya. All the others are bad.\n\nInput Specification:\nThe first line contains a string with length from 1 to 26 consisting of distinct lowercase English letters. These letters are good letters, all the others are bad.\n\nThe second line contains the pattern — a string *s* of lowercase English letters, characters \"?\" and \"*\" (1<=≤<=|*s*|<=≤<=105). It is guaranteed that character \"*\" occurs in *s* no more than once.\n\nThe third line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of query strings.\n\n*n* lines follow, each of them contains single non-empty string consisting of lowercase English letters — a query string.\n\nIt is guaranteed that the total length of all query strings is not greater than 105.\n\nOutput Specification:\nPrint *n* lines: in the *i*-th of them print \"YES\" if the pattern matches the *i*-th query string, and \"NO\" otherwise.\n\nYou can choose the case (lower or upper) for each letter arbitrary.\n\nDemo Input:\n['ab\\na?a\\n2\\naaa\\naab\\n', 'abc\\na?a?a*\\n4\\nabacaba\\nabaca\\napapa\\naaaaax\\n']\n\nDemo Output:\n['YES\\nNO\\n', 'NO\\nYES\\nNO\\nYES\\n']\n\nNote:\nIn the first example we can replace \"?\" with good letters \"a\" and \"b\", so we can see that the answer for the first query is \"YES\", and the answer for the second query is \"NO\", because we can't match the third letter.\n\nExplanation of the second example. \n -  The first query: \"NO\", because character \"*\" can be replaced with a string of bad letters only, but the only way to match the query string is to replace it with the string \"ba\", in which both letters are good. -  The second query: \"YES\", because characters \"?\" can be replaced with corresponding good letters, and character \"*\" can be replaced with empty string, and the strings will coincide. -  The third query: \"NO\", because characters \"?\" can't be replaced with bad letters. -  The fourth query: \"YES\", because characters \"?\" can be replaced with good letters \"a\", and character \"*\" can be replaced with a string of bad letters \"x\".",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem requires pattern matching with special rules:\n- '?' matches one good letter\n- '*' matches zero or more bad letters (occurs at most once)\n- Regular characters must match exactly\n\nThe solution involves splitting the pattern at '*' (if present), then checking if the query string can be matched by validating:\n1. The prefix before '*' matches with good letters for '?'\n2. The suffix after '*' matches with good letters for '?'\n3. The middle part (matched by '*') contains only bad letters\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse good letters into a set for O(1) lookup\n// 2. If pattern contains '*', split it into prefix and suffix\n// 3. For each query string:\n//    - Check length constraints based on pattern\n//    - Match prefix: each '?' must match a good letter, regular chars must match exactly\n//    - Match suffix: same rules as prefix\n//    - Middle part (if '*' exists): must contain only bad letters\n// 4. If no '*', simple matching with exact length and '?' rules\n\nimport ballerina/io;\n\nfunction isGoodLetter(string letter, map<boolean> goodLetters) returns boolean {\n    return goodLetters.hasKey(letter);\n}\n\nfunction matchesPattern(string pattern, string query, map<boolean> goodLetters) returns boolean {\n    // Find position of '*' if it exists\n    int starPos = -1;\n    int i = 0;\n    while i < pattern.length() {\n        if pattern[i] == \"*\" {\n            starPos = i;\n            break;\n        }\n        i += 1;\n    }\n    \n    if starPos == -1 {\n        // No '*' - exact length match required\n        if pattern.length() != query.length() {\n            return false;\n        }\n        \n        int j = 0;\n        while j < pattern.length() {\n            string patChar = pattern[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        return true;\n    } else {\n        // Has '*' - split into prefix and suffix\n        string prefix = pattern.substring(0, starPos);\n        string suffix = pattern.substring(starPos + 1, pattern.length());\n        \n        int minLen = prefix.length() + suffix.length();\n        if query.length() < minLen {\n            return false;\n        }\n        \n        // Match prefix\n        int j = 0;\n        while j < prefix.length() {\n            string patChar = prefix[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Match suffix (from end)\n        j = 0;\n        while j < suffix.length() {\n            string patChar = suffix[suffix.length() - 1 - j].toString();\n            string queryChar = query[query.length() - 1 - j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Check middle part (matched by '*') contains only bad letters\n        int startMiddle = prefix.length();\n        int endMiddle = query.length() - suffix.length();\n        \n        j = startMiddle;\n        while j < endMiddle {\n            string queryChar = query[j].toString();\n            if isGoodLetter(queryChar, goodLetters) {\n                return false;\n            }\n            j += 1;\n        }\n        \n        return true;\n    }\n}\n\npublic function main() returns error? {\n    // Read good letters\n    string? goodLettersLine = io:readln();\n    if goodLettersLine is () {\n        return;\n    }\n    \n    map<boolean> goodLetters = {};\n    int i = 0;\n    while i < goodLettersLine.length() {\n        string letter = goodLettersLine[i].toString();\n        goodLetters[letter] = true;\n        i += 1;\n    }\n    \n    // Read pattern\n    string? pattern = io:readln();\n    if pattern is () {\n        return;\n    }\n    \n    // Read number of queries\n    string? nLine = io:readln();\n    if nLine is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(nLine);\n    if n is error {\n        return;\n    }\n    \n    // Process each query\n    int j = 0;\n    while j < n {\n        string? query = io:readln();\n        if query is () {\n            break;\n        }\n        \n        if matchesPattern(pattern, query, goodLetters) {\n            io:println(\"YES\");\n        } else {\n            io:println(\"NO\");\n        }\n        j += 1;\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    map<boolean> goodLetters = {\"a\": true, \"b\": true};\n    string pattern = \"a?a\";\n    \n    boolean result1 = matchesPattern(pattern, \"aaa\", goodLetters);\n    test:assertEquals(result1, true, \"aaa should match a?a with good letters a,b\");\n    \n    boolean result2 = matchesPattern(pattern, \"aab\", goodLetters);\n    test:assertEquals(result2, false, \"aab should not match a?a\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    map<boolean> goodLetters = {\"a\": true, \"b\": true, \"c\": true};\n    string pattern = \"a?a?a*\";\n    \n    boolean result1 = matchesPattern(pattern, \"abacaba\", goodLetters);\n    test:assertEquals(result1, false, \"abacaba should not match (ba contains good letters)\");\n    \n    boolean result2 = matchesPattern(pattern, \"abaca\", goodLetters);\n    test:assertEquals(result2, true, \"abaca should match (empty * string)\");\n    \n    boolean result3 = matchesPattern(pattern, \"apapa\", goodLetters);\n    test:assertEquals(result3, false, \"apapa should not match (p is bad letter in ? position)\");\n    \n    boolean result4 = matchesPattern(pattern, \"aaaaax\", goodLetters);\n    test:assertEquals(result4, true, \"aaaaax should match (x is bad letter for *)\");\n}\n\n@test:Config {}\nfunction testNoStar() {\n    map<boolean> goodLetters = {\"x\": true, \"y\": true, \"z\": true};\n    string pattern = \"x?z\";\n    \n    boolean result1 = matchesPattern(pattern, \"xyz\", goodLetters);\n    test:assertEquals(result1, true, \"xyz should match x?z\");\n    \n    boolean result2 = matchesPattern(pattern, \"xaz\", goodLetters);\n    test:assertEquals(result2, false, \"xaz should not match (a is bad letter)\");\n}\n\n@test:Config {}\nfunction testStarOnly() {\n    map<boolean> goodLetters = {\"a\": true};\n    string pattern = \"*\";\n    \n    boolean result1 = matchesPattern(pattern, \"bcd\", goodLetters);\n    test:assertEquals(result1, true, \"bcd should match * (all bad letters)\");\n    \n    boolean result2 = matchesPattern(pattern, \"abc\", goodLetters);\n    test:assertEquals(result2, false, \"abc should not match * (contains good letter)\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Parse good letters into a set for O(1) lookup\n// 2. If pattern contains '*', split it into prefix and suffix\n// 3. For each query string:\n//    - Check length constraints based on pattern\n//    - Match prefix: each '?' must match a good letter, regular chars must match exactly\n//    - Match suffix: same rules as prefix\n//    - Middle part (if '*' exists): must contain only bad letters\n// 4. If no '*', simple matching with exact length and '?' rules\n\nimport ballerina/io;\n\nfunction isGoodLetter(string letter, map<boolean> goodLetters) returns boolean {\n    return goodLetters.hasKey(letter);\n}\n\nfunction matchesPattern(string pattern, string query, map<boolean> goodLetters) returns boolean {\n    // Find position of '*' if it exists\n    int starPos = -1;\n    int i = 0;\n    while i < pattern.length() {\n        if pattern[i] == \"*\" {\n            starPos = i;\n            break;\n        }\n        i += 1;\n    }\n    \n    if starPos == -1 {\n        // No '*' - exact length match required\n        if pattern.length() != query.length() {\n            return false;\n        }\n        \n        int j = 0;\n        while j < pattern.length() {\n            string patChar = pattern[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        return true;\n    } else {\n        // Has '*' - split into prefix and suffix\n        string prefix = pattern.substring(0, starPos);\n        string suffix = pattern.substring(starPos + 1, pattern.length());\n        \n        int minLen = prefix.length() + suffix.length();\n        if query.length() < minLen {\n            return false;\n        }\n        \n        // Match prefix\n        int j = 0;\n        while j < prefix.length() {\n            string patChar = prefix[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Match suffix (from end)\n        j = 0;\n        while j < suffix.length() {\n            string patChar = suffix[suffix.length() - 1 - j].toString();\n            string queryChar = query[query.length() - 1 - j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Check middle part (matched by '*') contains only bad letters\n        int startMiddle = prefix.length();\n        int endMiddle = query.length() - suffix.length();\n        \n        j = startMiddle;\n        while j < endMiddle {\n            string queryChar = query[j].toString();\n            if isGoodLetter(queryChar, goodLetters) {\n                return false;\n            }\n            j += 1;\n        }\n        \n        return true;\n    }\n}\n\npublic function main() returns error? {\n    // Read good letters\n    string? goodLettersLine = io:readln();\n    if goodLettersLine is () {\n        return;\n    }\n    \n    map<boolean> goodLetters = {};\n    int i = 0;\n    while i < goodLettersLine.length() {\n        string letter = goodLettersLine[i].toString();\n        goodLetters[letter] = true;\n        i += 1;\n    }\n    \n    // Read pattern\n    string? pattern = io:readln();\n    if pattern is () {\n        return;\n    }\n    \n    // Read number of queries\n    string? nLine = io:readln();\n    if nLine is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(nLine);\n    if n is error {\n        return;\n    }\n    \n    // Process each query\n    int j = 0;\n    while j < n {\n        string? query = io:readln();\n        if query is () {\n            break;\n        }\n        \n        if matchesPattern(pattern, query, goodLetters) {\n            io:println(\"YES\");\n        } else {\n            io:println(\"NO\");\n        }\n        j += 1;\n    }\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:03:57.958407",
      "status": "success",
      "completion": "# Overview\nThis problem requires pattern matching with special rules:\n- '?' matches one good letter\n- '*' matches zero or more bad letters (occurs at most once)\n- Regular characters must match exactly\n\nThe solution involves splitting the pattern at '*' (if present), then checking if the query string can be matched by validating:\n1. The prefix before '*' matches with good letters for '?'\n2. The suffix after '*' matches with good letters for '?'\n3. The middle part (matched by '*') contains only bad letters\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse good letters into a set for O(1) lookup\n// 2. If pattern contains '*', split it into prefix and suffix\n// 3. For each query string:\n//    - Check length constraints based on pattern\n//    - Match prefix: each '?' must match a good letter, regular chars must match exactly\n//    - Match suffix: same rules as prefix\n//    - Middle part (if '*' exists): must contain only bad letters\n// 4. If no '*', simple matching with exact length and '?' rules\n\nimport ballerina/io;\n\nfunction isGoodLetter(string letter, map<boolean> goodLetters) returns boolean {\n    return goodLetters.hasKey(letter);\n}\n\nfunction matchesPattern(string pattern, string query, map<boolean> goodLetters) returns boolean {\n    // Find position of '*' if it exists\n    int starPos = -1;\n    int i = 0;\n    while i < pattern.length() {\n        if pattern[i] == \"*\" {\n            starPos = i;\n            break;\n        }\n        i += 1;\n    }\n    \n    if starPos == -1 {\n        // No '*' - exact length match required\n        if pattern.length() != query.length() {\n            return false;\n        }\n        \n        int j = 0;\n        while j < pattern.length() {\n            string patChar = pattern[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        return true;\n    } else {\n        // Has '*' - split into prefix and suffix\n        string prefix = pattern.substring(0, starPos);\n        string suffix = pattern.substring(starPos + 1, pattern.length());\n        \n        int minLen = prefix.length() + suffix.length();\n        if query.length() < minLen {\n            return false;\n        }\n        \n        // Match prefix\n        int j = 0;\n        while j < prefix.length() {\n            string patChar = prefix[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Match suffix (from end)\n        j = 0;\n        while j < suffix.length() {\n            string patChar = suffix[suffix.length() - 1 - j].toString();\n            string queryChar = query[query.length() - 1 - j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Check middle part (matched by '*') contains only bad letters\n        int startMiddle = prefix.length();\n        int endMiddle = query.length() - suffix.length();\n        \n        j = startMiddle;\n        while j < endMiddle {\n            string queryChar = query[j].toString();\n            if isGoodLetter(queryChar, goodLetters) {\n                return false;\n            }\n            j += 1;\n        }\n        \n        return true;\n    }\n}\n\npublic function main() returns error? {\n    // Read good letters\n    string? goodLettersLine = io:readln();\n    if goodLettersLine is () {\n        return;\n    }\n    \n    map<boolean> goodLetters = {};\n    int i = 0;\n    while i < goodLettersLine.length() {\n        string letter = goodLettersLine[i].toString();\n        goodLetters[letter] = true;\n        i += 1;\n    }\n    \n    // Read pattern\n    string? pattern = io:readln();\n    if pattern is () {\n        return;\n    }\n    \n    // Read number of queries\n    string? nLine = io:readln();\n    if nLine is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(nLine);\n    if n is error {\n        return;\n    }\n    \n    // Process each query\n    int j = 0;\n    while j < n {\n        string? query = io:readln();\n        if query is () {\n            break;\n        }\n        \n        if matchesPattern(pattern, query, goodLetters) {\n            io:println(\"YES\");\n        } else {\n            io:println(\"NO\");\n        }\n        j += 1;\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    map<boolean> goodLetters = {\"a\": true, \"b\": true};\n    string pattern = \"a?a\";\n    \n    boolean result1 = matchesPattern(pattern, \"aaa\", goodLetters);\n    test:assertEquals(result1, true, \"aaa should match a?a with good letters a,b\");\n    \n    boolean result2 = matchesPattern(pattern, \"aab\", goodLetters);\n    test:assertEquals(result2, false, \"aab should not match a?a\");\n}\n\n@test:Config {}\nfunction testExample2() {\n    map<boolean> goodLetters = {\"a\": true, \"b\": true, \"c\": true};\n    string pattern = \"a?a?a*\";\n    \n    boolean result1 = matchesPattern(pattern, \"abacaba\", goodLetters);\n    test:assertEquals(result1, false, \"abacaba should not match (ba contains good letters)\");\n    \n    boolean result2 = matchesPattern(pattern, \"abaca\", goodLetters);\n    test:assertEquals(result2, true, \"abaca should match (empty * string)\");\n    \n    boolean result3 = matchesPattern(pattern, \"apapa\", goodLetters);\n    test:assertEquals(result3, false, \"apapa should not match (p is bad letter in ? position)\");\n    \n    boolean result4 = matchesPattern(pattern, \"aaaaax\", goodLetters);\n    test:assertEquals(result4, true, \"aaaaax should match (x is bad letter for *)\");\n}\n\n@test:Config {}\nfunction testNoStar() {\n    map<boolean> goodLetters = {\"x\": true, \"y\": true, \"z\": true};\n    string pattern = \"x?z\";\n    \n    boolean result1 = matchesPattern(pattern, \"xyz\", goodLetters);\n    test:assertEquals(result1, true, \"xyz should match x?z\");\n    \n    boolean result2 = matchesPattern(pattern, \"xaz\", goodLetters);\n    test:assertEquals(result2, false, \"xaz should not match (a is bad letter)\");\n}\n\n@test:Config {}\nfunction testStarOnly() {\n    map<boolean> goodLetters = {\"a\": true};\n    string pattern = \"*\";\n    \n    boolean result1 = matchesPattern(pattern, \"bcd\", goodLetters);\n    test:assertEquals(result1, true, \"bcd should match * (all bad letters)\");\n    \n    boolean result2 = matchesPattern(pattern, \"abc\", goodLetters);\n    test:assertEquals(result2, false, \"abc should not match * (contains good letter)\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse good letters into a set for O(1) lookup\n// 2. If pattern contains '*', split it into prefix and suffix\n// 3. For each query string:\n//    - Check length constraints based on pattern\n//    - Match prefix: each '?' must match a good letter, regular chars must match exactly\n//    - Match suffix: same rules as prefix\n//    - Middle part (if '*' exists): must contain only bad letters\n// 4. If no '*', simple matching with exact length and '?' rules\n\nimport ballerina/io;\n\nfunction isGoodLetter(string letter, map<boolean> goodLetters) returns boolean {\n    return goodLetters.hasKey(letter);\n}\n\nfunction matchesPattern(string pattern, string query, map<boolean> goodLetters) returns boolean {\n    // Find position of '*' if it exists\n    int starPos = -1;\n    int i = 0;\n    while i < pattern.length() {\n        if pattern[i] == \"*\" {\n            starPos = i;\n            break;\n        }\n        i += 1;\n    }\n    \n    if starPos == -1 {\n        // No '*' - exact length match required\n        if pattern.length() != query.length() {\n            return false;\n        }\n        \n        int j = 0;\n        while j < pattern.length() {\n            string patChar = pattern[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        return true;\n    } else {\n        // Has '*' - split into prefix and suffix\n        string prefix = pattern.substring(0, starPos);\n        string suffix = pattern.substring(starPos + 1, pattern.length());\n        \n        int minLen = prefix.length() + suffix.length();\n        if query.length() < minLen {\n            return false;\n        }\n        \n        // Match prefix\n        int j = 0;\n        while j < prefix.length() {\n            string patChar = prefix[j].toString();\n            string queryChar = query[j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Match suffix (from end)\n        j = 0;\n        while j < suffix.length() {\n            string patChar = suffix[suffix.length() - 1 - j].toString();\n            string queryChar = query[query.length() - 1 - j].toString();\n            \n            if patChar == \"?\" {\n                if !isGoodLetter(queryChar, goodLetters) {\n                    return false;\n                }\n            } else if patChar != queryChar {\n                return false;\n            }\n            j += 1;\n        }\n        \n        // Check middle part (matched by '*') contains only bad letters\n        int startMiddle = prefix.length();\n        int endMiddle = query.length() - suffix.length();\n        \n        j = startMiddle;\n        while j < endMiddle {\n            string queryChar = query[j].toString();\n            if isGoodLetter(queryChar, goodLetters) {\n                return false;\n            }\n            j += 1;\n        }\n        \n        return true;\n    }\n}\n\npublic function main() returns error? {\n    // Read good letters\n    string? goodLettersLine = io:readln();\n    if goodLettersLine is () {\n        return;\n    }\n    \n    map<boolean> goodLetters = {};\n    int i = 0;\n    while i < goodLettersLine.length() {\n        string letter = goodLettersLine[i].toString();\n        goodLetters[letter] = true;\n        i += 1;\n    }\n    \n    // Read pattern\n    string? pattern = io:readln();\n    if pattern is () {\n        return;\n    }\n    \n    // Read number of queries\n    string? nLine = io:readln();\n    if nLine is () {\n        return;\n    }\n    \n    int|error n = 'int:fromString(nLine);\n    if n is error {\n        return;\n    }\n    \n    // Process each query\n    int j = 0;\n    while j < n {\n        string? query = io:readln();\n        if query is () {\n            break;\n        }\n        \n        if matchesPattern(pattern, query, goodLetters) {\n            io:println(\"YES\");\n        } else {\n            io:println(\"NO\");\n        }\n        j += 1;\n    }\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T00:04:36.860590"
}