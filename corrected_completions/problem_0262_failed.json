{
  "entry_id": "problem_0262",
  "problem_index": 262,
  "prompt": "Title: Foe Pairs\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou are given a permutation *p* of length *n*. Also you are given *m* foe pairs (*a**i*,<=*b**i*) (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). \n\nYour task is to count the number of different intervals (*x*,<=*y*) (1<=≤<=*x*<=≤<=*y*<=≤<=*n*) that do not contain any foe pairs. So you shouldn't count intervals (*x*,<=*y*) that contain at least one foe pair in it (the positions and order of the values from the foe pair are not important).\n\nConsider some example: *p*<==<=[1,<=3,<=2,<=4] and foe pairs are {(3,<=2),<=(4,<=2)}. The interval (1,<=3) is incorrect because it contains a foe pair (3,<=2). The interval (1,<=4) is also incorrect because it contains two foe pairs (3,<=2) and (4,<=2). But the interval (1,<=2) is correct because it doesn't contain any foe pair.\n\nInput Specification:\nThe first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3·105) — the length of the permutation *p* and the number of foe pairs.\n\nThe second line contains *n* distinct integers *p**i* (1<=≤<=*p**i*<=≤<=*n*) — the elements of the permutation *p*.\n\nEach of the next *m* lines contains two integers (*a**i*,<=*b**i*) (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*) — the *i*-th foe pair. Note a foe pair can appear multiple times in the given list.\n\nOutput Specification:\nPrint the only integer *c* — the number of different intervals (*x*,<=*y*) that does not contain any foe pairs.\n\nNote that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\nDemo Input:\n['4 2\\n1 3 2 4\\n3 2\\n2 4\\n', '9 5\\n9 7 2 3 1 4 6 5 8\\n1 6\\n4 5\\n2 7\\n7 2\\n2 7\\n']\n\nDemo Output:\n['5\\n', '20\\n']\n\nNote:\nIn the first example the intervals from the answer are (1, 1), (1, 2), (2, 2), (3, 3) and (4, 4).",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T04:48:10.122065",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to count the number of intervals in a permutation that don't contain any \"foe pairs\". A foe pair (a, b) is contained in an interval if both values a and b appear somewhere in that interval.\n\nThe approach:\n1. Read the permutation and build a position map (value -> position in array)\n2. For each foe pair, determine their positions in the permutation\n3. For each starting position x, find the maximum ending position y such that the interval [x, y] doesn't contain any complete foe pair\n4. Use a sliding window approach: track the rightmost position where we can extend before hitting a foe pair\n\nThe key insight is that for each starting position, we need to find the furthest we can extend without including both elements of any foe pair. We can precompute for each position, what's the maximum position we can reach before completing a foe pair.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n (length) and m (number of foe pairs)\n// 2. Read the permutation array\n// 3. Create a position map: for each value, store its position in the array\n// 4. For each foe pair (a, b), find their positions in the permutation\n// 5. For each starting position, calculate how far we can extend without completing a foe pair\n// 6. Use dynamic programming: for position i, maxReach[i] tells us the furthest position\n//    we can go starting from i without completing any foe pair\n// 7. Count valid intervals using the maxReach array\n\nimport ballerina/io;\n\nfunction countValidIntervals(int[] permutation, int[][] foePairs) returns int {\n    int n = permutation.length();\n    \n    // Create position map: value -> position (0-indexed)\n    map<int> positionMap = {};\n    foreach int i in 0 ..< n {\n        positionMap[permutation[i].toString()] = i;\n    }\n    \n    // For each position, track the minimum \"bad\" position that would complete a foe pair\n    // Initialize with n (meaning no restriction)\n    int[] maxReach = [];\n    foreach int i in 0 ..< n {\n        maxReach.push(n - 1);\n    }\n    \n    // Process each foe pair\n    foreach int[] foePair in foePairs {\n        int val1 = foePair[0];\n        int val2 = foePair[1];\n        \n        // Get positions of both values\n        int|error pos1Result = positionMap[val1.toString()].ensureType(int);\n        int|error pos2Result = positionMap[val2.toString()].ensureType(int);\n        \n        if pos1Result is int && pos2Result is int {\n            int pos1 = pos1Result;\n            int pos2 = pos2Result;\n            \n            // For the earlier position, we can't extend beyond the later position - 1\n            int minPos = pos1 < pos2 ? pos1 : pos2;\n            int maxPos = pos1 > pos2 ? pos1 : pos2;\n            \n            // Any interval starting at or before minPos and extending to or beyond maxPos\n            // contains this foe pair\n            // So for positions 0 to minPos, the max reach should be at most maxPos - 1\n            foreach int i in 0 ..< minPos + 1 {\n                if maxReach[i] >= maxPos {\n                    maxReach[i] = maxPos - 1;\n                }\n            }\n        }\n    }\n    \n    // Now count valid intervals\n    // For each starting position x, we can have intervals (x, x), (x, x+1), ..., (x, maxReach[x])\n    int count = 0;\n    foreach int i in 0 ..< n {\n        // Number of valid intervals starting at position i\n        int validEndings = maxReach[i] - i + 1;\n        count += validEndings;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        io:println(\"Invalid input format\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: permutation\n    string? line2 = io:readln();\n    if line2 is () {\n        return;\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        io:println(\"Invalid permutation length\");\n        return;\n    }\n    \n    int[] permutation = [];\n    foreach string part in parts2 {\n        permutation.push(check 'int:fromString(part));\n    }\n    \n    // Read m foe pairs\n    int[][] foePairs = [];\n    foreach int i in 0 ..< m {\n        string? line = io:readln();\n        if line is () {\n            break;\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() == 2 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            foePairs.push([a, b]);\n        }\n    }\n    \n    // Calculate and output result\n    int result = countValidIntervals(permutation, foePairs);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] perm = [1, 3, 2, 4];\n    int[][] foes = [[3, 2], [2, 4]];\n    int result = countValidIntervals(perm, foes);\n    test:assertEquals(result, 5);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] perm = [9, 7, 2, 3, 1, 4, 6, 5, 8];\n    int[][] foes = [[1, 6], [4, 5], [2, 7], [7, 2], [2, 7]];\n    int result = countValidIntervals(perm, foes);\n    test:assertEquals(result, 20);\n}\n\n@test:Config {}\nfunction testNoFoePairs() {\n    int[] perm = [1, 2, 3];\n    int[][] foes = [];\n    int result = countValidIntervals(perm, foes);\n    // All intervals are valid: (1,1), (1,2), (1,3), (2,2), (2,3), (3,3) = 6\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSingleElement() {\n    int[] perm = [1];\n    int[][] foes = [];\n    int result = countValidIntervals(perm, foes);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testAllBlocked() {\n    int[] perm = [1, 2];\n    int[][] foes = [[1, 2]];\n    int result = countValidIntervals(perm, foes);\n    // Only (1,1) and (2,2) are valid = 2\n    test:assertEquals(result, 2);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n (length) and m (number of foe pairs)\n// 2. Read the permutation array\n// 3. Create a position map: for each value, store its position in the array\n// 4. For each foe pair (a, b), find their positions in the permutation\n// 5. For each starting position, calculate how far we can extend without completing a foe pair\n// 6. Use dynamic programming: for position i, maxReach[i] tells us the furthest position\n//    we can go starting from i without completing any foe pair\n// 7. Count valid intervals using the maxReach array\n\nimport ballerina/io;\n\nfunction countValidIntervals(int[] permutation, int[][] foePairs) returns int {\n    int n = permutation.length();\n    \n    // Create position map: value -> position (0-indexed)\n    map<int> positionMap = {};\n    foreach int i in 0 ..< n {\n        positionMap[permutation[i].toString()] = i;\n    }\n    \n    // For each position, track the minimum \"bad\" position that would complete a foe pair\n    // Initialize with n (meaning no restriction)\n    int[] maxReach = [];\n    foreach int i in 0 ..< n {\n        maxReach.push(n - 1);\n    }\n    \n    // Process each foe pair\n    foreach int[] foePair in foePairs {\n        int val1 = foePair[0];\n        int val2 = foePair[1];\n        \n        // Get positions of both values\n        int|error pos1Result = positionMap[val1.toString()].ensureType(int);\n        int|error pos2Result = positionMap[val2.toString()].ensureType(int);\n        \n        if pos1Result is int && pos2Result is int {\n            int pos1 = pos1Result;\n            int pos2 = pos2Result;\n            \n            // For the earlier position, we can't extend beyond the later position - 1\n            int minPos = pos1 < pos2 ? pos1 : pos2;\n            int maxPos = pos1 > pos2 ? pos1 : pos2;\n            \n            // Any interval starting at or before minPos and extending to or beyond maxPos\n            // contains this foe pair\n            // So for positions 0 to minPos, the max reach should be at most maxPos - 1\n            foreach int i in 0 ..< minPos + 1 {\n                if maxReach[i] >= maxPos {\n                    maxReach[i] = maxPos - 1;\n                }\n            }\n        }\n    }\n    \n    // Now count valid intervals\n    // For each starting position x, we can have intervals (x, x), (x, x+1), ..., (x, maxReach[x])\n    int count = 0;\n    foreach int i in 0 ..< n {\n        // Number of valid intervals starting at position i\n        int validEndings = maxReach[i] - i + 1;\n        count += validEndings;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln();\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts1 = line1.trim().split(\" \");\n    if parts1.length() != 2 {\n        io:println(\"Invalid input format\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: permutation\n    string? line2 = io:readln();\n    if line2 is () {\n        return;\n    }\n    \n    string[] parts2 = line2.trim().split(\" \");\n    if parts2.length() != n {\n        io:println(\"Invalid permutation length\");\n        return;\n    }\n    \n    int[] permutation = [];\n    foreach string part in parts2 {\n        permutation.push(check 'int:fromString(part));\n    }\n    \n    // Read m foe pairs\n    int[][] foePairs = [];\n    foreach int i in 0 ..< m {\n        string? line = io:readln();\n        if line is () {\n            break;\n        }\n        \n        string[] parts = line.trim().split(\" \");\n        if parts.length() == 2 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            foePairs.push([a, b]);\n        }\n    }\n    \n    // Calculate and output result\n    int result = countValidIntervals(permutation, foePairs);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(76:36,76:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(91:36,91:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(110:38,110:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(76:36,76:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(91:36,91:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(110:38,110:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(76:36,76:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(91:36,91:41)] undefined function 'split' in type 'string'\nERROR [main.bal:(110:38,110:43)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T04:48:40.975100",
      "status": "failed",
      "completion": "Looking at the compilation error, the issue is that `split` is not a method on `string` type in Ballerina. I need to use `string:split()` from the `ballerina/lang.string` module or use the `regex:split()` function. Let me use `regex:split()` for splitting strings.\n\nLet me also reconsider the algorithm. The key insight is:\n- For each starting position, I need to find the maximum ending position before any foe pair is completed\n- I need to propagate constraints properly: if position i cannot extend beyond position j, then all positions before i also have that constraint\n\n# Overview\n\nThis problem asks us to count intervals in a permutation that don't contain any \"foe pairs\". A foe pair (a, b) is contained in an interval if both values a and b appear in that interval.\n\nApproach:\n1. Build a position map (value -> position in the permutation)\n2. For each foe pair, find their positions and determine which starting positions are restricted\n3. For each starting position x, track the maximum ending position y such that [x, y] doesn't contain any complete foe pair\n4. Count all valid intervals by summing up the valid endings for each starting position\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Read n (permutation length) and m (number of foe pairs)\n// 2. Read the permutation array\n// 3. Build position map: value -> its position in permutation (0-indexed internally)\n// 4. For each foe pair (a, b), find their positions\n// 5. Calculate maxReach[i] = furthest position we can reach starting from position i\n//    without completing any foe pair\n// 6. For a foe pair at positions p1 and p2 (p1 < p2), any interval starting at or before p1\n//    and extending to or beyond p2 contains this foe pair, so we limit maxReach\n// 7. Count valid intervals: for starting position i, we can end at i, i+1, ..., maxReach[i]\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction countValidIntervals(int[] permutation, int[][] foePairs) returns int {\n    int n = permutation.length();\n    \n    // Create position map: value -> position (0-indexed)\n    map<int> positionMap = {};\n    foreach int i in 0 ..< n {\n        positionMap[permutation[i].toString()] = i;\n    }\n    \n    // For each position, track the maximum position we can reach without completing a foe pair\n    // Initialize with n-1 (can reach end of array)\n    int[] maxReach = [];\n    foreach int i in 0 ..< n {\n        maxReach.push(n - 1);\n    }\n    \n    // Process each foe pair\n    foreach int[] foePair in foePairs {\n        int val1 = foePair[0];\n        int val2 = foePair[1];\n        \n        // Get positions of both values (0-indexed)\n        int? pos1Opt = positionMap[val1.toString()];\n        int? pos2Opt = positionMap[val2.toString()];\n        \n        if pos1Opt is int && pos2Opt is int {\n            int pos1 = pos1Opt;\n            int pos2 = pos2Opt;\n            \n            // Ensure minPos < maxPos\n            int minPos = pos1 < pos2 ? pos1 : pos2;\n            int maxPos = pos1 > pos2 ? pos1 : pos2;\n            \n            // Any interval starting at or before minPos and extending to or beyond maxPos\n            // will contain this foe pair\n            // So for all positions from 0 to minPos, maxReach should be at most maxPos - 1\n            foreach int i in 0 ..< (minPos + 1) {\n                if maxReach[i] >= maxPos {\n                    maxReach[i] = maxPos - 1;\n                }\n            }\n        }\n    }\n    \n    // Propagate constraints: if position i cannot reach beyond j, \n    // then position i-1 also cannot reach beyond j\n    foreach int i in 1 ..< n {\n        if maxReach[i - 1] > maxReach[i] {\n            maxReach[i - 1] = maxReach[i];\n        }\n    }\n    \n    // Count valid intervals\n    int count = 0;\n    foreach int i in 0 ..< n {\n        // Ensure maxReach[i] >= i (at minimum, interval (i, i) is valid if no constraint)\n        if maxReach[i] >= i {\n            count += (maxReach[i] - i + 1);\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln(\"Enter n and m: \");\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        io:println(\"Invalid input format\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: permutation\n    string? line2 = io:readln(\"Enter permutation: \");\n    if line2 is () {\n        return;\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        io:println(\"Invalid permutation length\");\n        return;\n    }\n    \n    int[] permutation = [];\n    foreach string part in parts2 {\n        permutation.push(check 'int:fromString(part));\n    }\n    \n    // Read m foe pairs\n    int[][] foePairs = [];\n    foreach int i in 0 ..< m {\n        string? line = io:readln(\"Enter foe pair: \");\n        if line is () {\n            break;\n        }\n        \n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() == 2 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            foePairs.push([a, b]);\n        }\n    }\n    \n    // Calculate and output result\n    int result = countValidIntervals(permutation, foePairs);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    int[] perm = [1, 3, 2, 4];\n    int[][] foes = [[3, 2], [2, 4]];\n    int result = countValidIntervals(perm, foes);\n    test:assertEquals(result, 5);\n}\n\n@test:Config {}\nfunction testExample2() {\n    int[] perm = [9, 7, 2, 3, 1, 4, 6, 5, 8];\n    int[][] foes = [[1, 6], [4, 5], [2, 7], [7, 2], [2, 7]];\n    int result = countValidIntervals(perm, foes);\n    test:assertEquals(result, 20);\n}\n\n@test:Config {}\nfunction testNoFoePairs() {\n    int[] perm = [1, 2, 3];\n    int[][] foes = [];\n    int result = countValidIntervals(perm, foes);\n    // All intervals are valid: (1,1), (1,2), (1,3), (2,2), (2,3), (3,3) = 6\n    test:assertEquals(result, 6);\n}\n\n@test:Config {}\nfunction testSingleElement() {\n    int[] perm = [1];\n    int[][] foes = [];\n    int result = countValidIntervals(perm, foes);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testAllBlocked() {\n    int[] perm = [1, 2];\n    int[][] foes = [[1, 2]];\n    int result = countValidIntervals(perm, foes);\n    // Only (1,1) and (2,2) are valid = 2\n    test:assertEquals(result, 2);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Read n (permutation length) and m (number of foe pairs)\n// 2. Read the permutation array\n// 3. Build position map: value -> its position in permutation (0-indexed internally)\n// 4. For each foe pair (a, b), find their positions\n// 5. Calculate maxReach[i] = furthest position we can reach starting from position i\n//    without completing any foe pair\n// 6. For a foe pair at positions p1 and p2 (p1 < p2), any interval starting at or before p1\n//    and extending to or beyond p2 contains this foe pair, so we limit maxReach\n// 7. Count valid intervals: for starting position i, we can end at i, i+1, ..., maxReach[i]\n\nimport ballerina/io;\nimport ballerina/regex;\n\nfunction countValidIntervals(int[] permutation, int[][] foePairs) returns int {\n    int n = permutation.length();\n    \n    // Create position map: value -> position (0-indexed)\n    map<int> positionMap = {};\n    foreach int i in 0 ..< n {\n        positionMap[permutation[i].toString()] = i;\n    }\n    \n    // For each position, track the maximum position we can reach without completing a foe pair\n    // Initialize with n-1 (can reach end of array)\n    int[] maxReach = [];\n    foreach int i in 0 ..< n {\n        maxReach.push(n - 1);\n    }\n    \n    // Process each foe pair\n    foreach int[] foePair in foePairs {\n        int val1 = foePair[0];\n        int val2 = foePair[1];\n        \n        // Get positions of both values (0-indexed)\n        int? pos1Opt = positionMap[val1.toString()];\n        int? pos2Opt = positionMap[val2.toString()];\n        \n        if pos1Opt is int && pos2Opt is int {\n            int pos1 = pos1Opt;\n            int pos2 = pos2Opt;\n            \n            // Ensure minPos < maxPos\n            int minPos = pos1 < pos2 ? pos1 : pos2;\n            int maxPos = pos1 > pos2 ? pos1 : pos2;\n            \n            // Any interval starting at or before minPos and extending to or beyond maxPos\n            // will contain this foe pair\n            // So for all positions from 0 to minPos, maxReach should be at most maxPos - 1\n            foreach int i in 0 ..< (minPos + 1) {\n                if maxReach[i] >= maxPos {\n                    maxReach[i] = maxPos - 1;\n                }\n            }\n        }\n    }\n    \n    // Propagate constraints: if position i cannot reach beyond j, \n    // then position i-1 also cannot reach beyond j\n    foreach int i in 1 ..< n {\n        if maxReach[i - 1] > maxReach[i] {\n            maxReach[i - 1] = maxReach[i];\n        }\n    }\n    \n    // Count valid intervals\n    int count = 0;\n    foreach int i in 0 ..< n {\n        // Ensure maxReach[i] >= i (at minimum, interval (i, i) is valid if no constraint)\n        if maxReach[i] >= i {\n            count += (maxReach[i] - i + 1);\n        }\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    // Read first line: n and m\n    string? line1 = io:readln(\"Enter n and m: \");\n    if line1 is () {\n        return;\n    }\n    \n    string[] parts1 = regex:split(line1.trim(), \" \");\n    if parts1.length() != 2 {\n        io:println(\"Invalid input format\");\n        return;\n    }\n    \n    int n = check 'int:fromString(parts1[0]);\n    int m = check 'int:fromString(parts1[1]);\n    \n    // Read second line: permutation\n    string? line2 = io:readln(\"Enter permutation: \");\n    if line2 is () {\n        return;\n    }\n    \n    string[] parts2 = regex:split(line2.trim(), \" \");\n    if parts2.length() != n {\n        io:println(\"Invalid permutation length\");\n        return;\n    }\n    \n    int[] permutation = [];\n    foreach string part in parts2 {\n        permutation.push(check 'int:fromString(part));\n    }\n    \n    // Read m foe pairs\n    int[][] foePairs = [];\n    foreach int i in 0 ..< m {\n        string? line = io:readln(\"Enter foe pair: \");\n        if line is () {\n            break;\n        }\n        \n        string[] parts = regex:split(line.trim(), \" \");\n        if parts.length() == 2 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            foePairs.push([a, b]);\n        }\n    }\n    \n    // Calculate and output result\n    int result = countValidIntervals(permutation, foePairs);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "4 2\n1 3 2 4\n3 2\n2 4\n",
          "expected_output": "5\n",
          "actual_output": "Enter n and m: Enter permutation: Enter foe pair: Enter foe pair: 5\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T04:49:17.570685"
}