{
  "entry_id": "problem_0121",
  "problem_index": 121,
  "prompt": "Title: Wet Shark and Flowers\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nThere are *n* sharks who grow flowers for Wet Shark. They are all sitting around the table, such that sharks *i* and *i*<=+<=1 are neighbours for all *i* from 1 to *n*<=-<=1. Sharks *n* and 1 are neighbours too.\n\nEach shark will grow some number of flowers *s**i*. For *i*-th shark value *s**i* is random integer equiprobably chosen in range from *l**i* to *r**i*. Wet Shark has it's favourite prime number *p*, and he really likes it! If for any pair of neighbouring sharks *i* and *j* the product *s**i*·*s**j* is divisible by *p*, then Wet Shark becomes happy and gives 1000 dollars to each of these sharks.\n\nAt the end of the day sharks sum all the money Wet Shark granted to them. Find the expectation of this value.\n\nInput Specification:\nThe first line of the input contains two space-separated integers *n* and *p* (3<=≤<=*n*<=≤<=100<=000,<=2<=≤<=*p*<=≤<=109) — the number of sharks and Wet Shark's favourite prime number. It is guaranteed that *p* is prime.\n\nThe *i*-th of the following *n* lines contains information about *i*-th shark — two space-separated integers *l**i* and *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109), the range of flowers shark *i* can produce. Remember that *s**i* is chosen equiprobably among all integers from *l**i* to *r**i*, inclusive.\n\nOutput Specification:\nPrint a single real number — the expected number of dollars that the sharks receive in total. You answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6. \n\nNamely: let's assume that your answer is *a*, and the answer of the jury is *b*. The checker program will consider your answer correct, if .\n\nDemo Input:\n['3 2\\n1 2\\n420 421\\n420420 420421\\n', '3 5\\n1 4\\n2 3\\n11 14\\n']\n\nDemo Output:\n['4500.0\\n', '0.0\\n']\n\nNote:\nA prime number is a positive integer number that is divisible only by 1 and itself. 1 is not considered to be prime.\n\nConsider the first sample. First shark grows some number of flowers from 1 to 2, second sharks grows from 420 to 421 flowers and third from 420420 to 420421. There are eight cases for the quantities of flowers (*s*<sub class=\"lower-index\">0</sub>, *s*<sub class=\"lower-index\">1</sub>, *s*<sub class=\"lower-index\">2</sub>) each shark grows:\n1.  (1, 420, 420420): note that *s*<sub class=\"lower-index\">0</sub>·*s*<sub class=\"lower-index\">1</sub> = 420, *s*<sub class=\"lower-index\">1</sub>·*s*<sub class=\"lower-index\">2</sub> = 176576400, and *s*<sub class=\"lower-index\">2</sub>·*s*<sub class=\"lower-index\">0</sub> = 420420. For each pair, 1000 dollars will be awarded to each shark. Therefore, each shark will be awarded 2000 dollars, for a total of 6000 dollars.1.  (1, 420, 420421): now, the product *s*<sub class=\"lower-index\">2</sub>·*s*<sub class=\"lower-index\">0</sub> is not divisible by 2. Therefore, sharks *s*<sub class=\"lower-index\">0</sub> and *s*<sub class=\"lower-index\">2</sub> will receive 1000 dollars, while shark *s*<sub class=\"lower-index\">1</sub> will receive 2000. The total is 4000.1.  (1, 421, 420420): total is 4000 1.  (1, 421, 420421): total is 0. 1.  (2, 420, 420420): total is 6000. 1.  (2, 420, 420421): total is 6000. 1.  (2, 421, 420420): total is 6000. 1. (2, 421, 420421): total is 4000.\nThe expected value is <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/dfe520d00a8615f7c270ccbccbebe182cc7db883.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/>.\n\nIn the second sample, no combination of quantities will garner the sharks any money.",
  "rating": 1700,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the compilation errors, the issue is that `split` is not a method on `string` type in Ballerina. I need to use `regex:split` from the standard library instead.\n\nLet me analyze the problem:\n1. We have n sharks in a circle\n2. Each shark i grows flowers in range [li, ri] \n3. For neighboring pairs, if their product is divisible by prime p, each gets $1000\n4. We need to calculate the expected total money\n\nKey insights:\n- For prime p, si * sj is divisible by p iff at least one of si or sj is divisible by p\n- Probability that si is divisible by p = count of multiples of p in [li, ri] / (ri - li + 1)\n- For independent events: P(si * sj divisible by p) = P(si divisible) + P(sj divisible) - P(both divisible)\n- Expected money = sum over all n neighboring pairs of: probability * 2000\n\n<CODE>\n```ballerina\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate the probability that a number in range [l, r] is divisible by p\n// Reasoning:\n// - Count of numbers divisible by p in range [l, r] = floor(r/p) - floor((l-1)/p)\n// - Total numbers in range = r - l + 1\n// - Probability = count / total\nfunction calculateProbability(int l, int r, int p) returns float {\n    int total = r - l + 1;\n    int divisibleCount = (r / p) - ((l - 1) / p);\n    return <float>divisibleCount / <float>total;\n}\n\n// Main function to solve the Wet Shark and Flowers problem\n// Reasoning:\n// - For each shark, calculate probability that their flower count is divisible by p\n// - For each neighboring pair (circular arrangement), calculate probability that product is divisible by p\n// - Expected money for a pair = probability * 2000 (1000 per shark)\n// - Sum all expected values for all n pairs\nfunction calculateExpectedMoney(int n, int p, int[][] ranges) returns float {\n    // Calculate probability for each shark\n    float[] probs = [];\n    foreach int i in 0 ..< n {\n        float prob = calculateProbability(ranges[i][0], ranges[i][1], p);\n        probs.push(prob);\n    }\n    \n    float totalExpected = 0.0;\n    \n    // For each neighboring pair (including n-1 and 0 as they are neighbors in circle)\n    foreach int i in 0 ..< n {\n        int nextIndex = (i + 1) % n;\n        \n        // Probability that product is divisible by p\n        // P(A or B) = P(A) + P(B) - P(A and B)\n        // Since independent: P(A and B) = P(A) * P(B)\n        float probProduct = probs[i] + probs[nextIndex] - (probs[i] * probs[nextIndex]);\n        \n        // Each pair gets 2000 dollars (1000 per shark)\n        totalExpected += probProduct * 2000.0;\n    }\n    \n    return totalExpected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int p = check 'int:fromString(parts[1]);\n    \n    // Read n lines of ranges\n    int[][] ranges = [];\n    foreach int i in 0 ..< n {\n        string? rangeLine = io:readln();\n        if rangeLine is () {\n            return error(\"Failed to read range line\");\n        }\n        \n        string[] rangeParts = regex:split(rangeLine.trim(), \" \");\n        if rangeParts.length() != 2 {\n            return error(\"Invalid range format\");\n        }\n        \n        int l = check 'int:fromString(rangeParts[0]);\n        int r = check 'int:fromString(rangeParts[1]);\n        ranges.push([l, r]);\n    }\n    \n    float result = calculateExpectedMoney(n, p, ranges);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCalculateProbability() {\n    // Test case 1: Range [1, 2] with p=2\n    // Numbers: 1, 2. Only 2 is divisible by 2. Probability = 1/2 = 0.5\n    float prob1 = calculateProbability(1, 2, 2);\n    test:assertEquals(prob1, 0.5);\n    \n    // Test case 2: Range [420, 421] with p=2\n    // Numbers: 420, 421. Only 420 is divisible by 2. Probability = 1/2 = 0.5\n    float prob2 = calculateProbability(420, 421, 2);\n    test:assertEquals(prob2, 0.5);\n    \n    // Test case 3: Range [1, 4] with p=5\n    // Numbers: 1, 2, 3, 4. None divisible by 5. Probability = 0/4 = 0\n    float prob3 = calculateProbability(1, 4, 5);\n    test:assertEquals(prob3, 0.0);\n    \n    // Test case 4: Range [11, 14] with p=5\n    // Numbers: 11, 12, 13, 14. None divisible by 5. Probability = 0/4 = 0\n    float prob4 = calculateProbability(11, 14, 5);\n    test:assertEquals(prob4, 0.0);\n}\n\n@test:Config {}\nfunction testCalculateExpectedMoney() {\n    // Test case 1: Sample input 1 from problem\n    int[][] ranges1 = [[1, 2], [420, 421], [420420, 420421]];\n    float result1 = calculateExpectedMoney(3, 2, ranges1);\n    test:assertEquals(result1, 4500.0);\n    \n    // Test case 2: Sample input 2 from problem\n    int[][] ranges2 = [[1, 4], [2, 3], [11, 14]];\n    float result2 = calculateExpectedMoney(3, 5, ranges2);\n    test:assertEquals(result2, 0.0);\n    \n    // Test case 3: All sharks guaranteed divisible\n    int[][] ranges3 = [[2, 2], [4, 4], [6, 6]];\n    float result3 = calculateExpectedMoney(3, 2, ranges3);\n    test:assertEquals(result3, 6000.0);\n    \n    // Test case 4: Simple case with 3 sharks, p=3\n    int[][] ranges4 = [[1, 3], [1, 3], [1, 3]];\n    float result4 = calculateExpectedMoney(3, 3, ranges4);\n    // Each shark has prob 1/3 of being divisible by 3\n    // Prob of product divisible = 1/3 + 1/3 - 1/9 = 5/9\n    // Expected per pair = 5/9 * 2000 = 10000/9\n    // Total = 3 * 10000/9 = 30000/9 = 3333.333...\n    test:assertTrue((result4 - 3333.333333).abs() < 0.001);\n}\n```\n</TESTS>",
  "code": "import ballerina/io;\nimport ballerina/regex;\n\n// Calculate the probability that a number in range [l, r] is divisible by p\n// Reasoning:\n// - Count of numbers divisible by p in range [l, r] = floor(r/p) - floor((l-1)/p)\n// - Total numbers in range = r - l + 1\n// - Probability = count / total\nfunction calculateProbability(int l, int r, int p) returns float {\n    int total = r - l + 1;\n    int divisibleCount = (r / p) - ((l - 1) / p);\n    return <float>divisibleCount / <float>total;\n}\n\n// Main function to solve the Wet Shark and Flowers problem\n// Reasoning:\n// - For each shark, calculate probability that their flower count is divisible by p\n// - For each neighboring pair (circular arrangement), calculate probability that product is divisible by p\n// - Expected money for a pair = probability * 2000 (1000 per shark)\n// - Sum all expected values for all n pairs\nfunction calculateExpectedMoney(int n, int p, int[][] ranges) returns float {\n    // Calculate probability for each shark\n    float[] probs = [];\n    foreach int i in 0 ..< n {\n        float prob = calculateProbability(ranges[i][0], ranges[i][1], p);\n        probs.push(prob);\n    }\n    \n    float totalExpected = 0.0;\n    \n    // For each neighboring pair (including n-1 and 0 as they are neighbors in circle)\n    foreach int i in 0 ..< n {\n        int nextIndex = (i + 1) % n;\n        \n        // Probability that product is divisible by p\n        // P(A or B) = P(A) + P(B) - P(A and B)\n        // Since independent: P(A and B) = P(A) * P(B)\n        float probProduct = probs[i] + probs[nextIndex] - (probs[i] * probs[nextIndex]);\n        \n        // Each pair gets 2000 dollars (1000 per shark)\n        totalExpected += probProduct * 2000.0;\n    }\n    \n    return totalExpected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int p = check 'int:fromString(parts[1]);\n    \n    // Read n lines of ranges\n    int[][] ranges = [];\n    foreach int i in 0 ..< n {\n        string? rangeLine = io:readln();\n        if rangeLine is () {\n            return error(\"Failed to read range line\");\n        }\n        \n        string[] rangeParts = regex:split(rangeLine.trim(), \" \");\n        if rangeParts.length() != 2 {\n            return error(\"Invalid range format\");\n        }\n        \n        int l = check 'int:fromString(rangeParts[0]);\n        int r = check 'int:fromString(rangeParts[1]);\n        ranges.push([l, r]);\n    }\n    \n    float result = calculateExpectedMoney(n, p, ranges);\n    io:println(result);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T02:08:04.167981",
      "status": "failed",
      "completion": "# Overview\n\nThis problem asks us to calculate the expected value of money received by sharks based on probability. For each pair of neighboring sharks, if their product of flowers is divisible by prime p, each gets 1000 dollars.\n\nKey insights:\n- Sharks are arranged in a circle (shark n and shark 1 are neighbors)\n- For each neighboring pair (i, j), we need to calculate the probability that si * sj is divisible by p\n- Since p is prime, si * sj is divisible by p if and only if at least one of si or sj is divisible by p\n- For each pair with probability prob, expected money = prob * 2000 (1000 for each shark)\n- Total expected value = sum of expected values for all pairs\n\nAlgorithm:\n1. For each shark i with range [li, ri], calculate probability that si is divisible by p\n2. For each neighboring pair, calculate probability that their product is divisible by p using:\n   P(si * sj divisible by p) = P(si divisible by p) + P(sj divisible by p) - P(both divisible by p)\n   = pi + pj - pi*pj (since they're independent)\n3. Sum up: probability * 2000 for all n pairs\n\n<CODE>\n```ballerina\nimport ballerina/io;\n\n// Calculate the probability that a number in range [l, r] is divisible by p\n// Reasoning:\n// - Count of numbers divisible by p in range [l, r] = floor(r/p) - floor((l-1)/p)\n// - Total numbers in range = r - l + 1\n// - Probability = count / total\nfunction calculateProbability(int l, int r, int p) returns float {\n    int total = r - l + 1;\n    int divisibleCount = (r / p) - ((l - 1) / p);\n    return <float>divisibleCount / <float>total;\n}\n\n// Main function to solve the Wet Shark and Flowers problem\n// Reasoning:\n// - For each shark, calculate probability that their flower count is divisible by p\n// - For each neighboring pair, calculate probability that product is divisible by p\n// - Expected money for a pair = probability * 2000 (1000 per shark)\n// - Sum all expected values for all pairs\nfunction calculateExpectedMoney(int n, int p, int[][] ranges) returns float {\n    // Calculate probability for each shark\n    float[] probs = [];\n    foreach int i in 0 ..< n {\n        float prob = calculateProbability(ranges[i][0], ranges[i][1], p);\n        probs.push(prob);\n    }\n    \n    float totalExpected = 0.0;\n    \n    // For each neighboring pair (including n-1 and 0)\n    foreach int i in 0 ..< n {\n        int nextIndex = (i + 1) % n;\n        \n        // Probability that product is divisible by p\n        // P(A or B) = P(A) + P(B) - P(A and B)\n        // Since independent: P(A and B) = P(A) * P(B)\n        float probProduct = probs[i] + probs[nextIndex] - (probs[i] * probs[nextIndex]);\n        \n        // Each pair gets 2000 dollars (1000 per shark)\n        totalExpected += probProduct * 2000.0;\n    }\n    \n    return totalExpected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int p = check 'int:fromString(parts[1]);\n    \n    // Read n lines of ranges\n    int[][] ranges = [];\n    foreach int i in 0 ..< n {\n        string? rangeLine = io:readln();\n        if rangeLine is () {\n            return error(\"Failed to read range line\");\n        }\n        \n        string[] rangeParts = rangeLine.trim().split(\" \");\n        if rangeParts.length() != 2 {\n            return error(\"Invalid range format\");\n        }\n        \n        int l = check 'int:fromString(rangeParts[0]);\n        int r = check 'int:fromString(rangeParts[1]);\n        ranges.push([l, r]);\n    }\n    \n    float result = calculateExpectedMoney(n, p, ranges);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCalculateProbability() {\n    // Test case 1: Range [1, 2] with p=2\n    // Numbers: 1, 2. Only 2 is divisible by 2. Probability = 1/2 = 0.5\n    float prob1 = calculateProbability(1, 2, 2);\n    test:assertEquals(prob1, 0.5);\n    \n    // Test case 2: Range [420, 421] with p=2\n    // Numbers: 420, 421. Only 420 is divisible by 2. Probability = 1/2 = 0.5\n    float prob2 = calculateProbability(420, 421, 2);\n    test:assertEquals(prob2, 0.5);\n    \n    // Test case 3: Range [1, 4] with p=5\n    // Numbers: 1, 2, 3, 4. None divisible by 5. Probability = 0/4 = 0\n    float prob3 = calculateProbability(1, 4, 5);\n    test:assertEquals(prob3, 0.0);\n    \n    // Test case 4: Range [11, 14] with p=5\n    // Numbers: 11, 12, 13, 14. None divisible by 5. Probability = 0/4 = 0\n    float prob4 = calculateProbability(11, 14, 5);\n    test:assertEquals(prob4, 0.0);\n}\n\n@test:Config {}\nfunction testCalculateExpectedMoney() {\n    // Test case 1: Sample input 1 from problem\n    int[][] ranges1 = [[1, 2], [420, 421], [420420, 420421]];\n    float result1 = calculateExpectedMoney(3, 2, ranges1);\n    test:assertEquals(result1, 4500.0);\n    \n    // Test case 2: Sample input 2 from problem\n    int[][] ranges2 = [[1, 4], [2, 3], [11, 14]];\n    float result2 = calculateExpectedMoney(3, 5, ranges2);\n    test:assertEquals(result2, 0.0);\n    \n    // Test case 3: All sharks guaranteed divisible\n    int[][] ranges3 = [[2, 2], [4, 4], [6, 6]];\n    float result3 = calculateExpectedMoney(3, 2, ranges3);\n    test:assertEquals(result3, 6000.0);\n    \n    // Test case 4: Simple case with 3 sharks, p=3\n    int[][] ranges4 = [[1, 3], [1, 3], [1, 3]];\n    float result4 = calculateExpectedMoney(3, 3, ranges4);\n    // Each shark has prob 1/3 of being divisible by 3\n    // Prob of product divisible = 1/3 + 1/3 - 1/9 = 5/9\n    // Expected per pair = 5/9 * 2000 = 10000/9\n    // Total = 3 * 10000/9 = 30000/9 = 3333.333...\n    test:assertTrue((result4 - 3333.333333).abs() < 0.001);\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\n\n// Calculate the probability that a number in range [l, r] is divisible by p\n// Reasoning:\n// - Count of numbers divisible by p in range [l, r] = floor(r/p) - floor((l-1)/p)\n// - Total numbers in range = r - l + 1\n// - Probability = count / total\nfunction calculateProbability(int l, int r, int p) returns float {\n    int total = r - l + 1;\n    int divisibleCount = (r / p) - ((l - 1) / p);\n    return <float>divisibleCount / <float>total;\n}\n\n// Main function to solve the Wet Shark and Flowers problem\n// Reasoning:\n// - For each shark, calculate probability that their flower count is divisible by p\n// - For each neighboring pair, calculate probability that product is divisible by p\n// - Expected money for a pair = probability * 2000 (1000 per shark)\n// - Sum all expected values for all pairs\nfunction calculateExpectedMoney(int n, int p, int[][] ranges) returns float {\n    // Calculate probability for each shark\n    float[] probs = [];\n    foreach int i in 0 ..< n {\n        float prob = calculateProbability(ranges[i][0], ranges[i][1], p);\n        probs.push(prob);\n    }\n    \n    float totalExpected = 0.0;\n    \n    // For each neighboring pair (including n-1 and 0)\n    foreach int i in 0 ..< n {\n        int nextIndex = (i + 1) % n;\n        \n        // Probability that product is divisible by p\n        // P(A or B) = P(A) + P(B) - P(A and B)\n        // Since independent: P(A and B) = P(A) * P(B)\n        float probProduct = probs[i] + probs[nextIndex] - (probs[i] * probs[nextIndex]);\n        \n        // Each pair gets 2000 dollars (1000 per shark)\n        totalExpected += probProduct * 2000.0;\n    }\n    \n    return totalExpected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = line1.trim().split(\" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int p = check 'int:fromString(parts[1]);\n    \n    // Read n lines of ranges\n    int[][] ranges = [];\n    foreach int i in 0 ..< n {\n        string? rangeLine = io:readln();\n        if rangeLine is () {\n            return error(\"Failed to read range line\");\n        }\n        \n        string[] rangeParts = rangeLine.trim().split(\" \");\n        if rangeParts.length() != 2 {\n            return error(\"Invalid range format\");\n        }\n        \n        int l = check 'int:fromString(rangeParts[0]);\n        int r = check 'int:fromString(rangeParts[1]);\n        ranges.push([l, r]);\n    }\n    \n    float result = calculateExpectedMoney(n, p, ranges);\n    io:println(result);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(53:35,53:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(69:48,69:53)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(53:35,53:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(69:48,69:53)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(53:35,53:40)] undefined function 'split' in type 'string'\nERROR [main.bal:(69:48,69:53)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T02:08:36.290970",
      "status": "success",
      "completion": "Looking at the compilation errors, the issue is that `split` is not a method on `string` type in Ballerina. I need to use `regex:split` from the standard library instead.\n\nLet me analyze the problem:\n1. We have n sharks in a circle\n2. Each shark i grows flowers in range [li, ri] \n3. For neighboring pairs, if their product is divisible by prime p, each gets $1000\n4. We need to calculate the expected total money\n\nKey insights:\n- For prime p, si * sj is divisible by p iff at least one of si or sj is divisible by p\n- Probability that si is divisible by p = count of multiples of p in [li, ri] / (ri - li + 1)\n- For independent events: P(si * sj divisible by p) = P(si divisible) + P(sj divisible) - P(both divisible)\n- Expected money = sum over all n neighboring pairs of: probability * 2000\n\n<CODE>\n```ballerina\nimport ballerina/io;\nimport ballerina/regex;\n\n// Calculate the probability that a number in range [l, r] is divisible by p\n// Reasoning:\n// - Count of numbers divisible by p in range [l, r] = floor(r/p) - floor((l-1)/p)\n// - Total numbers in range = r - l + 1\n// - Probability = count / total\nfunction calculateProbability(int l, int r, int p) returns float {\n    int total = r - l + 1;\n    int divisibleCount = (r / p) - ((l - 1) / p);\n    return <float>divisibleCount / <float>total;\n}\n\n// Main function to solve the Wet Shark and Flowers problem\n// Reasoning:\n// - For each shark, calculate probability that their flower count is divisible by p\n// - For each neighboring pair (circular arrangement), calculate probability that product is divisible by p\n// - Expected money for a pair = probability * 2000 (1000 per shark)\n// - Sum all expected values for all n pairs\nfunction calculateExpectedMoney(int n, int p, int[][] ranges) returns float {\n    // Calculate probability for each shark\n    float[] probs = [];\n    foreach int i in 0 ..< n {\n        float prob = calculateProbability(ranges[i][0], ranges[i][1], p);\n        probs.push(prob);\n    }\n    \n    float totalExpected = 0.0;\n    \n    // For each neighboring pair (including n-1 and 0 as they are neighbors in circle)\n    foreach int i in 0 ..< n {\n        int nextIndex = (i + 1) % n;\n        \n        // Probability that product is divisible by p\n        // P(A or B) = P(A) + P(B) - P(A and B)\n        // Since independent: P(A and B) = P(A) * P(B)\n        float probProduct = probs[i] + probs[nextIndex] - (probs[i] * probs[nextIndex]);\n        \n        // Each pair gets 2000 dollars (1000 per shark)\n        totalExpected += probProduct * 2000.0;\n    }\n    \n    return totalExpected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int p = check 'int:fromString(parts[1]);\n    \n    // Read n lines of ranges\n    int[][] ranges = [];\n    foreach int i in 0 ..< n {\n        string? rangeLine = io:readln();\n        if rangeLine is () {\n            return error(\"Failed to read range line\");\n        }\n        \n        string[] rangeParts = regex:split(rangeLine.trim(), \" \");\n        if rangeParts.length() != 2 {\n            return error(\"Invalid range format\");\n        }\n        \n        int l = check 'int:fromString(rangeParts[0]);\n        int r = check 'int:fromString(rangeParts[1]);\n        ranges.push([l, r]);\n    }\n    \n    float result = calculateExpectedMoney(n, p, ranges);\n    io:println(result);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testCalculateProbability() {\n    // Test case 1: Range [1, 2] with p=2\n    // Numbers: 1, 2. Only 2 is divisible by 2. Probability = 1/2 = 0.5\n    float prob1 = calculateProbability(1, 2, 2);\n    test:assertEquals(prob1, 0.5);\n    \n    // Test case 2: Range [420, 421] with p=2\n    // Numbers: 420, 421. Only 420 is divisible by 2. Probability = 1/2 = 0.5\n    float prob2 = calculateProbability(420, 421, 2);\n    test:assertEquals(prob2, 0.5);\n    \n    // Test case 3: Range [1, 4] with p=5\n    // Numbers: 1, 2, 3, 4. None divisible by 5. Probability = 0/4 = 0\n    float prob3 = calculateProbability(1, 4, 5);\n    test:assertEquals(prob3, 0.0);\n    \n    // Test case 4: Range [11, 14] with p=5\n    // Numbers: 11, 12, 13, 14. None divisible by 5. Probability = 0/4 = 0\n    float prob4 = calculateProbability(11, 14, 5);\n    test:assertEquals(prob4, 0.0);\n}\n\n@test:Config {}\nfunction testCalculateExpectedMoney() {\n    // Test case 1: Sample input 1 from problem\n    int[][] ranges1 = [[1, 2], [420, 421], [420420, 420421]];\n    float result1 = calculateExpectedMoney(3, 2, ranges1);\n    test:assertEquals(result1, 4500.0);\n    \n    // Test case 2: Sample input 2 from problem\n    int[][] ranges2 = [[1, 4], [2, 3], [11, 14]];\n    float result2 = calculateExpectedMoney(3, 5, ranges2);\n    test:assertEquals(result2, 0.0);\n    \n    // Test case 3: All sharks guaranteed divisible\n    int[][] ranges3 = [[2, 2], [4, 4], [6, 6]];\n    float result3 = calculateExpectedMoney(3, 2, ranges3);\n    test:assertEquals(result3, 6000.0);\n    \n    // Test case 4: Simple case with 3 sharks, p=3\n    int[][] ranges4 = [[1, 3], [1, 3], [1, 3]];\n    float result4 = calculateExpectedMoney(3, 3, ranges4);\n    // Each shark has prob 1/3 of being divisible by 3\n    // Prob of product divisible = 1/3 + 1/3 - 1/9 = 5/9\n    // Expected per pair = 5/9 * 2000 = 10000/9\n    // Total = 3 * 10000/9 = 30000/9 = 3333.333...\n    test:assertTrue((result4 - 3333.333333).abs() < 0.001);\n}\n```\n</TESTS>",
      "code": "import ballerina/io;\nimport ballerina/regex;\n\n// Calculate the probability that a number in range [l, r] is divisible by p\n// Reasoning:\n// - Count of numbers divisible by p in range [l, r] = floor(r/p) - floor((l-1)/p)\n// - Total numbers in range = r - l + 1\n// - Probability = count / total\nfunction calculateProbability(int l, int r, int p) returns float {\n    int total = r - l + 1;\n    int divisibleCount = (r / p) - ((l - 1) / p);\n    return <float>divisibleCount / <float>total;\n}\n\n// Main function to solve the Wet Shark and Flowers problem\n// Reasoning:\n// - For each shark, calculate probability that their flower count is divisible by p\n// - For each neighboring pair (circular arrangement), calculate probability that product is divisible by p\n// - Expected money for a pair = probability * 2000 (1000 per shark)\n// - Sum all expected values for all n pairs\nfunction calculateExpectedMoney(int n, int p, int[][] ranges) returns float {\n    // Calculate probability for each shark\n    float[] probs = [];\n    foreach int i in 0 ..< n {\n        float prob = calculateProbability(ranges[i][0], ranges[i][1], p);\n        probs.push(prob);\n    }\n    \n    float totalExpected = 0.0;\n    \n    // For each neighboring pair (including n-1 and 0 as they are neighbors in circle)\n    foreach int i in 0 ..< n {\n        int nextIndex = (i + 1) % n;\n        \n        // Probability that product is divisible by p\n        // P(A or B) = P(A) + P(B) - P(A and B)\n        // Since independent: P(A and B) = P(A) * P(B)\n        float probProduct = probs[i] + probs[nextIndex] - (probs[i] * probs[nextIndex]);\n        \n        // Each pair gets 2000 dollars (1000 per shark)\n        totalExpected += probProduct * 2000.0;\n    }\n    \n    return totalExpected;\n}\n\npublic function main() returns error? {\n    // Read first line: n and p\n    string? line1 = io:readln();\n    if line1 is () {\n        return error(\"Failed to read input\");\n    }\n    \n    string[] parts = regex:split(line1.trim(), \" \");\n    if parts.length() != 2 {\n        return error(\"Invalid input format for first line\");\n    }\n    \n    int n = check 'int:fromString(parts[0]);\n    int p = check 'int:fromString(parts[1]);\n    \n    // Read n lines of ranges\n    int[][] ranges = [];\n    foreach int i in 0 ..< n {\n        string? rangeLine = io:readln();\n        if rangeLine is () {\n            return error(\"Failed to read range line\");\n        }\n        \n        string[] rangeParts = regex:split(rangeLine.trim(), \" \");\n        if rangeParts.length() != 2 {\n            return error(\"Invalid range format\");\n        }\n        \n        int l = check 'int:fromString(rangeParts[0]);\n        int r = check 'int:fromString(rangeParts[1]);\n        ranges.push([l, r]);\n    }\n    \n    float result = calculateExpectedMoney(n, p, ranges);\n    io:println(result);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T02:09:08.754056"
}