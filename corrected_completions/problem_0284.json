{
  "entry_id": "problem_0284",
  "problem_index": 284,
  "prompt": "Title: Kostya the Sculptor\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nKostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. \n\nZahar has *n* stones which are rectangular parallelepipeds. The edges sizes of the *i*-th of them are *a**i*, *b**i* and *c**i*. He can take no more than two stones and present them to Kostya. \n\nIf Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. \n\nHelp Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.\n\nInput Specification:\nThe first line contains the integer *n* (1<=≤<=*n*<=≤<=105).\n\n*n* lines follow, in the *i*-th of which there are three integers *a**i*,<=*b**i* and *c**i* (1<=≤<=*a**i*,<=*b**i*,<=*c**i*<=≤<=109) — the lengths of edges of the *i*-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.\n\nOutput Specification:\nIn the first line print *k* (1<=≤<=*k*<=≤<=2) the number of stones which Zahar has chosen. In the second line print *k* distinct integers from 1 to *n* — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to *n* in the order as they are given in the input data.\n\nYou can print the stones in arbitrary order. If there are several answers print any of them.\n\nDemo Input:\n['6\\n5 5 5\\n3 2 4\\n1 4 1\\n2 1 3\\n3 2 4\\n3 3 4\\n', '7\\n10 7 8\\n5 10 3\\n4 2 6\\n5 5 5\\n10 2 8\\n4 2 1\\n7 7 7\\n']\n\nDemo Output:\n['1\\n1\\n', '2\\n1 5\\n']\n\nNote:\nIn the first example we can connect the pairs of stones:\n -  2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1 -  2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. -  2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5 -  4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1 -  5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5 \nOr take only one stone:\n -  1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5 -  2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1 -  3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5 -  4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5 -  5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1 -  6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5 \nIt is most profitable to take only the first stone.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "Looking at the compilation error, the issue is that when getting a value from a map with `faceMap.get(faceKey)`, it returns a nullable type `[int, int][]?`, and we can't call `push` on a nullable array.\n\nI need to:\n1. Fix the map value retrieval and array operations\n2. Ensure proper handling of the map data structure\n3. Use array concatenation or proper initialization instead of push on nullable types\n\nLet me rewrite the solution with proper handling:\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get all stones with their dimensions\n// 2. For single stone: sphere radius = min(a,b,c)/2, so we want max of all min dimensions\n// 3. For two stones glued: they must share a matching face (rectangle)\n//    - Sort each stone's dimensions to standardize face representation\n//    - When gluing on face (a,b), the new parallelepiped is (a, b, c1+c2)\n// 4. Compare all possibilities and choose the one with maximum min dimension\n// 5. Group stones by their face dimensions using a map for efficient pair matching\n// 6. Fix: Properly handle map operations and avoid push on nullable arrays\n\nimport ballerina/io;\n\ntype Stone record {\n    int a;\n    int b;\n    int c;\n    int index;\n};\n\ntype StoneWithDim record {\n    int index;\n    int thirdDim;\n};\n\n// Sort three integers in ascending order\nfunction sortThree(int x, int y, int z) returns [int, int, int] {\n    int[] arr = [x, y, z];\n    // Simple bubble sort for 3 elements\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    if arr[1] > arr[2] {\n        int temp = arr[1];\n        arr[1] = arr[2];\n        arr[2] = temp;\n    }\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    return [arr[0], arr[1], arr[2]];\n}\n\nfunction getMinDimension(int a, int b, int c) returns int {\n    int min_val = a;\n    if b < min_val {\n        min_val = b;\n    }\n    if c < min_val {\n        min_val = c;\n    }\n    return min_val;\n}\n\nfunction solve(Stone[] stones) returns [int, int[]] {\n    int n = stones.length();\n    \n    // Best solution tracking\n    int bestMin = 0;\n    int bestK = 1;\n    int[] bestIndices = [1];\n    \n    // Check all single stones\n    foreach Stone stone in stones {\n        int minDim = getMinDimension(stone.a, stone.b, stone.c);\n        if minDim > bestMin {\n            bestMin = minDim;\n            bestK = 1;\n            bestIndices = [stone.index];\n        }\n    }\n    \n    // Check all pairs of stones\n    // Group stones by their faces for efficient matching\n    map<StoneWithDim[]> faceMap = {};\n    \n    foreach Stone stone in stones {\n        [int, int, int] sorted = sortThree(stone.a, stone.b, stone.c);\n        \n        // Three possible faces: (sorted[0], sorted[1]), (sorted[0], sorted[2]), (sorted[1], sorted[2])\n        // Face 1: sorted[0] x sorted[1], third dimension is sorted[2]\n        string key1 = sorted[0].toString() + \"_\" + sorted[1].toString();\n        StoneWithDim[] list1 = faceMap.hasKey(key1) ? faceMap.get(key1) : [];\n        list1.push({index: stone.index, thirdDim: sorted[2]});\n        faceMap[key1] = list1;\n        \n        // Face 2: sorted[0] x sorted[2], third dimension is sorted[1]\n        string key2 = sorted[0].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list2 = faceMap.hasKey(key2) ? faceMap.get(key2) : [];\n        list2.push({index: stone.index, thirdDim: sorted[1]});\n        faceMap[key2] = list2;\n        \n        // Face 3: sorted[1] x sorted[2], third dimension is sorted[0]\n        string key3 = sorted[1].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list3 = faceMap.hasKey(key3) ? faceMap.get(key3) : [];\n        list3.push({index: stone.index, thirdDim: sorted[0]});\n        faceMap[key3] = list3;\n    }\n    \n    // For each face type, try pairing stones\n    foreach string faceKey in faceMap.keys() {\n        StoneWithDim[] stonesWithFace = faceMap.get(faceKey);\n        string[] parts = re `_`.split(faceKey);\n        \n        if parts.length() == 2 {\n            int|error face1Result = 'int:fromString(parts[0]);\n            int|error face2Result = 'int:fromString(parts[1]);\n            \n            if face1Result is int && face2Result is int && stonesWithFace.length() >= 2 {\n                // Try all pairs\n                foreach int i in 0 ..< stonesWithFace.length() {\n                    foreach int j in (i + 1) ..< stonesWithFace.length() {\n                        int idx1 = stonesWithFace[i].index;\n                        int dim1 = stonesWithFace[i].thirdDim;\n                        int idx2 = stonesWithFace[j].index;\n                        int dim2 = stonesWithFace[j].thirdDim;\n                        \n                        // Glued dimensions: face1, face2, dim1 + dim2\n                        int minDim = getMinDimension(face1Result, face2Result, dim1 + dim2);\n                        if minDim > bestMin {\n                            bestMin = minDim;\n                            bestK = 2;\n                            bestIndices = [idx1, idx2];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return [bestK, bestIndices];\n}\n\npublic function main() returns error? {\n    string? n_line = io:readln();\n    if n_line is () {\n        return;\n    }\n    \n    int n = check 'int:fromString(n_line.trim());\n    Stone[] stones = [];\n    \n    foreach int i in 1 ... n {\n        string? stone_line = io:readln();\n        if stone_line is () {\n            return;\n        }\n        \n        string[] parts = re `\\s+`.split(stone_line.trim());\n        if parts.length() == 3 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            int c = check 'int:fromString(parts[2]);\n            \n            stones.push({a: a, b: b, c: c, index: i});\n        }\n    }\n    \n    [int, int[]] result = solve(stones);\n    io:println(result[0]);\n    \n    string output = \"\";\n    foreach int idx in result[1] {\n        if output.length() > 0 {\n            output = output + \" \";\n        }\n        output = output + idx.toString();\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleStone() {\n    Stone[] stones = [\n        {a: 5, b: 5, c: 5, index: 1},\n        {a: 3, b: 2, c: 4, index: 2}\n    ];\n    \n    [int, int[]] result = solve(stones);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1][0], 1);\n}\n\n@test:Config {}\nfunction testTwoStonesGlued() {\n    Stone[] stones = [\n        {a: 10, b: 7, c: 8, index: 1},\n        {a: 10, b: 2, c: 8, index: 2}\n    ];\n    \n    [int, int[]] result = solve(stones);\n    test:assertEquals(result[0], 2);\n    test:assertTrue(result[1].length() == 2);\n}\n\n@test:Config {}\nfunction testSortThree() {\n    [int, int, int] result = sortThree(5, 2, 8);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 5);\n    test:assertEquals(result[2], 8);\n}\n\n@test:Config {}\nfunction testGetMinDimension() {\n    int min1 = getMinDimension(5, 3, 7);\n    test:assertEquals(min1, 3);\n    \n    int min2 = getMinDimension(10, 10, 10);\n    test:assertEquals(min2, 10);\n    \n    int min3 = getMinDimension(1, 100, 50);\n    test:assertEquals(min3, 1);\n    \n    int min4 = getMinDimension(8, 7, 10);\n    test:assertEquals(min4, 7);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Parse input to get all stones with their dimensions\n// 2. For single stone: sphere radius = min(a,b,c)/2, so we want max of all min dimensions\n// 3. For two stones glued: they must share a matching face (rectangle)\n//    - Sort each stone's dimensions to standardize face representation\n//    - When gluing on face (a,b), the new parallelepiped is (a, b, c1+c2)\n// 4. Compare all possibilities and choose the one with maximum min dimension\n// 5. Group stones by their face dimensions using a map for efficient pair matching\n// 6. Fix: Properly handle map operations and avoid push on nullable arrays\n\nimport ballerina/io;\n\ntype Stone record {\n    int a;\n    int b;\n    int c;\n    int index;\n};\n\ntype StoneWithDim record {\n    int index;\n    int thirdDim;\n};\n\n// Sort three integers in ascending order\nfunction sortThree(int x, int y, int z) returns [int, int, int] {\n    int[] arr = [x, y, z];\n    // Simple bubble sort for 3 elements\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    if arr[1] > arr[2] {\n        int temp = arr[1];\n        arr[1] = arr[2];\n        arr[2] = temp;\n    }\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    return [arr[0], arr[1], arr[2]];\n}\n\nfunction getMinDimension(int a, int b, int c) returns int {\n    int min_val = a;\n    if b < min_val {\n        min_val = b;\n    }\n    if c < min_val {\n        min_val = c;\n    }\n    return min_val;\n}\n\nfunction solve(Stone[] stones) returns [int, int[]] {\n    int n = stones.length();\n    \n    // Best solution tracking\n    int bestMin = 0;\n    int bestK = 1;\n    int[] bestIndices = [1];\n    \n    // Check all single stones\n    foreach Stone stone in stones {\n        int minDim = getMinDimension(stone.a, stone.b, stone.c);\n        if minDim > bestMin {\n            bestMin = minDim;\n            bestK = 1;\n            bestIndices = [stone.index];\n        }\n    }\n    \n    // Check all pairs of stones\n    // Group stones by their faces for efficient matching\n    map<StoneWithDim[]> faceMap = {};\n    \n    foreach Stone stone in stones {\n        [int, int, int] sorted = sortThree(stone.a, stone.b, stone.c);\n        \n        // Three possible faces: (sorted[0], sorted[1]), (sorted[0], sorted[2]), (sorted[1], sorted[2])\n        // Face 1: sorted[0] x sorted[1], third dimension is sorted[2]\n        string key1 = sorted[0].toString() + \"_\" + sorted[1].toString();\n        StoneWithDim[] list1 = faceMap.hasKey(key1) ? faceMap.get(key1) : [];\n        list1.push({index: stone.index, thirdDim: sorted[2]});\n        faceMap[key1] = list1;\n        \n        // Face 2: sorted[0] x sorted[2], third dimension is sorted[1]\n        string key2 = sorted[0].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list2 = faceMap.hasKey(key2) ? faceMap.get(key2) : [];\n        list2.push({index: stone.index, thirdDim: sorted[1]});\n        faceMap[key2] = list2;\n        \n        // Face 3: sorted[1] x sorted[2], third dimension is sorted[0]\n        string key3 = sorted[1].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list3 = faceMap.hasKey(key3) ? faceMap.get(key3) : [];\n        list3.push({index: stone.index, thirdDim: sorted[0]});\n        faceMap[key3] = list3;\n    }\n    \n    // For each face type, try pairing stones\n    foreach string faceKey in faceMap.keys() {\n        StoneWithDim[] stonesWithFace = faceMap.get(faceKey);\n        string[] parts = re `_`.split(faceKey);\n        \n        if parts.length() == 2 {\n            int|error face1Result = 'int:fromString(parts[0]);\n            int|error face2Result = 'int:fromString(parts[1]);\n            \n            if face1Result is int && face2Result is int && stonesWithFace.length() >= 2 {\n                // Try all pairs\n                foreach int i in 0 ..< stonesWithFace.length() {\n                    foreach int j in (i + 1) ..< stonesWithFace.length() {\n                        int idx1 = stonesWithFace[i].index;\n                        int dim1 = stonesWithFace[i].thirdDim;\n                        int idx2 = stonesWithFace[j].index;\n                        int dim2 = stonesWithFace[j].thirdDim;\n                        \n                        // Glued dimensions: face1, face2, dim1 + dim2\n                        int minDim = getMinDimension(face1Result, face2Result, dim1 + dim2);\n                        if minDim > bestMin {\n                            bestMin = minDim;\n                            bestK = 2;\n                            bestIndices = [idx1, idx2];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return [bestK, bestIndices];\n}\n\npublic function main() returns error? {\n    string? n_line = io:readln();\n    if n_line is () {\n        return;\n    }\n    \n    int n = check 'int:fromString(n_line.trim());\n    Stone[] stones = [];\n    \n    foreach int i in 1 ... n {\n        string? stone_line = io:readln();\n        if stone_line is () {\n            return;\n        }\n        \n        string[] parts = re `\\s+`.split(stone_line.trim());\n        if parts.length() == 3 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            int c = check 'int:fromString(parts[2]);\n            \n            stones.push({a: a, b: b, c: c, index: i});\n        }\n    }\n    \n    [int, int[]] result = solve(stones);\n    io:println(result[0]);\n    \n    string output = \"\";\n    foreach int idx in result[1] {\n        if output.length() > 0 {\n            output = output + \" \";\n        }\n        output = output + idx.toString();\n    }\n    io:println(output);\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T09:57:01.959738",
      "status": "failed",
      "completion": "# Overview\nThe problem asks us to find the best way to present marble stones to Kostya so he can carve the largest possible sphere. The sphere's radius is limited by the smallest dimension of the parallelepiped. We need to either choose one stone or glue two stones together (matching one face) to maximize the minimum dimension.\n\nKey insights:\n1. For a single stone with dimensions a, b, c, the sphere radius is min(a, b, c)/2\n2. When gluing two stones, we match one rectangular face and add the third dimensions\n3. We need to consider all possible single stones and all valid pairs\n4. The goal is to maximize the minimum dimension of the resulting parallelepiped\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get all stones with their dimensions\n// 2. For single stone: sphere radius = min(a,b,c)/2, so we want max of all min dimensions\n// 3. For two stones glued: they must share a matching face (rectangle)\n//    - Sort each stone's dimensions, try matching faces\n//    - When gluing on face (a,b), the new parallelepiped is (a, b, c1+c2)\n// 4. Compare all possibilities and choose the one with maximum min dimension\n// 5. Use a map to group stones by their face dimensions for efficient pair matching\n\nimport ballerina/io;\n\ntype Stone record {\n    int a;\n    int b;\n    int c;\n    int index;\n};\n\n// Sort three integers in ascending order\nfunction sortThree(int x, int y, int z) returns [int, int, int] {\n    int[] arr = [x, y, z];\n    // Simple bubble sort for 3 elements\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    if arr[1] > arr[2] {\n        int temp = arr[1];\n        arr[1] = arr[2];\n        arr[2] = temp;\n    }\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    return [arr[0], arr[1], arr[2]];\n}\n\nfunction getMinDimension(int a, int b, int c) returns int {\n    int min_val = a;\n    if b < min_val {\n        min_val = b;\n    }\n    if c < min_val {\n        min_val = c;\n    }\n    return min_val;\n}\n\nfunction solve(Stone[] stones) returns [int, int[]] {\n    int n = stones.length();\n    \n    // Best solution tracking\n    int bestMin = 0;\n    int bestK = 1;\n    int[] bestIndices = [1];\n    \n    // Check all single stones\n    foreach Stone stone in stones {\n        int minDim = getMinDimension(stone.a, stone.b, stone.c);\n        if minDim > bestMin {\n            bestMin = minDim;\n            bestK = 1;\n            bestIndices = [stone.index];\n        }\n    }\n    \n    // Check all pairs of stones\n    // Group stones by their faces for efficient matching\n    map<[int, int][]> faceMap = {};\n    \n    foreach Stone stone in stones {\n        [int, int, int] sorted = sortThree(stone.a, stone.b, stone.c);\n        // Three possible faces: (sorted[0], sorted[1]), (sorted[0], sorted[2]), (sorted[1], sorted[2])\n        string key1 = sorted[0].toString() + \"_\" + sorted[1].toString();\n        string key2 = sorted[0].toString() + \"_\" + sorted[2].toString();\n        string key3 = sorted[1].toString() + \"_\" + sorted[2].toString();\n        \n        if !faceMap.hasKey(key1) {\n            faceMap[key1] = [];\n        }\n        faceMap[key1].push([stone.index, sorted[2]]);\n        \n        if !faceMap.hasKey(key2) {\n            faceMap[key2] = [];\n        }\n        faceMap[key2].push([stone.index, sorted[1]]);\n        \n        if !faceMap.hasKey(key3) {\n            faceMap[key3] = [];\n        }\n        faceMap[key3].push([stone.index, sorted[0]]);\n    }\n    \n    // For each face type, try pairing stones\n    foreach string faceKey in faceMap.keys() {\n        [int, int][] stonesWithFace = faceMap.get(faceKey);\n        string[] parts = re `_`.split(faceKey);\n        int|error face1 = 'int:fromString(parts[0]);\n        int|error face2 = 'int:fromString(parts[1]);\n        \n        if face1 is int && face2 is int && stonesWithFace.length() >= 2 {\n            // Try all pairs\n            foreach int i in 0 ..< stonesWithFace.length() {\n                foreach int j in (i + 1) ..< stonesWithFace.length() {\n                    int idx1 = stonesWithFace[i][0];\n                    int dim1 = stonesWithFace[i][1];\n                    int idx2 = stonesWithFace[j][0];\n                    int dim2 = stonesWithFace[j][1];\n                    \n                    // Glued dimensions: face1, face2, dim1 + dim2\n                    int minDim = getMinDimension(face1, face2, dim1 + dim2);\n                    if minDim > bestMin {\n                        bestMin = minDim;\n                        bestK = 2;\n                        bestIndices = [idx1, idx2];\n                    }\n                }\n            }\n        }\n    }\n    \n    return [bestK, bestIndices];\n}\n\npublic function main() returns error? {\n    string? n_line = io:readln();\n    if n_line is () {\n        return;\n    }\n    \n    int n = check 'int:fromString(n_line.trim());\n    Stone[] stones = [];\n    \n    foreach int i in 1 ... n {\n        string? stone_line = io:readln();\n        if stone_line is () {\n            return;\n        }\n        \n        string[] parts = re `\\s+`.split(stone_line.trim());\n        if parts.length() == 3 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            int c = check 'int:fromString(parts[2]);\n            \n            stones.push({a: a, b: b, c: c, index: i});\n        }\n    }\n    \n    [int, int[]] result = solve(stones);\n    io:println(result[0]);\n    \n    string output = \"\";\n    foreach int idx in result[1] {\n        if output.length() > 0 {\n            output = output + \" \";\n        }\n        output = output + idx.toString();\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleStone() {\n    Stone[] stones = [\n        {a: 5, b: 5, c: 5, index: 1},\n        {a: 3, b: 2, c: 4, index: 2}\n    ];\n    \n    [int, int[]] result = solve(stones);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1][0], 1);\n}\n\n@test:Config {}\nfunction testTwoStonesGlued() {\n    Stone[] stones = [\n        {a: 10, b: 7, c: 8, index: 1},\n        {a: 10, b: 2, c: 8, index: 2}\n    ];\n    \n    [int, int[]] result = solve(stones);\n    test:assertEquals(result[0], 2);\n    test:assertTrue(result[1].length() == 2);\n}\n\n@test:Config {}\nfunction testSortThree() {\n    [int, int, int] result = sortThree(5, 2, 8);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 5);\n    test:assertEquals(result[2], 8);\n}\n\n@test:Config {}\nfunction testGetMinDimension() {\n    int min1 = getMinDimension(5, 3, 7);\n    test:assertEquals(min1, 3);\n    \n    int min2 = getMinDimension(10, 10, 10);\n    test:assertEquals(min2, 10);\n    \n    int min3 = getMinDimension(1, 100, 50);\n    test:assertEquals(min3, 1);\n    \n    int min4 = getMinDimension(8, 7, 10);\n    test:assertEquals(min4, 7);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get all stones with their dimensions\n// 2. For single stone: sphere radius = min(a,b,c)/2, so we want max of all min dimensions\n// 3. For two stones glued: they must share a matching face (rectangle)\n//    - Sort each stone's dimensions, try matching faces\n//    - When gluing on face (a,b), the new parallelepiped is (a, b, c1+c2)\n// 4. Compare all possibilities and choose the one with maximum min dimension\n// 5. Use a map to group stones by their face dimensions for efficient pair matching\n\nimport ballerina/io;\n\ntype Stone record {\n    int a;\n    int b;\n    int c;\n    int index;\n};\n\n// Sort three integers in ascending order\nfunction sortThree(int x, int y, int z) returns [int, int, int] {\n    int[] arr = [x, y, z];\n    // Simple bubble sort for 3 elements\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    if arr[1] > arr[2] {\n        int temp = arr[1];\n        arr[1] = arr[2];\n        arr[2] = temp;\n    }\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    return [arr[0], arr[1], arr[2]];\n}\n\nfunction getMinDimension(int a, int b, int c) returns int {\n    int min_val = a;\n    if b < min_val {\n        min_val = b;\n    }\n    if c < min_val {\n        min_val = c;\n    }\n    return min_val;\n}\n\nfunction solve(Stone[] stones) returns [int, int[]] {\n    int n = stones.length();\n    \n    // Best solution tracking\n    int bestMin = 0;\n    int bestK = 1;\n    int[] bestIndices = [1];\n    \n    // Check all single stones\n    foreach Stone stone in stones {\n        int minDim = getMinDimension(stone.a, stone.b, stone.c);\n        if minDim > bestMin {\n            bestMin = minDim;\n            bestK = 1;\n            bestIndices = [stone.index];\n        }\n    }\n    \n    // Check all pairs of stones\n    // Group stones by their faces for efficient matching\n    map<[int, int][]> faceMap = {};\n    \n    foreach Stone stone in stones {\n        [int, int, int] sorted = sortThree(stone.a, stone.b, stone.c);\n        // Three possible faces: (sorted[0], sorted[1]), (sorted[0], sorted[2]), (sorted[1], sorted[2])\n        string key1 = sorted[0].toString() + \"_\" + sorted[1].toString();\n        string key2 = sorted[0].toString() + \"_\" + sorted[2].toString();\n        string key3 = sorted[1].toString() + \"_\" + sorted[2].toString();\n        \n        if !faceMap.hasKey(key1) {\n            faceMap[key1] = [];\n        }\n        faceMap[key1].push([stone.index, sorted[2]]);\n        \n        if !faceMap.hasKey(key2) {\n            faceMap[key2] = [];\n        }\n        faceMap[key2].push([stone.index, sorted[1]]);\n        \n        if !faceMap.hasKey(key3) {\n            faceMap[key3] = [];\n        }\n        faceMap[key3].push([stone.index, sorted[0]]);\n    }\n    \n    // For each face type, try pairing stones\n    foreach string faceKey in faceMap.keys() {\n        [int, int][] stonesWithFace = faceMap.get(faceKey);\n        string[] parts = re `_`.split(faceKey);\n        int|error face1 = 'int:fromString(parts[0]);\n        int|error face2 = 'int:fromString(parts[1]);\n        \n        if face1 is int && face2 is int && stonesWithFace.length() >= 2 {\n            // Try all pairs\n            foreach int i in 0 ..< stonesWithFace.length() {\n                foreach int j in (i + 1) ..< stonesWithFace.length() {\n                    int idx1 = stonesWithFace[i][0];\n                    int dim1 = stonesWithFace[i][1];\n                    int idx2 = stonesWithFace[j][0];\n                    int dim2 = stonesWithFace[j][1];\n                    \n                    // Glued dimensions: face1, face2, dim1 + dim2\n                    int minDim = getMinDimension(face1, face2, dim1 + dim2);\n                    if minDim > bestMin {\n                        bestMin = minDim;\n                        bestK = 2;\n                        bestIndices = [idx1, idx2];\n                    }\n                }\n            }\n        }\n    }\n    \n    return [bestK, bestIndices];\n}\n\npublic function main() returns error? {\n    string? n_line = io:readln();\n    if n_line is () {\n        return;\n    }\n    \n    int n = check 'int:fromString(n_line.trim());\n    Stone[] stones = [];\n    \n    foreach int i in 1 ... n {\n        string? stone_line = io:readln();\n        if stone_line is () {\n            return;\n        }\n        \n        string[] parts = re `\\s+`.split(stone_line.trim());\n        if parts.length() == 3 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            int c = check 'int:fromString(parts[2]);\n            \n            stones.push({a: a, b: b, c: c, index: i});\n        }\n    }\n    \n    [int, int[]] result = solve(stones);\n    io:println(result[0]);\n    \n    string output = \"\";\n    foreach int idx in result[1] {\n        if output.length() > 0 {\n            output = output + \" \";\n        }\n        output = output + idx.toString();\n    }\n    io:println(output);\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(84:23,84:27)] undefined function 'push' in type '[int,int][]?'\nERROR [main.bal:(89:23,89:27)] undefined function 'push' in type '[int,int][]?'\nERROR [main.bal:(94:23,94:27)] undefined function 'push' in type '[int,int][]?'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(84:23,84:27)] undefined function 'push' in type '[int,int][]?'\nERROR [main.bal:(89:23,89:27)] undefined function 'push' in type '[int,int][]?'\nERROR [main.bal:(94:23,94:27)] undefined function 'push' in type '[int,int][]?'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(84:23,84:27)] undefined function 'push' in type '[int,int][]?'\nERROR [main.bal:(89:23,89:27)] undefined function 'push' in type '[int,int][]?'\nERROR [main.bal:(94:23,94:27)] undefined function 'push' in type '[int,int][]?'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T09:57:36.569343",
      "status": "success",
      "completion": "Looking at the compilation error, the issue is that when getting a value from a map with `faceMap.get(faceKey)`, it returns a nullable type `[int, int][]?`, and we can't call `push` on a nullable array.\n\nI need to:\n1. Fix the map value retrieval and array operations\n2. Ensure proper handling of the map data structure\n3. Use array concatenation or proper initialization instead of push on nullable types\n\nLet me rewrite the solution with proper handling:\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input to get all stones with their dimensions\n// 2. For single stone: sphere radius = min(a,b,c)/2, so we want max of all min dimensions\n// 3. For two stones glued: they must share a matching face (rectangle)\n//    - Sort each stone's dimensions to standardize face representation\n//    - When gluing on face (a,b), the new parallelepiped is (a, b, c1+c2)\n// 4. Compare all possibilities and choose the one with maximum min dimension\n// 5. Group stones by their face dimensions using a map for efficient pair matching\n// 6. Fix: Properly handle map operations and avoid push on nullable arrays\n\nimport ballerina/io;\n\ntype Stone record {\n    int a;\n    int b;\n    int c;\n    int index;\n};\n\ntype StoneWithDim record {\n    int index;\n    int thirdDim;\n};\n\n// Sort three integers in ascending order\nfunction sortThree(int x, int y, int z) returns [int, int, int] {\n    int[] arr = [x, y, z];\n    // Simple bubble sort for 3 elements\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    if arr[1] > arr[2] {\n        int temp = arr[1];\n        arr[1] = arr[2];\n        arr[2] = temp;\n    }\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    return [arr[0], arr[1], arr[2]];\n}\n\nfunction getMinDimension(int a, int b, int c) returns int {\n    int min_val = a;\n    if b < min_val {\n        min_val = b;\n    }\n    if c < min_val {\n        min_val = c;\n    }\n    return min_val;\n}\n\nfunction solve(Stone[] stones) returns [int, int[]] {\n    int n = stones.length();\n    \n    // Best solution tracking\n    int bestMin = 0;\n    int bestK = 1;\n    int[] bestIndices = [1];\n    \n    // Check all single stones\n    foreach Stone stone in stones {\n        int minDim = getMinDimension(stone.a, stone.b, stone.c);\n        if minDim > bestMin {\n            bestMin = minDim;\n            bestK = 1;\n            bestIndices = [stone.index];\n        }\n    }\n    \n    // Check all pairs of stones\n    // Group stones by their faces for efficient matching\n    map<StoneWithDim[]> faceMap = {};\n    \n    foreach Stone stone in stones {\n        [int, int, int] sorted = sortThree(stone.a, stone.b, stone.c);\n        \n        // Three possible faces: (sorted[0], sorted[1]), (sorted[0], sorted[2]), (sorted[1], sorted[2])\n        // Face 1: sorted[0] x sorted[1], third dimension is sorted[2]\n        string key1 = sorted[0].toString() + \"_\" + sorted[1].toString();\n        StoneWithDim[] list1 = faceMap.hasKey(key1) ? faceMap.get(key1) : [];\n        list1.push({index: stone.index, thirdDim: sorted[2]});\n        faceMap[key1] = list1;\n        \n        // Face 2: sorted[0] x sorted[2], third dimension is sorted[1]\n        string key2 = sorted[0].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list2 = faceMap.hasKey(key2) ? faceMap.get(key2) : [];\n        list2.push({index: stone.index, thirdDim: sorted[1]});\n        faceMap[key2] = list2;\n        \n        // Face 3: sorted[1] x sorted[2], third dimension is sorted[0]\n        string key3 = sorted[1].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list3 = faceMap.hasKey(key3) ? faceMap.get(key3) : [];\n        list3.push({index: stone.index, thirdDim: sorted[0]});\n        faceMap[key3] = list3;\n    }\n    \n    // For each face type, try pairing stones\n    foreach string faceKey in faceMap.keys() {\n        StoneWithDim[] stonesWithFace = faceMap.get(faceKey);\n        string[] parts = re `_`.split(faceKey);\n        \n        if parts.length() == 2 {\n            int|error face1Result = 'int:fromString(parts[0]);\n            int|error face2Result = 'int:fromString(parts[1]);\n            \n            if face1Result is int && face2Result is int && stonesWithFace.length() >= 2 {\n                // Try all pairs\n                foreach int i in 0 ..< stonesWithFace.length() {\n                    foreach int j in (i + 1) ..< stonesWithFace.length() {\n                        int idx1 = stonesWithFace[i].index;\n                        int dim1 = stonesWithFace[i].thirdDim;\n                        int idx2 = stonesWithFace[j].index;\n                        int dim2 = stonesWithFace[j].thirdDim;\n                        \n                        // Glued dimensions: face1, face2, dim1 + dim2\n                        int minDim = getMinDimension(face1Result, face2Result, dim1 + dim2);\n                        if minDim > bestMin {\n                            bestMin = minDim;\n                            bestK = 2;\n                            bestIndices = [idx1, idx2];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return [bestK, bestIndices];\n}\n\npublic function main() returns error? {\n    string? n_line = io:readln();\n    if n_line is () {\n        return;\n    }\n    \n    int n = check 'int:fromString(n_line.trim());\n    Stone[] stones = [];\n    \n    foreach int i in 1 ... n {\n        string? stone_line = io:readln();\n        if stone_line is () {\n            return;\n        }\n        \n        string[] parts = re `\\s+`.split(stone_line.trim());\n        if parts.length() == 3 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            int c = check 'int:fromString(parts[2]);\n            \n            stones.push({a: a, b: b, c: c, index: i});\n        }\n    }\n    \n    [int, int[]] result = solve(stones);\n    io:println(result[0]);\n    \n    string output = \"\";\n    foreach int idx in result[1] {\n        if output.length() > 0 {\n            output = output + \" \";\n        }\n        output = output + idx.toString();\n    }\n    io:println(output);\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testSingleStone() {\n    Stone[] stones = [\n        {a: 5, b: 5, c: 5, index: 1},\n        {a: 3, b: 2, c: 4, index: 2}\n    ];\n    \n    [int, int[]] result = solve(stones);\n    test:assertEquals(result[0], 1);\n    test:assertEquals(result[1][0], 1);\n}\n\n@test:Config {}\nfunction testTwoStonesGlued() {\n    Stone[] stones = [\n        {a: 10, b: 7, c: 8, index: 1},\n        {a: 10, b: 2, c: 8, index: 2}\n    ];\n    \n    [int, int[]] result = solve(stones);\n    test:assertEquals(result[0], 2);\n    test:assertTrue(result[1].length() == 2);\n}\n\n@test:Config {}\nfunction testSortThree() {\n    [int, int, int] result = sortThree(5, 2, 8);\n    test:assertEquals(result[0], 2);\n    test:assertEquals(result[1], 5);\n    test:assertEquals(result[2], 8);\n}\n\n@test:Config {}\nfunction testGetMinDimension() {\n    int min1 = getMinDimension(5, 3, 7);\n    test:assertEquals(min1, 3);\n    \n    int min2 = getMinDimension(10, 10, 10);\n    test:assertEquals(min2, 10);\n    \n    int min3 = getMinDimension(1, 100, 50);\n    test:assertEquals(min3, 1);\n    \n    int min4 = getMinDimension(8, 7, 10);\n    test:assertEquals(min4, 7);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input to get all stones with their dimensions\n// 2. For single stone: sphere radius = min(a,b,c)/2, so we want max of all min dimensions\n// 3. For two stones glued: they must share a matching face (rectangle)\n//    - Sort each stone's dimensions to standardize face representation\n//    - When gluing on face (a,b), the new parallelepiped is (a, b, c1+c2)\n// 4. Compare all possibilities and choose the one with maximum min dimension\n// 5. Group stones by their face dimensions using a map for efficient pair matching\n// 6. Fix: Properly handle map operations and avoid push on nullable arrays\n\nimport ballerina/io;\n\ntype Stone record {\n    int a;\n    int b;\n    int c;\n    int index;\n};\n\ntype StoneWithDim record {\n    int index;\n    int thirdDim;\n};\n\n// Sort three integers in ascending order\nfunction sortThree(int x, int y, int z) returns [int, int, int] {\n    int[] arr = [x, y, z];\n    // Simple bubble sort for 3 elements\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    if arr[1] > arr[2] {\n        int temp = arr[1];\n        arr[1] = arr[2];\n        arr[2] = temp;\n    }\n    if arr[0] > arr[1] {\n        int temp = arr[0];\n        arr[0] = arr[1];\n        arr[1] = temp;\n    }\n    return [arr[0], arr[1], arr[2]];\n}\n\nfunction getMinDimension(int a, int b, int c) returns int {\n    int min_val = a;\n    if b < min_val {\n        min_val = b;\n    }\n    if c < min_val {\n        min_val = c;\n    }\n    return min_val;\n}\n\nfunction solve(Stone[] stones) returns [int, int[]] {\n    int n = stones.length();\n    \n    // Best solution tracking\n    int bestMin = 0;\n    int bestK = 1;\n    int[] bestIndices = [1];\n    \n    // Check all single stones\n    foreach Stone stone in stones {\n        int minDim = getMinDimension(stone.a, stone.b, stone.c);\n        if minDim > bestMin {\n            bestMin = minDim;\n            bestK = 1;\n            bestIndices = [stone.index];\n        }\n    }\n    \n    // Check all pairs of stones\n    // Group stones by their faces for efficient matching\n    map<StoneWithDim[]> faceMap = {};\n    \n    foreach Stone stone in stones {\n        [int, int, int] sorted = sortThree(stone.a, stone.b, stone.c);\n        \n        // Three possible faces: (sorted[0], sorted[1]), (sorted[0], sorted[2]), (sorted[1], sorted[2])\n        // Face 1: sorted[0] x sorted[1], third dimension is sorted[2]\n        string key1 = sorted[0].toString() + \"_\" + sorted[1].toString();\n        StoneWithDim[] list1 = faceMap.hasKey(key1) ? faceMap.get(key1) : [];\n        list1.push({index: stone.index, thirdDim: sorted[2]});\n        faceMap[key1] = list1;\n        \n        // Face 2: sorted[0] x sorted[2], third dimension is sorted[1]\n        string key2 = sorted[0].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list2 = faceMap.hasKey(key2) ? faceMap.get(key2) : [];\n        list2.push({index: stone.index, thirdDim: sorted[1]});\n        faceMap[key2] = list2;\n        \n        // Face 3: sorted[1] x sorted[2], third dimension is sorted[0]\n        string key3 = sorted[1].toString() + \"_\" + sorted[2].toString();\n        StoneWithDim[] list3 = faceMap.hasKey(key3) ? faceMap.get(key3) : [];\n        list3.push({index: stone.index, thirdDim: sorted[0]});\n        faceMap[key3] = list3;\n    }\n    \n    // For each face type, try pairing stones\n    foreach string faceKey in faceMap.keys() {\n        StoneWithDim[] stonesWithFace = faceMap.get(faceKey);\n        string[] parts = re `_`.split(faceKey);\n        \n        if parts.length() == 2 {\n            int|error face1Result = 'int:fromString(parts[0]);\n            int|error face2Result = 'int:fromString(parts[1]);\n            \n            if face1Result is int && face2Result is int && stonesWithFace.length() >= 2 {\n                // Try all pairs\n                foreach int i in 0 ..< stonesWithFace.length() {\n                    foreach int j in (i + 1) ..< stonesWithFace.length() {\n                        int idx1 = stonesWithFace[i].index;\n                        int dim1 = stonesWithFace[i].thirdDim;\n                        int idx2 = stonesWithFace[j].index;\n                        int dim2 = stonesWithFace[j].thirdDim;\n                        \n                        // Glued dimensions: face1, face2, dim1 + dim2\n                        int minDim = getMinDimension(face1Result, face2Result, dim1 + dim2);\n                        if minDim > bestMin {\n                            bestMin = minDim;\n                            bestK = 2;\n                            bestIndices = [idx1, idx2];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return [bestK, bestIndices];\n}\n\npublic function main() returns error? {\n    string? n_line = io:readln();\n    if n_line is () {\n        return;\n    }\n    \n    int n = check 'int:fromString(n_line.trim());\n    Stone[] stones = [];\n    \n    foreach int i in 1 ... n {\n        string? stone_line = io:readln();\n        if stone_line is () {\n            return;\n        }\n        \n        string[] parts = re `\\s+`.split(stone_line.trim());\n        if parts.length() == 3 {\n            int a = check 'int:fromString(parts[0]);\n            int b = check 'int:fromString(parts[1]);\n            int c = check 'int:fromString(parts[2]);\n            \n            stones.push({a: a, b: b, c: c, index: i});\n        }\n    }\n    \n    [int, int[]] result = solve(stones);\n    io:println(result[0]);\n    \n    string output = \"\";\n    foreach int idx in result[1] {\n        if output.length() > 0 {\n            output = output + \" \";\n        }\n        output = output + idx.toString();\n    }\n    io:println(output);\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T09:58:11.209992"
}