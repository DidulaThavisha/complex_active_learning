{
  "entry_id": "problem_0282",
  "problem_index": 282,
  "prompt": "Title: Primes on Interval\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou've decided to carry out a survey in the theory of prime numbers. Let us remind you that a prime number is a positive integer that has exactly two distinct positive integer divisors.\n\nConsider positive integers *a*, *a*<=+<=1, ..., *b* (*a*<=≤<=*b*). You want to find the minimum integer *l* (1<=≤<=*l*<=≤<=*b*<=-<=*a*<=+<=1) such that for any integer *x* (*a*<=≤<=*x*<=≤<=*b*<=-<=*l*<=+<=1) among *l* integers *x*, *x*<=+<=1, ..., *x*<=+<=*l*<=-<=1 there are at least *k* prime numbers. \n\nFind and print the required minimum *l*. If no value *l* meets the described limitations, print -1.\n\nInput Specification:\nA single line contains three space-separated integers *a*,<=*b*,<=*k* (1<=≤<=*a*,<=*b*,<=*k*<=≤<=106; *a*<=≤<=*b*).\n\nOutput Specification:\nIn a single line print a single integer — the required minimum *l*. If there's no solution, print -1.\n\nDemo Input:\n['2 4 2\\n', '6 13 1\\n', '1 4 3\\n']\n\nDemo Output:\n['3\\n', '4\\n', '-1\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem requires finding the minimum window length `l` such that every consecutive sequence of `l` numbers in the range `[a, b]` contains at least `k` prime numbers. We use the Sieve of Eratosthenes to find primes efficiently, create a prefix sum array for quick range queries, and then test increasing window sizes until we find one where all windows contain at least `k` primes.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Use Sieve of Eratosthenes to find all primes up to b efficiently\n// 2. Build a prefix sum array to count primes in any subrange in O(1) time\n// 3. For each window size l from 1 to (b-a+1):\n//    - Check if ALL sliding windows of size l contain at least k primes\n//    - If yes, return l as the answer\n// 4. If no valid l exists, return -1\n//\n// Key insight: We need the MINIMUM l such that EVERY window of size l\n// starting at any position x in [a, b-l+1] contains at least k primes.\n\nimport ballerina/io;\nimport ballerina/lang.'int as ints;\n\n// Sieve of Eratosthenes to find all primes up to maxNum\nfunction sieveOfEratosthenes(int maxNum) returns boolean[] {\n    boolean[] isPrimeArr = [];\n    int i = 0;\n    while i <= maxNum {\n        isPrimeArr.push(true);\n        i = i + 1;\n    }\n    \n    if maxNum >= 0 {\n        isPrimeArr[0] = false;\n    }\n    if maxNum >= 1 {\n        isPrimeArr[1] = false;\n    }\n    \n    i = 2;\n    while i * i <= maxNum {\n        if isPrimeArr[i] {\n            int j = i * i;\n            while j <= maxNum {\n                isPrimeArr[j] = false;\n                j = j + i;\n            }\n        }\n        i = i + 1;\n    }\n    \n    return isPrimeArr;\n}\n\n// Main function to solve the problem\nfunction findMinimumL(int a, int b, int k) returns int {\n    // Edge case: if k is 0, minimum window is 1\n    if k == 0 {\n        return 1;\n    }\n    \n    // Generate all primes up to b using sieve\n    boolean[] primes = sieveOfEratosthenes(b);\n    \n    // Create prefix sum array for counting primes in range [a, b]\n    // prefixSum[i] = number of primes in range [a, a+i-1]\n    int[] prefixSum = [];\n    prefixSum.push(0);  // prefixSum[0] = 0 (no elements)\n    \n    int i = a;\n    while i <= b {\n        int lastSum = prefixSum[prefixSum.length() - 1];\n        if primes[i] {\n            prefixSum.push(lastSum + 1);\n        } else {\n            prefixSum.push(lastSum);\n        }\n        i = i + 1;\n    }\n    \n    // Total primes in range [a, b]\n    int totalPrimes = prefixSum[prefixSum.length() - 1];\n    \n    // If total primes < k, impossible\n    if totalPrimes < k {\n        return -1;\n    }\n    \n    // Try each window size l from 1 to (b - a + 1)\n    int l = 1;\n    while l <= (b - a + 1) {\n        boolean allWindowsValid = true;\n        \n        // Check all windows of size l\n        // Window starts at x and covers [x, x+l-1]\n        int x = a;\n        while x <= b - l + 1 {\n            // Count primes in range [x, x+l-1]\n            // Map to prefix sum indices: x maps to index (x-a)\n            int startIdx = x - a;\n            int endIdx = x + l - 1 - a;\n            int primeCount = prefixSum[endIdx + 1] - prefixSum[startIdx];\n            \n            if primeCount < k {\n                allWindowsValid = false;\n                break;\n            }\n            x = x + 1;\n        }\n        \n        if allWindowsValid {\n            return l;\n        }\n        l = l + 1;\n    }\n    \n    return -1;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split from ballerina/lang.regexp module is not available\n        // Instead, manually parse space-separated integers\n        string trimmed = input_line.trim();\n        \n        // Find positions of spaces\n        int[] spacePositions = [];\n        int idx = 0;\n        while idx < trimmed.length() {\n            string:Char? ch = trimmed[idx];\n            if ch is string:Char && ch == \" \" {\n                spacePositions.push(idx);\n            }\n            idx = idx + 1;\n        }\n        \n        if spacePositions.length() >= 2 {\n            // Extract three parts\n            string part1 = trimmed.substring(0, spacePositions[0]);\n            string part2 = trimmed.substring(spacePositions[0] + 1, spacePositions[1]);\n            string part3 = trimmed.substring(spacePositions[1] + 1);\n            \n            int|error a_val = ints:fromString(part1);\n            int|error b_val = ints:fromString(part2);\n            int|error k_val = ints:fromString(part3);\n            \n            if a_val is int && b_val is int && k_val is int {\n                int result = findMinimumL(a_val, b_val, k_val);\n                io:println(result);\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 3 space-separated integers\");\n        }\n    } else {\n        io:println(\"Error: No input provided\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // Test case: a=2, b=4, k=2\n    // Range [2,3,4], primes are [2,3]\n    // Window size 3: [2,3,4] has 2 primes ✓\n    int result = findMinimumL(2, 4, 2);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    // Test case: a=6, b=13, k=1\n    // Primes in [6,13]: 7, 11, 13\n    // Window size 4: [6,7,8,9] has 1 prime (7) ✓\n    int result = findMinimumL(6, 13, 1);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testExample3() {\n    // Test case: a=1, b=4, k=3\n    // Primes in [1,4]: 2, 3 (only 2 primes total)\n    // Cannot find any window with 3 primes\n    int result = findMinimumL(1, 4, 3);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testSinglePrime() {\n    // Test case: a=2, b=2, k=1\n    // Only one number (2), which is prime\n    int result = findMinimumL(2, 2, 1);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNoPrimes() {\n    // Test case: a=8, b=10, k=1\n    // Range [8,9,10], no primes\n    int result = findMinimumL(8, 10, 1);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testZeroK() {\n    // Test case: a=1, b=5, k=0\n    // k=0 means we need at least 0 primes, so minimum window is 1\n    int result = findMinimumL(1, 5, 0);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Use Sieve of Eratosthenes to find all primes up to b efficiently\n// 2. Build a prefix sum array to count primes in any subrange in O(1) time\n// 3. For each window size l from 1 to (b-a+1):\n//    - Check if ALL sliding windows of size l contain at least k primes\n//    - If yes, return l as the answer\n// 4. If no valid l exists, return -1\n//\n// Key insight: We need the MINIMUM l such that EVERY window of size l\n// starting at any position x in [a, b-l+1] contains at least k primes.\n\nimport ballerina/io;\nimport ballerina/lang.'int as ints;\n\n// Sieve of Eratosthenes to find all primes up to maxNum\nfunction sieveOfEratosthenes(int maxNum) returns boolean[] {\n    boolean[] isPrimeArr = [];\n    int i = 0;\n    while i <= maxNum {\n        isPrimeArr.push(true);\n        i = i + 1;\n    }\n    \n    if maxNum >= 0 {\n        isPrimeArr[0] = false;\n    }\n    if maxNum >= 1 {\n        isPrimeArr[1] = false;\n    }\n    \n    i = 2;\n    while i * i <= maxNum {\n        if isPrimeArr[i] {\n            int j = i * i;\n            while j <= maxNum {\n                isPrimeArr[j] = false;\n                j = j + i;\n            }\n        }\n        i = i + 1;\n    }\n    \n    return isPrimeArr;\n}\n\n// Main function to solve the problem\nfunction findMinimumL(int a, int b, int k) returns int {\n    // Edge case: if k is 0, minimum window is 1\n    if k == 0 {\n        return 1;\n    }\n    \n    // Generate all primes up to b using sieve\n    boolean[] primes = sieveOfEratosthenes(b);\n    \n    // Create prefix sum array for counting primes in range [a, b]\n    // prefixSum[i] = number of primes in range [a, a+i-1]\n    int[] prefixSum = [];\n    prefixSum.push(0);  // prefixSum[0] = 0 (no elements)\n    \n    int i = a;\n    while i <= b {\n        int lastSum = prefixSum[prefixSum.length() - 1];\n        if primes[i] {\n            prefixSum.push(lastSum + 1);\n        } else {\n            prefixSum.push(lastSum);\n        }\n        i = i + 1;\n    }\n    \n    // Total primes in range [a, b]\n    int totalPrimes = prefixSum[prefixSum.length() - 1];\n    \n    // If total primes < k, impossible\n    if totalPrimes < k {\n        return -1;\n    }\n    \n    // Try each window size l from 1 to (b - a + 1)\n    int l = 1;\n    while l <= (b - a + 1) {\n        boolean allWindowsValid = true;\n        \n        // Check all windows of size l\n        // Window starts at x and covers [x, x+l-1]\n        int x = a;\n        while x <= b - l + 1 {\n            // Count primes in range [x, x+l-1]\n            // Map to prefix sum indices: x maps to index (x-a)\n            int startIdx = x - a;\n            int endIdx = x + l - 1 - a;\n            int primeCount = prefixSum[endIdx + 1] - prefixSum[startIdx];\n            \n            if primeCount < k {\n                allWindowsValid = false;\n                break;\n            }\n            x = x + 1;\n        }\n        \n        if allWindowsValid {\n            return l;\n        }\n        l = l + 1;\n    }\n    \n    return -1;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split from ballerina/lang.regexp module is not available\n        // Instead, manually parse space-separated integers\n        string trimmed = input_line.trim();\n        \n        // Find positions of spaces\n        int[] spacePositions = [];\n        int idx = 0;\n        while idx < trimmed.length() {\n            string:Char? ch = trimmed[idx];\n            if ch is string:Char && ch == \" \" {\n                spacePositions.push(idx);\n            }\n            idx = idx + 1;\n        }\n        \n        if spacePositions.length() >= 2 {\n            // Extract three parts\n            string part1 = trimmed.substring(0, spacePositions[0]);\n            string part2 = trimmed.substring(spacePositions[0] + 1, spacePositions[1]);\n            string part3 = trimmed.substring(spacePositions[1] + 1);\n            \n            int|error a_val = ints:fromString(part1);\n            int|error b_val = ints:fromString(part2);\n            int|error k_val = ints:fromString(part3);\n            \n            if a_val is int && b_val is int && k_val is int {\n                int result = findMinimumL(a_val, b_val, k_val);\n                io:println(result);\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 3 space-separated integers\");\n        }\n    } else {\n        io:println(\"Error: No input provided\");\n    }\n}",
  "tests_passed": 3,
  "tests_total": 3,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 3/3 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T09:54:54.020165",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the minimum window length `l` such that every consecutive sequence of `l` numbers in the range `[a, b]` contains at least `k` prime numbers.\n\nThe approach:\n1. First, we need to identify all prime numbers in the range `[a, b]` using the Sieve of Eratosthenes or prime checking.\n2. Then, we use a sliding window approach to find the minimum window length `l` where every window of size `l` contains at least `k` primes.\n3. We iterate through possible window sizes from 1 to (b - a + 1) and check if all sliding windows of that size contain at least `k` primes.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to find all primes in range [a, b]\n// 2. For each possible window length l (from 1 to b-a+1):\n//    - Check if every consecutive l numbers starting from any x in [a, b-l+1] \n//      contains at least k primes\n// 3. Return the minimum l that satisfies the condition, or -1 if none exists\n//\n// Strategy:\n// - Use Sieve of Eratosthenes to efficiently find all primes up to b\n// - Create a prefix sum array to quickly count primes in any range\n// - For each window size l, check all possible windows using the prefix sum\n\nimport ballerina/io;\n\n// Check if a number is prime (simple approach for smaller numbers)\nfunction isPrime(int n) returns boolean {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    \n    int i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i = i + 2;\n    }\n    return true;\n}\n\n// Sieve of Eratosthenes to find all primes up to maxNum\nfunction sieveOfEratosthenes(int maxNum) returns boolean[] {\n    boolean[] isPrimeArr = [];\n    int i = 0;\n    while i <= maxNum {\n        isPrimeArr.push(true);\n        i = i + 1;\n    }\n    \n    if maxNum >= 0 {\n        isPrimeArr[0] = false;\n    }\n    if maxNum >= 1 {\n        isPrimeArr[1] = false;\n    }\n    \n    i = 2;\n    while i * i <= maxNum {\n        if isPrimeArr[i] {\n            int j = i * i;\n            while j <= maxNum {\n                isPrimeArr[j] = false;\n                j = j + i;\n            }\n        }\n        i = i + 1;\n    }\n    \n    return isPrimeArr;\n}\n\n// Main function to solve the problem\nfunction findMinimumL(int a, int b, int k) returns int {\n    // Generate all primes up to b using sieve\n    boolean[] primes = sieveOfEratosthenes(b);\n    \n    // Create prefix sum array for counting primes in range [a, b]\n    int[] prefixSum = [];\n    prefixSum.push(0);  // prefixSum[0] = 0\n    \n    int i = a;\n    while i <= b {\n        int lastSum = prefixSum[prefixSum.length() - 1];\n        if primes[i] {\n            prefixSum.push(lastSum + 1);\n        } else {\n            prefixSum.push(lastSum);\n        }\n        i = i + 1;\n    }\n    \n    // Try each window size l from 1 to (b - a + 1)\n    int l = 1;\n    while l <= (b - a + 1) {\n        boolean allWindowsValid = true;\n        \n        // Check all windows of size l\n        int x = a;\n        while x <= b - l + 1 {\n            // Count primes in range [x, x+l-1]\n            int startIdx = x - a;\n            int endIdx = x + l - 1 - a;\n            int primeCount = prefixSum[endIdx + 1] - prefixSum[startIdx];\n            \n            if primeCount < k {\n                allWindowsValid = false;\n                break;\n            }\n            x = x + 1;\n        }\n        \n        if allWindowsValid {\n            return l;\n        }\n        l = l + 1;\n    }\n    \n    return -1;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() == 3 {\n            int|error a_val = 'int:fromString(parts[0]);\n            int|error b_val = 'int:fromString(parts[1]);\n            int|error k_val = 'int:fromString(parts[2]);\n            \n            if a_val is int && b_val is int && k_val is int {\n                int result = findMinimumL(a_val, b_val, k_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 3 space-separated integers\");\n        }\n    } else {\n        io:println(\"Error: No input provided\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // Test case: a=2, b=4, k=2\n    // Range [2,3,4], primes are [2,3]\n    // Window size 3: [2,3,4] has 2 primes ✓\n    int result = findMinimumL(2, 4, 2);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    // Test case: a=6, b=13, k=1\n    // Primes in [6,13]: 7, 11, 13\n    // Window size 4: [6,7,8,9] has 1 prime (7) ✓\n    int result = findMinimumL(6, 13, 1);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testExample3() {\n    // Test case: a=1, b=4, k=3\n    // Primes in [1,4]: 2, 3 (only 2 primes total)\n    // Cannot find any window with 3 primes\n    int result = findMinimumL(1, 4, 3);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testSinglePrime() {\n    // Test case: a=2, b=2, k=1\n    // Only one number (2), which is prime\n    int result = findMinimumL(2, 2, 1);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNoPrimes() {\n    // Test case: a=8, b=10, k=1\n    // Range [8,9,10], no primes\n    int result = findMinimumL(8, 10, 1);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testLargerRange() {\n    // Test case: a=10, b=20, k=2\n    // Primes: 11, 13, 17, 19\n    int result = findMinimumL(10, 20, 2);\n    test:assertTrue(result >= 1 && result <= 11);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need to find all primes in range [a, b]\n// 2. For each possible window length l (from 1 to b-a+1):\n//    - Check if every consecutive l numbers starting from any x in [a, b-l+1] \n//      contains at least k primes\n// 3. Return the minimum l that satisfies the condition, or -1 if none exists\n//\n// Strategy:\n// - Use Sieve of Eratosthenes to efficiently find all primes up to b\n// - Create a prefix sum array to quickly count primes in any range\n// - For each window size l, check all possible windows using the prefix sum\n\nimport ballerina/io;\n\n// Check if a number is prime (simple approach for smaller numbers)\nfunction isPrime(int n) returns boolean {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    \n    int i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i = i + 2;\n    }\n    return true;\n}\n\n// Sieve of Eratosthenes to find all primes up to maxNum\nfunction sieveOfEratosthenes(int maxNum) returns boolean[] {\n    boolean[] isPrimeArr = [];\n    int i = 0;\n    while i <= maxNum {\n        isPrimeArr.push(true);\n        i = i + 1;\n    }\n    \n    if maxNum >= 0 {\n        isPrimeArr[0] = false;\n    }\n    if maxNum >= 1 {\n        isPrimeArr[1] = false;\n    }\n    \n    i = 2;\n    while i * i <= maxNum {\n        if isPrimeArr[i] {\n            int j = i * i;\n            while j <= maxNum {\n                isPrimeArr[j] = false;\n                j = j + i;\n            }\n        }\n        i = i + 1;\n    }\n    \n    return isPrimeArr;\n}\n\n// Main function to solve the problem\nfunction findMinimumL(int a, int b, int k) returns int {\n    // Generate all primes up to b using sieve\n    boolean[] primes = sieveOfEratosthenes(b);\n    \n    // Create prefix sum array for counting primes in range [a, b]\n    int[] prefixSum = [];\n    prefixSum.push(0);  // prefixSum[0] = 0\n    \n    int i = a;\n    while i <= b {\n        int lastSum = prefixSum[prefixSum.length() - 1];\n        if primes[i] {\n            prefixSum.push(lastSum + 1);\n        } else {\n            prefixSum.push(lastSum);\n        }\n        i = i + 1;\n    }\n    \n    // Try each window size l from 1 to (b - a + 1)\n    int l = 1;\n    while l <= (b - a + 1) {\n        boolean allWindowsValid = true;\n        \n        // Check all windows of size l\n        int x = a;\n        while x <= b - l + 1 {\n            // Count primes in range [x, x+l-1]\n            int startIdx = x - a;\n            int endIdx = x + l - 1 - a;\n            int primeCount = prefixSum[endIdx + 1] - prefixSum[startIdx];\n            \n            if primeCount < k {\n                allWindowsValid = false;\n                break;\n            }\n            x = x + 1;\n        }\n        \n        if allWindowsValid {\n            return l;\n        }\n        l = l + 1;\n    }\n    \n    return -1;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string[] parts = input_line.trim().split(\" \");\n        \n        if parts.length() == 3 {\n            int|error a_val = 'int:fromString(parts[0]);\n            int|error b_val = 'int:fromString(parts[1]);\n            int|error k_val = 'int:fromString(parts[2]);\n            \n            if a_val is int && b_val is int && k_val is int {\n                int result = findMinimumL(a_val, b_val, k_val);\n                io:println(result.toString());\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 3 space-separated integers\");\n        }\n    } else {\n        io:println(\"Error: No input provided\");\n    }\n}",
      "tests_passed": 0,
      "tests_total": 3,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(121:44,121:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(121:44,121:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(121:44,121:49)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T09:55:22.714253",
      "status": "success",
      "completion": "# Overview\nThis problem requires finding the minimum window length `l` such that every consecutive sequence of `l` numbers in the range `[a, b]` contains at least `k` prime numbers. We use the Sieve of Eratosthenes to find primes efficiently, create a prefix sum array for quick range queries, and then test increasing window sizes until we find one where all windows contain at least `k` primes.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Use Sieve of Eratosthenes to find all primes up to b efficiently\n// 2. Build a prefix sum array to count primes in any subrange in O(1) time\n// 3. For each window size l from 1 to (b-a+1):\n//    - Check if ALL sliding windows of size l contain at least k primes\n//    - If yes, return l as the answer\n// 4. If no valid l exists, return -1\n//\n// Key insight: We need the MINIMUM l such that EVERY window of size l\n// starting at any position x in [a, b-l+1] contains at least k primes.\n\nimport ballerina/io;\nimport ballerina/lang.'int as ints;\n\n// Sieve of Eratosthenes to find all primes up to maxNum\nfunction sieveOfEratosthenes(int maxNum) returns boolean[] {\n    boolean[] isPrimeArr = [];\n    int i = 0;\n    while i <= maxNum {\n        isPrimeArr.push(true);\n        i = i + 1;\n    }\n    \n    if maxNum >= 0 {\n        isPrimeArr[0] = false;\n    }\n    if maxNum >= 1 {\n        isPrimeArr[1] = false;\n    }\n    \n    i = 2;\n    while i * i <= maxNum {\n        if isPrimeArr[i] {\n            int j = i * i;\n            while j <= maxNum {\n                isPrimeArr[j] = false;\n                j = j + i;\n            }\n        }\n        i = i + 1;\n    }\n    \n    return isPrimeArr;\n}\n\n// Main function to solve the problem\nfunction findMinimumL(int a, int b, int k) returns int {\n    // Edge case: if k is 0, minimum window is 1\n    if k == 0 {\n        return 1;\n    }\n    \n    // Generate all primes up to b using sieve\n    boolean[] primes = sieveOfEratosthenes(b);\n    \n    // Create prefix sum array for counting primes in range [a, b]\n    // prefixSum[i] = number of primes in range [a, a+i-1]\n    int[] prefixSum = [];\n    prefixSum.push(0);  // prefixSum[0] = 0 (no elements)\n    \n    int i = a;\n    while i <= b {\n        int lastSum = prefixSum[prefixSum.length() - 1];\n        if primes[i] {\n            prefixSum.push(lastSum + 1);\n        } else {\n            prefixSum.push(lastSum);\n        }\n        i = i + 1;\n    }\n    \n    // Total primes in range [a, b]\n    int totalPrimes = prefixSum[prefixSum.length() - 1];\n    \n    // If total primes < k, impossible\n    if totalPrimes < k {\n        return -1;\n    }\n    \n    // Try each window size l from 1 to (b - a + 1)\n    int l = 1;\n    while l <= (b - a + 1) {\n        boolean allWindowsValid = true;\n        \n        // Check all windows of size l\n        // Window starts at x and covers [x, x+l-1]\n        int x = a;\n        while x <= b - l + 1 {\n            // Count primes in range [x, x+l-1]\n            // Map to prefix sum indices: x maps to index (x-a)\n            int startIdx = x - a;\n            int endIdx = x + l - 1 - a;\n            int primeCount = prefixSum[endIdx + 1] - prefixSum[startIdx];\n            \n            if primeCount < k {\n                allWindowsValid = false;\n                break;\n            }\n            x = x + 1;\n        }\n        \n        if allWindowsValid {\n            return l;\n        }\n        l = l + 1;\n    }\n    \n    return -1;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split from ballerina/lang.regexp module is not available\n        // Instead, manually parse space-separated integers\n        string trimmed = input_line.trim();\n        \n        // Find positions of spaces\n        int[] spacePositions = [];\n        int idx = 0;\n        while idx < trimmed.length() {\n            string:Char? ch = trimmed[idx];\n            if ch is string:Char && ch == \" \" {\n                spacePositions.push(idx);\n            }\n            idx = idx + 1;\n        }\n        \n        if spacePositions.length() >= 2 {\n            // Extract three parts\n            string part1 = trimmed.substring(0, spacePositions[0]);\n            string part2 = trimmed.substring(spacePositions[0] + 1, spacePositions[1]);\n            string part3 = trimmed.substring(spacePositions[1] + 1);\n            \n            int|error a_val = ints:fromString(part1);\n            int|error b_val = ints:fromString(part2);\n            int|error k_val = ints:fromString(part3);\n            \n            if a_val is int && b_val is int && k_val is int {\n                int result = findMinimumL(a_val, b_val, k_val);\n                io:println(result);\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 3 space-separated integers\");\n        }\n    } else {\n        io:println(\"Error: No input provided\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    // Test case: a=2, b=4, k=2\n    // Range [2,3,4], primes are [2,3]\n    // Window size 3: [2,3,4] has 2 primes ✓\n    int result = findMinimumL(2, 4, 2);\n    test:assertEquals(result, 3);\n}\n\n@test:Config {}\nfunction testExample2() {\n    // Test case: a=6, b=13, k=1\n    // Primes in [6,13]: 7, 11, 13\n    // Window size 4: [6,7,8,9] has 1 prime (7) ✓\n    int result = findMinimumL(6, 13, 1);\n    test:assertEquals(result, 4);\n}\n\n@test:Config {}\nfunction testExample3() {\n    // Test case: a=1, b=4, k=3\n    // Primes in [1,4]: 2, 3 (only 2 primes total)\n    // Cannot find any window with 3 primes\n    int result = findMinimumL(1, 4, 3);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testSinglePrime() {\n    // Test case: a=2, b=2, k=1\n    // Only one number (2), which is prime\n    int result = findMinimumL(2, 2, 1);\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testNoPrimes() {\n    // Test case: a=8, b=10, k=1\n    // Range [8,9,10], no primes\n    int result = findMinimumL(8, 10, 1);\n    test:assertEquals(result, -1);\n}\n\n@test:Config {}\nfunction testZeroK() {\n    // Test case: a=1, b=5, k=0\n    // k=0 means we need at least 0 primes, so minimum window is 1\n    int result = findMinimumL(1, 5, 0);\n    test:assertEquals(result, 1);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Use Sieve of Eratosthenes to find all primes up to b efficiently\n// 2. Build a prefix sum array to count primes in any subrange in O(1) time\n// 3. For each window size l from 1 to (b-a+1):\n//    - Check if ALL sliding windows of size l contain at least k primes\n//    - If yes, return l as the answer\n// 4. If no valid l exists, return -1\n//\n// Key insight: We need the MINIMUM l such that EVERY window of size l\n// starting at any position x in [a, b-l+1] contains at least k primes.\n\nimport ballerina/io;\nimport ballerina/lang.'int as ints;\n\n// Sieve of Eratosthenes to find all primes up to maxNum\nfunction sieveOfEratosthenes(int maxNum) returns boolean[] {\n    boolean[] isPrimeArr = [];\n    int i = 0;\n    while i <= maxNum {\n        isPrimeArr.push(true);\n        i = i + 1;\n    }\n    \n    if maxNum >= 0 {\n        isPrimeArr[0] = false;\n    }\n    if maxNum >= 1 {\n        isPrimeArr[1] = false;\n    }\n    \n    i = 2;\n    while i * i <= maxNum {\n        if isPrimeArr[i] {\n            int j = i * i;\n            while j <= maxNum {\n                isPrimeArr[j] = false;\n                j = j + i;\n            }\n        }\n        i = i + 1;\n    }\n    \n    return isPrimeArr;\n}\n\n// Main function to solve the problem\nfunction findMinimumL(int a, int b, int k) returns int {\n    // Edge case: if k is 0, minimum window is 1\n    if k == 0 {\n        return 1;\n    }\n    \n    // Generate all primes up to b using sieve\n    boolean[] primes = sieveOfEratosthenes(b);\n    \n    // Create prefix sum array for counting primes in range [a, b]\n    // prefixSum[i] = number of primes in range [a, a+i-1]\n    int[] prefixSum = [];\n    prefixSum.push(0);  // prefixSum[0] = 0 (no elements)\n    \n    int i = a;\n    while i <= b {\n        int lastSum = prefixSum[prefixSum.length() - 1];\n        if primes[i] {\n            prefixSum.push(lastSum + 1);\n        } else {\n            prefixSum.push(lastSum);\n        }\n        i = i + 1;\n    }\n    \n    // Total primes in range [a, b]\n    int totalPrimes = prefixSum[prefixSum.length() - 1];\n    \n    // If total primes < k, impossible\n    if totalPrimes < k {\n        return -1;\n    }\n    \n    // Try each window size l from 1 to (b - a + 1)\n    int l = 1;\n    while l <= (b - a + 1) {\n        boolean allWindowsValid = true;\n        \n        // Check all windows of size l\n        // Window starts at x and covers [x, x+l-1]\n        int x = a;\n        while x <= b - l + 1 {\n            // Count primes in range [x, x+l-1]\n            // Map to prefix sum indices: x maps to index (x-a)\n            int startIdx = x - a;\n            int endIdx = x + l - 1 - a;\n            int primeCount = prefixSum[endIdx + 1] - prefixSum[startIdx];\n            \n            if primeCount < k {\n                allWindowsValid = false;\n                break;\n            }\n            x = x + 1;\n        }\n        \n        if allWindowsValid {\n            return l;\n        }\n        l = l + 1;\n    }\n    \n    return -1;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        // Use regex:split from ballerina/lang.regexp module is not available\n        // Instead, manually parse space-separated integers\n        string trimmed = input_line.trim();\n        \n        // Find positions of spaces\n        int[] spacePositions = [];\n        int idx = 0;\n        while idx < trimmed.length() {\n            string:Char? ch = trimmed[idx];\n            if ch is string:Char && ch == \" \" {\n                spacePositions.push(idx);\n            }\n            idx = idx + 1;\n        }\n        \n        if spacePositions.length() >= 2 {\n            // Extract three parts\n            string part1 = trimmed.substring(0, spacePositions[0]);\n            string part2 = trimmed.substring(spacePositions[0] + 1, spacePositions[1]);\n            string part3 = trimmed.substring(spacePositions[1] + 1);\n            \n            int|error a_val = ints:fromString(part1);\n            int|error b_val = ints:fromString(part2);\n            int|error k_val = ints:fromString(part3);\n            \n            if a_val is int && b_val is int && k_val is int {\n                int result = findMinimumL(a_val, b_val, k_val);\n                io:println(result);\n            } else {\n                io:println(\"Error: Invalid integer input\");\n            }\n        } else {\n            io:println(\"Error: Expected 3 space-separated integers\");\n        }\n    } else {\n        io:println(\"Error: No input provided\");\n    }\n}",
      "tests_passed": 3,
      "tests_total": 3,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 3/3 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T09:55:59.181339"
}