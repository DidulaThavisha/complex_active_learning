{
  "entry_id": "problem_0015",
  "problem_index": 15,
  "prompt": "Title: Bus Number\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nThis night wasn't easy on Vasya. His favorite team lost, and he didn't find himself victorious either — although he played perfectly, his teammates let him down every time. He had to win at least one more time, but the losestreak only grew longer and longer... It's no wonder he didn't get any sleep this night at all.\n\nIn the morning, Vasya was waiting the bus to the university on the bus stop. Vasya's thoughts were hazy and so he couldn't remember the right bus' number quite right and got onto the bus with the number $n$.\n\nIn the bus, Vasya thought that he could get the order of the digits in the number of the bus wrong. Futhermore, he could \"see\" some digits several times, but the digits he saw were definitely in the real number of the bus. For example, if Vasya saw the number 2028, it could mean that the real bus number could be 2028, 8022, 2820 or just 820. However, numbers 80, 22208, 52 definitely couldn't be the number of the bus. Also, real bus number couldn't start with the digit 0, this meaning that, for example, number 082 couldn't be the real bus number too.\n\nGiven $n$, determine the total number of possible bus number variants.\n\nInput Specification:\nThe first line contains one integer $n$ ($1 \\leq n \\leq 10^{18}$) — the number of the bus that was seen by Vasya. It is guaranteed that this number does not start with $0$.\n\nOutput Specification:\nOutput a single integer — the amount of possible variants of the real bus number.\n\nDemo Input:\n['97\\n', '2028\\n']\n\nDemo Output:\n['2\\n', '13\\n']\n\nNote:\nIn the first sample, only variants $97$ and $79$ are possible.\n\nIn the second sample, the variants (in the increasing order) are the following: $208$, $280$, $802$, $820$, $2028$, $2082$, $2208$, $2280$, $2802$, $2820$, $8022$, $8202$, $8220$.",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:11:08.996303",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the number of valid bus numbers that can be formed by rearranging the digits of a given number, where:\n1. Each digit from the input can be used at most as many times as it appears\n2. The resulting number cannot start with 0\n3. We can use fewer digits than the input (creating shorter numbers)\n\nThe solution involves:\n- Counting frequency of each digit\n- For each possible subset of digits, calculate the number of valid permutations\n- Handle the special case where 0 cannot be the leading digit\n- Use factorial formulas to count permutations with repetitions\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Count frequency of each digit in the input number\n// 2. For each possible non-empty subset of these digits:\n//    - Calculate permutations using formula: n! / (count1! * count2! * ...)\n//    - If the subset contains 0, subtract invalid permutations (those starting with 0)\n//    - Invalid permutations = (n-1)! / (count1! * ... * (count0-1)! * ...)\n// 3. Sum all valid permutations\n\nimport ballerina/io;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Count permutations with repetition\nfunction countPermutations(int[] digitCounts) returns int {\n    int total = 0;\n    foreach int count in digitCounts {\n        total = total + count;\n    }\n    \n    if total == 0 {\n        return 0;\n    }\n    \n    int numerator = factorial(total);\n    int denominator = 1;\n    \n    foreach int count in digitCounts {\n        if count > 0 {\n            denominator = denominator * factorial(count);\n        }\n    }\n    \n    return numerator / denominator;\n}\n\nfunction countBusNumbers(string n) returns int {\n    // Count frequency of each digit (0-9)\n    int[] digitFreq = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    \n    foreach int i in 0 ..< n.length() {\n        string char = n.substring(i, i + 1);\n        int|error digit = 'int:fromString(char);\n        if digit is int {\n            digitFreq[digit] = digitFreq[digit] + 1;\n        }\n    }\n    \n    int totalCount = 0;\n    \n    // Generate all possible subsets (using bitmask approach)\n    // For each digit, we can choose 0 to freq[digit] occurrences\n    int[] maxCounts = digitFreq.clone();\n    \n    // Recursive function to generate all subsets\n    totalCount = generateSubsets(digitFreq, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    \n    return totalCount;\n}\n\nfunction generateSubsets(int[] maxCounts, int digitIndex, int[] currentCounts) returns int {\n    if digitIndex == 10 {\n        // Check if current subset is non-empty\n        int sum = 0;\n        foreach int count in currentCounts {\n            sum = sum + count;\n        }\n        \n        if sum == 0 {\n            return 0;\n        }\n        \n        // Calculate valid permutations\n        int totalPerms = countPermutations(currentCounts);\n        \n        // Subtract permutations starting with 0\n        if currentCounts[0] > 0 && sum > 1 {\n            int[] withoutOneZero = currentCounts.clone();\n            withoutOneZero[0] = withoutOneZero[0] - 1;\n            int invalidPerms = countPermutations(withoutOneZero);\n            totalPerms = totalPerms - invalidPerms;\n        }\n        \n        return totalPerms;\n    }\n    \n    int count = 0;\n    int i = 0;\n    while i <= maxCounts[digitIndex] {\n        int[] newCounts = currentCounts.clone();\n        newCounts[digitIndex] = i;\n        count = count + generateSubsets(maxCounts, digitIndex + 1, newCounts);\n        i = i + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter bus number: \");\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        \n        // Validate input\n        if trimmed.length() == 0 {\n            io:println(\"Error: Empty input\");\n            return;\n        }\n        \n        // Check if all characters are digits\n        foreach int i in 0 ..< trimmed.length() {\n            string char = trimmed.substring(i, i + 1);\n            int|error digit = 'int:fromString(char);\n            if digit is error {\n                io:println(\"Error: Invalid input - not a number\");\n                return;\n            }\n        }\n        \n        int result = countBusNumbers(trimmed);\n        io:println(result);\n    } else {\n        io:println(\"Error: Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBusNumber97() {\n    int result = countBusNumbers(\"97\");\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testBusNumber2028() {\n    int result = countBusNumbers(\"2028\");\n    test:assertEquals(result, 13);\n}\n\n@test:Config {}\nfunction testBusNumberSingleDigit() {\n    int result = countBusNumbers(\"5\");\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testBusNumberWithZero() {\n    int result = countBusNumbers(\"10\");\n    // Possible numbers: 1, 10, 01 (invalid)\n    // So: 1 (single digit) + 10 (two digits) = 2\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testBusNumberRepeatingDigits() {\n    int result = countBusNumbers(\"11\");\n    // Possible numbers: 1 (single digit, but we have two 1s so just one unique), 11\n    // 1 (using one 1) + 11 (using both 1s) = 2\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testFactorial() {\n    test:assertEquals(factorial(0), 1);\n    test:assertEquals(factorial(1), 1);\n    test:assertEquals(factorial(5), 120);\n    test:assertEquals(factorial(3), 6);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Count frequency of each digit in the input number\n// 2. For each possible non-empty subset of these digits:\n//    - Calculate permutations using formula: n! / (count1! * count2! * ...)\n//    - If the subset contains 0, subtract invalid permutations (those starting with 0)\n//    - Invalid permutations = (n-1)! / (count1! * ... * (count0-1)! * ...)\n// 3. Sum all valid permutations\n\nimport ballerina/io;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Count permutations with repetition\nfunction countPermutations(int[] digitCounts) returns int {\n    int total = 0;\n    foreach int count in digitCounts {\n        total = total + count;\n    }\n    \n    if total == 0 {\n        return 0;\n    }\n    \n    int numerator = factorial(total);\n    int denominator = 1;\n    \n    foreach int count in digitCounts {\n        if count > 0 {\n            denominator = denominator * factorial(count);\n        }\n    }\n    \n    return numerator / denominator;\n}\n\nfunction countBusNumbers(string n) returns int {\n    // Count frequency of each digit (0-9)\n    int[] digitFreq = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    \n    foreach int i in 0 ..< n.length() {\n        string char = n.substring(i, i + 1);\n        int|error digit = 'int:fromString(char);\n        if digit is int {\n            digitFreq[digit] = digitFreq[digit] + 1;\n        }\n    }\n    \n    int totalCount = 0;\n    \n    // Generate all possible subsets (using bitmask approach)\n    // For each digit, we can choose 0 to freq[digit] occurrences\n    int[] maxCounts = digitFreq.clone();\n    \n    // Recursive function to generate all subsets\n    totalCount = generateSubsets(digitFreq, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    \n    return totalCount;\n}\n\nfunction generateSubsets(int[] maxCounts, int digitIndex, int[] currentCounts) returns int {\n    if digitIndex == 10 {\n        // Check if current subset is non-empty\n        int sum = 0;\n        foreach int count in currentCounts {\n            sum = sum + count;\n        }\n        \n        if sum == 0 {\n            return 0;\n        }\n        \n        // Calculate valid permutations\n        int totalPerms = countPermutations(currentCounts);\n        \n        // Subtract permutations starting with 0\n        if currentCounts[0] > 0 && sum > 1 {\n            int[] withoutOneZero = currentCounts.clone();\n            withoutOneZero[0] = withoutOneZero[0] - 1;\n            int invalidPerms = countPermutations(withoutOneZero);\n            totalPerms = totalPerms - invalidPerms;\n        }\n        \n        return totalPerms;\n    }\n    \n    int count = 0;\n    int i = 0;\n    while i <= maxCounts[digitIndex] {\n        int[] newCounts = currentCounts.clone();\n        newCounts[digitIndex] = i;\n        count = count + generateSubsets(maxCounts, digitIndex + 1, newCounts);\n        i = i + 1;\n    }\n    \n    return count;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln(\"Enter bus number: \");\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        \n        // Validate input\n        if trimmed.length() == 0 {\n            io:println(\"Error: Empty input\");\n            return;\n        }\n        \n        // Check if all characters are digits\n        foreach int i in 0 ..< trimmed.length() {\n            string char = trimmed.substring(i, i + 1);\n            int|error digit = 'int:fromString(char);\n            if digit is error {\n                io:println(\"Error: Invalid input - not a number\");\n                return;\n            }\n        }\n        \n        int result = countBusNumbers(trimmed);\n        io:println(result);\n    } else {\n        io:println(\"Error: Failed to read input\");\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "97\n",
          "expected_output": "2\n",
          "actual_output": "Enter bus number: 4\n",
          "error": "Output mismatch"
        }
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T00:11:46.524431",
      "status": "failed",
      "completion": "Looking at the error, I can see that my previous code had issues:\n1. It was prompting for input with \"Enter bus number: \" which shouldn't be there\n2. The logic for counting valid bus numbers was incorrect\n\nLet me analyze the problem more carefully:\n- We need to count all possible DISTINCT numbers that can be formed using subsets of the digits\n- Each digit can be used up to its frequency in the original number\n- Numbers cannot start with 0\n- We can use fewer digits than in the input\n\nThe correct approach:\n1. Count digit frequencies\n2. For each possible non-empty subset of digits (considering frequencies), count valid permutations\n3. Use the formula: total_perms = n! / (d1! * d2! * ... * d9!)\n4. Subtract invalid ones starting with 0: invalid = (n-1)! / ((d0-1)! * d1! * ...)\n\n# Overview\nThis problem requires counting all distinct valid bus numbers that can be formed by using subsets of digits from the input number. We count digit frequencies, then for each possible subset, calculate permutations using factorial division, accounting for repeated digits. We subtract permutations starting with 0 as they're invalid.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input number and count frequency of each digit (0-9)\n// 2. For each possible subset of these digits (considering their frequencies):\n//    - A subset is defined by choosing count[i] digits of value i, where 0 <= count[i] <= frequency[i]\n//    - For each non-empty subset, calculate number of valid permutations\n//    - Use formula: n! / (count[0]! * count[1]! * ... * count[9]!)\n//    - If subset contains zeros, subtract invalid permutations (starting with 0)\n//    - Invalid count: (n-1)! / ((count[0]-1)! * count[1]! * ... * count[9]!)\n// 3. Sum all valid permutations from all subsets\n\nimport ballerina/io;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Count valid permutations for a given digit count array\nfunction countValidPermutations(int[] digitCounts) returns int {\n    // Calculate total number of digits\n    int total = 0;\n    foreach int count in digitCounts {\n        total = total + count;\n    }\n    \n    if total == 0 {\n        return 0;\n    }\n    \n    // Calculate total permutations: n! / (c0! * c1! * ... * c9!)\n    int totalPerms = factorial(total);\n    foreach int count in digitCounts {\n        totalPerms = totalPerms / factorial(count);\n    }\n    \n    // Subtract permutations starting with 0\n    if digitCounts[0] > 0 && total > 1 {\n        // Remove one 0 from the front, arrange the rest\n        int invalidPerms = factorial(total - 1);\n        invalidPerms = invalidPerms / factorial(digitCounts[0] - 1);\n        int i = 1;\n        while i < 10 {\n            invalidPerms = invalidPerms / factorial(digitCounts[i]);\n            i = i + 1;\n        }\n        totalPerms = totalPerms - invalidPerms;\n    }\n    \n    return totalPerms;\n}\n\n// Recursively generate all subsets and count valid permutations\nfunction generateAndCount(int[] maxFreq, int digit, int[] currentCounts) returns int {\n    if digit == 10 {\n        return countValidPermutations(currentCounts);\n    }\n    \n    int totalCount = 0;\n    int useCount = 0;\n    \n    // Try using 0 to maxFreq[digit] of this digit\n    while useCount <= maxFreq[digit] {\n        int[] newCounts = currentCounts.clone();\n        newCounts[digit] = useCount;\n        totalCount = totalCount + generateAndCount(maxFreq, digit + 1, newCounts);\n        useCount = useCount + 1;\n    }\n    \n    return totalCount;\n}\n\nfunction countBusNumbers(string n) returns int {\n    // Count frequency of each digit (0-9)\n    int[] digitFreq = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    \n    int i = 0;\n    while i < n.length() {\n        string char = n.substring(i, i + 1);\n        int|error digit = 'int:fromString(char);\n        if digit is int && digit >= 0 && digit <= 9 {\n            digitFreq[digit] = digitFreq[digit] + 1;\n        }\n        i = i + 1;\n    }\n    \n    // Generate all subsets and count valid permutations\n    // Subtract 1 for the empty subset (which generates 0 permutations anyway, but we count it)\n    int total = generateAndCount(digitFreq, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    \n    // The empty subset contributes 0, so we need to subtract it if counted\n    // Actually, our countValidPermutations returns 0 for empty, so total is already correct\n    return total - 1; // Subtract 1 for the empty subset\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        \n        if trimmed.length() == 0 {\n            return;\n        }\n        \n        int result = countBusNumbers(trimmed);\n        io:println(result);\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testBusNumber97() {\n    int result = countBusNumbers(\"97\");\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testBusNumber2028() {\n    int result = countBusNumbers(\"2028\");\n    test:assertEquals(result, 13);\n}\n\n@test:Config {}\nfunction testBusNumberSingleDigit() {\n    int result = countBusNumbers(\"5\");\n    test:assertEquals(result, 1);\n}\n\n@test:Config {}\nfunction testBusNumberWithZero() {\n    int result = countBusNumbers(\"10\");\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testBusNumberRepeatingDigits() {\n    int result = countBusNumbers(\"11\");\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testFactorial() {\n    test:assertEquals(factorial(0), 1);\n    test:assertEquals(factorial(1), 1);\n    test:assertEquals(factorial(5), 120);\n    test:assertEquals(factorial(3), 6);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input number and count frequency of each digit (0-9)\n// 2. For each possible subset of these digits (considering their frequencies):\n//    - A subset is defined by choosing count[i] digits of value i, where 0 <= count[i] <= frequency[i]\n//    - For each non-empty subset, calculate number of valid permutations\n//    - Use formula: n! / (count[0]! * count[1]! * ... * count[9]!)\n//    - If subset contains zeros, subtract invalid permutations (starting with 0)\n//    - Invalid count: (n-1)! / ((count[0]-1)! * count[1]! * ... * count[9]!)\n// 3. Sum all valid permutations from all subsets\n\nimport ballerina/io;\n\n// Calculate factorial\nfunction factorial(int n) returns int {\n    if n <= 1 {\n        return 1;\n    }\n    int result = 1;\n    int i = 2;\n    while i <= n {\n        result = result * i;\n        i = i + 1;\n    }\n    return result;\n}\n\n// Count valid permutations for a given digit count array\nfunction countValidPermutations(int[] digitCounts) returns int {\n    // Calculate total number of digits\n    int total = 0;\n    foreach int count in digitCounts {\n        total = total + count;\n    }\n    \n    if total == 0 {\n        return 0;\n    }\n    \n    // Calculate total permutations: n! / (c0! * c1! * ... * c9!)\n    int totalPerms = factorial(total);\n    foreach int count in digitCounts {\n        totalPerms = totalPerms / factorial(count);\n    }\n    \n    // Subtract permutations starting with 0\n    if digitCounts[0] > 0 && total > 1 {\n        // Remove one 0 from the front, arrange the rest\n        int invalidPerms = factorial(total - 1);\n        invalidPerms = invalidPerms / factorial(digitCounts[0] - 1);\n        int i = 1;\n        while i < 10 {\n            invalidPerms = invalidPerms / factorial(digitCounts[i]);\n            i = i + 1;\n        }\n        totalPerms = totalPerms - invalidPerms;\n    }\n    \n    return totalPerms;\n}\n\n// Recursively generate all subsets and count valid permutations\nfunction generateAndCount(int[] maxFreq, int digit, int[] currentCounts) returns int {\n    if digit == 10 {\n        return countValidPermutations(currentCounts);\n    }\n    \n    int totalCount = 0;\n    int useCount = 0;\n    \n    // Try using 0 to maxFreq[digit] of this digit\n    while useCount <= maxFreq[digit] {\n        int[] newCounts = currentCounts.clone();\n        newCounts[digit] = useCount;\n        totalCount = totalCount + generateAndCount(maxFreq, digit + 1, newCounts);\n        useCount = useCount + 1;\n    }\n    \n    return totalCount;\n}\n\nfunction countBusNumbers(string n) returns int {\n    // Count frequency of each digit (0-9)\n    int[] digitFreq = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    \n    int i = 0;\n    while i < n.length() {\n        string char = n.substring(i, i + 1);\n        int|error digit = 'int:fromString(char);\n        if digit is int && digit >= 0 && digit <= 9 {\n            digitFreq[digit] = digitFreq[digit] + 1;\n        }\n        i = i + 1;\n    }\n    \n    // Generate all subsets and count valid permutations\n    // Subtract 1 for the empty subset (which generates 0 permutations anyway, but we count it)\n    int total = generateAndCount(digitFreq, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    \n    // The empty subset contributes 0, so we need to subtract it if counted\n    // Actually, our countValidPermutations returns 0 for empty, so total is already correct\n    return total - 1; // Subtract 1 for the empty subset\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string trimmed = input_line.trim();\n        \n        if trimmed.length() == 0 {\n            return;\n        }\n        \n        int result = countBusNumbers(trimmed);\n        io:println(result);\n    }\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Only passed 0/2 tests (0.0%), need 75%",
      "error": "Only passed 0/2 tests (0.0%), need 75%",
      "error_details": {
        "failing_test_case": {
          "input": "97\n",
          "expected_output": "2\n",
          "actual_output": "3\n",
          "error": "Output mismatch"
        }
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Only passed 0/2 tests (0.0%), need 75%",
  "timestamp": "2026-01-05T00:12:23.273049"
}