{
  "entry_id": "problem_0061",
  "problem_index": 61,
  "prompt": "Title: Balancer\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nPetya has *k* matches, placed in *n* matchboxes lying in a line from left to right. We know that *k* is divisible by *n*. Petya wants all boxes to have the same number of matches inside. For that, he can move a match from its box to the adjacent one in one move. How many such moves does he need to achieve the desired configuration?\n\nInput Specification:\nThe first line contains integer *n* (1<=≤<=*n*<=≤<=50000). The second line contains *n* non-negative numbers that do not exceed 109, the *i*-th written number is the number of matches in the *i*-th matchbox. It is guaranteed that the total number of matches is divisible by *n*.\n\nOutput Specification:\nPrint the total minimum number of moves.\n\nDemo Input:\n['6\\n1 6 2 5 3 7\\n']\n\nDemo Output:\n['12\\n']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 2,
  "completion": "# Overview\nThis problem asks us to find the minimum number of moves to balance matches across matchboxes, where a move consists of transferring one match to an adjacent box. The key insight is that we need to calculate the target number of matches per box (total/n), then determine how many matches need to flow from left to right through each position to achieve balance.\n\nThe optimal strategy is to greedily balance from left to right. At each position, we calculate the deficit or surplus compared to the target, and this represents matches that must flow through to the right. The sum of absolute values of these flows gives us the minimum moves.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Calculate target matches per box = total_matches / n\n// 2. Traverse from left to right, maintaining a \"flow\" variable\n// 3. At each position, calculate the deficit/surplus: current[i] - target\n// 4. The flow accumulates these deficits/surpluses\n// 5. The absolute value of flow at each position represents matches moving through\n// 6. Sum of all absolute flows gives the minimum moves needed\n//\n// Example: [1, 6, 2, 5, 3, 7] with target = 4\n// Position 0: has 1, needs 4, deficit = -3, flow = -3, moves += 3\n// Position 1: has 6, needs 4, surplus = 2, flow = -3+2 = -1, moves += 1\n// Position 2: has 2, needs 4, deficit = -2, flow = -1-2 = -3, moves += 3\n// Position 3: has 5, needs 4, surplus = 1, flow = -3+1 = -2, moves += 2\n// Position 4: has 3, needs 4, deficit = -1, flow = -2-1 = -3, moves += 3\n// Total = 3+1+3+2+3 = 12\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction calculateMinimumMoves(int n, int[] boxes) returns int|error {\n    if n <= 0 || boxes.length() != n {\n        return error(\"Invalid input: n must be positive and match boxes length\");\n    }\n    \n    // Calculate total matches and target per box\n    int total = 0;\n    foreach int matches in boxes {\n        total += matches;\n    }\n    \n    if total % n != 0 {\n        return error(\"Total matches not divisible by n\");\n    }\n    \n    int target = total / n;\n    int flow = 0;\n    int totalMoves = 0;\n    \n    // Calculate flows from left to right\n    foreach int i in 0 ..< n - 1 {\n        // Current box deficit/surplus\n        flow += boxes[i] - target;\n        // Add absolute flow (matches passing through this position)\n        if flow < 0 {\n            totalMoves += -flow;\n        } else {\n            totalMoves += flow;\n        }\n    }\n    \n    return totalMoves;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided for n\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read matchbox values\n    string? boxesLine = io:readln();\n    if boxesLine is () {\n        io:println(\"Error: No input provided for matchboxes\");\n        return;\n    }\n    \n    // Split the input string by spaces using regex:split\n    string trimmedLine = boxesLine.trim();\n    int[] boxes = [];\n    \n    // Manual split by spaces\n    string currentNum = \"\";\n    int idx = 0;\n    while idx < trimmedLine.length() {\n        string:Char ch = trimmedLine[idx];\n        if ch == \" \" {\n            if currentNum.length() > 0 {\n                int value = check langint:fromString(currentNum);\n                boxes.push(value);\n                currentNum = \"\";\n            }\n        } else {\n            currentNum += ch;\n        }\n        idx += 1;\n    }\n    \n    // Don't forget the last number\n    if currentNum.length() > 0 {\n        int value = check langint:fromString(currentNum);\n        boxes.push(value);\n    }\n    \n    if boxes.length() != n {\n        io:println(\"Error: Number of values doesn't match n\");\n        return;\n    }\n    \n    int|error result = calculateMinimumMoves(n, boxes);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n    } else {\n        io:println(result.toString());\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testDemoCase() {\n    int[] boxes = [1, 6, 2, 5, 3, 7];\n    int|error result = calculateMinimumMoves(6, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 12);\n    }\n}\n\n@test:Config {}\nfunction testAllEqual() {\n    // All boxes already have equal matches\n    int[] boxes = [5, 5, 5, 5];\n    int|error result = calculateMinimumMoves(4, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testTwoBoxes() {\n    // Simple case: [1, 5] -> target = 3, need to move 2 from box 2 to box 1\n    int[] boxes = [1, 5];\n    int|error result = calculateMinimumMoves(2, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 2);\n    }\n}\n\n@test:Config {}\nfunction testThreeBoxes() {\n    // [0, 6, 0] -> target = 2\n    // Position 0: has 0, needs 2, flow = -2, moves += 2\n    // Position 1: has 6, needs 2, flow = -2+4 = 2, moves += 2\n    // Total = 4\n    int[] boxes = [0, 6, 0];\n    int|error result = calculateMinimumMoves(3, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 4);\n    }\n}\n\n@test:Config {}\nfunction testSingleBox() {\n    // Single box is already balanced\n    int[] boxes = [10];\n    int|error result = calculateMinimumMoves(1, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. Calculate target matches per box = total_matches / n\n// 2. Traverse from left to right, maintaining a \"flow\" variable\n// 3. At each position, calculate the deficit/surplus: current[i] - target\n// 4. The flow accumulates these deficits/surpluses\n// 5. The absolute value of flow at each position represents matches moving through\n// 6. Sum of all absolute flows gives the minimum moves needed\n//\n// Example: [1, 6, 2, 5, 3, 7] with target = 4\n// Position 0: has 1, needs 4, deficit = -3, flow = -3, moves += 3\n// Position 1: has 6, needs 4, surplus = 2, flow = -3+2 = -1, moves += 1\n// Position 2: has 2, needs 4, deficit = -2, flow = -1-2 = -3, moves += 3\n// Position 3: has 5, needs 4, surplus = 1, flow = -3+1 = -2, moves += 2\n// Position 4: has 3, needs 4, deficit = -1, flow = -2-1 = -3, moves += 3\n// Total = 3+1+3+2+3 = 12\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction calculateMinimumMoves(int n, int[] boxes) returns int|error {\n    if n <= 0 || boxes.length() != n {\n        return error(\"Invalid input: n must be positive and match boxes length\");\n    }\n    \n    // Calculate total matches and target per box\n    int total = 0;\n    foreach int matches in boxes {\n        total += matches;\n    }\n    \n    if total % n != 0 {\n        return error(\"Total matches not divisible by n\");\n    }\n    \n    int target = total / n;\n    int flow = 0;\n    int totalMoves = 0;\n    \n    // Calculate flows from left to right\n    foreach int i in 0 ..< n - 1 {\n        // Current box deficit/surplus\n        flow += boxes[i] - target;\n        // Add absolute flow (matches passing through this position)\n        if flow < 0 {\n            totalMoves += -flow;\n        } else {\n            totalMoves += flow;\n        }\n    }\n    \n    return totalMoves;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided for n\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read matchbox values\n    string? boxesLine = io:readln();\n    if boxesLine is () {\n        io:println(\"Error: No input provided for matchboxes\");\n        return;\n    }\n    \n    // Split the input string by spaces using regex:split\n    string trimmedLine = boxesLine.trim();\n    int[] boxes = [];\n    \n    // Manual split by spaces\n    string currentNum = \"\";\n    int idx = 0;\n    while idx < trimmedLine.length() {\n        string:Char ch = trimmedLine[idx];\n        if ch == \" \" {\n            if currentNum.length() > 0 {\n                int value = check langint:fromString(currentNum);\n                boxes.push(value);\n                currentNum = \"\";\n            }\n        } else {\n            currentNum += ch;\n        }\n        idx += 1;\n    }\n    \n    // Don't forget the last number\n    if currentNum.length() > 0 {\n        int value = check langint:fromString(currentNum);\n        boxes.push(value);\n    }\n    \n    if boxes.length() != n {\n        io:println(\"Error: Number of values doesn't match n\");\n        return;\n    }\n    \n    int|error result = calculateMinimumMoves(n, boxes);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n    } else {\n        io:println(result.toString());\n    }\n}",
  "tests_passed": 1,
  "tests_total": 1,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 1/1 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:02:22.751019",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the minimum number of moves to balance matches across matchboxes, where a move consists of transferring one match to an adjacent box. The key insight is that we need to calculate the target number of matches per box (total/n), then determine how many matches need to flow from left to right through each position to achieve balance.\n\nThe optimal strategy is to greedily balance from left to right. At each position, we calculate the deficit or surplus compared to the target, and this represents matches that must flow through to the right. The sum of absolute values of these flows gives us the minimum moves.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Calculate target matches per box = total_matches / n\n// 2. Traverse from left to right, maintaining a \"flow\" variable\n// 3. At each position, calculate the deficit/surplus: current[i] - target\n// 4. The flow accumulates these deficits/surpluses\n// 5. The absolute value of flow at each position represents matches moving through\n// 6. Sum of all absolute flows gives the minimum moves needed\n//\n// Example: [1, 6, 2, 5, 3, 7] with target = 4\n// Position 0: has 1, needs 4, deficit = -3, flow = -3, moves += 3\n// Position 1: has 6, needs 4, surplus = 2, flow = -3+2 = -1, moves += 1\n// Position 2: has 2, needs 4, deficit = -2, flow = -1-2 = -3, moves += 3\n// Position 3: has 5, needs 4, surplus = 1, flow = -3+1 = -2, moves += 2\n// Position 4: has 3, needs 4, deficit = -1, flow = -2-1 = -3, moves += 3\n// Total = 3+1+3+2+3 = 12\n\nimport ballerina/io;\n\nfunction calculateMinimumMoves(int n, int[] boxes) returns int|error {\n    if n <= 0 || boxes.length() != n {\n        return error(\"Invalid input: n must be positive and match boxes length\");\n    }\n    \n    // Calculate total matches and target per box\n    int total = 0;\n    foreach int matches in boxes {\n        total += matches;\n    }\n    \n    if total % n != 0 {\n        return error(\"Total matches not divisible by n\");\n    }\n    \n    int target = total / n;\n    int flow = 0;\n    int totalMoves = 0;\n    \n    // Calculate flows from left to right\n    foreach int i in 0 ..< n - 1 {\n        // Current box deficit/surplus\n        flow += boxes[i] - target;\n        // Add absolute flow (matches passing through this position)\n        if flow < 0 {\n            totalMoves += -flow;\n        } else {\n            totalMoves += flow;\n        }\n    }\n    \n    return totalMoves;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln(\"Enter n: \");\n    if nLine is () {\n        io:println(\"Error: No input provided for n\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read matchbox values\n    string? boxesLine = io:readln(\"Enter matchbox values (space-separated): \");\n    if boxesLine is () {\n        io:println(\"Error: No input provided for matchboxes\");\n        return;\n    }\n    \n    string[] parts = boxesLine.trim().split(\" \");\n    if parts.length() != n {\n        io:println(\"Error: Number of values doesn't match n\");\n        return;\n    }\n    \n    int[] boxes = [];\n    foreach string part in parts {\n        int value = check 'int:fromString(part.trim());\n        boxes.push(value);\n    }\n    \n    int|error result = calculateMinimumMoves(n, boxes);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n    } else {\n        io:println(result.toString());\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testDemoCase() {\n    int[] boxes = [1, 6, 2, 5, 3, 7];\n    int|error result = calculateMinimumMoves(6, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 12);\n    }\n}\n\n@test:Config {}\nfunction testAllEqual() {\n    // All boxes already have equal matches\n    int[] boxes = [5, 5, 5, 5];\n    int|error result = calculateMinimumMoves(4, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testTwoBoxes() {\n    // Simple case: [1, 5] -> target = 3, need to move 2 from box 2 to box 1\n    int[] boxes = [1, 5];\n    int|error result = calculateMinimumMoves(2, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 2);\n    }\n}\n\n@test:Config {}\nfunction testThreeBoxes() {\n    // [0, 6, 0] -> target = 2\n    // Position 0: has 0, needs 2, flow = -2, moves += 2\n    // Position 1: has 6, needs 2, flow = -2+4 = 2, moves += 2\n    // Total = 4\n    int[] boxes = [0, 6, 0];\n    int|error result = calculateMinimumMoves(3, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 4);\n    }\n}\n\n@test:Config {}\nfunction testSingleBox() {\n    // Single box is already balanced\n    int[] boxes = [10];\n    int|error result = calculateMinimumMoves(1, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Calculate target matches per box = total_matches / n\n// 2. Traverse from left to right, maintaining a \"flow\" variable\n// 3. At each position, calculate the deficit/surplus: current[i] - target\n// 4. The flow accumulates these deficits/surpluses\n// 5. The absolute value of flow at each position represents matches moving through\n// 6. Sum of all absolute flows gives the minimum moves needed\n//\n// Example: [1, 6, 2, 5, 3, 7] with target = 4\n// Position 0: has 1, needs 4, deficit = -3, flow = -3, moves += 3\n// Position 1: has 6, needs 4, surplus = 2, flow = -3+2 = -1, moves += 1\n// Position 2: has 2, needs 4, deficit = -2, flow = -1-2 = -3, moves += 3\n// Position 3: has 5, needs 4, surplus = 1, flow = -3+1 = -2, moves += 2\n// Position 4: has 3, needs 4, deficit = -1, flow = -2-1 = -3, moves += 3\n// Total = 3+1+3+2+3 = 12\n\nimport ballerina/io;\n\nfunction calculateMinimumMoves(int n, int[] boxes) returns int|error {\n    if n <= 0 || boxes.length() != n {\n        return error(\"Invalid input: n must be positive and match boxes length\");\n    }\n    \n    // Calculate total matches and target per box\n    int total = 0;\n    foreach int matches in boxes {\n        total += matches;\n    }\n    \n    if total % n != 0 {\n        return error(\"Total matches not divisible by n\");\n    }\n    \n    int target = total / n;\n    int flow = 0;\n    int totalMoves = 0;\n    \n    // Calculate flows from left to right\n    foreach int i in 0 ..< n - 1 {\n        // Current box deficit/surplus\n        flow += boxes[i] - target;\n        // Add absolute flow (matches passing through this position)\n        if flow < 0 {\n            totalMoves += -flow;\n        } else {\n            totalMoves += flow;\n        }\n    }\n    \n    return totalMoves;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln(\"Enter n: \");\n    if nLine is () {\n        io:println(\"Error: No input provided for n\");\n        return;\n    }\n    \n    int n = check 'int:fromString(nLine.trim());\n    \n    // Read matchbox values\n    string? boxesLine = io:readln(\"Enter matchbox values (space-separated): \");\n    if boxesLine is () {\n        io:println(\"Error: No input provided for matchboxes\");\n        return;\n    }\n    \n    string[] parts = boxesLine.trim().split(\" \");\n    if parts.length() != n {\n        io:println(\"Error: Number of values doesn't match n\");\n        return;\n    }\n    \n    int[] boxes = [];\n    foreach string part in parts {\n        int value = check 'int:fromString(part.trim());\n        boxes.push(value);\n    }\n    \n    int|error result = calculateMinimumMoves(n, boxes);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n    } else {\n        io:println(result.toString());\n    }\n}",
      "tests_passed": 0,
      "tests_total": 1,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(70:39,70:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(70:39,70:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(70:39,70:44)] undefined function 'split' in type 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T01:02:49.472602",
      "status": "success",
      "completion": "# Overview\nThis problem asks us to find the minimum number of moves to balance matches across matchboxes, where a move consists of transferring one match to an adjacent box. The key insight is that we need to calculate the target number of matches per box (total/n), then determine how many matches need to flow from left to right through each position to achieve balance.\n\nThe optimal strategy is to greedily balance from left to right. At each position, we calculate the deficit or surplus compared to the target, and this represents matches that must flow through to the right. The sum of absolute values of these flows gives us the minimum moves.\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Calculate target matches per box = total_matches / n\n// 2. Traverse from left to right, maintaining a \"flow\" variable\n// 3. At each position, calculate the deficit/surplus: current[i] - target\n// 4. The flow accumulates these deficits/surpluses\n// 5. The absolute value of flow at each position represents matches moving through\n// 6. Sum of all absolute flows gives the minimum moves needed\n//\n// Example: [1, 6, 2, 5, 3, 7] with target = 4\n// Position 0: has 1, needs 4, deficit = -3, flow = -3, moves += 3\n// Position 1: has 6, needs 4, surplus = 2, flow = -3+2 = -1, moves += 1\n// Position 2: has 2, needs 4, deficit = -2, flow = -1-2 = -3, moves += 3\n// Position 3: has 5, needs 4, surplus = 1, flow = -3+1 = -2, moves += 2\n// Position 4: has 3, needs 4, deficit = -1, flow = -2-1 = -3, moves += 3\n// Total = 3+1+3+2+3 = 12\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction calculateMinimumMoves(int n, int[] boxes) returns int|error {\n    if n <= 0 || boxes.length() != n {\n        return error(\"Invalid input: n must be positive and match boxes length\");\n    }\n    \n    // Calculate total matches and target per box\n    int total = 0;\n    foreach int matches in boxes {\n        total += matches;\n    }\n    \n    if total % n != 0 {\n        return error(\"Total matches not divisible by n\");\n    }\n    \n    int target = total / n;\n    int flow = 0;\n    int totalMoves = 0;\n    \n    // Calculate flows from left to right\n    foreach int i in 0 ..< n - 1 {\n        // Current box deficit/surplus\n        flow += boxes[i] - target;\n        // Add absolute flow (matches passing through this position)\n        if flow < 0 {\n            totalMoves += -flow;\n        } else {\n            totalMoves += flow;\n        }\n    }\n    \n    return totalMoves;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided for n\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read matchbox values\n    string? boxesLine = io:readln();\n    if boxesLine is () {\n        io:println(\"Error: No input provided for matchboxes\");\n        return;\n    }\n    \n    // Split the input string by spaces using regex:split\n    string trimmedLine = boxesLine.trim();\n    int[] boxes = [];\n    \n    // Manual split by spaces\n    string currentNum = \"\";\n    int idx = 0;\n    while idx < trimmedLine.length() {\n        string:Char ch = trimmedLine[idx];\n        if ch == \" \" {\n            if currentNum.length() > 0 {\n                int value = check langint:fromString(currentNum);\n                boxes.push(value);\n                currentNum = \"\";\n            }\n        } else {\n            currentNum += ch;\n        }\n        idx += 1;\n    }\n    \n    // Don't forget the last number\n    if currentNum.length() > 0 {\n        int value = check langint:fromString(currentNum);\n        boxes.push(value);\n    }\n    \n    if boxes.length() != n {\n        io:println(\"Error: Number of values doesn't match n\");\n        return;\n    }\n    \n    int|error result = calculateMinimumMoves(n, boxes);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n    } else {\n        io:println(result.toString());\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testDemoCase() {\n    int[] boxes = [1, 6, 2, 5, 3, 7];\n    int|error result = calculateMinimumMoves(6, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 12);\n    }\n}\n\n@test:Config {}\nfunction testAllEqual() {\n    // All boxes already have equal matches\n    int[] boxes = [5, 5, 5, 5];\n    int|error result = calculateMinimumMoves(4, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testTwoBoxes() {\n    // Simple case: [1, 5] -> target = 3, need to move 2 from box 2 to box 1\n    int[] boxes = [1, 5];\n    int|error result = calculateMinimumMoves(2, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 2);\n    }\n}\n\n@test:Config {}\nfunction testThreeBoxes() {\n    // [0, 6, 0] -> target = 2\n    // Position 0: has 0, needs 2, flow = -2, moves += 2\n    // Position 1: has 6, needs 2, flow = -2+4 = 2, moves += 2\n    // Total = 4\n    int[] boxes = [0, 6, 0];\n    int|error result = calculateMinimumMoves(3, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 4);\n    }\n}\n\n@test:Config {}\nfunction testSingleBox() {\n    // Single box is already balanced\n    int[] boxes = [10];\n    int|error result = calculateMinimumMoves(1, boxes);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 0);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Calculate target matches per box = total_matches / n\n// 2. Traverse from left to right, maintaining a \"flow\" variable\n// 3. At each position, calculate the deficit/surplus: current[i] - target\n// 4. The flow accumulates these deficits/surpluses\n// 5. The absolute value of flow at each position represents matches moving through\n// 6. Sum of all absolute flows gives the minimum moves needed\n//\n// Example: [1, 6, 2, 5, 3, 7] with target = 4\n// Position 0: has 1, needs 4, deficit = -3, flow = -3, moves += 3\n// Position 1: has 6, needs 4, surplus = 2, flow = -3+2 = -1, moves += 1\n// Position 2: has 2, needs 4, deficit = -2, flow = -1-2 = -3, moves += 3\n// Position 3: has 5, needs 4, surplus = 1, flow = -3+1 = -2, moves += 2\n// Position 4: has 3, needs 4, deficit = -1, flow = -2-1 = -3, moves += 3\n// Total = 3+1+3+2+3 = 12\n\nimport ballerina/io;\nimport ballerina/lang.'int as langint;\n\nfunction calculateMinimumMoves(int n, int[] boxes) returns int|error {\n    if n <= 0 || boxes.length() != n {\n        return error(\"Invalid input: n must be positive and match boxes length\");\n    }\n    \n    // Calculate total matches and target per box\n    int total = 0;\n    foreach int matches in boxes {\n        total += matches;\n    }\n    \n    if total % n != 0 {\n        return error(\"Total matches not divisible by n\");\n    }\n    \n    int target = total / n;\n    int flow = 0;\n    int totalMoves = 0;\n    \n    // Calculate flows from left to right\n    foreach int i in 0 ..< n - 1 {\n        // Current box deficit/surplus\n        flow += boxes[i] - target;\n        // Add absolute flow (matches passing through this position)\n        if flow < 0 {\n            totalMoves += -flow;\n        } else {\n            totalMoves += flow;\n        }\n    }\n    \n    return totalMoves;\n}\n\npublic function main() returns error? {\n    // Read n\n    string? nLine = io:readln();\n    if nLine is () {\n        io:println(\"Error: No input provided for n\");\n        return;\n    }\n    \n    int n = check langint:fromString(nLine.trim());\n    \n    // Read matchbox values\n    string? boxesLine = io:readln();\n    if boxesLine is () {\n        io:println(\"Error: No input provided for matchboxes\");\n        return;\n    }\n    \n    // Split the input string by spaces using regex:split\n    string trimmedLine = boxesLine.trim();\n    int[] boxes = [];\n    \n    // Manual split by spaces\n    string currentNum = \"\";\n    int idx = 0;\n    while idx < trimmedLine.length() {\n        string:Char ch = trimmedLine[idx];\n        if ch == \" \" {\n            if currentNum.length() > 0 {\n                int value = check langint:fromString(currentNum);\n                boxes.push(value);\n                currentNum = \"\";\n            }\n        } else {\n            currentNum += ch;\n        }\n        idx += 1;\n    }\n    \n    // Don't forget the last number\n    if currentNum.length() > 0 {\n        int value = check langint:fromString(currentNum);\n        boxes.push(value);\n    }\n    \n    if boxes.length() != n {\n        io:println(\"Error: Number of values doesn't match n\");\n        return;\n    }\n    \n    int|error result = calculateMinimumMoves(n, boxes);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n    } else {\n        io:println(result.toString());\n    }\n}",
      "tests_passed": 1,
      "tests_total": 1,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 1/1 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 2,
  "timestamp": "2026-01-05T01:03:14.325946"
}