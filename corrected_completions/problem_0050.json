{
  "entry_id": "problem_0050",
  "problem_index": 50,
  "prompt": "Title: Ancient Prophesy\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nA recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters \"-\".\n\nWe'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format \"dd-mm-yyyy\". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy \"0012-10-2012-10-2012\" mentions date 12-10-2012 twice (first time as \"0012-10-2012-10-2012\", second time as \"0012-10-2012-10-2012\").\n\nThe date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.\n\nA date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format \"dd-mm-yyyy\", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date \"1-1-2013\" isn't recorded in the format \"dd-mm-yyyy\", and date \"01-01-2013\" is recorded in it.\n\nNotice, that any year between 2013 and 2015 is not a leap year.\n\nInput Specification:\nThe first line contains the Prophesy: a non-empty string that only consists of digits and characters \"-\". The length of the Prophesy doesn't exceed 105 characters.\n\nOutput Specification:\nIn a single line print the date of the Apocalypse. It is guaranteed that such date exists and is unique.\n\nDemo Input:\n['777-444---21-12-2013-12-2013-12-2013---444-777\\n']\n\nDemo Output:\n['13-12-2013']\n\nNote:\nnone",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThis problem requires finding the date in format \"dd-mm-yyyy\" that appears most frequently in a given string (prophesy). The dates must be valid with years 2013-2015, months 1-12, and days valid for each month (considering non-leap years).\n\nThe approach:\n1. Generate all valid dates in the range (2013-2015)\n2. For each valid date, count how many times it appears as a substring in the prophesy\n3. Return the date with the maximum count\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to generate all valid dates in format \"dd-mm-yyyy\" for years 2013-2015\n// 2. For each valid date, count occurrences in the prophesy string\n// 3. Track the date with maximum occurrences\n// 4. Return that date\n//\n// Valid date constraints:\n// - Year: 2013, 2014, 2015 (none are leap years)\n// - Month: 01-12 (with leading zero)\n// - Day: 01-31 depending on month (with leading zero)\n//\n// Days per month (non-leap year):\n// Jan(1): 31, Feb(2): 28, Mar(3): 31, Apr(4): 30, May(5): 31, Jun(6): 30,\n// Jul(7): 31, Aug(8): 31, Sep(9): 30, Oct(10): 31, Nov(11): 30, Dec(12): 31\n\nimport ballerina/io;\n\n// Get number of days in a month for non-leap years\nfunction getDaysInMonth(int month) returns int {\n    match month {\n        1 => { return 31; }\n        2 => { return 28; } // Non-leap year\n        3 => { return 31; }\n        4 => { return 30; }\n        5 => { return 31; }\n        6 => { return 30; }\n        7 => { return 31; }\n        8 => { return 31; }\n        9 => { return 30; }\n        10 => { return 31; }\n        11 => { return 30; }\n        12 => { return 31; }\n        _ => { return 0; }\n    }\n}\n\n// Format a number with leading zero if needed (for 2-digit format)\nfunction formatTwoDigits(int num) returns string {\n    if num < 10 {\n        return \"0\" + num.toString();\n    }\n    return num.toString();\n}\n\n// Count occurrences of a substring in a string\nfunction countOccurrences(string text, string pattern) returns int {\n    int count = 0;\n    int textLen = text.length();\n    int patternLen = pattern.length();\n    \n    if patternLen > textLen {\n        return 0;\n    }\n    \n    int i = 0;\n    while i <= textLen - patternLen {\n        string substring = text.substring(i, i + patternLen);\n        if substring == pattern {\n            count += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\n// Find the apocalypse date from the prophesy\nfunction findApocalypseDate(string prophesy) returns string {\n    string maxDate = \"\";\n    int maxCount = 0;\n    \n    // Iterate through all valid years\n    int year = 2013;\n    while year <= 2015 {\n        // Iterate through all months\n        int month = 1;\n        while month <= 12 {\n            int daysInMonth = getDaysInMonth(month);\n            // Iterate through all days\n            int day = 1;\n            while day <= daysInMonth {\n                // Format date as dd-mm-yyyy\n                string dateStr = formatTwoDigits(day) + \"-\" + \n                                formatTwoDigits(month) + \"-\" + \n                                year.toString();\n                \n                // Count occurrences\n                int occurrences = countOccurrences(prophesy, dateStr);\n                \n                // Update max if this date has more occurrences\n                if occurrences > maxCount {\n                    maxCount = occurrences;\n                    maxDate = dateStr;\n                }\n                \n                day += 1;\n            }\n            month += 1;\n        }\n        year += 1;\n    }\n    \n    return maxDate;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string prophesy = input_line.trim();\n        string result = findApocalypseDate(prophesy);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testApocalypseDateExample() {\n    string prophesy = \"777-444---21-12-2013-12-2013-12-2013---444-777\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"13-12-2013\");\n}\n\n@test:Config {}\nfunction testApocalypseDateSingleOccurrence() {\n    string prophesy = \"01-01-2013\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"01-01-2013\");\n}\n\n@test:Config {}\nfunction testApocalypseDateMultipleYears() {\n    string prophesy = \"01-01-2014-01-01-2014-01-01-2015\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"01-01-2014\");\n}\n\n@test:Config {}\nfunction testApocalypseDateFebruary() {\n    string prophesy = \"28-02-2013-28-02-2013-28-02-2013-01-01-2013\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"28-02-2013\");\n}\n\n@test:Config {}\nfunction testCountOccurrences() {\n    int count1 = countOccurrences(\"12-10-2012-10-2012\", \"12-10-2012\");\n    test:assertEquals(count1, 2);\n    \n    int count2 = countOccurrences(\"01-01-2013\", \"01-01-2013\");\n    test:assertEquals(count2, 1);\n    \n    int count3 = countOccurrences(\"abcabc\", \"abc\");\n    test:assertEquals(count3, 2);\n    \n    int count4 = countOccurrences(\"test\", \"notfound\");\n    test:assertEquals(count4, 0);\n}\n\n@test:Config {}\nfunction testGetDaysInMonth() {\n    test:assertEquals(getDaysInMonth(1), 31);\n    test:assertEquals(getDaysInMonth(2), 28);\n    test:assertEquals(getDaysInMonth(4), 30);\n    test:assertEquals(getDaysInMonth(12), 31);\n}\n\n@test:Config {}\nfunction testFormatTwoDigits() {\n    test:assertEquals(formatTwoDigits(1), \"01\");\n    test:assertEquals(formatTwoDigits(9), \"09\");\n    test:assertEquals(formatTwoDigits(10), \"10\");\n    test:assertEquals(formatTwoDigits(31), \"31\");\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// 1. We need to generate all valid dates in format \"dd-mm-yyyy\" for years 2013-2015\n// 2. For each valid date, count occurrences in the prophesy string\n// 3. Track the date with maximum occurrences\n// 4. Return that date\n//\n// Valid date constraints:\n// - Year: 2013, 2014, 2015 (none are leap years)\n// - Month: 01-12 (with leading zero)\n// - Day: 01-31 depending on month (with leading zero)\n//\n// Days per month (non-leap year):\n// Jan(1): 31, Feb(2): 28, Mar(3): 31, Apr(4): 30, May(5): 31, Jun(6): 30,\n// Jul(7): 31, Aug(8): 31, Sep(9): 30, Oct(10): 31, Nov(11): 30, Dec(12): 31\n\nimport ballerina/io;\n\n// Get number of days in a month for non-leap years\nfunction getDaysInMonth(int month) returns int {\n    match month {\n        1 => { return 31; }\n        2 => { return 28; } // Non-leap year\n        3 => { return 31; }\n        4 => { return 30; }\n        5 => { return 31; }\n        6 => { return 30; }\n        7 => { return 31; }\n        8 => { return 31; }\n        9 => { return 30; }\n        10 => { return 31; }\n        11 => { return 30; }\n        12 => { return 31; }\n        _ => { return 0; }\n    }\n}\n\n// Format a number with leading zero if needed (for 2-digit format)\nfunction formatTwoDigits(int num) returns string {\n    if num < 10 {\n        return \"0\" + num.toString();\n    }\n    return num.toString();\n}\n\n// Count occurrences of a substring in a string\nfunction countOccurrences(string text, string pattern) returns int {\n    int count = 0;\n    int textLen = text.length();\n    int patternLen = pattern.length();\n    \n    if patternLen > textLen {\n        return 0;\n    }\n    \n    int i = 0;\n    while i <= textLen - patternLen {\n        string substring = text.substring(i, i + patternLen);\n        if substring == pattern {\n            count += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\n// Find the apocalypse date from the prophesy\nfunction findApocalypseDate(string prophesy) returns string {\n    string maxDate = \"\";\n    int maxCount = 0;\n    \n    // Iterate through all valid years\n    int year = 2013;\n    while year <= 2015 {\n        // Iterate through all months\n        int month = 1;\n        while month <= 12 {\n            int daysInMonth = getDaysInMonth(month);\n            // Iterate through all days\n            int day = 1;\n            while day <= daysInMonth {\n                // Format date as dd-mm-yyyy\n                string dateStr = formatTwoDigits(day) + \"-\" + \n                                formatTwoDigits(month) + \"-\" + \n                                year.toString();\n                \n                // Count occurrences\n                int occurrences = countOccurrences(prophesy, dateStr);\n                \n                // Update max if this date has more occurrences\n                if occurrences > maxCount {\n                    maxCount = occurrences;\n                    maxDate = dateStr;\n                }\n                \n                day += 1;\n            }\n            month += 1;\n        }\n        year += 1;\n    }\n    \n    return maxDate;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string prophesy = input_line.trim();\n        string result = findApocalypseDate(prophesy);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}",
  "tests_passed": 1,
  "tests_total": 1,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 1/1 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T00:48:52.479197",
      "status": "success",
      "completion": "# Overview\nThis problem requires finding the date in format \"dd-mm-yyyy\" that appears most frequently in a given string (prophesy). The dates must be valid with years 2013-2015, months 1-12, and days valid for each month (considering non-leap years).\n\nThe approach:\n1. Generate all valid dates in the range (2013-2015)\n2. For each valid date, count how many times it appears as a substring in the prophesy\n3. Return the date with the maximum count\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. We need to generate all valid dates in format \"dd-mm-yyyy\" for years 2013-2015\n// 2. For each valid date, count occurrences in the prophesy string\n// 3. Track the date with maximum occurrences\n// 4. Return that date\n//\n// Valid date constraints:\n// - Year: 2013, 2014, 2015 (none are leap years)\n// - Month: 01-12 (with leading zero)\n// - Day: 01-31 depending on month (with leading zero)\n//\n// Days per month (non-leap year):\n// Jan(1): 31, Feb(2): 28, Mar(3): 31, Apr(4): 30, May(5): 31, Jun(6): 30,\n// Jul(7): 31, Aug(8): 31, Sep(9): 30, Oct(10): 31, Nov(11): 30, Dec(12): 31\n\nimport ballerina/io;\n\n// Get number of days in a month for non-leap years\nfunction getDaysInMonth(int month) returns int {\n    match month {\n        1 => { return 31; }\n        2 => { return 28; } // Non-leap year\n        3 => { return 31; }\n        4 => { return 30; }\n        5 => { return 31; }\n        6 => { return 30; }\n        7 => { return 31; }\n        8 => { return 31; }\n        9 => { return 30; }\n        10 => { return 31; }\n        11 => { return 30; }\n        12 => { return 31; }\n        _ => { return 0; }\n    }\n}\n\n// Format a number with leading zero if needed (for 2-digit format)\nfunction formatTwoDigits(int num) returns string {\n    if num < 10 {\n        return \"0\" + num.toString();\n    }\n    return num.toString();\n}\n\n// Count occurrences of a substring in a string\nfunction countOccurrences(string text, string pattern) returns int {\n    int count = 0;\n    int textLen = text.length();\n    int patternLen = pattern.length();\n    \n    if patternLen > textLen {\n        return 0;\n    }\n    \n    int i = 0;\n    while i <= textLen - patternLen {\n        string substring = text.substring(i, i + patternLen);\n        if substring == pattern {\n            count += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\n// Find the apocalypse date from the prophesy\nfunction findApocalypseDate(string prophesy) returns string {\n    string maxDate = \"\";\n    int maxCount = 0;\n    \n    // Iterate through all valid years\n    int year = 2013;\n    while year <= 2015 {\n        // Iterate through all months\n        int month = 1;\n        while month <= 12 {\n            int daysInMonth = getDaysInMonth(month);\n            // Iterate through all days\n            int day = 1;\n            while day <= daysInMonth {\n                // Format date as dd-mm-yyyy\n                string dateStr = formatTwoDigits(day) + \"-\" + \n                                formatTwoDigits(month) + \"-\" + \n                                year.toString();\n                \n                // Count occurrences\n                int occurrences = countOccurrences(prophesy, dateStr);\n                \n                // Update max if this date has more occurrences\n                if occurrences > maxCount {\n                    maxCount = occurrences;\n                    maxDate = dateStr;\n                }\n                \n                day += 1;\n            }\n            month += 1;\n        }\n        year += 1;\n    }\n    \n    return maxDate;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string prophesy = input_line.trim();\n        string result = findApocalypseDate(prophesy);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testApocalypseDateExample() {\n    string prophesy = \"777-444---21-12-2013-12-2013-12-2013---444-777\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"13-12-2013\");\n}\n\n@test:Config {}\nfunction testApocalypseDateSingleOccurrence() {\n    string prophesy = \"01-01-2013\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"01-01-2013\");\n}\n\n@test:Config {}\nfunction testApocalypseDateMultipleYears() {\n    string prophesy = \"01-01-2014-01-01-2014-01-01-2015\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"01-01-2014\");\n}\n\n@test:Config {}\nfunction testApocalypseDateFebruary() {\n    string prophesy = \"28-02-2013-28-02-2013-28-02-2013-01-01-2013\";\n    string result = findApocalypseDate(prophesy);\n    test:assertEquals(result, \"28-02-2013\");\n}\n\n@test:Config {}\nfunction testCountOccurrences() {\n    int count1 = countOccurrences(\"12-10-2012-10-2012\", \"12-10-2012\");\n    test:assertEquals(count1, 2);\n    \n    int count2 = countOccurrences(\"01-01-2013\", \"01-01-2013\");\n    test:assertEquals(count2, 1);\n    \n    int count3 = countOccurrences(\"abcabc\", \"abc\");\n    test:assertEquals(count3, 2);\n    \n    int count4 = countOccurrences(\"test\", \"notfound\");\n    test:assertEquals(count4, 0);\n}\n\n@test:Config {}\nfunction testGetDaysInMonth() {\n    test:assertEquals(getDaysInMonth(1), 31);\n    test:assertEquals(getDaysInMonth(2), 28);\n    test:assertEquals(getDaysInMonth(4), 30);\n    test:assertEquals(getDaysInMonth(12), 31);\n}\n\n@test:Config {}\nfunction testFormatTwoDigits() {\n    test:assertEquals(formatTwoDigits(1), \"01\");\n    test:assertEquals(formatTwoDigits(9), \"09\");\n    test:assertEquals(formatTwoDigits(10), \"10\");\n    test:assertEquals(formatTwoDigits(31), \"31\");\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. We need to generate all valid dates in format \"dd-mm-yyyy\" for years 2013-2015\n// 2. For each valid date, count occurrences in the prophesy string\n// 3. Track the date with maximum occurrences\n// 4. Return that date\n//\n// Valid date constraints:\n// - Year: 2013, 2014, 2015 (none are leap years)\n// - Month: 01-12 (with leading zero)\n// - Day: 01-31 depending on month (with leading zero)\n//\n// Days per month (non-leap year):\n// Jan(1): 31, Feb(2): 28, Mar(3): 31, Apr(4): 30, May(5): 31, Jun(6): 30,\n// Jul(7): 31, Aug(8): 31, Sep(9): 30, Oct(10): 31, Nov(11): 30, Dec(12): 31\n\nimport ballerina/io;\n\n// Get number of days in a month for non-leap years\nfunction getDaysInMonth(int month) returns int {\n    match month {\n        1 => { return 31; }\n        2 => { return 28; } // Non-leap year\n        3 => { return 31; }\n        4 => { return 30; }\n        5 => { return 31; }\n        6 => { return 30; }\n        7 => { return 31; }\n        8 => { return 31; }\n        9 => { return 30; }\n        10 => { return 31; }\n        11 => { return 30; }\n        12 => { return 31; }\n        _ => { return 0; }\n    }\n}\n\n// Format a number with leading zero if needed (for 2-digit format)\nfunction formatTwoDigits(int num) returns string {\n    if num < 10 {\n        return \"0\" + num.toString();\n    }\n    return num.toString();\n}\n\n// Count occurrences of a substring in a string\nfunction countOccurrences(string text, string pattern) returns int {\n    int count = 0;\n    int textLen = text.length();\n    int patternLen = pattern.length();\n    \n    if patternLen > textLen {\n        return 0;\n    }\n    \n    int i = 0;\n    while i <= textLen - patternLen {\n        string substring = text.substring(i, i + patternLen);\n        if substring == pattern {\n            count += 1;\n        }\n        i += 1;\n    }\n    \n    return count;\n}\n\n// Find the apocalypse date from the prophesy\nfunction findApocalypseDate(string prophesy) returns string {\n    string maxDate = \"\";\n    int maxCount = 0;\n    \n    // Iterate through all valid years\n    int year = 2013;\n    while year <= 2015 {\n        // Iterate through all months\n        int month = 1;\n        while month <= 12 {\n            int daysInMonth = getDaysInMonth(month);\n            // Iterate through all days\n            int day = 1;\n            while day <= daysInMonth {\n                // Format date as dd-mm-yyyy\n                string dateStr = formatTwoDigits(day) + \"-\" + \n                                formatTwoDigits(month) + \"-\" + \n                                year.toString();\n                \n                // Count occurrences\n                int occurrences = countOccurrences(prophesy, dateStr);\n                \n                // Update max if this date has more occurrences\n                if occurrences > maxCount {\n                    maxCount = occurrences;\n                    maxDate = dateStr;\n                }\n                \n                day += 1;\n            }\n            month += 1;\n        }\n        year += 1;\n    }\n    \n    return maxDate;\n}\n\npublic function main() returns error? {\n    string? input_line = io:readln();\n    \n    if input_line is string {\n        string prophesy = input_line.trim();\n        string result = findApocalypseDate(prophesy);\n        io:println(result);\n    } else {\n        return error(\"Failed to read input\");\n    }\n}",
      "tests_passed": 1,
      "tests_total": 1,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 1/1 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T00:49:23.801538"
}