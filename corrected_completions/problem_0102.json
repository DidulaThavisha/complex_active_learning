{
  "entry_id": "problem_0102",
  "problem_index": 102,
  "prompt": "Title: LCM Challenge\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nSome days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.\n\nBut I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than *n*. Can you help me to find the maximum possible least common multiple of these three integers?\n\nInput Specification:\nThe first line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the *n* mentioned in the statement.\n\nOutput Specification:\nPrint a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than *n*.\n\nDemo Input:\n['9\\n', '7\\n']\n\nDemo Output:\n['504\\n', '210\\n']\n\nNote:\nThe least common multiple of some positive integers is the least positive integer which is multiple for each of them.\n\nThe result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.\n\nFor the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.",
  "rating": 1600,
  "final_status": "success",
  "successful_attempt": 1,
  "completion": "# Overview\nThe problem asks to find the maximum LCM of three positive integers not greater than n. To maximize LCM, we want to choose numbers that are as large as possible and share minimal common factors (ideally coprime). The key insight is:\n- If n, n-1, n-2 are mutually coprime or have small common factors, their LCM will be close to their product\n- We need to handle special cases where n is even (n and n-2 share factor 2)\n- Best candidates are: (n, n-1, n-2), (n, n-1, n-3), (n-1, n-2, n-3)\n\n<CODE>\n```ballerina\n// Reasoning:\n// To maximize LCM of 3 numbers <= n, we want:\n// 1. Large numbers (close to n)\n// 2. Numbers with minimal common factors\n//\n// Strategy:\n// - If n <= 2: edge cases, handle directly\n// - If n is odd: n, n-1, n-2 are good candidates (n and n-2 are both odd, n-1 is even)\n// - If n is even:\n//   - n and n-2 are both even (share factor 2)\n//   - Better to try: n-1, n-2, n-3 OR n, n-1, n-3\n//   - If n divisible by 3, avoid n and n-3 together\n//\n// Key cases:\n// - n == 1: LCM(1,1,1) = 1\n// - n == 2: LCM(2,2,2) = 2  \n// - n odd: LCM(n, n-1, n-2)\n// - n even and not divisible by 3: LCM(n, n-1, n-3)\n// - n even and divisible by 3: LCM(n-1, n-2, n-3)\n\nimport ballerina/io;\n\n// Calculate GCD of two numbers using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\n// Calculate LCM of two numbers\nfunction lcm(int a, int b) returns int {\n    return (a * b) / gcd(a, b);\n}\n\n// Calculate LCM of three numbers\nfunction lcm3(int a, int b, int c) returns int {\n    return lcm(lcm(a, b), c);\n}\n\n// Find maximum LCM of three positive integers not greater than n\nfunction findMaxLCM(int n) returns int {\n    // Edge cases\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n    }\n    \n    // If n is odd, n, n-1, n-2 is optimal\n    // (n and n-2 are odd, n-1 is even, minimal overlap)\n    if n % 2 == 1 {\n        return lcm3(n, n - 1, n - 2);\n    }\n    \n    // n is even\n    // If n is divisible by 3, n-1, n-2, n-3 is better\n    // (avoid having n and n-3 both divisible by 3)\n    if n % 3 == 0 {\n        return lcm3(n - 1, n - 2, n - 3);\n    }\n    \n    // n is even but not divisible by 3\n    // n, n-1, n-3 is optimal (avoid n and n-2 both even)\n    return lcm3(n, n - 1, n - 3);\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 1 || n > 1000000 {\n        io:println(\"Error: n must be between 1 and 1000000\");\n        return;\n    }\n    \n    int result = findMaxLCM(n);\n    io:println(result.toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxLCMBasicCases() {\n    // Test case from demo: n=9\n    int result = findMaxLCM(9);\n    test:assertEquals(result, 504); // LCM(9, 8, 7) = 504\n    \n    // Test case from demo: n=7\n    result = findMaxLCM(7);\n    test:assertEquals(result, 210); // LCM(7, 6, 5) = 210\n    \n    // Edge case: n=1\n    result = findMaxLCM(1);\n    test:assertEquals(result, 1);\n    \n    // Edge case: n=2\n    result = findMaxLCM(2);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxLCMSmallValues() {\n    // n=3\n    int result = findMaxLCM(3);\n    test:assertEquals(result, 6); // LCM(3, 2, 1) = 6\n    \n    // n=4\n    result = findMaxLCM(4);\n    test:assertEquals(result, 12); // LCM(4, 3, 2) = 12\n    \n    // n=5\n    result = findMaxLCM(5);\n    test:assertEquals(result, 60); // LCM(5, 4, 3) = 60\n    \n    // n=6\n    result = findMaxLCM(6);\n    test:assertEquals(result, 60); // LCM(5, 4, 3) = 60\n}\n\n@test:Config {}\nfunction testGCDFunction() {\n    test:assertEquals(gcd(12, 8), 4);\n    test:assertEquals(gcd(7, 5), 1);\n    test:assertEquals(gcd(10, 5), 5);\n    test:assertEquals(gcd(1, 1), 1);\n}\n\n@test:Config {}\nfunction testLCMFunction() {\n    test:assertEquals(lcm(4, 6), 12);\n    test:assertEquals(lcm(3, 5), 15);\n    test:assertEquals(lcm(7, 14), 14);\n    test:assertEquals(lcm(1, 5), 5);\n}\n```\n</TESTS>",
  "code": "// Reasoning:\n// To maximize LCM of 3 numbers <= n, we want:\n// 1. Large numbers (close to n)\n// 2. Numbers with minimal common factors\n//\n// Strategy:\n// - If n <= 2: edge cases, handle directly\n// - If n is odd: n, n-1, n-2 are good candidates (n and n-2 are both odd, n-1 is even)\n// - If n is even:\n//   - n and n-2 are both even (share factor 2)\n//   - Better to try: n-1, n-2, n-3 OR n, n-1, n-3\n//   - If n divisible by 3, avoid n and n-3 together\n//\n// Key cases:\n// - n == 1: LCM(1,1,1) = 1\n// - n == 2: LCM(2,2,2) = 2  \n// - n odd: LCM(n, n-1, n-2)\n// - n even and not divisible by 3: LCM(n, n-1, n-3)\n// - n even and divisible by 3: LCM(n-1, n-2, n-3)\n\nimport ballerina/io;\n\n// Calculate GCD of two numbers using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\n// Calculate LCM of two numbers\nfunction lcm(int a, int b) returns int {\n    return (a * b) / gcd(a, b);\n}\n\n// Calculate LCM of three numbers\nfunction lcm3(int a, int b, int c) returns int {\n    return lcm(lcm(a, b), c);\n}\n\n// Find maximum LCM of three positive integers not greater than n\nfunction findMaxLCM(int n) returns int {\n    // Edge cases\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n    }\n    \n    // If n is odd, n, n-1, n-2 is optimal\n    // (n and n-2 are odd, n-1 is even, minimal overlap)\n    if n % 2 == 1 {\n        return lcm3(n, n - 1, n - 2);\n    }\n    \n    // n is even\n    // If n is divisible by 3, n-1, n-2, n-3 is better\n    // (avoid having n and n-3 both divisible by 3)\n    if n % 3 == 0 {\n        return lcm3(n - 1, n - 2, n - 3);\n    }\n    \n    // n is even but not divisible by 3\n    // n, n-1, n-3 is optimal (avoid n and n-2 both even)\n    return lcm3(n, n - 1, n - 3);\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 1 || n > 1000000 {\n        io:println(\"Error: n must be between 1 and 1000000\");\n        return;\n    }\n    \n    int result = findMaxLCM(n);\n    io:println(result.toString());\n}",
  "tests_passed": 2,
  "tests_total": 2,
  "tests_pass_rate": 1.0,
  "validation_msg": "Passed 2/2 tests (100.0%)",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T01:46:42.518669",
      "status": "success",
      "completion": "# Overview\nThe problem asks to find the maximum LCM of three positive integers not greater than n. To maximize LCM, we want to choose numbers that are as large as possible and share minimal common factors (ideally coprime). The key insight is:\n- If n, n-1, n-2 are mutually coprime or have small common factors, their LCM will be close to their product\n- We need to handle special cases where n is even (n and n-2 share factor 2)\n- Best candidates are: (n, n-1, n-2), (n, n-1, n-3), (n-1, n-2, n-3)\n\n<CODE>\n```ballerina\n// Reasoning:\n// To maximize LCM of 3 numbers <= n, we want:\n// 1. Large numbers (close to n)\n// 2. Numbers with minimal common factors\n//\n// Strategy:\n// - If n <= 2: edge cases, handle directly\n// - If n is odd: n, n-1, n-2 are good candidates (n and n-2 are both odd, n-1 is even)\n// - If n is even:\n//   - n and n-2 are both even (share factor 2)\n//   - Better to try: n-1, n-2, n-3 OR n, n-1, n-3\n//   - If n divisible by 3, avoid n and n-3 together\n//\n// Key cases:\n// - n == 1: LCM(1,1,1) = 1\n// - n == 2: LCM(2,2,2) = 2  \n// - n odd: LCM(n, n-1, n-2)\n// - n even and not divisible by 3: LCM(n, n-1, n-3)\n// - n even and divisible by 3: LCM(n-1, n-2, n-3)\n\nimport ballerina/io;\n\n// Calculate GCD of two numbers using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\n// Calculate LCM of two numbers\nfunction lcm(int a, int b) returns int {\n    return (a * b) / gcd(a, b);\n}\n\n// Calculate LCM of three numbers\nfunction lcm3(int a, int b, int c) returns int {\n    return lcm(lcm(a, b), c);\n}\n\n// Find maximum LCM of three positive integers not greater than n\nfunction findMaxLCM(int n) returns int {\n    // Edge cases\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n    }\n    \n    // If n is odd, n, n-1, n-2 is optimal\n    // (n and n-2 are odd, n-1 is even, minimal overlap)\n    if n % 2 == 1 {\n        return lcm3(n, n - 1, n - 2);\n    }\n    \n    // n is even\n    // If n is divisible by 3, n-1, n-2, n-3 is better\n    // (avoid having n and n-3 both divisible by 3)\n    if n % 3 == 0 {\n        return lcm3(n - 1, n - 2, n - 3);\n    }\n    \n    // n is even but not divisible by 3\n    // n, n-1, n-3 is optimal (avoid n and n-2 both even)\n    return lcm3(n, n - 1, n - 3);\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 1 || n > 1000000 {\n        io:println(\"Error: n must be between 1 and 1000000\");\n        return;\n    }\n    \n    int result = findMaxLCM(n);\n    io:println(result.toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testMaxLCMBasicCases() {\n    // Test case from demo: n=9\n    int result = findMaxLCM(9);\n    test:assertEquals(result, 504); // LCM(9, 8, 7) = 504\n    \n    // Test case from demo: n=7\n    result = findMaxLCM(7);\n    test:assertEquals(result, 210); // LCM(7, 6, 5) = 210\n    \n    // Edge case: n=1\n    result = findMaxLCM(1);\n    test:assertEquals(result, 1);\n    \n    // Edge case: n=2\n    result = findMaxLCM(2);\n    test:assertEquals(result, 2);\n}\n\n@test:Config {}\nfunction testMaxLCMSmallValues() {\n    // n=3\n    int result = findMaxLCM(3);\n    test:assertEquals(result, 6); // LCM(3, 2, 1) = 6\n    \n    // n=4\n    result = findMaxLCM(4);\n    test:assertEquals(result, 12); // LCM(4, 3, 2) = 12\n    \n    // n=5\n    result = findMaxLCM(5);\n    test:assertEquals(result, 60); // LCM(5, 4, 3) = 60\n    \n    // n=6\n    result = findMaxLCM(6);\n    test:assertEquals(result, 60); // LCM(5, 4, 3) = 60\n}\n\n@test:Config {}\nfunction testGCDFunction() {\n    test:assertEquals(gcd(12, 8), 4);\n    test:assertEquals(gcd(7, 5), 1);\n    test:assertEquals(gcd(10, 5), 5);\n    test:assertEquals(gcd(1, 1), 1);\n}\n\n@test:Config {}\nfunction testLCMFunction() {\n    test:assertEquals(lcm(4, 6), 12);\n    test:assertEquals(lcm(3, 5), 15);\n    test:assertEquals(lcm(7, 14), 14);\n    test:assertEquals(lcm(1, 5), 5);\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// To maximize LCM of 3 numbers <= n, we want:\n// 1. Large numbers (close to n)\n// 2. Numbers with minimal common factors\n//\n// Strategy:\n// - If n <= 2: edge cases, handle directly\n// - If n is odd: n, n-1, n-2 are good candidates (n and n-2 are both odd, n-1 is even)\n// - If n is even:\n//   - n and n-2 are both even (share factor 2)\n//   - Better to try: n-1, n-2, n-3 OR n, n-1, n-3\n//   - If n divisible by 3, avoid n and n-3 together\n//\n// Key cases:\n// - n == 1: LCM(1,1,1) = 1\n// - n == 2: LCM(2,2,2) = 2  \n// - n odd: LCM(n, n-1, n-2)\n// - n even and not divisible by 3: LCM(n, n-1, n-3)\n// - n even and divisible by 3: LCM(n-1, n-2, n-3)\n\nimport ballerina/io;\n\n// Calculate GCD of two numbers using Euclidean algorithm\nfunction gcd(int a, int b) returns int {\n    int x = a;\n    int y = b;\n    while y != 0 {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}\n\n// Calculate LCM of two numbers\nfunction lcm(int a, int b) returns int {\n    return (a * b) / gcd(a, b);\n}\n\n// Calculate LCM of three numbers\nfunction lcm3(int a, int b, int c) returns int {\n    return lcm(lcm(a, b), c);\n}\n\n// Find maximum LCM of three positive integers not greater than n\nfunction findMaxLCM(int n) returns int {\n    // Edge cases\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n    }\n    \n    // If n is odd, n, n-1, n-2 is optimal\n    // (n and n-2 are odd, n-1 is even, minimal overlap)\n    if n % 2 == 1 {\n        return lcm3(n, n - 1, n - 2);\n    }\n    \n    // n is even\n    // If n is divisible by 3, n-1, n-2, n-3 is better\n    // (avoid having n and n-3 both divisible by 3)\n    if n % 3 == 0 {\n        return lcm3(n - 1, n - 2, n - 3);\n    }\n    \n    // n is even but not divisible by 3\n    // n, n-1, n-3 is optimal (avoid n and n-2 both even)\n    return lcm3(n, n - 1, n - 3);\n}\n\npublic function main() returns error? {\n    string input_line = check io:readln();\n    int n = check int:fromString(input_line.trim());\n    \n    if n < 1 || n > 1000000 {\n        io:println(\"Error: n must be between 1 and 1000000\");\n        return;\n    }\n    \n    int result = findMaxLCM(n);\n    io:println(result.toString());\n}",
      "tests_passed": 2,
      "tests_total": 2,
      "tests_pass_rate": 1.0,
      "validation_msg": "Passed 2/2 tests (100.0%)",
      "error": null,
      "error_details": {}
    }
  ],
  "total_attempts": 1,
  "timestamp": "2026-01-05T01:47:17.821049"
}