{
  "entry_id": "problem_0216",
  "problem_index": 216,
  "prompt": "Title: Good Substrings\n\nTime Limit: None seconds\n\nMemory Limit: None megabytes\n\nProblem Description:\nYou've got string *s*, consisting of small English letters. Some of the English letters are good, the rest are bad.\n\nA substring *s*[*l*...*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) of string *s*<=<==<=<=*s*1*s*2...*s*|*s*| (where |*s*| is the length of string *s*) is string <=*s**l**s**l*<=+<=1...*s**r*.\n\nThe substring *s*[*l*...*r*] is good, if among the letters <=*s**l*,<=*s**l*<=+<=1,<=...,<=*s**r* there are at most *k* bad ones (look at the sample's explanation to understand it more clear).\n\nYour task is to find the number of distinct good substrings of the given string *s*. Two substrings *s*[*x*...*y*] and *s*[*p*...*q*] are considered distinct if their content is different, i.e. *s*[*x*...*y*]<=≠<=*s*[*p*...*q*].\n\nInput Specification:\nThe first line of the input is the non-empty string *s*, consisting of small English letters, the string's length is at most 1500 characters.\n\nThe second line of the input is the string of characters \"0\" and \"1\", the length is exactly 26 characters. If the *i*-th character of this string equals \"1\", then the *i*-th English letter is good, otherwise it's bad. That is, the first character of this string corresponds to letter \"a\", the second one corresponds to letter \"b\" and so on.\n\nThe third line of the input consists a single integer *k* (0<=≤<=*k*<=≤<=|*s*|) — the maximum acceptable number of bad characters in a good substring.\n\nOutput Specification:\nPrint a single integer — the number of distinct good substrings of string *s*.\n\nDemo Input:\n['ababab\\n01000000000000000000000000\\n1\\n', 'acbacbacaa\\n00000000000000000000000000\\n2\\n']\n\nDemo Output:\n['5\\n', '8\\n']\n\nNote:\nIn the first example there are following good substrings: \"a\", \"ab\", \"b\", \"ba\", \"bab\".\n\nIn the second example there are following good substrings: \"a\", \"aa\", \"ac\", \"b\", \"ba\", \"c\", \"ca\", \"cb\".",
  "rating": 1800,
  "final_status": "failed",
  "all_attempts": [
    {
      "attempt_number": 1,
      "timestamp": "2026-01-05T03:58:49.368203",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the number of distinct good substrings in a given string. A substring is \"good\" if it contains at most k \"bad\" characters. Characters are classified as good or bad based on a 26-character bitmask string.\n\nThe approach:\n1. Read the input string, the good/bad character mask, and k\n2. Generate all possible substrings\n3. For each substring, count the number of bad characters\n4. If bad character count <= k, add the substring to a set (to ensure uniqueness)\n5. Return the size of the set\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input: string s, 26-char mask (0=bad, 1=good), integer k\n// 2. For each possible substring s[l...r], count bad characters\n// 3. A substring is good if it has at most k bad characters\n// 4. Use a map to track distinct substrings (only store good ones)\n// 5. Return the count of distinct good substrings\n//\n// Algorithm:\n// - Iterate through all pairs (l, r) where 0 <= l <= r < |s|\n// - For each substring, count bad chars by checking the mask\n// - If bad_count <= k, add to a set for uniqueness\n// - Return set size\n\nimport ballerina/io;\n\nfunction countDistinctGoodSubstrings(string s, string mask, int k) returns int|error {\n    // Validate inputs\n    if mask.length() != 26 {\n        return error(\"Mask must be exactly 26 characters\");\n    }\n    \n    if k < 0 {\n        return error(\"k must be non-negative\");\n    }\n    \n    // Map to store distinct good substrings\n    map<boolean> distinctSubstrings = {};\n    \n    int len = s.length();\n    \n    // Generate all substrings\n    int l = 0;\n    while l < len {\n        int badCount = 0;\n        int r = l;\n        \n        // Extend substring from position l\n        while r < len {\n            // Get character at position r\n            string char = s.substring(r, r + 1);\n            \n            // Calculate index in alphabet (a=0, b=1, ..., z=25)\n            int charCode = char.toCodePointInt();\n            int aCode = \"a\".toCodePointInt();\n            int index = charCode - aCode;\n            \n            // Check if character is valid lowercase letter\n            if index < 0 || index >= 26 {\n                return error(\"String must contain only lowercase English letters\");\n            }\n            \n            // Check if this character is bad\n            string maskChar = mask.substring(index, index + 1);\n            if maskChar == \"0\" {\n                badCount += 1;\n            }\n            \n            // If bad count exceeds k, no point extending further from this l\n            if badCount > k {\n                break;\n            }\n            \n            // This is a good substring, add to set\n            string substring = s.substring(l, r + 1);\n            distinctSubstrings[substring] = true;\n            \n            r += 1;\n        }\n        \n        l += 1;\n    }\n    \n    return distinctSubstrings.length();\n}\n\npublic function main() returns error? {\n    // Read string s\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: Expected string input\");\n        return;\n    }\n    string s = line1.trim();\n    \n    // Read mask\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: Expected mask input\");\n        return;\n    }\n    string mask = line2.trim();\n    \n    // Read k\n    string? line3 = io:readln();\n    if line3 is () {\n        io:println(\"Error: Expected k input\");\n        return;\n    }\n    int|error k = 'int:fromString(line3.trim());\n    \n    if k is error {\n        io:println(\"Error: k must be an integer\");\n        return;\n    }\n    \n    // Calculate result\n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    string s = \"ababab\";\n    string mask = \"01000000000000000000000000\";\n    int k = 1;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 5);\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    string s = \"acbacbacaa\";\n    string mask = \"00000000000000000000000000\";\n    int k = 2;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 8);\n    }\n}\n\n@test:Config {}\nfunction testAllGoodCharacters() {\n    string s = \"abc\";\n    string mask = \"11111111111111111111111111\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // All substrings are good: \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\" = 6\n        test:assertEquals(result, 6);\n    }\n}\n\n@test:Config {}\nfunction testAllBadCharactersWithKZero() {\n    string s = \"aaa\";\n    string mask = \"00000000000000000000000000\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // No good substrings possible since all chars are bad and k=0\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testSingleCharacter() {\n    string s = \"a\";\n    string mask = \"10000000000000000000000000\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // Only \"a\" is good\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testDuplicateSubstrings() {\n    string s = \"aa\";\n    string mask = \"10000000000000000000000000\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // Distinct good substrings: \"a\", \"aa\" = 2\n        test:assertEquals(result, 2);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input: string s, 26-char mask (0=bad, 1=good), integer k\n// 2. For each possible substring s[l...r], count bad characters\n// 3. A substring is good if it has at most k bad characters\n// 4. Use a map to track distinct substrings (only store good ones)\n// 5. Return the count of distinct good substrings\n//\n// Algorithm:\n// - Iterate through all pairs (l, r) where 0 <= l <= r < |s|\n// - For each substring, count bad chars by checking the mask\n// - If bad_count <= k, add to a set for uniqueness\n// - Return set size\n\nimport ballerina/io;\n\nfunction countDistinctGoodSubstrings(string s, string mask, int k) returns int|error {\n    // Validate inputs\n    if mask.length() != 26 {\n        return error(\"Mask must be exactly 26 characters\");\n    }\n    \n    if k < 0 {\n        return error(\"k must be non-negative\");\n    }\n    \n    // Map to store distinct good substrings\n    map<boolean> distinctSubstrings = {};\n    \n    int len = s.length();\n    \n    // Generate all substrings\n    int l = 0;\n    while l < len {\n        int badCount = 0;\n        int r = l;\n        \n        // Extend substring from position l\n        while r < len {\n            // Get character at position r\n            string char = s.substring(r, r + 1);\n            \n            // Calculate index in alphabet (a=0, b=1, ..., z=25)\n            int charCode = char.toCodePointInt();\n            int aCode = \"a\".toCodePointInt();\n            int index = charCode - aCode;\n            \n            // Check if character is valid lowercase letter\n            if index < 0 || index >= 26 {\n                return error(\"String must contain only lowercase English letters\");\n            }\n            \n            // Check if this character is bad\n            string maskChar = mask.substring(index, index + 1);\n            if maskChar == \"0\" {\n                badCount += 1;\n            }\n            \n            // If bad count exceeds k, no point extending further from this l\n            if badCount > k {\n                break;\n            }\n            \n            // This is a good substring, add to set\n            string substring = s.substring(l, r + 1);\n            distinctSubstrings[substring] = true;\n            \n            r += 1;\n        }\n        \n        l += 1;\n    }\n    \n    return distinctSubstrings.length();\n}\n\npublic function main() returns error? {\n    // Read string s\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: Expected string input\");\n        return;\n    }\n    string s = line1.trim();\n    \n    // Read mask\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: Expected mask input\");\n        return;\n    }\n    string mask = line2.trim();\n    \n    // Read k\n    string? line3 = io:readln();\n    if line3 is () {\n        io:println(\"Error: Expected k input\");\n        return;\n    }\n    int|error k = 'int:fromString(line3.trim());\n    \n    if k is error {\n        io:println(\"Error: k must be an integer\");\n        return;\n    }\n    \n    // Calculate result\n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(43:28,43:32)] incompatible types: expected 'string:Char', found 'string'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(43:28,43:32)] incompatible types: expected 'string:Char', found 'string'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(43:28,43:32)] incompatible types: expected 'string:Char', found 'string'\nerror: compilation contains errors\n"
      }
    },
    {
      "attempt_number": 2,
      "timestamp": "2026-01-05T03:59:17.496876",
      "status": "failed",
      "completion": "# Overview\nThis problem asks us to find the number of distinct good substrings in a given string. A substring is \"good\" if it contains at most k \"bad\" characters. Characters are classified as good or bad based on a 26-character bitmask string.\n\nThe main issue in the previous attempt was using `toCodePointInt()` on a string instead of a char. In Ballerina, we need to handle character operations differently - we can get a codepoint from a specific position in the string using `getCodePoint()` method.\n\nThe approach:\n1. Read the input string, the good/bad character mask, and k\n2. Generate all possible substrings using a sliding window approach\n3. For each substring, count the number of bad characters by checking the mask\n4. If bad character count <= k, add the substring to a map (to ensure uniqueness)\n5. Return the size of the map\n\n<CODE>\n```ballerina\n// Reasoning:\n// 1. Parse input: string s, 26-char mask (0=bad, 1=good), integer k\n// 2. For each possible substring s[l...r], count bad characters\n// 3. A substring is good if it has at most k bad characters\n// 4. Use a map to track distinct substrings (only store good ones)\n// 5. Return the count of distinct good substrings\n//\n// Key fix: Use string indexing and codepoint operations correctly\n// - For character at position i: use s[i] to get the codepoint\n// - Convert codepoint to index: subtract 'a' codepoint (97)\n// - Check mask at that index to determine if character is good/bad\n//\n// Algorithm:\n// - Iterate through all pairs (l, r) where 0 <= l <= r < |s|\n// - For each substring starting at l, extend to r and count bad chars incrementally\n// - If bad_count <= k, add substring to map for uniqueness\n// - When bad_count > k, break inner loop (no point extending further)\n// - Return map size\n\nimport ballerina/io;\n\nfunction countDistinctGoodSubstrings(string s, string mask, int k) returns int|error {\n    // Validate inputs\n    if mask.length() != 26 {\n        return error(\"Mask must be exactly 26 characters\");\n    }\n    \n    if k < 0 {\n        return error(\"k must be non-negative\");\n    }\n    \n    // Map to store distinct good substrings\n    map<boolean> distinctSubstrings = {};\n    \n    int len = s.length();\n    \n    // Generate all substrings\n    int l = 0;\n    while l < len {\n        int badCount = 0;\n        int r = l;\n        \n        // Extend substring from position l\n        while r < len {\n            // Get codepoint at position r\n            int charCode = s[r];\n            int aCode = 97; // codepoint of 'a'\n            int index = charCode - aCode;\n            \n            // Check if character is valid lowercase letter\n            if index < 0 || index >= 26 {\n                return error(\"String must contain only lowercase English letters\");\n            }\n            \n            // Check if this character is bad (mask[index] == '0')\n            int maskCharCode = mask[index];\n            int zeroCode = 48; // codepoint of '0'\n            if maskCharCode == zeroCode {\n                badCount += 1;\n            }\n            \n            // If bad count exceeds k, no point extending further from this l\n            if badCount > k {\n                break;\n            }\n            \n            // This is a good substring, add to set\n            string substring = s.substring(l, r + 1);\n            distinctSubstrings[substring] = true;\n            \n            r += 1;\n        }\n        \n        l += 1;\n    }\n    \n    return distinctSubstrings.length();\n}\n\npublic function main() returns error? {\n    // Read string s\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: Expected string input\");\n        return;\n    }\n    string s = line1.trim();\n    \n    // Read mask\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: Expected mask input\");\n        return;\n    }\n    string mask = line2.trim();\n    \n    // Read k\n    string? line3 = io:readln();\n    if line3 is () {\n        io:println(\"Error: Expected k input\");\n        return;\n    }\n    int|error k = 'int:fromString(line3.trim());\n    \n    if k is error {\n        io:println(\"Error: k must be an integer\");\n        return;\n    }\n    \n    // Calculate result\n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}\n```\n</CODE>\n\n<TESTS>\n```ballerina\nimport ballerina/test;\n\n@test:Config {}\nfunction testExample1() {\n    string s = \"ababab\";\n    string mask = \"01000000000000000000000000\";\n    int k = 1;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 5);\n    }\n}\n\n@test:Config {}\nfunction testExample2() {\n    string s = \"acbacbacaa\";\n    string mask = \"00000000000000000000000000\";\n    int k = 2;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        test:assertEquals(result, 8);\n    }\n}\n\n@test:Config {}\nfunction testAllGoodCharacters() {\n    string s = \"abc\";\n    string mask = \"11111111111111111111111111\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // All substrings are good: \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\" = 6\n        test:assertEquals(result, 6);\n    }\n}\n\n@test:Config {}\nfunction testAllBadCharactersWithKZero() {\n    string s = \"aaa\";\n    string mask = \"00000000000000000000000000\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // No good substrings possible since all chars are bad and k=0\n        test:assertEquals(result, 0);\n    }\n}\n\n@test:Config {}\nfunction testSingleCharacter() {\n    string s = \"a\";\n    string mask = \"10000000000000000000000000\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // Only \"a\" is good\n        test:assertEquals(result, 1);\n    }\n}\n\n@test:Config {}\nfunction testDuplicateSubstrings() {\n    string s = \"aa\";\n    string mask = \"10000000000000000000000000\";\n    int k = 0;\n    \n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    test:assertTrue(result is int);\n    if result is int {\n        // Distinct good substrings: \"a\", \"aa\" = 2\n        test:assertEquals(result, 2);\n    }\n}\n```\n</TESTS>",
      "code": "// Reasoning:\n// 1. Parse input: string s, 26-char mask (0=bad, 1=good), integer k\n// 2. For each possible substring s[l...r], count bad characters\n// 3. A substring is good if it has at most k bad characters\n// 4. Use a map to track distinct substrings (only store good ones)\n// 5. Return the count of distinct good substrings\n//\n// Key fix: Use string indexing and codepoint operations correctly\n// - For character at position i: use s[i] to get the codepoint\n// - Convert codepoint to index: subtract 'a' codepoint (97)\n// - Check mask at that index to determine if character is good/bad\n//\n// Algorithm:\n// - Iterate through all pairs (l, r) where 0 <= l <= r < |s|\n// - For each substring starting at l, extend to r and count bad chars incrementally\n// - If bad_count <= k, add substring to map for uniqueness\n// - When bad_count > k, break inner loop (no point extending further)\n// - Return map size\n\nimport ballerina/io;\n\nfunction countDistinctGoodSubstrings(string s, string mask, int k) returns int|error {\n    // Validate inputs\n    if mask.length() != 26 {\n        return error(\"Mask must be exactly 26 characters\");\n    }\n    \n    if k < 0 {\n        return error(\"k must be non-negative\");\n    }\n    \n    // Map to store distinct good substrings\n    map<boolean> distinctSubstrings = {};\n    \n    int len = s.length();\n    \n    // Generate all substrings\n    int l = 0;\n    while l < len {\n        int badCount = 0;\n        int r = l;\n        \n        // Extend substring from position l\n        while r < len {\n            // Get codepoint at position r\n            int charCode = s[r];\n            int aCode = 97; // codepoint of 'a'\n            int index = charCode - aCode;\n            \n            // Check if character is valid lowercase letter\n            if index < 0 || index >= 26 {\n                return error(\"String must contain only lowercase English letters\");\n            }\n            \n            // Check if this character is bad (mask[index] == '0')\n            int maskCharCode = mask[index];\n            int zeroCode = 48; // codepoint of '0'\n            if maskCharCode == zeroCode {\n                badCount += 1;\n            }\n            \n            // If bad count exceeds k, no point extending further from this l\n            if badCount > k {\n                break;\n            }\n            \n            // This is a good substring, add to set\n            string substring = s.substring(l, r + 1);\n            distinctSubstrings[substring] = true;\n            \n            r += 1;\n        }\n        \n        l += 1;\n    }\n    \n    return distinctSubstrings.length();\n}\n\npublic function main() returns error? {\n    // Read string s\n    string? line1 = io:readln();\n    if line1 is () {\n        io:println(\"Error: Expected string input\");\n        return;\n    }\n    string s = line1.trim();\n    \n    // Read mask\n    string? line2 = io:readln();\n    if line2 is () {\n        io:println(\"Error: Expected mask input\");\n        return;\n    }\n    string mask = line2.trim();\n    \n    // Read k\n    string? line3 = io:readln();\n    if line3 is () {\n        io:println(\"Error: Expected k input\");\n        return;\n    }\n    int|error k = 'int:fromString(line3.trim());\n    \n    if k is error {\n        io:println(\"Error: k must be an integer\");\n        return;\n    }\n    \n    // Calculate result\n    int|error result = countDistinctGoodSubstrings(s, mask, k);\n    \n    if result is error {\n        io:println(\"Error: \" + result.message());\n        return;\n    }\n    \n    io:println(result.toString());\n}",
      "tests_passed": 0,
      "tests_total": 2,
      "tests_pass_rate": 0.0,
      "validation_msg": "Compilation error: ERROR [main.bal:(46:28,46:32)] incompatible types: expected 'int', found 'string:Char'\nERROR [main.bal:(56:32,56:43)] incompatible types: expected 'int', found 'string:Char'\nerror: compilation contains errors\n",
      "error": "Compilation error: ERROR [main.bal:(46:28,46:32)] incompatible types: expected 'int', found 'string:Char'\nERROR [main.bal:(56:32,56:43)] incompatible types: expected 'int', found 'string:Char'\nerror: compilation contains errors\n",
      "error_details": {
        "compilation_error": "ERROR [main.bal:(46:28,46:32)] incompatible types: expected 'int', found 'string:Char'\nERROR [main.bal:(56:32,56:43)] incompatible types: expected 'int', found 'string:Char'\nerror: compilation contains errors\n"
      }
    }
  ],
  "total_attempts": 2,
  "last_error": "Compilation error: ERROR [main.bal:(46:28,46:32)] incompatible types: expected 'int', found 'string:Char'\nERROR [main.bal:(56:32,56:43)] incompatible types: expected 'int', found 'string:Char'\nerror: compilation contains errors\n",
  "timestamp": "2026-01-05T03:59:42.176038"
}